diff -r -u buggy/src/com/google/javascript/jscomp/NameAnalyzer.java inducing/src/com/google/javascript/jscomp/NameAnalyzer.java
--- buggy/src/com/google/javascript/jscomp/NameAnalyzer.java	2023-06-12 11:34:32.510331269 +0800
+++ inducing/src/com/google/javascript/jscomp/NameAnalyzer.java	2023-06-12 11:34:32.922338796 +0800
@@ -19,23 +19,20 @@
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.LinkedListMultimap;
-import com.google.common.collect.ListMultimap;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;
-import com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.GetReplacementSideEffectSubexpressions;
+import com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.CopySideEffectSubexpressions;
 import com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.SideEffectAccumulator;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.jscomp.NodeTraversal.Callback;
 import com.google.javascript.jscomp.Scope.Var;
 import com.google.javascript.jscomp.graph.DiGraph;
-import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;
 import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;
-import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;
 import com.google.javascript.jscomp.graph.LinkedDirectedGraph;
-import com.google.javascript.rhino.IR;
+import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;
+import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 
@@ -69,7 +66,7 @@
  * TODO(nicksantos): In the initial implementation of this pass, it was
  * important to understand namespaced names (e.g., that a.b is distinct from
  * a.b.c). Now that this pass comes after CollapseProperties, this is no longer
- * necessary. For now, I've changed so that {@code referenceParentNames}
+ * necessary. For now, I've changed so that {@code refernceParentNames}
  * creates a two-way reference between a.b and a.b.c, so that they're
  * effectively the same name. When someone has the time, we should completely
  * rip out all the logic that understands namespaces.
@@ -94,8 +91,7 @@
    * If scopes.get(node).equals(name) && node2 is a child of node, then node2
    * will not get executed unless name is referenced via a get operation
    */
-  private final ListMultimap<Node, NameInformation> scopes =
-      LinkedListMultimap.create();
+  private final Map<Node, NameInformation> scopes = Maps.newHashMap();
 
   /** Used to parse prototype names */
   private static final String PROTOTYPE_SUBSTRING = ".prototype.";
@@ -165,11 +161,10 @@
   }
 
   /**
-   * Callback that propagates reference information.
+   * Callback that propagates side effect information across call sites.
    */
   private static class ReferencePropagationCallback
       implements EdgeCallback<JsName, RefType> {
-    @Override
     public boolean traverseEdge(JsName from,
                                 RefType callSite,
                                 JsName to) {
@@ -228,9 +223,6 @@
     /** Whether the name has descendants that are written to. */
     boolean hasWrittenDescendants = false;
 
-    /** Whether the name is used in a instanceof check */
-    boolean hasInstanceOfReference = false;
-
     /**
      * Output the node as a string
      *
@@ -256,7 +248,6 @@
       return out.toString();
     }
 
-    @Override
     public int compareTo(JsName rhs) {
       return this.name.compareTo(rhs.name);
     }
@@ -274,21 +265,19 @@
    * Class for nodes that reference a fully-qualified JS name. Fully qualified
    * names are of form A or A.B (A.B.C, etc.). References can get the value or
    * set the value of the JS name.
+   *
+   * TODO(user) Create an interface with a remove() method that is
+   * implemented differently by type of parent node
    */
   private class JsNameRefNode implements RefNode {
     /** JsName node for this reference */
     JsName name;
 
-    /**
-     * Top GETPROP or NAME or STRING [objlit key] node defining the name of
-     * this node
-     */
-    @SuppressWarnings("unused")
+    /** Top GETPROP or NAME node defining the name of this node */
     Node node;
 
     /**
-     * Parent node of the name access
-     * (ASSIGN, VAR, FUNCTION, OBJECTLIT, or CALL)
+     * Parent node of the name access (ASSIGN, VAR, FUNCTION, or CALL)
      */
     Node parent;
 
@@ -297,7 +286,7 @@
      * Create a node that refers to a name
      *
      * @param name The name
-     * @param node The top node representing the name (GETPROP, NAME, STRING)
+     * @param node The top node representing the name (GETPROP, NAME)
      */
     JsNameRefNode(JsName name, Node node) {
       this.name = name;
@@ -305,12 +294,10 @@
       this.parent = node.getParent();
     }
 
-    @Override
     public JsName name() {
       return name;
     }
 
-    @Override
     public void remove() {
       // Setters have VAR, FUNCTION, or ASSIGN parent nodes. CALL parent
       // nodes are global refs, and are handled later in this function.
@@ -324,17 +311,12 @@
           replaceWithRhs(containingNode, parent);
           break;
         case Token.ASSIGN:
-          if (containingNode.isExprResult()) {
+          if (NodeUtil.isExpressionNode(containingNode)) {
             replaceWithRhs(containingNode.getParent(), containingNode);
           } else {
             replaceWithRhs(containingNode, parent);
           }
           break;
-        case Token.OBJECTLIT:
-          // TODO(nicksantos): Come up with a way to remove this.
-          // If we remove object lit keys, then we will need to also
-          // create dependency scopes for them.
-          break;
       }
     }
   }
@@ -353,18 +335,18 @@
     PrototypeSetNode(JsName name, Node parent) {
       super(name, parent.getFirstChild());
 
-      Preconditions.checkState(parent.isAssign());
+      Preconditions.checkState(parent.getType() == Token.ASSIGN);
     }
 
     @Override public void remove() {
       Node gramps = parent.getParent();
-      if (gramps.isExprResult()) {
+      if (NodeUtil.isExpressionNode(gramps)) {
         // name.prototype.foo = function() { ... };
         changeProxy.removeChild(gramps.getParent(), gramps);
       } else {
         // ... name.prototype.foo = function() { ... } ...
         changeProxy.replaceWith(gramps, parent,
-                                parent.getLastChild().detachFromParent());
+                                parent.getLastChild().cloneTree());
       }
     }
   }
@@ -379,29 +361,31 @@
     /** The CALL node */
     Node node;
 
+    /** The parent of {@code node} */
+    Node parent;
+
+    /** The parent of {@code parent} */
+    Node gramps;
+
     /**
      * Create a special reference node.
      *
      * @param name The name
      * @param node The CALL node
+     * @param parent The parent of {@code node}
+     * @param gramps The parent of {@code parent}
      */
-    SpecialReferenceNode(JsName name, Node node) {
+    SpecialReferenceNode(JsName name, Node node, Node parent,
+        Node gramps) {
       this.name = name;
       this.node = node;
+      this.parent = parent;
+      this.gramps = gramps;
     }
 
-    @Override
     public JsName name() {
       return name;
     }
-
-    Node getParent() {
-      return node.getParent();
-    }
-
-    Node getGramps() {
-      return node.getParent() == null ? null : node.getParent().getParent();
-    }
   }
 
 
@@ -416,20 +400,22 @@
      *
      * @param name The name
      * @param node The CALL node
+     * @param parent The parent of {@code node}
+     * @param gramps The parent of {@code parent}
      */
-    ClassDefiningFunctionNode(JsName name, Node node) {
-      super(name, node);
-      Preconditions.checkState(node.isCall());
+    ClassDefiningFunctionNode(JsName name, Node node, Node parent,
+        Node gramps) {
+      super(name, node, parent, gramps);
+      Preconditions.checkState(node.getType() == Token.CALL);
     }
 
-    @Override
     public void remove() {
-      Preconditions.checkState(node.isCall());
-      Node parent = getParent();
-      if (parent.isExprResult()) {
-        changeProxy.removeChild(getGramps(), parent);
+      Preconditions.checkState(node.getType() == Token.CALL);
+      if (NodeUtil.isExpressionNode(parent)) {
+        changeProxy.removeChild(gramps, parent);
       } else {
-        changeProxy.replaceWith(parent, node, IR.voidNode(IR.number(0)));
+        changeProxy.replaceWith(
+            parent, node, new Node(Token.VOID, Node.newNumber(0)));
       }
     }
   }
@@ -445,16 +431,18 @@
      *
      * @param name The name
      * @param node The qualified name node
+     * @param parent The parent of {@code node}, this should be an instanceof
+     *     node.
+     * @param gramps The parent of {@code parent}.
      */
-    InstanceOfCheckNode(JsName name, Node node) {
-      super(name, node);
+    InstanceOfCheckNode(JsName name, Node node, Node parent, Node gramps) {
+      super(name, node, parent, gramps);
       Preconditions.checkState(node.isQualifiedName());
-      Preconditions.checkState(getParent().isInstanceOf());
+      Preconditions.checkState(parent.getType() == Token.INSTANCEOF);
     }
 
-    @Override
     public void remove() {
-      changeProxy.replaceWith(getGramps(), getParent(), IR.falseNode());
+      changeProxy.replaceWith(gramps, parent, new Node(Token.FALSE));
     }
   }
 
@@ -462,13 +450,12 @@
    * Walk through externs and mark nodes as externally declared if declared
    */
   private class ProcessExternals extends AbstractPostOrderCallback {
-    @Override
     public void visit(NodeTraversal t, Node n, Node parent) {
       NameInformation ns = null;
       if (NodeUtil.isVarDeclaration(n)) {
-        ns = createNameInformation(t, n);
+        ns = createNameInformation(t, n, parent);
       } else if (NodeUtil.isFunctionDeclaration(n)) {
-        ns = createNameInformation(t, n.getFirstChild());
+        ns = createNameInformation(t, n.getFirstChild(), n);
       }
       if (ns != null) {
         JsName jsName = getName(ns.name, true);
@@ -500,114 +487,75 @@
    * </pre>
    */
   private class FindDependencyScopes extends AbstractPostOrderCallback {
-    @Override
     public void visit(NodeTraversal t, Node n, Node parent) {
       if (!t.inGlobalScope()) {
         return;
       }
 
-      if (n.isAssign()) {
-        recordAssignment(t, n, n);
-        if (!NodeUtil.isImmutableResult(n.getLastChild())) {
-          recordConsumers(t, n, n);
+      if (n.getType() == Token.ASSIGN) {
+        Node nameNode = n.getFirstChild();
+        NameInformation ns = createNameInformation(t, nameNode, n);
+        if (ns != null) {
+          if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent)) {
+            // Patch for assignments that appear in the init,
+            // condition or iteration part of a FOR loop.  Without
+            // this change, all 3 of those parts try to claim the for
+            // loop as their dependency scope.  The last assignment in
+            // those three fields wins, which can result in incorrect
+            // reference edges between referenced and assigned variables.
+            //
+            // TODO(user) revisit the dependency scope calculation
+            // logic.
+            if (parent.getFirstChild().getNext() != n) {
+              recordDepScope(n, ns);
+            } else {
+              recordDepScope(nameNode, ns);
+            }
+          } else {
+            recordDepScope(parent, ns);
+          }
         }
       } else if (NodeUtil.isVarDeclaration(n)) {
-        NameInformation ns = createNameInformation(t, n);
+        NameInformation ns = createNameInformation(t, n, parent);
         recordDepScope(n, ns);
       } else if (NodeUtil.isFunctionDeclaration(n)) {
-        NameInformation ns = createNameInformation(t, n.getFirstChild());
+        NameInformation ns = createNameInformation(t, n.getFirstChild(), n);
         recordDepScope(n, ns);
       } else if (NodeUtil.isExprCall(n)) {
         Node callNode = n.getFirstChild();
         Node nameNode = callNode.getFirstChild();
-        NameInformation ns = createNameInformation(t, nameNode);
+        NameInformation ns = createNameInformation(t, nameNode, callNode);
         if (ns != null && ns.onlyAffectsClassDef) {
           recordDepScope(n, ns);
         }
       }
     }
 
-    private void recordConsumers(NodeTraversal t, Node n, Node recordNode) {
-      Node parent = n.getParent();
-      switch (parent.getType()) {
-        case Token.ASSIGN:
-          if (n == parent.getLastChild()) {
-            recordAssignment(t, parent, recordNode);
-          }
-          recordConsumers(t, parent, recordNode);
-          break;
-        case Token.NAME:
-          NameInformation ns = createNameInformation(t, parent);
-          recordDepScope(recordNode, ns);
-          break;
-        case Token.OR:
-          recordConsumers(t, parent, recordNode);
-          break;
-        case Token.AND:
-          // In "a && b" only "b" can be meaningfully aliased.
-          // "a" must be falsy, which it must be an immutable, non-Object
-        case Token.COMMA:
-        case Token.HOOK:
-          if (n != parent.getFirstChild()) {
-            recordConsumers(t, parent, recordNode);
-          }
-          break;
-      }
-    }
-
-    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
-      Node nameNode = n.getFirstChild();
-      Node parent = n.getParent();
-      NameInformation ns = createNameInformation(t, nameNode);
-      if (ns != null) {
-        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
-          // Patch for assignments that appear in the init,
-          // condition or iteration part of a FOR loop.  Without
-          // this change, all 3 of those parts try to claim the for
-          // loop as their dependency scope.  The last assignment in
-          // those three fields wins, which can result in incorrect
-          // reference edges between referenced and assigned variables.
-          //
-          // TODO(user) revisit the dependency scope calculation
-          // logic.
-          if (parent.getFirstChild().getNext() != n) {
-            recordDepScope(recordNode, ns);
-          } else {
-            recordDepScope(nameNode, ns);
-          }
-        } else {
-          recordDepScope(recordNode, ns);
-        }
-      }
-    }
-
     /**
      * Defines a dependency scope.
      */
     private void recordDepScope(Node node, NameInformation name) {
-      Preconditions.checkNotNull(name);
       scopes.put(node, name);
     }
   }
 
   /**
    * Create JsName objects for variable and function declarations in
-   * the global scope before computing name references.  In JavaScript
+   * the global scope before computing name references.  In javascript
    * it is legal to refer to variable and function names before the
    * actual declaration.
    */
   private class HoistVariableAndFunctionDeclarations
       extends NodeTraversal.AbstractShallowCallback {
 
-    @Override
     public void visit(NodeTraversal t, Node n, Node parent) {
       if (NodeUtil.isVarDeclaration(n)) {
-        NameInformation ns = createNameInformation(t, n);
+        NameInformation ns = createNameInformation(t, n, parent);
         Preconditions.checkNotNull(ns, "NameInformation is null");
         createName(ns.name);
       } else if (NodeUtil.isFunctionDeclaration(n)) {
         Node nameNode = n.getFirstChild();
-        NameInformation ns = createNameInformation(t, nameNode);
+        NameInformation ns = createNameInformation(t, nameNode, n);
         Preconditions.checkNotNull(ns, "NameInformation is null");
         createName(nameNode.getString());
       }
@@ -624,35 +572,29 @@
    */
   private class FindDeclarationsAndSetters extends AbstractPostOrderCallback {
 
-    @Override
     public void visit(NodeTraversal t, Node n, Node parent) {
 
       // Record global variable and function declarations
       if (t.inGlobalScope()) {
         if (NodeUtil.isVarDeclaration(n)) {
-          NameInformation ns = createNameInformation(t, n);
+          NameInformation ns = createNameInformation(t, n, parent);
           Preconditions.checkNotNull(ns);
           recordSet(ns.name, n);
         } else if (NodeUtil.isFunctionDeclaration(n)) {
           Node nameNode = n.getFirstChild();
-          NameInformation ns = createNameInformation(t, nameNode);
+          NameInformation ns = createNameInformation(t, nameNode, n);
           if (ns != null) {
             JsName nameInfo = getName(nameNode.getString(), true);
             recordSet(nameInfo.name, nameNode);
           }
-        } else if (NodeUtil.isObjectLitKey(n)) {
-          NameInformation ns = createNameInformation(t, n);
-          if (ns != null) {
-            recordSet(ns.name, n);
-          }
         }
       }
 
       // Record assignments and call sites
-      if (n.isAssign()) {
+      if (n.getType() == Token.ASSIGN) {
         Node nameNode = n.getFirstChild();
 
-        NameInformation ns = createNameInformation(t, nameNode);
+        NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null) {
           if (ns.isPrototype) {
             recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
@@ -660,12 +602,15 @@
             recordSet(ns.name, nameNode);
           }
         }
-      } else if (n.isCall()) {
+      } else if (n.getType() == Token.CALL) {
         Node nameNode = n.getFirstChild();
-        NameInformation ns = createNameInformation(t, nameNode);
+        NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
-          JsName name = getName(ns.name, true);
-          refNodes.add(new ClassDefiningFunctionNode(name, n));
+          JsName name = getName(ns.name, false);
+          if (name != null) {
+            refNodes.add(new ClassDefiningFunctionNode(
+                            name, n, parent, parent.getParent()));
+          }
         }
       }
     }
@@ -674,8 +619,7 @@
      * Records the assignment of a value to a global name.
      *
      * @param name Fully qualified name
-     * @param node The top node representing the name (GETPROP, NAME, or STRING
-     * [objlit key])
+     * @param node The top node representing the name (GETPROP, NAME)
      */
     private void recordSet(String name, Node node) {
       JsName jsn = getName(name, true);
@@ -684,7 +628,7 @@
 
       // Now, look at all parent names and record that their properties have
       // been written to.
-      if (node.isGetElem()) {
+      if (node.getType() == Token.GETELEM) {
         recordWriteOnProperties(name);
       } else if (name.indexOf('.') != -1) {
         recordWriteOnProperties(name.substring(0, name.lastIndexOf('.')));
@@ -701,10 +645,12 @@
      */
     private void recordPrototypeSet(String className, String prototypeProperty,
         Node node) {
-      JsName name = getName(className, true);
-      name.prototypeNames.add(prototypeProperty);
-      refNodes.add(new PrototypeSetNode(name, node));
-      recordWriteOnProperties(className);
+      JsName name = getName(className, false);
+      if (name != null) {
+        name.prototypeNames.add(prototypeProperty);
+        refNodes.add(new PrototypeSetNode(name, node));
+        recordWriteOnProperties(className);
+      }
     }
 
     /**
@@ -733,11 +679,11 @@
       new Predicate<Node>() {
         @Override
         public boolean apply(Node input) {
-          if (input.isCall()) {
+          if (input.getType() == Token.CALL) {
             return false;
           }
           // TODO(johnlenz): handle NEW calls that record their 'this'
-          // in global scope and effectively return an alias.
+          // in global scope and effectly return an alias.
           // Other non-local references are handled by this pass.
           return true;
         }
@@ -774,27 +720,26 @@
     }
 
     private void addSimplifiedExpression(Node n, Node parent) {
-      if (parent.isVar()) {
+      if (parent.getType() == Token.VAR) {
         Node value = n.getFirstChild();
         if (value != null) {
           addSimplifiedChildren(value);
         }
-      } else if (n.isAssign() &&
-          (parent.isExprResult() ||
-           parent.isFor() ||
-           parent.isReturn())) {
+      } else if (n.getType() == Token.ASSIGN &&
+          (parent.getType() == Token.EXPR_RESULT ||
+           parent.getType() == Token.FOR ||
+           parent.getType() == Token.RETURN)) {
         for (Node child : n.children()) {
           addSimplifiedChildren(child);
         }
-      } else if (n.isCall() &&
-                 parent.isExprResult()) {
+      } else if (n.getType() == Token.CALL &&
+                 parent.getType() == Token.EXPR_RESULT) {
         addSimplifiedChildren(n);
       } else {
         addAllChildren(n);
       }
     }
 
-    @Override
     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       if (parent == null) {
         return true;
@@ -804,7 +749,7 @@
       // arguments to function calls with side effects or are used in
       // control structure predicates.  These names are always
       // referenced when the enclosing function is called.
-      if (n.isFor()) {
+      if (n.getType() == Token.FOR) {
         if (!NodeUtil.isForIn(n)) {
           Node decl = n.getFirstChild();
           Node pred = decl.getNext();
@@ -820,38 +765,37 @@
         }
       }
 
-      if (parent.isVar() ||
-          parent.isExprResult() ||
-          parent.isReturn() ||
-          parent.isThrow()) {
+      if (parent.getType() == Token.VAR ||
+          parent.getType() == Token.EXPR_RESULT ||
+          parent.getType() == Token.RETURN ||
+          parent.getType() == Token.THROW) {
         addSimplifiedExpression(n, parent);
       }
 
-      if ((parent.isIf() ||
-           parent.isWhile() ||
-           parent.isWith() ||
-           parent.isSwitch() ||
-           parent.isCase()) &&
+      if ((parent.getType() == Token.IF ||
+           parent.getType() == Token.WHILE ||
+           parent.getType() == Token.WITH ||
+           parent.getType() == Token.SWITCH ||
+           parent.getType() == Token.CASE) &&
           parent.getFirstChild() == n) {
         addAllChildren(n);
       }
 
-      if (parent.isDo() && parent.getLastChild() == n) {
+      if (parent.getType() == Token.DO && parent.getLastChild() == n) {
         addAllChildren(n);
       }
 
       return true;
     }
 
-    @Override
     public void visit(NodeTraversal t, Node n, Node parent) {
-      if (!(n.isName() ||
-            NodeUtil.isGet(n) && !parent.isGetProp())) {
+      if (!(NodeUtil.isName(n) ||
+            NodeUtil.isGet(n) && !NodeUtil.isGetProp(parent))) {
         // This is not a simple or qualified name.
         return;
       }
 
-      NameInformation nameInfo = createNameInformation(t, n);
+      NameInformation nameInfo = createNameInformation(t, n, parent);
       if (nameInfo == null) {
         // The name is not a global name
         return;
@@ -875,13 +819,14 @@
         return;
       }
 
-      if (parent.isInstanceOf() &&
+      if (parent.getType() == Token.INSTANCEOF &&
           parent.getLastChild() == n &&
           // Don't cover GETELEMs with a global root node.
           n.isQualifiedName()) {
         JsName checkedClass = getName(nameInfo.name, true);
-        refNodes.add(new InstanceOfCheckNode(checkedClass, n));
-        checkedClass.hasInstanceOfReference = true;
+        refNodes.add(
+            new InstanceOfCheckNode(
+                checkedClass, n, parent, parent.getParent()));
         return;
       }
 
@@ -889,20 +834,7 @@
       // looking up the nearest enclosing dependency scope. It's unnecessary to
       // determine all enclosing dependency scopes because this callback should
       // create a chain of references between them.
-      List<NameInformation> referers = getDependencyScope(n);
-      if (referers.isEmpty()) {
-        maybeRecordReferenceOrAlias(t, n, parent, nameInfo, null);
-      } else {
-        for (NameInformation referring : referers) {
-          maybeRecordReferenceOrAlias(t, n, parent, nameInfo, referring);
-        }
-        recordAliases(referers);
-      }
-    }
-
-    private void maybeRecordReferenceOrAlias(
-        NodeTraversal t, Node n, Node parent,
-        NameInformation nameInfo, NameInformation referring) {
+      NameInformation referring = getDependencyScope(n);
       String referringName = "";
       if (referring != null) {
         referringName = referring.isPrototype
@@ -916,7 +848,7 @@
       // can be an alias to global object.
       // Here we add a alias to the general "global" object
       // to act as a placeholder for the actual (unnamed) value.
-      if (maybeHiddenAlias(n)) {
+      if (maybeHiddenAlias(name, n)) {
         recordAlias(name, WINDOW);
       }
 
@@ -930,7 +862,7 @@
 
       // An assignment implies a reference from the enclosing dependency scope.
       // For example, foo references bar in: function foo() {bar=5}.
-      if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {
+      if (NodeUtil.isLhs(n, parent)) {
         if (referring != null) {
           recordReference(referringName, name, RefType.REGULAR);
         }
@@ -938,17 +870,11 @@
       }
 
       if (nodesToKeep.contains(n)) {
-        List<NameInformation> functionScopes =
-            getEnclosingFunctionDependencyScope(t);
-        if (!functionScopes.isEmpty()) {
-          for (NameInformation functionScope : functionScopes) {
-            recordReference(functionScope.name, name, RefType.REGULAR);
-          }
+        NameInformation functionScope = getEnclosingFunctionDependencyScope(t);
+        if (functionScope != null) {
+          recordReference(functionScope.name, name, RefType.REGULAR);
         } else {
           recordReference(WINDOW, name, RefType.REGULAR);
-          if (referring != null) {
-            maybeRecordAlias(name, parent, referring, referringName);
-          }
         }
       } else if (referring != null) {
         if (!maybeRecordAlias(name, parent, referring, referringName)) {
@@ -963,7 +889,7 @@
         // protect this node by creating a reference to WINDOW.
         for (Node ancestor : n.getAncestors()) {
           if (NodeUtil.isAssignmentOp(ancestor) ||
-              ancestor.isFunction()) {
+              NodeUtil.isFunction(ancestor)) {
             recordReference(WINDOW, name, RefType.REGULAR);
             break;
           }
@@ -971,26 +897,16 @@
       }
     }
 
-    private void recordAliases(List<NameInformation> referers) {
-      int size = referers.size();
-      for (int i = 0; i < size; i++) {
-        for (int j = i + 1; j < size; j++) {
-          recordAlias(referers.get(i).name, referers.get(j).name);
-          recordAlias(referers.get(j).name, referers.get(i).name);
-        }
-      }
-    }
-
     /**
      * A value whose result is the return value of a function call
      * can be an alias to global object. The dependency on the call target will
      * prevent the removal of the function and its dependent values, but won't
      * prevent the alias' removal.
      */
-    private boolean maybeHiddenAlias(Node n) {
+    private boolean maybeHiddenAlias(String name, Node n) {
       Node parent = n.getParent();
-      if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {
-        Node rhs = (parent.isVar())
+      if (NodeUtil.isLhs(n, parent)) {
+        Node rhs = (parent.getType() == Token.VAR)
             ? n.getFirstChild() : parent.getLastChild();
         return (rhs != null && !NodeUtil.evaluatesToLocalValue(
             rhs, NON_LOCAL_RESULT_PREDICATE));
@@ -1004,31 +920,10 @@
     private boolean maybeRecordAlias(
         String name, Node parent,
         NameInformation referring, String referringName) {
-      // A common type of reference is
-      // function F() {}
-      // F.prototype.bar = goog.nullFunction;
-      //
-      // In this specific case, we do not want a reference to goog.nullFunction
-      // to preserve F.
-      //
-      // In the general case, the user could do something like
-      // function F() {}
-      // F.prototype.bar = goog.nullFunction;
-      // F.prototype.bar.baz = 3;
-      // where it would not be safe to remove F.
-      //
-      // So we do not treat this alias as a backdoor for people to mutate the
-      // original object. We think that this heuristic will always be
-      // OK in real code.
-      boolean isPrototypePropAssignment =
-          parent.isAssign()
-          && NodeUtil.isPrototypeProperty(parent.getFirstChild());
-
-      if ((parent.isName() ||
-          parent.isAssign()) &&
-          !isPrototypePropAssignment &&
+      if ((parent.getType() == Token.NAME ||
+          parent.getType() == Token.ASSIGN) &&
           referring != null &&
-          scopes.get(parent).contains(referring)) {
+          scopes.get(parent) == referring) {
         recordAlias(referringName, name);
         return true;
       }
@@ -1079,7 +974,6 @@
   }
 
   private class RemoveListener implements AstChangeProxy.ChangeListener {
-    @Override
     public void nodeRemoved(Node n) {
       compiler.reportCodeChange();
     }
@@ -1114,7 +1008,7 @@
     NodeTraversal.traverse(compiler, root, new FindReferences());
 
     // Create bi-directional references between parent names and their
-    // descendants. This may create new names.
+    // descendents. This may create new names.
     referenceParentNames();
 
     // If we modify the property of an alias, make sure that modification
@@ -1341,15 +1235,11 @@
    * directional reference from the original name to the alias. For example,
    * in this case, the assign to {@code a.foo} triggers a reference from
    * {@code b} to {@code a}, but NOT from a to b.
-   *
-   * Similarly, "instanceof" checks do not prevent the removal
-   * of a unaliased name but an instanceof check on an alias can only be removed
-   * if the other aliases are also removed, so we add a connection here.
    */
   private void referenceAliases() {
     for (Map.Entry<String, AliasSet> entry : aliases.entrySet()) {
       JsName name = getName(entry.getKey(), false);
-      if (name.hasWrittenDescendants || name.hasInstanceOfReference) {
+      if (name.hasWrittenDescendants) {
         for (String alias : entry.getValue().names) {
           recordReference(alias, entry.getKey(), RefType.REGULAR);
         }
@@ -1390,53 +1280,32 @@
    *
    * @param t The node traversal
    * @param n The current node
+   * @param parent The parent of n
    * @return The name information, or null if the name is irrelevant to this
    *     pass
    */
-  private NameInformation createNameInformation(NodeTraversal t, Node n) {
-    Node parent = n.getParent();
+  private NameInformation createNameInformation(NodeTraversal t, Node n,
+      Node parent) {
     // Build the full name and find its root node by iterating down through all
     // GETPROP/GETELEM nodes.
     String name = "";
     Node rootNameNode = n;
     boolean bNameWasShortened = false;
-    while (true) {
-      if (NodeUtil.isGet(rootNameNode)) {
-        Node prop = rootNameNode.getLastChild();
-        if (rootNameNode.isGetProp()) {
-          name = "." + prop.getString() + name;
-        } else {
-          // We consider the name to be "a.b" in a.b['c'] or a.b[x].d.
-          bNameWasShortened = true;
-          name = "";
-        }
-        rootNameNode = rootNameNode.getFirstChild();
-      } else if (NodeUtil.isObjectLitKey(rootNameNode)) {
-        name = "." + rootNameNode.getString() + name;
-
-        // Check if this is an object literal assigned to something.
-        Node objLit = rootNameNode.getParent();
-        Node objLitParent = objLit.getParent();
-        if (objLitParent.isAssign()) {
-          // This must be the right side of the assign.
-          rootNameNode = objLitParent.getFirstChild();
-        } else if (objLitParent.isName()) {
-          // This must be a VAR initialization.
-          rootNameNode = objLitParent;
-        } else if (objLitParent.isStringKey()) {
-          // This must be a object literal key initialization.
-          rootNameNode = objLitParent;
-        } else {
-          return null;
-        }
+    while (NodeUtil.isGet(rootNameNode)) {
+      Node prop = rootNameNode.getLastChild();
+      if (rootNameNode.getType() == Token.GETPROP) {
+        name = "." + prop.getString() + name;
       } else {
-        break;
+        // We consider the name to be "a.b" in a.b['c'] or a.b[x].d.
+        bNameWasShortened = true;
+        name = "";
       }
+      rootNameNode = rootNameNode.getFirstChild();
     }
 
     // Check whether this is a class-defining call. Classes may only be defined
     // in the global scope.
-    if (parent.isCall() && t.inGlobalScope()) {
+    if (NodeUtil.isCall(parent) && t.inGlobalScope()) {
       CodingConvention convention = compiler.getCodingConvention();
       SubclassRelationship classes = convention.getClassesDefinedByCall(parent);
       if (classes != null) {
@@ -1462,10 +1331,10 @@
         // Check whether this is an assignment to a prototype property
         // of an object defined in the global scope.
         if (!bNameWasShortened &&
-            n.isGetProp() &&
-            parent.isAssign() &&
+            n.getType() == Token.GETPROP &&
+            parent.getType() == Token.ASSIGN &&
             "prototype".equals(n.getLastChild().getString())) {
-          if (createNameInformation(t, n.getFirstChild()) != null) {
+          if (createNameInformation(t, n.getFirstChild(), n) != null) {
             name = rootNameNode.getString() + name;
             name = name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN);
             NameInformation nameInfo = new NameInformation();
@@ -1559,15 +1428,15 @@
   /**
    * Gets the nearest enclosing dependency scope, or null if there isn't one.
    */
-  private List<NameInformation> getDependencyScope(Node n) {
+  private NameInformation getDependencyScope(Node n) {
     for (Node node : n.getAncestors()) {
-      List<NameInformation> refs = scopes.get(node);
-      if (!refs.isEmpty()) {
-        return refs;
+      NameInformation ref = scopes.get(node);
+      if (ref != null) {
+        return ref;
       }
     }
 
-    return Collections.emptyList();
+    return null;
   }
 
   /**
@@ -1576,16 +1445,15 @@
    * its parent if the parent node is a variable declaration or
    * assignment.
    */
-  private List<NameInformation> getEnclosingFunctionDependencyScope(
-      NodeTraversal t) {
+  private NameInformation getEnclosingFunctionDependencyScope(NodeTraversal t) {
     Node function = t.getEnclosingFunction();
     if (function == null) {
-      return Collections.emptyList();
+      return null;
     }
 
-    List<NameInformation> refs = scopes.get(function);
-    if (!refs.isEmpty()) {
-      return refs;
+    NameInformation ref = scopes.get(function);
+    if (ref != null) {
+      return ref;
     }
 
     // Function expression.  try to get a name from the parent var
@@ -1594,20 +1462,23 @@
     if (parent != null) {
       // Account for functions defined in the form:
       //   var a = cond ? function a() {} : function b() {};
-      while (parent.isHook()) {
+      while (parent.getType() == Token.HOOK) {
         parent = parent.getParent();
       }
 
-      if (parent.isName()) {
+      if (parent.getType() == Token.NAME) {
         return scopes.get(parent);
       }
 
-      if (parent.isAssign()) {
-        return scopes.get(parent);
+      if (parent.getType() == Token.ASSIGN) {
+        Node gramp = parent.getParent();
+        if (gramp != null && gramp.getType() == Token.EXPR_RESULT) {
+          return scopes.get(gramp);
+        }
       }
     }
 
-    return Collections.emptyList();
+    return null;
   }
 
   /**
@@ -1676,8 +1547,7 @@
         compiler, n,
         new GatherSideEffectSubexpressionsCallback(
             compiler,
-            new GetReplacementSideEffectSubexpressions(
-                compiler, subexpressions)));
+            new CopySideEffectSubexpressions(compiler, subexpressions)));
 
     List<Node> replacements =
         Lists.newArrayListWithExpectedSize(subexpressions.size());
@@ -1691,7 +1561,7 @@
    * Replace n with a simpler expression, while preserving program
    * behavior.
    *
-   * If the n's value is used, replace it with its RHS; otherwise
+   * If the n's value is used, replace it with its rhs; otherwise
    * replace it with the subexpressions that have side effects.
    */
   private void replaceWithRhs(Node parent, Node n) {
@@ -1708,7 +1578,7 @@
       newReplacements.add(valueExpr);
       changeProxy.replaceWith(
           parent, n, collapseReplacements(newReplacements));
-    } else if (n.isAssign() && !parent.isFor()) {
+    } else if (n.getType() == Token.ASSIGN && parent.getType() != Token.FOR) {
       // assignment appears in a RHS expression.  we have already
       // considered names in the assignment's RHS as being referenced;
       // replace the assignment with its RHS.
@@ -1746,8 +1616,9 @@
       case Token.VAR:
         break;
       case Token.ASSIGN:
-        Preconditions.checkArgument(parent.isFor(),
-            "Unsupported assignment in replaceWithRhs. parent: %s",
+        Preconditions.checkArgument(
+            parent.getType() == Token.FOR,
+            "Unsupported assignment in replaceWithRhs. parent: " +
             Token.name(parent.getType()));
         break;
       default:
@@ -1762,10 +1633,10 @@
       replacements.addAll(getSideEffectNodes(rhs));
     }
 
-    if (parent.isFor()) {
+    if (parent.getType() == Token.FOR) {
       // tweak replacements array s.t. it is a single expression node.
       if (replacements.isEmpty()) {
-        replacements.add(IR.empty());
+        replacements.add(new Node(Token.EMPTY));
       } else {
         Node expr = collapseReplacements(replacements);
         replacements.clear();
@@ -1779,14 +1650,14 @@
   /**
    * Determine if the parent reads the value of a child expression
    * directly.  This is true children used in predicates, RETURN
-   * statements and, RHS of variable declarations and assignments.
+   * statements and, rhs of variable declarations and assignments.
    *
    * In the case of:
    * if (a) b else c
    *
    * This method returns true for "a", and false for "b" and "c": the
    * IF expression does something special based on "a"'s value.  "b"
-   * and "c" are effectively outputs.  Same logic applies to FOR,
+   * and "c" are effectivelly outputs.  Same logic applies to FOR,
    * WHILE and DO loop predicates.  AND/OR/HOOK expressions are
    * syntactic sugar for IF statements; therefore this method returns
    * true for the predicate and false otherwise.
@@ -1823,7 +1694,7 @@
   private Node collapseReplacements(List<Node> replacements) {
     Node expr = null;
     for (Node rep : replacements) {
-      if (rep.isExprResult()) {
+      if (rep.getType() == Token.EXPR_RESULT) {
         rep = rep.getFirstChild();
         rep.detachFromParent();
       }
@@ -1831,7 +1702,7 @@
       if (expr == null) {
         expr = rep;
       } else {
-        expr = IR.comma(expr, rep);
+        expr = new Node(Token.COMMA, expr, rep);
       }
     }
 
@@ -1847,11 +1718,11 @@
         // process body
         return getRhsSubexpressions(n.getFirstChild());
       case Token.FUNCTION:
-        // function nodes have no RHS
+        // function nodes have no rhs
         return Collections.emptyList();
       case Token.NAME:
         {
-          // parent is a var node.  RHS is the first child
+          // parent is a var node.  rhs is first child
           Node rhs = n.getFirstChild();
           if (rhs != null) {
             return Lists.newArrayList(rhs);
@@ -1861,7 +1732,7 @@
         }
       case Token.ASSIGN:
         {
-          // add LHS and RHS expressions - LHS may be a complex expression
+          // add lhs and rhs expressions - lhs may be a complex expression
           Node lhs = n.getFirstChild();
           Node rhs = lhs.getNext();
           return Lists.newArrayList(lhs, rhs);
diff -r -u buggy/test/com/google/javascript/jscomp/NameAnalyzerTest.java inducing/test/com/google/javascript/jscomp/NameAnalyzerTest.java
--- buggy/test/com/google/javascript/jscomp/NameAnalyzerTest.java	2023-06-12 11:34:32.510331269 +0800
+++ inducing/test/com/google/javascript/jscomp/NameAnalyzerTest.java	2023-06-12 11:34:32.922338796 +0800
@@ -27,9 +27,7 @@
   private static String kExterns =
       "var window, top;" +
       "var document;" +
-      "var Function;" +
-      "var Array;" +
-      "var externfoo; methods.externfoo;";
+      "var Function; var externfoo; methods.externfoo;";
 
   public NameAnalyzerTest() {
     super(kExterns);
@@ -47,84 +45,43 @@
     return 1;
   }
 
-  public void testRemoveVarDeclaration1() {
+  public void testRemoveVarDeclartion1() {
     test("var foo = 3;", "");
   }
 
-  public void testRemoveVarDeclaration2() {
+  public void testRemoveVarDeclartion2() {
     test("var foo = 3, bar = 4; externfoo = foo;",
          "var foo = 3; externfoo = foo;");
   }
 
-  public void testRemoveVarDeclaration3() {
+  public void testRemoveVarDeclartion3() {
     test("var a = f(), b = 1, c = 2; b; c", "f();var b = 1, c = 2; b; c");
   }
 
-  public void testRemoveVarDeclaration4() {
+  public void testRemoveVarDeclartion4() {
     test("var a = 0, b = f(), c = 2; a; c", "var a = 0;f();var c = 2; a; c");
   }
 
-  public void testRemoveVarDeclaration5() {
+  public void testRemoveVarDeclartion5() {
     test("var a = 0, b = 1, c = f(); a; b", "var a = 0, b = 1; f(); a; b");
   }
 
-  public void testRemoveVarDeclaration6() {
+  public void testRemoveVarDeclartion6() {
     test("var a = 0, b = a = 1; a", "var a = 0; a = 1; a");
   }
 
-  public void testRemoveVarDeclaration7() {
+  public void testRemoveVarDeclartion7() {
     test("var a = 0, b = a = 1", "");
   }
 
-  public void testRemoveVarDeclaration8() {
+  public void testRemoveVarDeclartion8() {
     test("var a;var b = 0, c = a = b = 1", "");
   }
 
-
-  public void testRemoveDeclaration1() {
-    test("var a;var b = 0, c = a = b = 1", "");
-  }
-
-  public void testRemoveDeclaration2() {
-    test("var a,b,c; c = a = b = 1", "");
-  }
-
-  public void testRemoveDeclaration3() {
-    test("var a,b,c; c = a = b = {}; a.x = 1;", "");
-  }
-
-  public void testRemoveDeclaration4() {
-    testSame("var a,b,c; c = a = b = {}; a.x = 1;alert(c.x);");
-  }
-
-  public void testRemoveDeclaration5() {
-    test("var a,b,c; c = a = b = null; use(b)", "var b;b=null;use(b)");
-  }
-
-  public void testRemoveDeclaration6() {
-    test("var a,b,c; c = a = b = 'str';use(b)", "var b;b='str';use(b)");
-  }
-
-  public void testRemoveDeclaration7() {
-    test("var a,b,c; c = a = b = true;use(b)", "var b;b=true;use(b)");
-  }
-
-  public void testRemoveFunction1() {
-    test("var foo = function(){};", "");
-  }
-
-  public void testRemoveFunction2() {
-    test("var foo; foo = function(){};", "");
-  }
-
-  public void testRemoveFunction3() {
+  public void testRemoveFunction() {
     test("var foo = {}; foo.bar = function() {};", "");
   }
 
-  public void testRemoveFunction4() {
-    test("var a = {}; a.b = {}; a.b.c = function() {};", "");
-  }
-
   public void testReferredToByWindow() {
     testSame("var foo = {}; foo.bar = function() {}; window['fooz'] = foo.bar");
   }
@@ -145,16 +102,12 @@
     test("var f = function (){f()}", "");
   }
 
-  public void testRemoveRecursiveFunction2a() {
-    test("var f = function g(){g()}", "");
-  }
-
   public void testRemoveRecursiveFunction3() {
     test("var f;f = function (){f()}", "");
   }
 
   public void testRemoveRecursiveFunction4() {
-    // don't removed if name definition doesn't exist.
+    // TODO(user) bug?  not removed if name definition doesn't exist.
     testSame("f = function (){f()}");
   }
 
@@ -615,22 +568,6 @@
          "var e = false;if(e);");
   }
 
-  public void testIf4a() {
-    // TODO(johnlenz): fix this.
-    testSame("var e = [], f;if(f=e);f[0] = 1;");
-  }
-
-  public void testIf4b() {
-    // TODO(johnlenz): fix this.
-    test("var e = [], f;if(e=f);f[0] = 1;",
-         "var f;if(f);f[0] = 1;");
-  }
-
-  public void testIf4c() {
-    test("var e = [], f;if(f=e);e[0] = 1;",
-         "var e = [];if(e);e[0] = 1;");
-  }
-
   public void testIf5() {
     test("var e = false, f;var foo = {};if(f = e + 1)foo.bar=function(){};",
          "var e = false;if(e + 1);");
@@ -753,11 +690,17 @@
   }
 
   public void testSetterInForIn3() {
-    testSame("var foo = {}; var bar; for(e in bar = foo.a); bar.b = 3");
+    // TODO(user) Fix issue similar to b/2316773: bar should be preserved
+    // but isn't due to missing references between e and foo.a
+    test("var foo = {}; var bar; for(e in bar = foo.a); bar.b = 3",
+         "var foo = {}; for(e in foo.a);");
   }
 
   public void testSetterInForIn4() {
-    testSame("var foo = {}; var bar; for (e in bar = foo.a); bar.b = 3; foo.a");
+    // TODO(user) Fix issue similar to b/2316773: bar should be preserved
+    // but isn't due to missing references between e and foo.a
+    test("var foo = {}; var bar; for (e in bar = foo.a); bar.b = 3; foo.a",
+         "var foo = {}; for (e in foo.a); foo.a");
   }
 
   public void testSetterInForIn5() {
@@ -806,13 +749,9 @@
     testSame("var x = 0; x += 3; x *= 5;");
   }
 
-  public void testNestedAssigns1() {
-    test("var x = 0; var y = x = 3; window.alert(y);",
-         "var y = 3; window.alert(y);");
-  }
-
-  public void testNestedAssigns2() {
-    testSame("var x = 0; var y = x = {}; x.b = 3; window.alert(y);");
+  public void testNestedAssigns() {
+    // TODO(nicksantos): Make NameAnalyzer smarter, so that we can eliminate x.
+    testSame("var x = 0; var y = x = 3; window.alert(y);");
   }
 
   public void testComplexNestedAssigns1() {
@@ -932,11 +871,6 @@
     testSame("var g; 1 || (externfoo.x = function() { g; })");
   }
 
-  public void testConditionallyDefinedFunction3() {
-      testSame("var a = {};" +
-           "rand() % 2 || (a.f = function() { externfoo = 1; } || alert());");
-  }
-
   public void testGetElemOnThis() {
     testSame("var a = 3; this['foo'] = a;");
     testSame("this['foo'] = 3;");
@@ -985,19 +919,6 @@
         "}; new Bar().func();");
   }
 
-  public void testDoNotChangeLocalScopeReferencedLocalScopedInstanceOf2() {
-    test(
-        "function Foo() {}" +
-        "var createAxis = function(f) { return window.passThru(f); };" +
-        "var axis = createAxis(function(test) {" +
-        "  return test instanceof Foo;" +
-        "});",
-        "var createAxis = function(f) { return window.passThru(f); };" +
-        "createAxis(function(test) {" +
-        "  return false;" +
-        "});");
-  }
-
   public void testDoNotChangeInstanceOfGetElem() {
     testSame("var goog = {};" +
         "function f(obj, name) {" +
@@ -1148,13 +1069,6 @@
         "");
   }
 
-  public void testAssignWithHook2a() {
-    test("function Foo(){} var foo = null;" +
-        "var f; f = window.a ? " +
-        "    function () {return new Foo()} : function () {return foo};",
-        "");
-  }
-
   public void testAssignWithHook3() {
     testSame("function Foo(){} var foo = null; var f = {};" +
         "f.b = window.a ? " +
@@ -1183,72 +1097,20 @@
         "");
   }
 
-  public void testAssignWithHook7() {
-    testSame("function Foo(){} var foo = null;" +
-        "var f = window.a ? new Foo() : foo;" +
-        "f()");
-  }
-
-  public void testAssignWithHook8() {
-    test("function Foo(){} var foo = null;" +
-        "var f = window.a ? new Foo() : foo;",
-        "function Foo(){}" +
-        "window.a && new Foo()");
-  }
-
-  public void testAssignWithHook9() {
-    test("function Foo(){} var foo = null; var f = {};" +
-        "f.b = window.a ? new Foo() : foo;",
-        "function Foo(){} window.a && new Foo()");
-  }
-
-  public void testAssign1() {
-    test("function Foo(){} var foo = null; var f = {};" +
-        "f.b = window.a;",
-        "");
-  }
-
-  public void testAssign2() {
-    test("function Foo(){} var foo = null; var f = {};" +
-        "f.b = window;",
-        "");
-  }
-
-  public void testAssign3() {
-    test("var f = {};" +
-        "f.b = window;",
-        "");
-  }
-
-  public void testAssign4() {
-    test("function Foo(){} var foo = null; var f = {};" +
-        "f.b = new Foo();",
-        "function Foo(){} new Foo()");
-  }
-
-  public void testAssign5() {
-    test("function Foo(){} var foo = null; var f = {};" +
-        "f.b = foo;",
-        "");
-  }
-
   public void testNestedAssign1() {
     test("var a, b = a = 1, c = 2", "");
   }
 
   public void testNestedAssign2() {
-    test("var a, b = a = 1; foo(b)",
-         "var b = 1; foo(b)");
+    testSame("var a, b = a = 1; foo(b)");
   }
 
   public void testNestedAssign3() {
-    test("var a, b = a = 1; a = b = 2; foo(b)",
-         "var b = 1; b = 2; foo(b)");
+    testSame("var a, b = a = 1; a = b = 2; foo(b)");
   }
 
   public void testNestedAssign4() {
-    test("var a, b = a = 1; b = a = 2; foo(b)",
-         "var b = 1; b = 2; foo(b)");
+    testSame("var a, b = a = 1; b = a = 2; foo(b)");
   }
 
   public void testNestedAssign5() {
@@ -1571,7 +1433,13 @@
         "this.x = Foo.getInstance();");
   }
 
-
+  // TODO(user): Make NameAnalyzer handle this. The OR subexpressions may
+  // modify global state.
+  // public void testConditionallyDefinedFunction3() {
+  //    test("var a = {};" +
+  //         "rand() % 2 || (a.f = function() { externfoo = 1; } || alert());",
+  //         "rand() % 2 || function() { externfoo = 1; } || alert();");
+  // }
 
   public void testNoRemoveWindowPropertyAlias1() {
      testSame(
@@ -1591,62 +1459,6 @@
         "self_['qs'] = function() {};");
   }
 
-  public void testNoRemoveWindowPropertyAlias4() {
-    // TODO(johnlenz): fix this. "self_" should remain.
-    test(
-        "var self_ = window['gbar'] || {};\n" +
-        "self_.qs = function() {};",
-        "");
- }
-
-  public void testNoRemoveWindowPropertyAlias4a() {
-    // TODO(johnlenz): fix this. "self_" should remain.
-    test(
-        "var self_; self_ = window.gbar || {};\n" +
-        "self_.qs = function() {};",
-        "");
- }
-
-  public void testNoRemoveWindowPropertyAlias5() {
-    // TODO(johnlenz): fix this. "self_" should remain.
-    test(
-        "var self_ = window || {};\n" +
-        "self_['qs'] = function() {};",
-        "");
-  }
-
-  public void testNoRemoveWindowPropertyAlias5a() {
-    // TODO(johnlenz): fix this.
-    test(
-        "var self_; self_ = window || {};\n" +
-        "self_['qs'] = function() {};",
-        "");
-  }
-
-  public void testNoRemoveWindowPropertyAlias6() {
-    testSame(
-        "var self_ = (window.gbar = window.gbar || {});\n" +
-        "self_.qs = function() {};");
-  }
-
-  public void testNoRemoveWindowPropertyAlias6a() {
-    testSame(
-        "var self_; self_ = (window.gbar = window.gbar || {});\n" +
-        "self_.qs = function() {};");
-  }
-
-  public void testNoRemoveWindowPropertyAlias7() {
-    testSame(
-        "var self_ = (window = window || {});\n" +
-        "self_['qs'] = function() {};");
-  }
-
-  public void testNoRemoveWindowPropertyAlias7a() {
-    testSame(
-        "var self_; self_ = (window = window || {});\n" +
-        "self_['qs'] = function() {};");
-  }
-
   public void testNoRemoveAlias0() {
     testSame(
         "var x = {}; function f() { return x; }; " +
@@ -1708,221 +1520,6 @@
       "throw new e();");
   }
 
-  public void testClassDefinedInObjectLit1() {
-    test(
-      "var data = {Foo: function() {}};" +
-      "data.Foo.prototype.toString = function() {};",
-      "");
-  }
-
-  public void testClassDefinedInObjectLit2() {
-    test(
-      "var data = {}; data.bar = {Foo: function() {}};" +
-      "data.bar.Foo.prototype.toString = function() {};",
-      "");
-  }
-
-  public void testClassDefinedInObjectLit3() {
-    test(
-      "var data = {bar: {Foo: function() {}}};" +
-      "data.bar.Foo.prototype.toString = function() {};",
-      "");
-  }
-
-  public void testClassDefinedInObjectLit4() {
-    test(
-      "var data = {};" +
-      "data.baz = {bar: {Foo: function() {}}};" +
-      "data.baz.bar.Foo.prototype.toString = function() {};",
-      "");
-  }
-
-  public void testVarReferencedInClassDefinedInObjectLit1() {
-    testSame(
-      "var ref = 3;" +
-      "var data = {Foo: function() { this.x = ref; }};" +
-      "window.Foo = data.Foo;");
-  }
-
-  public void testVarReferencedInClassDefinedInObjectLit2() {
-    testSame(
-      "var ref = 3;" +
-      "var data = {Foo: function() { this.x = ref; }," +
-      "            Bar: function() {}};" +
-      "window.Bar = data.Bar;");
-  }
-
-  public void testArrayExt() {
-    testSame(
-      "Array.prototype.foo = function() { return 1 };" +
-      "var y = [];" +
-      "switch (y.foo()) {" +
-      "}");
-  }
-
-  public void testArrayAliasExt() {
-    testSame(
-      "Array$X = Array;" +
-      "Array$X.prototype.foo = function() { return 1 };" +
-      "function Array$X() {}" +
-      "var y = [];" +
-      "switch (y.foo()) {" +
-      "}");
-  }
-
-  public void testExternalAliasInstanceof1() {
-    test(
-      "Array$X = Array;" +
-      "function Array$X() {}" +
-      "var y = [];" +
-      "if (y instanceof Array) {}",
-      "var y = [];" +
-      "if (y instanceof Array) {}"
-      );
-  }
-
-  public void testExternalAliasInstanceof2() {
-    testSame(
-      "Array$X = Array;" +
-      "function Array$X() {}" +
-      "var y = [];" +
-      "if (y instanceof Array$X) {}");
-  }
-
-  public void testExternalAliasInstanceof3() {
-    testSame(
-      "var b = Array;" +
-      "var y = [];" +
-      "if (y instanceof b) {}");
-  }
-
-  public void testAliasInstanceof4() {
-    testSame(
-      "function Foo() {};" +
-      "var b = Foo;" +
-      "var y = new Foo();" +
-      "if (y instanceof b) {}");
-  }
-
-  public void testAliasInstanceof5() {
-    // TODO(johnlenz): fix this. "b" should remain.
-    test(
-      "function Foo() {}" +
-      "function Bar() {}" +
-      "var b = x ? Foo : Bar;" +
-      "var y = new Foo();" +
-      "if (y instanceof b) {}",
-      "function Foo() {}" +
-      "var y = new Foo;" +
-      "if (false){}");
-  }
-
-  // We cannot leave x.a.prototype there because it will
-  // fail sanity var check.
-  public void testBrokenNamespaceWithPrototypeAssignment() {
-    test("var x = {}; x.a.prototype = 1", "");
-  }
-
-  public void testRemovePrototypeAliases() {
-    test(
-        "function g() {}" +
-        "function F() {} F.prototype.bar = g;" +
-        "window.g = g;",
-        "function g() {}" +
-        "window.g = g;");
-  }
-
-  public void testIssue284() {
-    test(
-        "var goog = {};" +
-        "goog.inherits = function(x, y) {};" +
-        "var ns = {};" +
-        "/** @constructor */" +
-        "ns.PageSelectionModel = function() {};" +
-        "/** @constructor */" +
-        "ns.PageSelectionModel.FooEvent = function() {};" +
-        "/** @constructor */" +
-        "ns.PageSelectionModel.SelectEvent = function() {};" +
-        "goog.inherits(ns.PageSelectionModel.ChangeEvent," +
-        "    ns.PageSelectionModel.FooEvent);",
-        "");
-  }
-
-  public void testIssue838a() {
-    testSame("var z = window['z'] || (window['z'] = {});\n" +
-         "z['hello'] = 'Hello';\n" +
-         "z['world'] = 'World';");
-  }
-
-  public void testIssue838b() {
-    testSame(
-         "var z;" +
-         "window['z'] = z || (z = {});\n" +
-         "z['hello'] = 'Hello';\n" +
-         "z['world'] = 'World';");
-  }
-
-
-  public void testIssue874a() {
-    testSame(
-        "var a = a || {};\n" +
-        "var b = a;\n" +
-        "b.View = b.View || {}\n" +
-        "var c = b.View;\n" +
-        "c.Editor = function f(d, e) {\n" +
-        "  return d + e\n" +
-        "};\n" +
-        "window.ImageEditor.View.Editor = a.View.Editor;");
-  }
-
-  public void testIssue874b() {
-    testSame(
-        "var b;\n" +
-        "var c = b = {};\n" +
-        "c.Editor = function f(d, e) {\n" +
-        "  return d + e\n" +
-        "};\n" +
-        "window['Editor'] = b.Editor;");
-  }
-
-  public void testIssue874c() {
-    testSame(
-        "var b, c;\n" +
-        "c = b = {};\n" +
-        "c.Editor = function f(d, e) {\n" +
-        "  return d + e\n" +
-        "};\n" +
-        "window['Editor'] = b.Editor;");
-  }
-
-  public void testIssue874d() {
-    testSame(
-        "var b = {}, c;\n" +
-        "c = b;\n" +
-        "c.Editor = function f(d, e) {\n" +
-        "  return d + e\n" +
-        "};\n" +
-        "window['Editor'] = b.Editor;");
-  }
-
-  public void testIssue874e() {
-    testSame(
-        "var a;\n" +
-        "var b = a || (a = {});\n" +
-        "var c = b.View || (b.View = {});\n" +
-        "c.Editor = function f(d, e) {\n" +
-        "  return d + e\n" +
-        "};\n" +
-        "window.ImageEditor.View.Editor = a.View.Editor;");
-  }
-
-  public void testBug6575051() {
-    testSame(
-        "var hackhack = window['__o_o_o__'] = window['__o_o_o__'] || {};\n" +
-        "window['__o_o_o__']['va'] = 1;\n" +
-        "hackhack['Vb'] = 1;");
-  }
-
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
     return new MarkNoSideEffectCallsAndNameAnalyzerRunner(compiler);
@@ -1937,7 +1534,6 @@
       this.analyzer = new NameAnalyzer(compiler, true);
     }
 
-    @Override
     public void process(Node externs, Node root) {
       markNoSideEffectCalls.process(externs, root);
       analyzer.process(externs, root);
