{
  "logger": {
    "currentLogLevel": 20,
    "name": "root.bean.benchmarks.Defects4JBug"
  },
  "d4jCmd": "/home/liumengjiao/Desktop/defects4j/framework/bin/defects4j",
  "dataDir": "data/changesInfo/",
  "timeoutSecond": 300,
  "proj": "Closure",
  "id": "48",
  "workingDir": "../bugs/Closure_48_buggy",
  "inducingCommit": "41abf3b75893403d9e21c33d06e8dc233b5cf657",
  "originalCommit": "e1feab189248bba77e40434f2bf5185cad6a20e7",
  "bug_name": "Closure_48",
  "derive": "defects4j",
  "original_fixing_commit": "46da17d59abb4f9c48b6ffd31601c212490b970b",
  "buildFiles_changed": false,
  "inducing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "src/com/google/javascript/jscomp/TypedScopeCreator.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "getObjectSlot",
            "CollectProperties",
            "createScope",
            "maybeDeclareQualifiedName",
            "visit",
            "visit",
            "checkForTypedef",
            "GlobalScopeBuilder",
            "visit",
            "getDeclaredGetPropType",
            "getFunctionType",
            "visit",
            "resolveStubDeclarations",
            "StubDeclaration",
            "maybeCollectMember"
          ],
          "num": 15
        },
        {
          "qualified_names": [
            "getDeclaredGetPropType",
            "maybeDeclareQualifiedName",
            "createScope",
            "visit",
            "getFunctionType",
            "maybeDeclareQualifiedName",
            "checkForTypedef",
            "CollectProperties",
            "resolveStubDeclarations",
            "getObjectSlot",
            "defineSlot",
            "visit",
            "visit",
            "GlobalScopeBuilder",
            "StubDeclaration",
            "visit",
            "maybeCollectMember"
          ],
          "num": 17
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "165",
            "167",
            "168",
            "169",
            "170",
            "171",
            "172",
            "173",
            "174",
            "175",
            "176",
            "177",
            "178",
            "179",
            "180",
            "181",
            "182",
            "183",
            "184",
            "185",
            "186",
            "189",
            "190",
            "191",
            "361",
            "406",
            "618",
            "619",
            "866",
            "867",
            "868",
            "869",
            "870",
            "871",
            "872",
            "875",
            "876",
            "877",
            "878",
            "879",
            "880",
            "882",
            "883",
            "885",
            "886",
            "887",
            "888",
            "889",
            "890",
            "891",
            "892",
            "893",
            "894",
            "895",
            "896",
            "897",
            "898",
            "899",
            "900",
            "901",
            "902",
            "903",
            "904",
            "905",
            "906",
            "907",
            "908",
            "909",
            "910",
            "911",
            "912",
            "913",
            "914",
            "915",
            "916",
            "917",
            "918",
            "919",
            "920",
            "921",
            "922",
            "923",
            "924",
            "925",
            "926",
            "927",
            "928",
            "929",
            "930",
            "931",
            "932",
            "933",
            "934",
            "935",
            "936",
            "937",
            "938",
            "939",
            "940",
            "941",
            "942",
            "943",
            "944",
            "945",
            "946",
            "947",
            "948",
            "949",
            "950",
            "951",
            "952",
            "953",
            "954",
            "955",
            "956",
            "957",
            "958",
            "959",
            "1070",
            "1139",
            "1140",
            "1141",
            "1142",
            "1143",
            "1144",
            "1145",
            "1146",
            "1147",
            "1148",
            "1149",
            "1150",
            "1151",
            "1152",
            "1153",
            "1154",
            "1155",
            "1156",
            "1157",
            "1158",
            "1159",
            "1160",
            "1161",
            "1162",
            "1163",
            "1164",
            "1165",
            "1166",
            "1167",
            "1168",
            "1169",
            "1170",
            "1171",
            "1172",
            "1173",
            "1174",
            "1175",
            "1176",
            "1177",
            "1178",
            "1179",
            "1180",
            "1181",
            "1182",
            "1183",
            "1184",
            "1185",
            "1186",
            "1187",
            "1188",
            "1189",
            "1190",
            "1191",
            "1192",
            "1193",
            "1194",
            "1195",
            "1196",
            "1197",
            "1198",
            "1199",
            "1200",
            "1201",
            "1202",
            "1203",
            "1204",
            "1205",
            "1206",
            "1207",
            "1208",
            "1209",
            "1210",
            "1211",
            "1212",
            "1213",
            "1214",
            "1215",
            "1216",
            "1217",
            "1218",
            "1219",
            "1220",
            "1221",
            "1222",
            "1223",
            "1224",
            "1225",
            "1226",
            "1227",
            "1228",
            "1229",
            "1230",
            "1231",
            "1232",
            "1233",
            "1234",
            "1235",
            "1236",
            "1237",
            "1238",
            "1239",
            "1240",
            "1241",
            "1242",
            "1243",
            "1244",
            "1245",
            "1246",
            "1247",
            "1248",
            "1249",
            "1250",
            "1251",
            "1252",
            "1253",
            "1254",
            "1255",
            "1256",
            "1257",
            "1258",
            "1259",
            "1260",
            "1261",
            "1262",
            "1263",
            "1264",
            "1265",
            "1266",
            "1267",
            "1268",
            "1269",
            "1270",
            "1271",
            "1272",
            "1273",
            "1274",
            "1275",
            "1276",
            "1277",
            "1278",
            "1279",
            "1280",
            "1281",
            "1282",
            "1283",
            "1284",
            "1285",
            "1286",
            "1287",
            "1288",
            "1289",
            "1290",
            "1291",
            "1292",
            "1293",
            "1294",
            "1295",
            "1296",
            "1297",
            "1298",
            "1299",
            "1300",
            "1301",
            "1302",
            "1303",
            "1304",
            "1305",
            "1306",
            "1307",
            "1308",
            "1309",
            "1310",
            "1311",
            "1312",
            "1313",
            "1314",
            "1315",
            "1316",
            "1317",
            "1318",
            "1319",
            "1320",
            "1321",
            "1322",
            "1323",
            "1324",
            "1325",
            "1326",
            "1327",
            "1328",
            "1329",
            "1330",
            "1331",
            "1332",
            "1333",
            "1334",
            "1335",
            "1336",
            "1337",
            "1338",
            "1339",
            "1340",
            "1341",
            "1342",
            "1343",
            "1344",
            "1345",
            "1346",
            "1347",
            "1348",
            "1349",
            "1350",
            "1351",
            "1352",
            "1353",
            "1354",
            "1355",
            "1356",
            "1357",
            "1358",
            "1359",
            "1360",
            "1361",
            "1362",
            "1363",
            "1364",
            "1365",
            "1366",
            "1367",
            "1368",
            "1369",
            "1370",
            "1371",
            "1372",
            "1373",
            "1374",
            "1375",
            "1376",
            "1377",
            "1378",
            "1379",
            "1380",
            "1381",
            "1382",
            "1383",
            "1384",
            "1385",
            "1386",
            "1387",
            "1388",
            "1389",
            "1390",
            "1428",
            "1429",
            "1430",
            "1431",
            "1432",
            "1433",
            "1434",
            "1435",
            "1436",
            "1437",
            "1438",
            "1439",
            "1440",
            "1441",
            "1442",
            "1443",
            "1444",
            "1445"
          ],
          "num": 389
        },
        {
          "qualified_names": [
            "161",
            "166",
            "167",
            "171",
            "172",
            "173",
            "174",
            "175",
            "176",
            "177",
            "178",
            "179",
            "180",
            "181",
            "182",
            "183",
            "184",
            "185",
            "186",
            "187",
            "188",
            "189",
            "190",
            "191",
            "192",
            "193",
            "194",
            "195",
            "196",
            "367",
            "368",
            "369",
            "370",
            "371",
            "372",
            "373",
            "374",
            "375",
            "376",
            "377",
            "378",
            "379",
            "380",
            "425",
            "426",
            "427",
            "428",
            "429",
            "430",
            "431",
            "432",
            "433",
            "434",
            "435",
            "436",
            "437",
            "438",
            "439",
            "440",
            "441",
            "442",
            "443",
            "444",
            "445",
            "446",
            "447",
            "448",
            "449",
            "450",
            "451",
            "452",
            "453",
            "454",
            "455",
            "456",
            "457",
            "458",
            "459",
            "460",
            "461",
            "462",
            "463",
            "464",
            "465",
            "466",
            "467",
            "468",
            "469",
            "470",
            "471",
            "472",
            "473",
            "474",
            "475",
            "476",
            "688",
            "689",
            "863",
            "938",
            "940",
            "941",
            "942",
            "943",
            "944",
            "946",
            "947",
            "948",
            "949",
            "950",
            "951",
            "952",
            "953",
            "954",
            "955",
            "956",
            "1068",
            "1069",
            "1070",
            "1071",
            "1072",
            "1073",
            "1074",
            "1075",
            "1076",
            "1077",
            "1078",
            "1079",
            "1080",
            "1081",
            "1082",
            "1083",
            "1084",
            "1085",
            "1086",
            "1087",
            "1088",
            "1089",
            "1090",
            "1091",
            "1092",
            "1093",
            "1094",
            "1095",
            "1096",
            "1097",
            "1098",
            "1099",
            "1100",
            "1101",
            "1102",
            "1103",
            "1104",
            "1105",
            "1106",
            "1107",
            "1108",
            "1109",
            "1110",
            "1111",
            "1112",
            "1113",
            "1114",
            "1115",
            "1116",
            "1117",
            "1118",
            "1119",
            "1120",
            "1121",
            "1122",
            "1123",
            "1124",
            "1125",
            "1126",
            "1127",
            "1128",
            "1129",
            "1130",
            "1131",
            "1132",
            "1133",
            "1134",
            "1135",
            "1136",
            "1137",
            "1138",
            "1139",
            "1140",
            "1141",
            "1142",
            "1143",
            "1144",
            "1145",
            "1146",
            "1147",
            "1148",
            "1149",
            "1150",
            "1151",
            "1152",
            "1153",
            "1154",
            "1155",
            "1156",
            "1157",
            "1158",
            "1159",
            "1160",
            "1161",
            "1162",
            "1163",
            "1164",
            "1165",
            "1166",
            "1167",
            "1168",
            "1169",
            "1170",
            "1171",
            "1172",
            "1173",
            "1174",
            "1175",
            "1176",
            "1177",
            "1178",
            "1179",
            "1180",
            "1181",
            "1182",
            "1183",
            "1184",
            "1185",
            "1186",
            "1187",
            "1188",
            "1189",
            "1190",
            "1191",
            "1192",
            "1193",
            "1194",
            "1195",
            "1196",
            "1197",
            "1198",
            "1199",
            "1200",
            "1201",
            "1202",
            "1203",
            "1204",
            "1205",
            "1206",
            "1207",
            "1208",
            "1209",
            "1210",
            "1211",
            "1212",
            "1213",
            "1214",
            "1215",
            "1216",
            "1217",
            "1218",
            "1219",
            "1220",
            "1221",
            "1222",
            "1223",
            "1224",
            "1225",
            "1226",
            "1227",
            "1228",
            "1229",
            "1230",
            "1231",
            "1232",
            "1233",
            "1234",
            "1235",
            "1236",
            "1237",
            "1238",
            "1239",
            "1240",
            "1241",
            "1242",
            "1243",
            "1244",
            "1245",
            "1246",
            "1247",
            "1248",
            "1249",
            "1250",
            "1251",
            "1252",
            "1253",
            "1254",
            "1255",
            "1256",
            "1257",
            "1258",
            "1259",
            "1260",
            "1261",
            "1262",
            "1263",
            "1264",
            "1265",
            "1266",
            "1267",
            "1268",
            "1269",
            "1270",
            "1271",
            "1272",
            "1273",
            "1274",
            "1275",
            "1276",
            "1277",
            "1278",
            "1279",
            "1280",
            "1281",
            "1282",
            "1283",
            "1284",
            "1285",
            "1286",
            "1287",
            "1288",
            "1289",
            "1290",
            "1291",
            "1292",
            "1293",
            "1294",
            "1295",
            "1296",
            "1297",
            "1298",
            "1299",
            "1300",
            "1301",
            "1302",
            "1303",
            "1304",
            "1305",
            "1306",
            "1307",
            "1308",
            "1309",
            "1310",
            "1311",
            "1312",
            "1313",
            "1314",
            "1315",
            "1316",
            "1317",
            "1318",
            "1319",
            "1320",
            "1321",
            "1322",
            "1323",
            "1324",
            "1325",
            "1326",
            "1327",
            "1328",
            "1329",
            "1330",
            "1331",
            "1332",
            "1333",
            "1334",
            "1335",
            "1336",
            "1337",
            "1338",
            "1339",
            "1340",
            "1341",
            "1342",
            "1343",
            "1344",
            "1345",
            "1451"
          ],
          "num": 394
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 28d9d37..5628a08 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -158,37 +158,42 @@\n     // inner scopes, because only global scopes can contain named classes that\n     // show up in the type registry.\n     Scope newScope \u003d null;\n+    AbstractScopeBuilder scopeBuilder \u003d null;\n     if (parent \u003d\u003d null) {\n       // Find all the classes in the global scope.\n       newScope \u003d createInitialScope(root);\n \n-      GlobalScopeBuilder scopeBuilder \u003d new GlobalScopeBuilder(newScope);\n+      GlobalScopeBuilder globalScopeBuilder \u003d new GlobalScopeBuilder(newScope);\n+      scopeBuilder \u003d globalScopeBuilder;\n       NodeTraversal.traverse(compiler, root, scopeBuilder);\n-      scopeBuilder.resolveStubDeclarations();\n-      scopeBuilder.resolveTypes();\n-\n-      // Gather the properties in each function that we found in the\n-      // global scope, if that function has a @this type that we can\n-      // build properties on.\n-      for (Node functionNode : scopeBuilder.nonExternFunctions) {\n-        JSType type \u003d functionNode.getJSType();\n-        if (type !\u003d null \u0026\u0026 type instanceof FunctionType) {\n-          FunctionType fnType \u003d (FunctionType) type;\n-          ObjectType fnThisType \u003d fnType.getTypeOfThis();\n-          if (!fnThisType.isUnknownType()) {\n-            NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n-                scopeBuilder.new CollectProperties(fnThisType));\n-          }\n-        }\n-      }\n-\n-      codingConvention.defineDelegateProxyPrototypeProperties(\n-          typeRegistry, newScope, delegateProxyPrototypes);\n     } else {\n       newScope \u003d new Scope(parent, root);\n-      LocalScopeBuilder scopeBuilder \u003d new LocalScopeBuilder(newScope);\n-      scopeBuilder.build();\n-      scopeBuilder.resolveTypes();\n+      LocalScopeBuilder localScopeBuilder \u003d new LocalScopeBuilder(newScope);\n+      scopeBuilder \u003d localScopeBuilder;\n+      localScopeBuilder.build();\n+    }\n+\n+    scopeBuilder.resolveStubDeclarations();\n+    scopeBuilder.resolveTypes();\n+\n+    // Gather the properties in each function that we found in the\n+    // global scope, if that function has a @this type that we can\n+    // build properties on.\n+    for (Node functionNode : scopeBuilder.nonExternFunctions) {\n+      JSType type \u003d functionNode.getJSType();\n+      if (type !\u003d null \u0026\u0026 type instanceof FunctionType) {\n+        FunctionType fnType \u003d (FunctionType) type;\n+        ObjectType fnThisType \u003d fnType.getTypeOfThis();\n+        if (!fnThisType.isUnknownType()) {\n+          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n+              scopeBuilder.new CollectProperties(fnThisType));\n+        }\n+      }\n+    }\n+\n+    if (parent \u003d\u003d null) {\n+      codingConvention.defineDelegateProxyPrototypeProperties(\n+          typeRegistry, newScope, delegateProxyPrototypes);\n     }\n     return newScope;\n   }\n@@ -359,6 +364,20 @@\n         Lists.newArrayList();\n \n     /**\n+     * Functions that we found in the global scope and not in externs.\n+     */\n+    private final List\u003cNode\u003e nonExternFunctions \u003d Lists.newArrayList();\n+\n+    /**\n+     * Type-less stubs.\n+     *\n+     * If at the end of traversal, we still don\u0027t have types for these\n+     * stubs, then we should declare UNKNOWN types.\n+     */\n+    private final List\u003cStubDeclaration\u003e stubDeclarations \u003d\n+        Lists.newArrayList();\n+\n+    /**\n      * The current source file that we\u0027re in.\n      */\n     private String sourceName \u003d null;\n@@ -403,7 +422,58 @@\n     }\n \n     @Override\n-    public abstract void visit(NodeTraversal t, Node n, Node parent);\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      attachLiteralTypes(n);\n+\n+      switch (n.getType()) {\n+        case Token.CALL:\n+          checkForClassDefiningCalls(t, n, parent);\n+          break;\n+\n+        case Token.FUNCTION:\n+          if (t.getInput() \u003d\u003d null || !t.getInput().isExtern()) {\n+            nonExternFunctions.add(n);\n+          }\n+\n+          // VARs and ASSIGNs are handled in different branches of this\n+          // switch statement.\n+          if (parent.getType() !\u003d Token.ASSIGN \u0026\u0026\n+              parent.getType() !\u003d Token.NAME) {\n+            defineDeclaredFunction(n, parent);\n+          }\n+\n+          break;\n+\n+        case Token.ASSIGN:\n+          // Handle constructor and enum definitions.\n+          defineNamedTypeAssign(n, parent);\n+\n+          // Handle initialization of properties.\n+          Node firstChild \u003d n.getFirstChild();\n+          if (firstChild.getType() \u003d\u003d Token.GETPROP \u0026\u0026\n+              firstChild.isQualifiedName()) {\n+            maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n+                firstChild, n, firstChild.getNext());\n+          }\n+          break;\n+\n+        case Token.CATCH:\n+          defineCatch(n, parent);\n+          break;\n+\n+        case Token.VAR:\n+          defineVar(n, parent);\n+          break;\n+\n+        case Token.GETPROP:\n+          // Handle stubbed properties.\n+          if (parent.getType() \u003d\u003d Token.EXPR_RESULT \u0026\u0026\n+              n.isQualifiedName()) {\n+            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n+          }\n+          break;\n+      }\n+    }\n \n     /**\n      * Returns the type specified in a JSDoc annotation near a GETPROP or NAME.\n@@ -615,8 +685,8 @@\n         Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n       FunctionType functionType \u003d null;\n \n-      // Handle function aliases.\n-      if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName()) {\n+      // Global function aliases should be registered with the type registry.\n+      if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n         Var var \u003d scope.getVar(rValue.getQualifiedName());\n         if (var !\u003d null \u0026\u0026 var.getType() instanceof FunctionType) {\n           functionType \u003d (FunctionType) var.getType();\n@@ -863,100 +933,27 @@\n         }\n       }\n     }\n-  }\n-\n-  /**\n-   * A shallow traversal of the global scope to build up all classes,\n-   * functions, and methods.\n-   */\n-  private final class GlobalScopeBuilder extends AbstractScopeBuilder {\n \n     /**\n-     * Functions that we found in the global scope and not in externs.\n-     */\n-    private final List\u003cNode\u003e nonExternFunctions \u003d Lists.newArrayList();\n-\n-    /**\n-     * Type-less stubs in the global scope.\n+     * Look for a type declaration on a GETPROP node.\n      *\n-     * If at the end of traversal, we still don\u0027t have types for these\n-     * stubs, then we should declare UNKNOWN types.\n+     * @param info The doc info for this property.\n+     * @param n A top-level GETPROP node (it should not be contained inside\n+     *     another GETPROP).\n+     * @param rhsValue The node that {@code n} is being initialized to,\n+     *     or {@code null} if this is a stub declaration.\n      */\n-    private final List\u003cStubDeclaration\u003e stubDeclarations \u003d\n-        Lists.newArrayList();\n-\n-    private GlobalScopeBuilder(Scope scope) {\n-      super(scope);\n-    }\n-\n-    /**\n-     * Visit a node in the global scope, and add anything it declares to the\n-     * global symbol table.\n-     *\n-     * @param t The current traversal.\n-     * @param n The node being visited.\n-     * @param parent The parent of n\n-     */\n-    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n-      attachLiteralTypes(n);\n-\n-      switch (n.getType()) {\n-        case Token.CALL:\n-          checkForClassDefiningCalls(t, n, parent);\n-          break;\n-\n-        case Token.FUNCTION:\n-          if (!t.getInput().isExtern()) {\n-            nonExternFunctions.add(n);\n-          }\n-\n-          // VARs and ASSIGNs are handled separately.\n-          if (parent.getType() \u003d\u003d Token.ASSIGN ||\n-              parent.getType() \u003d\u003d Token.NAME) {\n-            return;\n-          }\n-\n-          defineDeclaredFunction(n, parent);\n-          break;\n-\n-        case Token.ASSIGN:\n-          // Handle constructor and enum definitions.\n-          defineNamedTypeAssign(n, parent);\n-\n-          // Handle typedefs.\n-          checkForOldStyleTypedef(t, n);\n-\n-          // Handle initialization of properties.\n-          Node firstChild \u003d n.getFirstChild();\n-          if (firstChild.getType() \u003d\u003d Token.GETPROP \u0026\u0026\n-              firstChild.isQualifiedName()) {\n-            maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n-                firstChild, n, firstChild.getNext());\n-          }\n-          break;\n-\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-\n-        case Token.VAR:\n-          defineVar(n, parent);\n-\n-          // Handle typedefs.\n-          if (n.hasOneChild()) {\n-            checkForOldStyleTypedef(t, n);\n-            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());\n-          }\n-          break;\n-\n-        case Token.GETPROP:\n-          // Handle stubbed properties.\n-          if (parent.getType() \u003d\u003d Token.EXPR_RESULT \u0026\u0026\n-              n.isQualifiedName()) {\n-            checkForTypedef(t, n, n.getJSDocInfo());\n-            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n-          }\n-          break;\n+    private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,\n+        Node n, Node rhsValue) {\n+      if (info !\u003d null \u0026\u0026 info.hasType()) {\n+        return getDeclaredTypeInAnnotation(t, n, info);\n+      } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n+        return n.getJSType();\n+      } else if (rhsValue !\u003d null \u0026\u0026\n+          rhsValue.getType() \u003d\u003d Token.FUNCTION) {\n+        return rhsValue.getJSType();\n+      } else {\n+        return getDeclaredTypeInAnnotation(t, n, info);\n       }\n     }\n \n@@ -1068,6 +1065,284 @@\n     }\n \n     /**\n+     * Declare the symbol for a qualified name in the global scope.\n+     *\n+     * @param info The doc info for this property.\n+     * @param n A top-level GETPROP node (it should not be contained inside\n+     *     another GETPROP).\n+     * @param parent The parent of {@code n}.\n+     * @param rhsValue The node that {@code n} is being initialized to,\n+     *     or {@code null} if this is a stub declaration.\n+     */\n+    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n+        Node n, Node parent, Node rhsValue) {\n+      Node ownerNode \u003d n.getFirstChild();\n+      String ownerName \u003d ownerNode.getQualifiedName();\n+      String qName \u003d n.getQualifiedName();\n+      String propName \u003d n.getLastChild().getString();\n+      Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n+\n+      // Function prototypes are special.\n+      // It\u0027s a common JS idiom to do:\n+      // F.prototype \u003d { ... };\n+      // So if F does not have an explicitly declared super type,\n+      // allow F.prototype to be redefined arbitrarily.\n+      if (\"prototype\".equals(propName)) {\n+        Var qVar \u003d scope.getVar(qName);\n+        if (qVar !\u003d null) {\n+          if (!qVar.isTypeInferred()) {\n+            // Just ignore assigns to declared prototypes.\n+            return;\n+          }\n+          scope.undeclare(qVar);\n+        }\n+      }\n+\n+      // Precedence of type information on GETPROPs:\n+      // 1) @type annotation / @enum annotation\n+      // 2) ASSIGN to FUNCTION literal\n+      // 3) @param/@return annotation (with no function literal)\n+      // 4) ASSIGN to anything else\n+      //\n+      // 1 and 3 are declarations, 4 is inferred, and 2 is a declaration iff\n+      // the function has not been declared before.\n+      //\n+      // FUNCTION literals are special because TypedScopeCreator is very smart\n+      // about getting as much type information as possible for them.\n+\n+      // Determining type for #1 + #2 + #3\n+      JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n+      if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n+        // Determining type for #4\n+        valueType \u003d rhsValue.getJSType();\n+      }\n+\n+      if (valueType \u003d\u003d null) {\n+        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n+          stubDeclarations.add(new StubDeclaration(\n+              n,\n+              t.getInput() !\u003d null \u0026\u0026 t.getInput().isExtern(),\n+              ownerName));\n+        }\n+\n+        return;\n+      }\n+\n+      boolean inferred \u003d true;\n+      if (info !\u003d null) {\n+        // Determining declaration for #1 + #3\n+        inferred \u003d !(info.hasType() || info.hasEnumParameterType() ||\n+            FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n+      }\n+\n+      if (inferred) {\n+        // Determining declaration for #2\n+        inferred \u003d !(rhsValue !\u003d null \u0026\u0026\n+            rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026\n+            !scope.isDeclared(qName, false));\n+      }\n+\n+      if (!inferred) {\n+        ObjectType ownerType \u003d getObjectSlot(ownerName);\n+        if (ownerType !\u003d null) {\n+          // Only declare this as an official property if it has not been\n+          // declared yet.\n+          boolean isExtern \u003d t.getInput() !\u003d null \u0026\u0026 t.getInput().isExtern();\n+          if ((!ownerType.hasOwnProperty(propName) ||\n+               ownerType.isPropertyTypeInferred(propName)) \u0026\u0026\n+              ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) ||\n+               !ownerType.isInstanceType())) {\n+            // If the property is undeclared or inferred, declare it now.\n+            ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n+          }\n+        }\n+\n+        // If the property is already declared, the error will be\n+        // caught when we try to declare it in the current scope.\n+        defineSlot(n, parent, valueType, inferred);\n+      } else if (rhsValue !\u003d null \u0026\u0026\n+          rhsValue.getType() \u003d\u003d Token.TRUE) {\n+        // We declare these for delegate proxy method properties.\n+        ObjectType ownerType \u003d getObjectSlot(ownerName);\n+        if (ownerType instanceof FunctionType) {\n+          JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n+          String delegateName \u003d codingConvention.getDelegateSuperclassName();\n+          JSType delegateType \u003d delegateName \u003d\u003d null ?\n+              null : typeRegistry.getType(delegateName);\n+          if (delegateType !\u003d null \u0026\u0026\n+              ownerTypeOfThis.isSubtype(delegateType)) {\n+            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE),\n+                true);\n+          }\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Find the ObjectType associated with the given slot.\n+     * @param slotName The name of the slot to find the type in.\n+     * @return An object type, or null if this slot does not contain an object.\n+     */\n+    private ObjectType getObjectSlot(String slotName) {\n+      Var ownerVar \u003d scope.getVar(slotName);\n+      if (ownerVar !\u003d null) {\n+        JSType ownerVarType \u003d ownerVar.getType();\n+        return ObjectType.cast(ownerVarType \u003d\u003d null ?\n+            null : ownerVarType.restrictByNotNullOrUndefined());\n+      }\n+      return null;\n+    }\n+\n+    /**\n+     * Resolve any stub delcarations to unknown types if we could not\n+     * find types for them during traversal.\n+     */\n+    void resolveStubDeclarations() {\n+      for (StubDeclaration stub : stubDeclarations) {\n+        Node n \u003d stub.node;\n+        Node parent \u003d n.getParent();\n+        String qName \u003d n.getQualifiedName();\n+        String propName \u003d n.getLastChild().getString();\n+        String ownerName \u003d stub.ownerName;\n+        boolean isExtern \u003d stub.isExtern;\n+\n+        if (scope.isDeclared(qName, false)) {\n+          continue;\n+        }\n+\n+        // If we see a stub property, make sure to register this property\n+        // in the type registry.\n+        ObjectType ownerType \u003d getObjectSlot(ownerName);\n+        ObjectType unknownType \u003d typeRegistry.getNativeObjectType(UNKNOWN_TYPE);\n+        defineSlot(n, parent, unknownType, true);\n+\n+        if (ownerType !\u003d null \u0026\u0026\n+            (isExtern || ownerType.isFunctionPrototypeType())) {\n+          // If this is a stub for a prototype, just declare it\n+          // as an unknown type. These are seen often in externs.\n+          ownerType.defineInferredProperty(\n+              propName, unknownType, isExtern);\n+        } else {\n+          typeRegistry.registerPropertyOnType(\n+              propName, ownerType \u003d\u003d null ? unknownType : ownerType);\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Collects all declared properties in a function, and\n+     * resolves them relative to the global scope.\n+     */\n+    private final class CollectProperties\n+        extends AbstractShallowCallback {\n+      private final ObjectType thisType;\n+\n+      CollectProperties(ObjectType thisType) {\n+        this.thisType \u003d thisType;\n+      }\n+\n+      public void visit(NodeTraversal t, Node n, Node parent) {\n+        if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n+          switch (n.getType()) {\n+            case Token.ASSIGN:\n+              maybeCollectMember(t, n.getFirstChild(), n);\n+              break;\n+            case Token.GETPROP:\n+              maybeCollectMember(t, n, n);\n+              break;\n+          }\n+        }\n+      }\n+\n+      private void maybeCollectMember(NodeTraversal t,\n+          Node member, Node nodeWithJsDocInfo) {\n+        JSDocInfo info \u003d nodeWithJsDocInfo.getJSDocInfo();\n+\n+        // Do nothing if there is no JSDoc type info, or\n+        // if the node is not a member expression, or\n+        // if the member expression is not of the form: this.someProperty.\n+        if (info \u003d\u003d null ||\n+            member.getType() !\u003d Token.GETPROP ||\n+            member.getFirstChild().getType() !\u003d Token.THIS) {\n+          return;\n+        }\n+\n+        member.getFirstChild().setJSType(thisType);\n+        JSType jsType \u003d getDeclaredTypeInAnnotation(t, member, info);\n+        Node name \u003d member.getLastChild();\n+        if (jsType !\u003d null \u0026\u0026\n+            (name.getType() \u003d\u003d Token.NAME || name.getType() \u003d\u003d Token.STRING)) {\n+          thisType.defineDeclaredProperty(\n+              name.getString(),\n+              jsType,\n+              false /* functions with implementations are not in externs */);\n+        }\n+      }\n+    } // end CollectProperties\n+  }\n+\n+  /**\n+   * A stub declaration without any type information.\n+   */\n+  private static final class StubDeclaration {\n+    private final Node node;\n+    private final boolean isExtern;\n+    private final String ownerName;\n+\n+    private StubDeclaration(Node node, boolean isExtern, String ownerName) {\n+      this.node \u003d node;\n+      this.isExtern \u003d isExtern;\n+      this.ownerName \u003d ownerName;\n+    }\n+  }\n+\n+  /**\n+   * A shallow traversal of the global scope to build up all classes,\n+   * functions, and methods.\n+   */\n+  private final class GlobalScopeBuilder extends AbstractScopeBuilder {\n+\n+    private GlobalScopeBuilder(Scope scope) {\n+      super(scope);\n+    }\n+\n+    /**\n+     * Visit a node in the global scope, and add anything it declares to the\n+     * global symbol table.\n+     *\n+     * @param t The current traversal.\n+     * @param n The node being visited.\n+     * @param parent The parent of n\n+     */\n+    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n+      super.visit(t, n, parent);\n+\n+      switch (n.getType()) {\n+\n+        case Token.ASSIGN:\n+          // Handle typedefs.\n+          checkForOldStyleTypedef(t, n);\n+          break;\n+\n+        case Token.VAR:\n+          // Handle typedefs.\n+          if (n.hasOneChild()) {\n+            checkForOldStyleTypedef(t, n);\n+            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());\n+          }\n+          break;\n+      }\n+    }\n+\n+    @Override\n+    void maybeDeclareQualifiedName(\n+        NodeTraversal t, JSDocInfo info,\n+        Node n, Node parent, Node rhsValue) {\n+      checkForTypedef(t, n, info);\n+      super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n+    }\n+\n+    /**\n      * Handle typedefs.\n      * @param t The current traversal.\n      * @param candidate A qualified name node.\n@@ -1136,258 +1411,6 @@\n         // this typedef in the scope.\n       }\n     }\n-\n-    /**\n-     * Declare the symbol for a qualified name in the global scope.\n-     *\n-     * @param info The doc info for this property.\n-     * @param n A top-level GETPROP node (it should not be contained inside\n-     *     another GETPROP).\n-     * @param parent The parent of {@code n}.\n-     * @param rhsValue The node that {@code n} is being initialized to,\n-     *     or {@code null} if this is a stub declaration.\n-     */\n-    private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n-        Node n, Node parent, Node rhsValue) {\n-      Node ownerNode \u003d n.getFirstChild();\n-      String ownerName \u003d ownerNode.getQualifiedName();\n-      String qName \u003d n.getQualifiedName();\n-      String propName \u003d n.getLastChild().getString();\n-      Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n-\n-      // Function prototypes are special.\n-      // It\u0027s a common JS idiom to do:\n-      // F.prototype \u003d { ... };\n-      // So if F does not have an explicitly declared super type,\n-      // allow F.prototype to be redefined arbitrarily.\n-      if (\"prototype\".equals(propName)) {\n-        Var qVar \u003d scope.getVar(qName);\n-        if (qVar !\u003d null) {\n-          if (!qVar.isTypeInferred()) {\n-            // Just ignore assigns to declared prototypes.\n-            return;\n-          }\n-          scope.undeclare(qVar);\n-        }\n-      }\n-\n-      // Precedence of type information on GETPROPs:\n-      // 1) @type annotation / @enum annotation\n-      // 2) ASSIGN to FUNCTION literal\n-      // 3) @param/@return annotation (with no function literal)\n-      // 4) ASSIGN to anything else\n-      //\n-      // 1 and 3 are declarations, 4 is inferred, and 2 is a declaration iff\n-      // the function has not been declared before.\n-      //\n-      // FUNCTION literals are special because TypedScopeCreator is very smart\n-      // about getting as much type information as possible for them.\n-\n-      // Determining type for #1 + #2 + #3\n-      JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n-      if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n-        // Determining type for #4\n-        valueType \u003d rhsValue.getJSType();\n-      }\n-\n-      if (valueType \u003d\u003d null) {\n-        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n-          stubDeclarations.add(new StubDeclaration(\n-              n, t.getInput().isExtern(), ownerName));\n-        }\n-\n-        return;\n-      }\n-\n-      boolean inferred \u003d true;\n-      if (info !\u003d null) {\n-        // Determining declaration for #1 + #3\n-        inferred \u003d !(info.hasType() || info.hasEnumParameterType() ||\n-            FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-      }\n-\n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred \u003d !(rhsValue !\u003d null \u0026\u0026\n-            rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026\n-            !scope.isDeclared(qName, false));\n-      }\n-\n-      if (!inferred) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType !\u003d null) {\n-          // Only declare this as an official property if it has not been\n-          // declared yet.\n-          boolean isExtern \u003d t.getInput().isExtern();\n-          if ((!ownerType.hasOwnProperty(propName) ||\n-               ownerType.isPropertyTypeInferred(propName)) \u0026\u0026\n-              ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) ||\n-               !ownerType.isInstanceType())) {\n-            // If the property is undeclared or inferred, declare it now.\n-            ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n-          }\n-        }\n-\n-        // If the property is already declared, the error will be\n-        // caught when we try to declare it in the current scope.\n-        defineSlot(n, parent, valueType, inferred);\n-      } else if (rhsValue !\u003d null \u0026\u0026\n-          rhsValue.getType() \u003d\u003d Token.TRUE) {\n-        // We declare these for delegate proxy method properties.\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType instanceof FunctionType) {\n-          JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n-          String delegateName \u003d codingConvention.getDelegateSuperclassName();\n-          JSType delegateType \u003d delegateName \u003d\u003d null ?\n-              null : typeRegistry.getType(delegateName);\n-          if (delegateType !\u003d null \u0026\u0026\n-              ownerTypeOfThis.isSubtype(delegateType)) {\n-            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE),\n-                true);\n-          }\n-        }\n-      }\n-    }\n-\n-    /**\n-     * Find the ObjectType associated with the given slot.\n-     * @param slotName The name of the slot to find the type in.\n-     * @return An object type, or null if this slot does not contain an object.\n-     */\n-    private ObjectType getObjectSlot(String slotName) {\n-      Var ownerVar \u003d scope.getVar(slotName);\n-      if (ownerVar !\u003d null) {\n-        JSType ownerVarType \u003d ownerVar.getType();\n-        return ObjectType.cast(ownerVarType \u003d\u003d null ?\n-            null : ownerVarType.restrictByNotNullOrUndefined());\n-      }\n-      return null;\n-    }\n-\n-    /**\n-     * Look for a type declaration on a GETPROP node.\n-     *\n-     * @param info The doc info for this property.\n-     * @param n A top-level GETPROP node (it should not be contained inside\n-     *     another GETPROP).\n-     * @param rhsValue The node that {@code n} is being initialized to,\n-     *     or {@code null} if this is a stub declaration.\n-     */\n-    private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,\n-        Node n, Node rhsValue) {\n-      if (info !\u003d null \u0026\u0026 info.hasType()) {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n-      } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-        return n.getJSType();\n-      } else if (rhsValue !\u003d null \u0026\u0026\n-          rhsValue.getType() \u003d\u003d Token.FUNCTION) {\n-        return rhsValue.getJSType();\n-      } else {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n-      }\n-    }\n-\n-    /**\n-     * Resolve any stub delcarations to unknown types if we could not\n-     * find types for them during traversal.\n-     */\n-    private void resolveStubDeclarations() {\n-      for (StubDeclaration stub : stubDeclarations) {\n-        Node n \u003d stub.node;\n-        Node parent \u003d n.getParent();\n-        String qName \u003d n.getQualifiedName();\n-        String propName \u003d n.getLastChild().getString();\n-        String ownerName \u003d stub.ownerName;\n-        boolean isExtern \u003d stub.isExtern;\n-\n-        if (scope.isDeclared(qName, false)) {\n-          continue;\n-        }\n-\n-        // If we see a stub property, make sure to register this property\n-        // in the type registry.\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        ObjectType unknownType \u003d typeRegistry.getNativeObjectType(UNKNOWN_TYPE);\n-        defineSlot(n, parent, unknownType, true);\n-\n-        if (ownerType !\u003d null \u0026\u0026\n-            (isExtern || ownerType.isFunctionPrototypeType())) {\n-          // If this is a stub for a prototype, just declare it\n-          // as an unknown type. These are seen often in externs.\n-          ownerType.defineInferredProperty(\n-              propName, unknownType, isExtern);\n-        } else {\n-          typeRegistry.registerPropertyOnType(\n-              propName, ownerType \u003d\u003d null ? unknownType : ownerType);\n-        }\n-      }\n-    }\n-\n-    /**\n-     * A stub declaration without any type information.\n-     */\n-    private final class StubDeclaration {\n-      private final Node node;\n-      private final boolean isExtern;\n-      private final String ownerName;\n-\n-      private StubDeclaration(Node node, boolean isExtern, String ownerName) {\n-        this.node \u003d node;\n-        this.isExtern \u003d isExtern;\n-        this.ownerName \u003d ownerName;\n-      }\n-    }\n-\n-    /**\n-     * Collects all declared properties in a function, and\n-     * resolves them relative to the global scope.\n-     */\n-    private final class CollectProperties\n-        extends AbstractShallowCallback {\n-      private final ObjectType thisType;\n-\n-      CollectProperties(ObjectType thisType) {\n-        this.thisType \u003d thisType;\n-      }\n-\n-      public void visit(NodeTraversal t, Node n, Node parent) {\n-        if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n-          switch (n.getType()) {\n-            case Token.ASSIGN:\n-              maybeCollectMember(t, n.getFirstChild(), n);\n-              break;\n-            case Token.GETPROP:\n-              maybeCollectMember(t, n, n);\n-              break;\n-          }\n-        }\n-      }\n-\n-      private void maybeCollectMember(NodeTraversal t,\n-          Node member, Node nodeWithJsDocInfo) {\n-        JSDocInfo info \u003d nodeWithJsDocInfo.getJSDocInfo();\n-\n-        // Do nothing if there is no JSDoc type info, or\n-        // if the node is not a member expression, or\n-        // if the member expression is not of the form: this.someProperty.\n-        if (info \u003d\u003d null ||\n-            member.getType() !\u003d Token.GETPROP ||\n-            member.getFirstChild().getType() !\u003d Token.THIS) {\n-          return;\n-        }\n-\n-        member.getFirstChild().setJSType(thisType);\n-        JSType jsType \u003d getDeclaredTypeInAnnotation(t, member, info);\n-        Node name \u003d member.getLastChild();\n-        if (jsType !\u003d null \u0026\u0026\n-            (name.getType() \u003d\u003d Token.NAME || name.getType() \u003d\u003d Token.STRING)) {\n-          thisType.defineDeclaredProperty(\n-              name.getString(),\n-              jsType,\n-              false /* functions with implementations are not in externs */);\n-        }\n-      }\n-    } // end CollectProperties\n   } // end GlobalScopeBuilder\n \n   /**\n@@ -1425,24 +1448,7 @@\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          // VARs and ASSIGNs are handled separately.\n-          if (parent.getType() \u003d\u003d Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+      super.visit(t, n, parent);\n     }\n \n     /** Handle bleeding functions and function parameters. */\n",
      "operations": [
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [15691,17241]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [39829,44302]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TypeDeclaration [46188,47923]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Modifier: static [48030,48036]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [7239,7280]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [8517,8667]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MarkerAnnotation [49347,49356]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [8521,8535]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [8537,8667]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [48926,48952]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [49486,49514]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [49521,49583]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [52866,52892]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [7488,7522]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [7721,7754]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "InfixExpression [24991,25053]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "INFIX_EXPRESSION_OPERATOR: \u0026\u0026 [25034,25036]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodInvocation [25037,25053]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [8524,8552]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [15162,15241]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Modifier: private [47881,47888]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [33477,33499]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SwitchCase [33538,33554]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [33565,33606]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "BreakStatement [33617,33623]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SwitchCase [33633,33653]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [33664,33746]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [33812,33931]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [33943,33977]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "BreakStatement [33988,33994]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [34087,34120]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [34254,34290]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [34301,34516]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SwitchCase [34543,34560]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [34571,34594]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "BreakStatement [34605,34611]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [34647,34668]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SwitchCase [34883,34902]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [34953,35176]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "BreakStatement [35187,35193]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "Javadoc [41910,42328]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Modifier: private [42333,42340]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [42457,42492]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [42499,42547]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [42554,42590]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [42597,42644]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [42651,42715]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [42958,43243]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [43832,43896]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [43903,44032]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [44040,44259]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [44267,44291]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [44298,44508]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [44516,44720]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [44728,46309]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TypeDeclaration [49496,51231]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [52268,52290]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SwitchStatement [52297,52704]",
          "to": ""
        }
      ]
    }
  ],
  "inducing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [],
      "num": 0
    },
    "add_functions": {
      "qualified_names": [
        "defineSlot"
      ],
      "num": 1
    },
    "delete_functions": {
      "qualified_names": [],
      "num": 0
    }
  },
  "trigger_tests": [
    {
      "test_class": "com.google.javascript.jscomp.CrossModuleMethodMotionTest",
      "test_function": "testTwoMethods",
      "exception": "junit.framework.AssertionFailedError",
      "message": ""
    },
    {
      "test_class": "com.google.javascript.jscomp.CrossModuleMethodMotionTest",
      "test_function": "testClosureVariableReads3",
      "exception": "junit.framework.AssertionFailedError",
      "message": ""
    }
  ],
  "fixing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "src/com/google/javascript/jscomp/TypedScopeCreator.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "maybeDeclareQualifiedName"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "maybeDeclareQualifiedName"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "1141",
            "1142"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "1141",
            "1142",
            "1143"
          ],
          "num": 3
        }
      ],
      "diff": "diff -u -r data/changesInfo//Closure_48/properties/modified_classes/inducing/src/com/google/javascript/jscomp/TypedScopeCreator.java data/changesInfo//Closure_48/cleaned/fixing/src/com/google/javascript/jscomp/TypedScopeCreator.java\n--- data/changesInfo//Closure_48/properties/modified_classes/inducing/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2023-08-25 13:11:12.140784980 +0800\n+++ data/changesInfo//Closure_48/cleaned/fixing/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2023-07-31 23:28:30.753538940 +0800\n@@ -1138,8 +1138,9 @@\n       if (inferred) {\n         // Determining declaration for #2\n         inferred \u003d !(rhsValue !\u003d null \u0026\u0026\n-            rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026\n-            !scope.isDeclared(qName, false));\n+                rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026\n+                !scope.isDeclared(qName, false) \u0026\u0026\n+                n.isUnscopedQualifiedName());\n       }\n \n       if (!inferred) {\n",
      "operations": [
        {
          "type": "insert-node",
          "from": "",
          "to": "InfixExpression [42558,42728]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "INFIX_EXPRESSION_OPERATOR: \u0026\u0026 [42682,42684]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodInvocation [42701,42728]"
        }
      ]
    }
  ],
  "fixing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [],
      "num": 0
    },
    "add_functions": {
      "qualified_names": [],
      "num": 0
    },
    "delete_functions": {
      "qualified_names": [],
      "num": 0
    }
  }
}