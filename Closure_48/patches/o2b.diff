diff -r -u original/src/com/google/javascript/jscomp/TypedScopeCreator.java buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java
--- original/src/com/google/javascript/jscomp/TypedScopeCreator.java	2023-06-13 15:31:40.139085026 +0800
+++ buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java	2023-06-12 11:40:20.870974375 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004 Google Inc.
+ * Copyright 2004 The Closure Compiler Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,7 +16,6 @@
 
 package com.google.javascript.jscomp;
 
-import static com.google.javascript.jscomp.TypeCheck.ENUM_DUP;
 import static com.google.javascript.jscomp.TypeCheck.ENUM_NOT_CONSTANT;
 import static com.google.javascript.jscomp.TypeCheck.MULTIPLE_VAR_DEF;
 import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_FUNCTION_TYPE;
@@ -26,6 +25,7 @@
 import static com.google.javascript.rhino.jstype.JSTypeNative.ERROR_FUNCTION_TYPE;
 import static com.google.javascript.rhino.jstype.JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
 import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE;
+import static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS;
 import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE;
 import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;
 import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;
@@ -48,14 +48,19 @@
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.javascript.jscomp.CodingConvention.DelegateRelationship;
 import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast;
 import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;
 import com.google.javascript.jscomp.CodingConvention.SubclassType;
-import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;
+import com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents;
+import com.google.javascript.jscomp.NodeTraversal.AbstractScopedCallback;
+import com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback;
 import com.google.javascript.jscomp.Scope.Var;
 import com.google.javascript.rhino.ErrorReporter;
+import com.google.javascript.rhino.InputId;
 import com.google.javascript.rhino.JSDocInfo;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
@@ -69,6 +74,7 @@
 
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 
 import javax.annotation.Nullable;
 
@@ -88,7 +94,8 @@
   /**
    * A suffix for naming delegate proxies differently from their base.
    */
-  static final String DELEGATE_PROXY_SUFFIX = "(Proxy)";
+  static final String DELEGATE_PROXY_SUFFIX =
+      ObjectType.createDelegateSuffix("Proxy");
 
   static final DiagnosticType MALFORMED_TYPEDEF =
       DiagnosticType.warning(
@@ -100,17 +107,43 @@
           "JSC_ENUM_INITIALIZER_NOT_ENUM",
           "enum initializer must be an object literal or an enum");
 
+  static final DiagnosticType CTOR_INITIALIZER =
+      DiagnosticType.warning(
+          "JSC_CTOR_INITIALIZER_NOT_CTOR",
+          "Constructor {0} must be initialized at declaration");
+
+  static final DiagnosticType IFACE_INITIALIZER =
+      DiagnosticType.warning(
+          "JSC_IFACE_INITIALIZER_NOT_IFACE",
+          "Interface {0} must be initialized at declaration");
+
   static final DiagnosticType CONSTRUCTOR_EXPECTED =
       DiagnosticType.warning(
           "JSC_REFLECT_CONSTRUCTOR_EXPECTED",
           "Constructor expected as first argument");
 
+  static final DiagnosticType UNKNOWN_LENDS =
+      DiagnosticType.warning(
+          "JSC_UNKNOWN_LENDS",
+          "Variable {0} not declared before @lends annotation.");
+
+  static final DiagnosticType LENDS_ON_NON_OBJECT =
+      DiagnosticType.warning(
+          "JSC_LENDS_ON_NON_OBJECT",
+          "May only lend properties to object types. {0} has type {1}.");
+
   private final AbstractCompiler compiler;
   private final ErrorReporter typeParsingErrorReporter;
   private final TypeValidator validator;
   private final CodingConvention codingConvention;
   private final JSTypeRegistry typeRegistry;
-  private List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();
+  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();
+  private final Map<String, String> delegateCallingConventions =
+      Maps.newHashMap();
+
+  // Simple properties inferred about functions.
+  private final Map<Node, AstFunctionContents> functionAnalysisResults =
+      Maps.newHashMap();
 
   /**
    * Defer attachment of types to nodes until all type names
@@ -153,54 +186,114 @@
    * Creates a scope with all types declared. Declares newly discovered types
    * and type properties in the type registry.
    */
+  @Override
   public Scope createScope(Node root, Scope parent) {
     // Constructing the global scope is very different than constructing
     // inner scopes, because only global scopes can contain named classes that
     // show up in the type registry.
     Scope newScope = null;
+    AbstractScopeBuilder scopeBuilder = null;
     if (parent == null) {
+      // Run a first-order analysis over the syntax tree.
+      (new FirstOrderFunctionAnalyzer(compiler, functionAnalysisResults))
+          .process(root.getFirstChild(), root.getLastChild());
+
       // Find all the classes in the global scope.
       newScope = createInitialScope(root);
 
-      GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(newScope);
+      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
+      scopeBuilder = globalScopeBuilder;
       NodeTraversal.traverse(compiler, root, scopeBuilder);
-      scopeBuilder.resolveStubDeclarations();
-      scopeBuilder.resolveTypes();
-
-      // Gather the properties in each function that we found in the
-      // global scope, if that function has a @this type that we can
-      // build properties on.
-      for (Node functionNode : scopeBuilder.nonExternFunctions) {
-        JSType type = functionNode.getJSType();
-        if (type != null && type instanceof FunctionType) {
-          FunctionType fnType = (FunctionType) type;
-          ObjectType fnThisType = fnType.getTypeOfThis();
-          if (!fnThisType.isUnknownType()) {
-            NodeTraversal.traverse(compiler, functionNode.getLastChild(),
-                scopeBuilder.new CollectProperties(fnThisType));
-          }
+    } else {
+      newScope = new Scope(parent, root);
+      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
+      scopeBuilder = localScopeBuilder;
+      localScopeBuilder.build();
+    }
+
+    scopeBuilder.resolveStubDeclarations();
+    scopeBuilder.resolveTypes();
+
+    // Gather the properties in each function that we found in the
+    // global scope, if that function has a @this type that we can
+    // build properties on.
+    for (Node functionNode : scopeBuilder.nonExternFunctions) {
+      JSType type = functionNode.getJSType();
+      if (type != null && type.isFunctionType()) {
+        FunctionType fnType = type.toMaybeFunctionType();
+        ObjectType fnThisType = fnType.getTypeOfThis();
+        if (!fnThisType.isUnknownType()) {
+          NodeTraversal.traverse(compiler, functionNode.getLastChild(),
+              scopeBuilder.new CollectProperties(fnThisType));
         }
       }
+    }
 
+    if (parent == null) {
       codingConvention.defineDelegateProxyPrototypeProperties(
-          typeRegistry, newScope, delegateProxyPrototypes);
-    } else {
-      newScope = new Scope(parent, root);
-      LocalScopeBuilder scopeBuilder = new LocalScopeBuilder(newScope);
-      scopeBuilder.build();
-      scopeBuilder.resolveTypes();
+          typeRegistry, newScope, delegateProxyPrototypes,
+          delegateCallingConventions);
     }
     return newScope;
   }
 
   /**
+   * Patches a given global scope by removing variables previously declared in
+   * a script and re-traversing a new version of that script.
+   *
+   * @param globalScope The global scope generated by {@code createScope}.
+   * @param scriptRoot The script that is modified.
+   */
+  void patchGlobalScope(Scope globalScope, Node scriptRoot) {
+    // Preconditions: This is supposed to be called only on (named) SCRIPT nodes
+    // and a global typed scope should have been generated already.
+    Preconditions.checkState(scriptRoot.isScript());
+    Preconditions.checkNotNull(globalScope);
+    Preconditions.checkState(globalScope.isGlobal());
+
+    String scriptName = NodeUtil.getSourceName(scriptRoot);
+    Preconditions.checkNotNull(scriptName);
+    for (Node node : ImmutableList.copyOf(functionAnalysisResults.keySet())) {
+      if (scriptName.equals(NodeUtil.getSourceName(node))) {
+        functionAnalysisResults.remove(node);
+      }
+    }
+
+    (new FirstOrderFunctionAnalyzer(
+        compiler, functionAnalysisResults)).process(null, scriptRoot);
+
+    // TODO(bashir): Variable declaration is not the only side effect of last
+    // global scope generation but here we only wipe that part off!
+
+    // Remove all variables that were previously declared in this scripts.
+    // First find all vars to remove then remove them because of iterator!
+    Iterator<Var> varIter = globalScope.getVars();
+    List<Var> varsToRemove = Lists.newArrayList();
+    while (varIter.hasNext()) {
+      Var oldVar = varIter.next();
+      if (scriptName.equals(oldVar.getInputName())) {
+        varsToRemove.add(oldVar);
+      }
+    }
+    for (Var var : varsToRemove) {
+      globalScope.undeclare(var);
+      globalScope.getTypeOfThis().removeProperty(var.getName());
+    }
+
+    // Now re-traverse the given script.
+    GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(globalScope);
+    NodeTraversal.traverse(compiler, scriptRoot, scopeBuilder);
+  }
+
+  /**
    * Create the outermost scope. This scope contains native binding such as
    * {@code Object}, {@code Date}, etc.
    */
   @VisibleForTesting
   Scope createInitialScope(Node root) {
 
-    NodeTraversal.traverse(compiler, root, new DiscoverEnums(typeRegistry));
+    NodeTraversal.traverse(
+        compiler, root, new DiscoverEnumsAndTypedefs(typeRegistry));
 
     Scope s = new Scope(root, compiler);
     declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);
@@ -220,11 +313,6 @@
     declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE);
     declareNativeValueType(s, "undefined", VOID_TYPE);
 
-    // The typedef construct needs the any type, so that it can be assigned
-    // to anything. This is kind of a hack, and an artifact of the typedef
-    // syntax we've chosen.
-    declareNativeValueType(s, "goog.typedef", NO_TYPE);
-
     // ActiveXObject is unqiuely special, because it can be used to construct
     // any type (the type that it creates is related to the arguments you
     // pass to it).
@@ -249,10 +337,11 @@
     scope.declare(name, null, t, null, false);
   }
 
-  private static class DiscoverEnums extends AbstractShallowCallback {
+  private static class DiscoverEnumsAndTypedefs
+      extends AbstractShallowStatementCallback {
     private final JSTypeRegistry registry;
 
-    DiscoverEnums(JSTypeRegistry registry) {
+    DiscoverEnumsAndTypedefs(JSTypeRegistry registry) {
       this.registry = registry;
     }
 
@@ -260,87 +349,40 @@
     public void visit(NodeTraversal t, Node node, Node parent) {
       Node nameNode = null;
       switch (node.getType()) {
-        case Token.NAME:
-          nameNode = node;
-          break;
         case Token.VAR:
-          if (node.hasOneChild()) {
-            nameNode = node.getFirstChild();
+          for (Node child = node.getFirstChild();
+               child != null; child = child.getNext()) {
+            identifyNameNode(
+                child, child.getFirstChild(),
+                NodeUtil.getBestJSDocInfo(child));
           }
           break;
-        case Token.ASSIGN:
-          nameNode = node.getFirstChild();
+        case Token.EXPR_RESULT:
+          Node firstChild = node.getFirstChild();
+          if (firstChild.isAssign()) {
+            identifyNameNode(
+                firstChild.getFirstChild(), firstChild.getLastChild(),
+                firstChild.getJSDocInfo());
+          } else {
+            identifyNameNode(
+                firstChild, null, firstChild.getJSDocInfo());
+          }
           break;
       }
-
-      if (nameNode != null) {
-        JSDocInfo info = node.getJSDocInfo();
-        if (info != null && info.hasEnumParameterType()) {
-          registry.identifyEnumName(nameNode.getQualifiedName());
-        }
-      }
     }
-  }
 
-  /**
-   * Given a node, determines whether that node names a prototype
-   * property, and if so, returns the qualfied name node representing
-   * the owner of that property. Otherwise, returns null.
-   */
-  private static Node getPrototypePropertyOwner(Node n) {
-    if (n.getType() == Token.GETPROP) {
-      Node firstChild = n.getFirstChild();
-      if (firstChild.getType() == Token.GETPROP &&
-          firstChild.getLastChild().getString().equals("prototype")) {
-        Node maybeOwner = firstChild.getFirstChild();
-        if (maybeOwner.isQualifiedName()) {
-          return maybeOwner;
+    private void identifyNameNode(
+        Node nameNode, Node valueNode, JSDocInfo info) {
+      if (nameNode.isQualifiedName()) {
+        if (info != null) {
+          if (info.hasEnumParameterType()) {
+            registry.identifyNonNullableName(nameNode.getQualifiedName());
+          } else if (info.hasTypedefType()) {
+            registry.identifyNonNullableName(nameNode.getQualifiedName());
+          }
         }
       }
     }
-    return null;
-  }
-
-  private void attachLiteralTypes(Node n) {
-    switch (n.getType()) {
-      case Token.NULL:
-        n.setJSType(getNativeType(NULL_TYPE));
-        break;
-
-      case Token.VOID:
-        n.setJSType(getNativeType(VOID_TYPE));
-        break;
-
-      case Token.STRING:
-        n.setJSType(getNativeType(STRING_TYPE));
-        break;
-
-      case Token.NUMBER:
-        n.setJSType(getNativeType(NUMBER_TYPE));
-        break;
-
-      case Token.TRUE:
-      case Token.FALSE:
-        n.setJSType(getNativeType(BOOLEAN_TYPE));
-        break;
-
-      case Token.REGEXP:
-        n.setJSType(getNativeType(REGEXP_TYPE));
-        break;
-
-      case Token.REF_SPECIAL:
-        n.setJSType(getNativeType(UNKNOWN_TYPE));
-        break;
-
-      case Token.OBJECTLIT:
-        if (n.getJSType() == null) {
-          n.setJSType(typeRegistry.createAnonymousObjectType());
-        }
-        break;
-
-      // NOTE(nicksantos): If we ever support Array tuples,
-      // we will need to put ARRAYLIT here as well.
-    }
   }
 
   private JSType getNativeType(JSTypeNative nativeType) {
@@ -359,10 +401,29 @@
         Lists.newArrayList();
 
     /**
+     * Functions that we found in the global scope and not in externs.
+     */
+    private final List<Node> nonExternFunctions = Lists.newArrayList();
+
+    /**
+     * Type-less stubs.
+     *
+     * If at the end of traversal, we still don't have types for these
+     * stubs, then we should declare UNKNOWN types.
+     */
+    private final List<StubDeclaration> stubDeclarations =
+        Lists.newArrayList();
+
+    /**
      * The current source file that we're in.
      */
     private String sourceName = null;
 
+    /**
+     * The InputId of the current node.
+     */
+    private InputId inputId;
+
     private AbstractScopeBuilder(Scope scope) {
       this.scope = scope;
     }
@@ -389,21 +450,212 @@
     }
 
     @Override
-    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,
+    public final boolean shouldTraverse(NodeTraversal t, Node n,
         Node parent) {
-      if (n.getType() == Token.FUNCTION ||
-          n.getType() == Token.SCRIPT) {
-        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
+      inputId = t.getInputId();
+      if (n.isFunction() ||
+          n.isScript()) {
+        Preconditions.checkNotNull(inputId);
+        sourceName = NodeUtil.getSourceName(n);
       }
 
       // We do want to traverse the name of a named function, but we don't
       // want to traverse the arguments or body.
-      return parent == null || parent.getType() != Token.FUNCTION ||
+      boolean descend = parent == null || parent.getType() != Token.FUNCTION ||
           n == parent.getFirstChild() || parent == scope.getRootNode();
+
+      if (descend) {
+        // Handle hoisted functions on pre-order traversal, so that they
+        // get hit before other things in the scope.
+        if (NodeUtil.isStatementParent(n)) {
+          for (Node child = n.getFirstChild();
+               child != null;
+               child = child.getNext()) {
+            if (NodeUtil.isHoistedFunctionDeclaration(child)) {
+              defineFunctionLiteral(child, n);
+            }
+          }
+        }
+      }
+
+      return descend;
     }
 
     @Override
-    public abstract void visit(NodeTraversal t, Node n, Node parent);
+    public void visit(NodeTraversal t, Node n, Node parent) {
+      inputId = t.getInputId();
+      attachLiteralTypes(t, n);
+
+      switch (n.getType()) {
+        case Token.CALL:
+          checkForClassDefiningCalls(t, n, parent);
+          checkForCallingConventionDefiningCalls(n, delegateCallingConventions);
+          break;
+
+        case Token.FUNCTION:
+          if (t.getInput() == null || !t.getInput().isExtern()) {
+            nonExternFunctions.add(n);
+          }
+
+          // Hoisted functions are handled during pre-traversal.
+          if (!NodeUtil.isHoistedFunctionDeclaration(n)) {
+            defineFunctionLiteral(n, parent);
+          }
+          break;
+
+        case Token.ASSIGN:
+          // Handle initialization of properties.
+          Node firstChild = n.getFirstChild();
+          if (firstChild.isGetProp() &&
+              firstChild.isQualifiedName()) {
+            maybeDeclareQualifiedName(t, n.getJSDocInfo(),
+                firstChild, n, firstChild.getNext());
+          }
+          break;
+
+        case Token.CATCH:
+          defineCatch(n, parent);
+          break;
+
+        case Token.VAR:
+          defineVar(n, parent);
+          break;
+
+        case Token.GETPROP:
+          // Handle stubbed properties.
+          if (parent.isExprResult() &&
+              n.isQualifiedName()) {
+            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
+          }
+          break;
+      }
+    }
+
+    private void attachLiteralTypes(NodeTraversal t, Node n) {
+      switch (n.getType()) {
+        case Token.NULL:
+          n.setJSType(getNativeType(NULL_TYPE));
+          break;
+
+        case Token.VOID:
+          n.setJSType(getNativeType(VOID_TYPE));
+          break;
+
+        case Token.STRING:
+          // Defer keys to the Token.OBJECTLIT case
+          if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
+            n.setJSType(getNativeType(STRING_TYPE));
+          }
+          break;
+
+        case Token.NUMBER:
+          n.setJSType(getNativeType(NUMBER_TYPE));
+          break;
+
+        case Token.TRUE:
+        case Token.FALSE:
+          n.setJSType(getNativeType(BOOLEAN_TYPE));
+          break;
+
+        case Token.REGEXP:
+          n.setJSType(getNativeType(REGEXP_TYPE));
+          break;
+
+        case Token.OBJECTLIT:
+          defineObjectLiteral(t, n);
+          break;
+
+          // NOTE(nicksantos): If we ever support Array tuples,
+          // we will need to put ARRAYLIT here as well.
+      }
+    }
+
+    private void defineObjectLiteral(NodeTraversal t, Node objectLit) {
+      // Handle the @lends annotation.
+      JSType type = null;
+      JSDocInfo info = objectLit.getJSDocInfo();
+      if (info != null &&
+          info.getLendsName() != null) {
+        String lendsName = info.getLendsName();
+        Var lendsVar = scope.getVar(lendsName);
+        if (lendsVar == null) {
+          compiler.report(
+              JSError.make(sourceName, objectLit, UNKNOWN_LENDS, lendsName));
+        } else {
+          type = lendsVar.getType();
+          if (type == null) {
+            type = typeRegistry.getNativeType(UNKNOWN_TYPE);
+          }
+          if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {
+            compiler.report(
+                JSError.make(sourceName, objectLit, LENDS_ON_NON_OBJECT,
+                    lendsName, type.toString()));
+            type = null;
+          } else {
+            objectLit.setJSType(type);
+          }
+        }
+      }
+
+      info = NodeUtil.getBestJSDocInfo(objectLit);
+      Node lValue = NodeUtil.getBestLValue(objectLit);
+      String lValueName = NodeUtil.getBestLValueName(lValue);
+      boolean createdEnumType = false;
+      if (info != null && info.hasEnumParameterType()) {
+        type = createEnumTypeFromNodes(objectLit, lValueName, info, lValue);
+        createdEnumType = true;
+      }
+
+      if (type == null) {
+        type = typeRegistry.createAnonymousObjectType();
+      }
+
+      setDeferredType(objectLit, type);
+
+      // If this is an enum, the properties were already taken care of above.
+      processObjectLitProperties(
+          t, objectLit, ObjectType.cast(objectLit.getJSType()), !createdEnumType);
+    }
+
+    /**
+     * Process an object literal and all the types on it.
+     * @param objLit The OBJECTLIT node.
+     * @param objLitType The type of the OBJECTLIT node. This might be a named
+     *     type, because of the lends annotation.
+     * @param declareOnOwner If true, declare properties on the objLitType as
+     *     well. If false, the caller should take crae of this.
+     */
+    void processObjectLitProperties(
+        NodeTraversal t, Node objLit, ObjectType objLitType,
+        boolean declareOnOwner) {
+      for (Node keyNode = objLit.getFirstChild(); keyNode != null;
+           keyNode = keyNode.getNext()) {
+        Node value = keyNode.getFirstChild();
+        String memberName = NodeUtil.getObjectLitKeyName(keyNode);
+        JSDocInfo info = keyNode.getJSDocInfo();
+        JSType valueType =
+            getDeclaredType(t.getSourceName(), info, keyNode, value);
+        JSType keyType =  objLitType.isEnumType() ?
+            objLitType.toMaybeEnumType().getElementsType() :
+            NodeUtil.getObjectLitKeyTypeFromValueType(keyNode, valueType);
+        if (keyType != null) {
+          // Try to declare this property in the current scope if it
+          // has an authoritative name.
+          String qualifiedName = NodeUtil.getBestLValueName(keyNode);
+          if (qualifiedName != null) {
+            defineSlot(keyNode, objLit, qualifiedName, keyType, false);
+          } else {
+            setDeferredType(keyNode, keyType);
+          }
+
+          if (objLitType != null && declareOnOwner) {
+            // Declare this property on its object literal.
+            boolean isExtern = t.getInput() != null && t.getInput().isExtern();
+            objLitType.defineDeclaredProperty(memberName, keyType, keyNode);
+          }
+        }
+      }
+    }
 
     /**
      * Returns the type specified in a JSDoc annotation near a GETPROP or NAME.
@@ -411,53 +663,20 @@
      * Extracts type information from either the {@code @type} tag or from
      * the {@code @return} and {@code @param} tags.
      */
-    JSType getDeclaredTypeInAnnotation(
-        NodeTraversal t, Node node, JSDocInfo info) {
-      return getDeclaredTypeInAnnotation(t.getSourceName(), node, info);
-    }
-
-    JSType getDeclaredTypeInAnnotation(String sourceName,
+    private JSType getDeclaredTypeInAnnotation(String sourceName,
         Node node, JSDocInfo info) {
       JSType jsType = null;
-      Node objNode = node.getType() == Token.GETPROP ?
-          node.getFirstChild() : null;
+      Node objNode =
+          node.isGetProp() ? node.getFirstChild() :
+          NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() :
+          null;
       if (info != null) {
         if (info.hasType()) {
           jsType = info.getType().evaluate(scope, typeRegistry);
         } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {
           String fnName = node.getQualifiedName();
-
-          // constructors are often handled separately.
-          if (info.isConstructor() && typeRegistry.getType(fnName) != null) {
-            return null;
-          }
-
-          FunctionTypeBuilder builder =
-              new FunctionTypeBuilder(
-                  fnName, compiler, node, sourceName, scope)
-              .inferTemplateTypeName(info)
-              .inferReturnType(info)
-              .inferParameterTypes(info)
-              .inferInheritance(info);
-
-          // Infer the context type.
-          boolean searchedForThisType = false;
-          if (objNode != null) {
-            if (objNode.getType() == Token.GETPROP &&
-                objNode.getLastChild().getString().equals("prototype")) {
-              builder.inferThisType(info, objNode.getFirstChild());
-              searchedForThisType = true;
-            } else if (objNode.getType() == Token.THIS) {
-              builder.inferThisType(info, objNode.getJSType());
-              searchedForThisType = true;
-            }
-          }
-
-          if (!searchedForThisType) {
-            builder.inferThisType(info, (Node) null);
-          }
-
-          jsType = builder.buildAndRegister();
+          jsType = createFunctionTypeFromNodes(
+              null, fnName, info, node);
         }
       }
       return jsType;
@@ -503,59 +722,31 @@
     }
 
     /**
-     * Defines a declared function.
+     * Defines a function literal.
      */
-    void defineDeclaredFunction(Node n, Node parent) {
+    void defineFunctionLiteral(Node n, Node parent) {
       assertDefinitionNode(n, Token.FUNCTION);
 
-      JSDocInfo info = n.getJSDocInfo();
-      int parentType = parent.getType();
-      Preconditions.checkState(
-          (scope.isLocal() || parentType != Token.ASSIGN) &&
-          parentType != Token.NAME,
-          "function defined as standalone function when it is being " +
-          "assigned");
-      String functionName = n.getFirstChild().getString();
-      FunctionType functionType = getFunctionType(functionName, n, info,
-          null);
+      // Determine the name and JSDocInfo and lvalue for the function.
+      // Any of these may be null.
+      Node lValue = NodeUtil.getBestLValue(n);
+      JSDocInfo info = NodeUtil.getBestJSDocInfo(n);
+      String functionName = NodeUtil.getBestLValueName(lValue);
+      FunctionType functionType =
+          createFunctionTypeFromNodes(n, functionName, info, lValue);
+
+      // Assigning the function type to the function node
+      setDeferredType(n, functionType);
+
+      // Declare this symbol in the current scope iff it's a function
+      // declaration. Otherwise, the declaration will happen in other
+      // code paths.
       if (NodeUtil.isFunctionDeclaration(n)) {
         defineSlot(n.getFirstChild(), n, functionType);
       }
     }
 
     /**
-     * Defines a qualified name assign to an enum or constructor.
-     */
-    void defineNamedTypeAssign(Node n, Node parent) {
-      assertDefinitionNode(n, Token.ASSIGN);
-      JSDocInfo info = n.getJSDocInfo();
-
-      // TODO(nicksantos): We should support direct assignment to a
-      // prototype, as in:
-      // Foo.prototype = {
-      //   a: function() { ... },
-      //   b: function() { ... }
-      // };
-      // Right now (6/23/08), we understand most of this syntax, but we
-      // don't tie the "a" and "b" methods to the context of Foo.
-
-      Node rvalue = n.getLastChild();
-      Node lvalue = n.getFirstChild();
-      info = (info != null) ? info : rvalue.getJSDocInfo();
-      if (rvalue.getType() == Token.FUNCTION ||
-          info != null && info.isConstructor()) {
-        getFunctionType(lvalue.getQualifiedName(), rvalue, info,
-            lvalue);
-      } else if (info != null && info.hasEnumParameterType()) {
-        JSType type = getEnumType(lvalue.getQualifiedName(), n, rvalue,
-            info.getEnumParameterType().evaluate(scope, typeRegistry));
-        if (type != null) {
-          setDeferredType(lvalue, type);
-        }
-      }
-    }
-
-    /**
      * Defines a variable based on the {@link Token#NAME} node passed.
      * @param name The {@link Token#NAME} node.
      * @param var The parent of the {@code name} node, which must be a
@@ -567,123 +758,154 @@
     private void defineName(Node name, Node var, Node parent, JSDocInfo info) {
       Node value = name.getFirstChild();
 
-      if (value != null && value.getType() == Token.FUNCTION) {
-        // function
-        String functionName = name.getString();
-        FunctionType functionType =
-            getFunctionType(functionName, value, info, null);
-        if (functionType.isReturnTypeInferred() &&
-            scope.isLocal()) {
-          defineSlot(name, var, null);
-        } else {
-          defineSlot(name, var, functionType);
-        }
-      } else {
-        // variable's type
-        JSType type = null;
-        if (info == null) {
-          // the variable's type will be inferred
-          CompilerInput input = compiler.getInput(sourceName);
-          Preconditions.checkNotNull(input, sourceName);
-          type = input.isExtern() ?
-              getNativeType(UNKNOWN_TYPE) : null;
-        } else if (info.hasEnumParameterType()) {
-          type = getEnumType(name.getString(), var, value,
-              info.getEnumParameterType().evaluate(scope, typeRegistry));
-        } else if (info.isConstructor()) {
-          type = getFunctionType(name.getString(), value, info, name);
-        } else {
-          type = getDeclaredTypeInAnnotation(sourceName, name, info);
-        }
+      // variable's type
+      JSType type = getDeclaredType(sourceName, info, name, value);
+      if (type == null) {
+        // The variable's type will be inferred.
+        type = name.isFromExterns() ?
+            getNativeType(UNKNOWN_TYPE) : null;
+      }
+      defineSlot(name, var, type);
+    }
 
-        defineSlot(name, var, type);
+    /**
+     * If a variable is assigned a function literal in the global scope,
+     * make that a declared type (even if there's no doc info).
+     * There's only one exception to this rule:
+     * if the return type is inferred, and we're in a local
+     * scope, we should assume the whole function is inferred.
+     */
+    private boolean shouldUseFunctionLiteralType(
+        FunctionType type, JSDocInfo info, Node lValue) {
+      if (info != null) {
+        return true;
       }
+      if (lValue != null &&
+          NodeUtil.isObjectLitKey(lValue, lValue.getParent())) {
+        return false;
+      }
+      return scope.isGlobal() || !type.isReturnTypeInferred();
     }
 
     /**
-     * Gets the function type from the function node and its attached
-     * {@link JSDocInfo}.
+     * Creates a new function type, based on the given nodes.
+     *
+     * This handles two cases that are semantically very different, but
+     * are not mutually exclusive:
+     * - A function literal that needs a type attached to it.
+     * - An assignment expression with function-type info in the jsdoc.
+     *
+     * All parameters are optional, and we will do the best we can to create
+     * a function type.
+     *
+     * This function will always create a function type, so only call it if
+     * you're sure that's what you want.
+     *
+     * @param rValue The function node.
      * @param name the function's name
-     * @param rValue the function node. It must be a {@link Token#FUNCTION}.
      * @param info the {@link JSDocInfo} attached to the function definition
      * @param lvalueNode The node where this function is being
      *     assigned. For example, {@code A.prototype.foo = ...} would be used to
      *     determine that this function is a method of A.prototype. May be
      *     null to indicate that this is not being assigned to a qualified name.
      */
-    private FunctionType getFunctionType(String name,
-        Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {
+    private FunctionType createFunctionTypeFromNodes(
+        @Nullable Node rValue,
+        @Nullable String name,
+        @Nullable JSDocInfo info,
+        @Nullable Node lvalueNode) {
+
       FunctionType functionType = null;
 
-      // Handle function aliases.
-      if (rValue != null && rValue.isQualifiedName()) {
+      // Global ctor aliases should be registered with the type registry.
+      if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {
         Var var = scope.getVar(rValue.getQualifiedName());
-        if (var != null && var.getType() instanceof FunctionType) {
-          functionType = (FunctionType) var.getType();
-          if (functionType != null && functionType.isConstructor()) {
-            typeRegistry.declareType(name, functionType.getInstanceType());
+        if (var != null && var.getType() != null &&
+            var.getType().isFunctionType()) {
+          FunctionType aliasedType  = var.getType().toMaybeFunctionType();
+          if ((aliasedType.isConstructor() || aliasedType.isInterface()) &&
+              !aliasedType.isNativeObjectType()) {
+            functionType = aliasedType;
+
+            if (name != null && scope.isGlobal()) {
+              typeRegistry.declareType(name, functionType.getInstanceType());
+            }
           }
         }
-        return functionType;
       }
 
-      Node owner = null;
-      if (lvalueNode != null) {
-        owner = getPrototypePropertyOwner(lvalueNode);
-      }
+      if (functionType == null) {
+        Node errorRoot = rValue == null ? lvalueNode : rValue;
+        boolean isFnLiteral =
+            rValue != null && rValue.isFunction();
+        Node fnRoot = isFnLiteral ? rValue : null;
+        Node parametersNode = isFnLiteral ?
+            rValue.getFirstChild().getNext() : null;
+        Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;
+
+        if (info != null && info.hasType()) {
+          JSType type = info.getType().evaluate(scope, typeRegistry);
+
+          // Known to be not null since we have the FUNCTION token there.
+          type = type.restrictByNotNullOrUndefined();
+          if (type.isFunctionType()) {
+            functionType = type.toMaybeFunctionType();
+            functionType.setJSDocInfo(info);
+          }
+        }
 
-      Node errorRoot = rValue == null ? lvalueNode : rValue;
-      boolean isFnLiteral =
-          rValue != null && rValue.getType() == Token.FUNCTION;
-      Node fnRoot = isFnLiteral ? rValue : null;
-      Node parametersNode = isFnLiteral ?
-          rValue.getFirstChild().getNext() : null;
-      Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;
+        if (functionType == null) {
+          // Find the type of any overridden function.
+          Node ownerNode = NodeUtil.getBestLValueOwner(lvalueNode);
+          String ownerName = NodeUtil.getBestLValueName(ownerNode);
+          Var ownerVar = null;
+          String propName = null;
+          ObjectType ownerType = null;
+          if (ownerName != null) {
+            ownerVar = scope.getVar(ownerName);
+            if (ownerVar != null) {
+              ownerType = ObjectType.cast(ownerVar.getType());
+            }
+            if (name != null) {
+              propName = name.substring(ownerName.length() + 1);
+            }
+          }
 
-      if (functionType == null && info != null && info.hasType()) {
-        JSType type = info.getType().evaluate(scope, typeRegistry);
+          FunctionType overriddenPropType = null;
+          if (ownerType != null && propName != null) {
+            overriddenPropType =
+                findOverriddenFunction(ownerType, propName);
+          }
 
-        // Known to be not null since we have the FUNCTION token there.
-        type = type.restrictByNotNullOrUndefined();
-        if (type.isFunctionType()) {
-          functionType = (FunctionType) type;
-          functionType.setJSDocInfo(info);
-        }
-      }
+          FunctionTypeBuilder builder =
+              new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,
+                  scope)
+              .setContents(getFunctionAnalysisResults(fnRoot))
+              .inferFromOverriddenFunction(overriddenPropType, parametersNode)
+              .inferTemplateTypeName(info)
+              .inferReturnType(info)
+              .inferInheritance(info);
 
-      if (functionType == null) {
-        // Find the type of any overridden function.
-        FunctionType overriddenPropType = null;
-        if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP &&
-            lvalueNode.isQualifiedName()) {
-          Var var = scope.getVar(
-              lvalueNode.getFirstChild().getQualifiedName());
-          if (var != null) {
-            ObjectType ownerType = ObjectType.cast(var.getType());
-            if (ownerType != null) {
-              String propName = lvalueNode.getLastChild().getString();
-              overriddenPropType = findOverriddenFunction(ownerType, propName);
-            }
+
+          // Infer the context type.
+          boolean searchedForThisType = false;
+          if (ownerType != null && ownerType.isFunctionPrototypeType()) {
+            builder.inferThisType(
+                info, ownerType.getOwnerFunction().getInstanceType());
+            searchedForThisType = true;
+          } else if (ownerNode != null && ownerNode.isThis()) {
+            builder.inferThisType(info, ownerNode.getJSType());
+            searchedForThisType = true;
+          }
+
+          if (!searchedForThisType) {
+            builder.inferThisType(info);
           }
-        }
 
-        functionType =
-            new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,
-                scope)
-            .setSourceNode(fnRoot)
-            .inferFromOverriddenFunction(overriddenPropType, parametersNode)
-            .inferTemplateTypeName(info)
-            .inferReturnType(info)
-            .inferInheritance(info)
-            .inferThisType(info, owner)
-            .inferParameterTypes(parametersNode, info)
-            .inferReturnStatementsAsLastResort(fnBlock)
-            .buildAndRegister();
-      }
-
-      // assigning the function type to the function node
-      if (rValue != null) {
-        setDeferredType(rValue, functionType);
+          functionType = builder
+              .inferParameterTypes(parametersNode, info)
+              .buildAndRegister();
+        }
       }
 
       // all done
@@ -698,16 +920,16 @@
       // First, check to see if the property is implemented
       // on a superclass.
       JSType propType = ownerType.getPropertyType(propName);
-      if (propType instanceof FunctionType) {
-        return (FunctionType) propType;
+      if (propType != null && propType.isFunctionType()) {
+        return propType.toMaybeFunctionType();
       } else {
         // If it's not, then check to see if it's implemented
         // on an implemented interface.
         for (ObjectType iface :
                  ownerType.getCtorImplementedInterfaces()) {
           propType = iface.getPropertyType(propName);
-          if (propType instanceof FunctionType) {
-            return (FunctionType) propType;
+          if (propType != null && propType.isFunctionType()) {
+            return propType.toMaybeFunctionType();
           }
         }
       }
@@ -716,58 +938,63 @@
     }
 
     /**
-     * Gets an enum type. If the definition is correct, the object literal used
-     * to define the enum is traversed to gather the elements name, and this
-     * method checks for duplicates. This method also enforces that all
-     * elements' name be syntactic constants according to the
-     * {@link CodingConvention} used.
+     * Creates a new enum type, based on the given nodes.
      *
-     * @param name the enum's name such as {@code HELLO} or {@code goog.foo.BAR}
-     * @param value the enum's original value. This value may be {@code null}.
-     * @param parent the value's parent
-     * @param elementsType the type of the elements of this enum
-     * @return the enum type
-     */
-    private EnumType getEnumType(String name, Node parent,
-        Node value, JSType elementsType) {
+     * This handles two cases that are semantically very different, but
+     * are not mutually exclusive:
+     * - An object literal that needs an enum type attached to it.
+     * - An assignment expression with an enum tag in the jsdoc.
+     *
+     * This function will always create an enum type, so only call it if
+     * you're sure that's what you want.
+     *
+     * @param rValue The node of the enum.
+     * @param name The enum's name
+     * @param info The {@link JSDocInfo} attached to the enum definition.
+     * @param lValueNode The node where this function is being
+     *     assigned.
+     */
+    private EnumType createEnumTypeFromNodes(Node rValue, String name,
+        JSDocInfo info, Node lValueNode) {
+      Preconditions.checkNotNull(info);
+      Preconditions.checkState(info.hasEnumParameterType());
+
       EnumType enumType = null;
+      if (rValue != null && rValue.isQualifiedName()) {
+        // Handle an aliased enum.
+        Var var = scope.getVar(rValue.getQualifiedName());
+        if (var != null && var.getType() instanceof EnumType) {
+          enumType = (EnumType) var.getType();
+        }
+      }
 
-      // no value with @enum
-      if (value != null) {
-        if (value.getType() == Token.OBJECTLIT) {
-          // collect enum elements
-          enumType = typeRegistry.createEnumType(name, elementsType);
+      if (enumType == null) {
+        JSType elementsType =
+            info.getEnumParameterType().evaluate(scope, typeRegistry);
+        enumType = typeRegistry.createEnumType(name, rValue, elementsType);
 
-          // populate the enum type.
-          Node key = value.getFirstChild();
+        if (rValue != null && rValue.isObjectLit()) {
+          // collect enum elements
+          Node key = rValue.getFirstChild();
           while (key != null) {
             String keyName = NodeUtil.getStringValue(key);
-
-            if (enumType.hasOwnProperty(keyName)) {
-              compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));
+            if (keyName == null) {
+              // GET and SET don't have a String value;
+              compiler.report(
+                  JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));
             } else if (!codingConvention.isValidEnumKey(keyName)) {
               compiler.report(
                   JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));
             } else {
-              enumType.defineElement(keyName);
+              enumType.defineElement(keyName, key);
             }
             key = key.getNext();
-            key = (key == null) ? null : key.getNext();
-          }
-        } else if (value.isQualifiedName()) {
-          Var var = scope.getVar(value.getQualifiedName());
-          if (var != null && var.getType() instanceof EnumType) {
-            enumType = (EnumType) var.getType();
           }
         }
       }
 
-      if (enumType == null) {
-        compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER));
-      } else if (scope.isGlobal()) {
-        if (name != null && !name.isEmpty()) {
-          typeRegistry.declareType(name, enumType.getElementsType());
-        }
+      if (name != null && scope.isGlobal()) {
+        typeRegistry.declareType(name, enumType.getElementsType());
       }
 
       return enumType;
@@ -801,163 +1028,254 @@
       Preconditions.checkArgument(inferred || type != null);
 
       // Only allow declarations of NAMEs and qualfied names.
-      boolean shouldDeclareOnGlobalThis = false;
-      if (n.getType() == Token.NAME) {
+      // Object literal keys will have to compute their names themselves.
+      if (n.isName()) {
         Preconditions.checkArgument(
-            parent.getType() == Token.FUNCTION ||
-            parent.getType() == Token.VAR ||
-            parent.getType() == Token.LP ||
-            parent.getType() == Token.CATCH);
-        shouldDeclareOnGlobalThis = scope.isGlobal() &&
-            (parent.getType() == Token.VAR ||
-             parent.getType() == Token.FUNCTION);
+            parent.isFunction() ||
+            parent.isVar() ||
+            parent.isParamList() ||
+            parent.isCatch());
       } else {
         Preconditions.checkArgument(
-            n.getType() == Token.GETPROP &&
-            (parent.getType() == Token.ASSIGN ||
-             parent.getType() == Token.EXPR_RESULT));
+            n.isGetProp() &&
+            (parent.isAssign() ||
+             parent.isExprResult()));
       }
-      String variableName = n.getQualifiedName();
+      defineSlot(n, parent, n.getQualifiedName(), type, inferred);
+    }
+
+
+    /**
+     * Defines a symbol in the current scope.
+     *
+     * @param n the defining NAME or GETPROP or object literal key node.
+     * @param parent the {@code n}'s parent.
+     * @param variableName The name that this should be known by.
+     * @param type the variable's type. It may be {@code null} if
+     *     {@code inferred} is {@code true}.
+     * @param inferred Whether the type is inferred or declared.
+     */
+    void defineSlot(Node n, Node parent, String variableName,
+        JSType type, boolean inferred) {
       Preconditions.checkArgument(!variableName.isEmpty());
 
+      boolean isGlobalVar = n.isName() && scope.isGlobal();
+      boolean shouldDeclareOnGlobalThis =
+          isGlobalVar &&
+          (parent.isVar() ||
+           parent.isFunction());
+
+      // If n is a property, then we should really declare it in the
+      // scope where the root object appears. This helps out people
+      // who declare "global" names in an anonymous namespace.
+      Scope scopeToDeclareIn = scope;
+      if (n.isGetProp() && !scope.isGlobal() &&
+          isQnameRootedInGlobalScope(n)) {
+        Scope globalScope = scope.getGlobalScope();
+
+        // don't try to declare in the global scope if there's
+        // already a symbol there with this name.
+        if (!globalScope.isDeclared(variableName, false)) {
+          scopeToDeclareIn = scope.getGlobalScope();
+        }
+      }
+
       // declared in closest scope?
-      if (scope.isDeclared(variableName, false)) {
-        Var oldVar = scope.getVar(variableName);
+      CompilerInput input = compiler.getInput(inputId);
+      if (scopeToDeclareIn.isDeclared(variableName, false)) {
+        Var oldVar = scopeToDeclareIn.getVar(variableName);
         validator.expectUndeclaredVariable(
-            sourceName, n, parent, oldVar, variableName, type);
+            sourceName, input, n, parent, oldVar, variableName, type);
       } else {
         if (!inferred) {
           setDeferredType(n, type);
         }
-        CompilerInput input = compiler.getInput(sourceName);
-        scope.declare(variableName, n, type, input, inferred);
 
-        if (shouldDeclareOnGlobalThis) {
-          ObjectType globalThis =
-              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
-          boolean isExtern = input.isExtern();
-          if (inferred) {
-            globalThis.defineInferredProperty(variableName,
-                type == null ?
-                    getNativeType(JSTypeNative.NO_TYPE) :
-                    type,
-                isExtern);
-          } else {
-            globalThis.defineDeclaredProperty(variableName, type, isExtern);
+        // The input may be null if we are working with a AST snippet.
+        boolean isExtern = n.isFromExterns();
+        Var newVar =
+            scopeToDeclareIn.declare(variableName, n, type, input, inferred);
+
+        if (type instanceof EnumType) {
+          Node initialValue = newVar.getInitialValue();
+          boolean isValidValue = initialValue != null &&
+              (initialValue.isObjectLit() ||
+               initialValue.isQualifiedName());
+          if (!isValidValue) {
+            compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER));
           }
         }
 
-        // If we're in the global scope, also declare var.prototype
-        // in the scope chain.
-        if (scope.isGlobal() && type instanceof FunctionType) {
-          FunctionType fnType = (FunctionType) type;
-          if (fnType.isConstructor() || fnType.isInterface()) {
+        // We need to do some additional work for constructors and interfaces.
+        FunctionType fnType = JSType.toMaybeFunctionType(type);
+        if (fnType != null &&
+            // We don't want to look at empty function types.
+            !type.isEmptyType()) {
+          if ((fnType.isConstructor() || fnType.isInterface()) &&
+              !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {
+            // Declare var.prototype in the scope chain.
             FunctionType superClassCtor = fnType.getSuperClassConstructor();
-            scope.declare(variableName + ".prototype", n,
-                fnType.getPrototype(), compiler.getInput(sourceName),
-                /* declared iff there's an explicit supertype */
-                superClassCtor == null ||
-                superClassCtor.getInstanceType().equals(
-                    getNativeType(OBJECT_TYPE)));
+            ObjectType.Property prototypeSlot = fnType.getSlot("prototype");
+
+            String prototypeName = variableName + ".prototype";
+
+            // There are some rare cases where the prototype will already
+            // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.
+            // Fortunately, other warnings will complain if this happens.
+            if (scopeToDeclareIn.getOwnSlot(prototypeName) == null) {
+              // When we declare the function prototype implicitly, we
+              // want to make sure that the function and its prototype
+              // are declared at the same node. We also want to make sure
+              // that the if a symbol has both a Var and a JSType, they have
+              // the same node.
+              //
+              // This consistency is helpful to users of SymbolTable,
+              // because everything gets declared at the same place.
+              prototypeSlot.setNode(n);
+
+              scopeToDeclareIn.declare(prototypeName,
+                  n, prototypeSlot.getType(), input,
+                  /* declared iff there's an explicit supertype */
+                  superClassCtor == null ||
+                  superClassCtor.getInstanceType().equals(
+                      getNativeType(OBJECT_TYPE)));
+            }
+
+            // Make sure the variable is initialized to something if
+            // it constructs itself.
+            if (newVar.getInitialValue() == null &&
+                !isExtern &&
+                // We want to make sure that when we declare a new instance
+                // type (with @constructor) that there's actually a ctor for it.
+                // This doesn't apply to structural constructors
+                // (like function(new:Array). Checking the constructed
+                // type against the variable name is a sufficient check for
+                // this.
+                variableName.equals(
+                    fnType.getInstanceType().getReferenceName())) {
+              compiler.report(
+                  JSError.make(sourceName, n,
+                      fnType.isConstructor() ?
+                          CTOR_INITIALIZER : IFACE_INITIALIZER,
+                      variableName));
+            }
           }
         }
       }
-    }
-  }
 
-  /**
-   * A shallow traversal of the global scope to build up all classes,
-   * functions, and methods.
-   */
-  private final class GlobalScopeBuilder extends AbstractScopeBuilder {
+      if (shouldDeclareOnGlobalThis) {
+        ObjectType globalThis =
+            typeRegistry.getNativeObjectType(GLOBAL_THIS);
+        if (inferred) {
+          globalThis.defineInferredProperty(variableName,
+              type == null ?
+              getNativeType(JSTypeNative.NO_TYPE) :
+              type,
+              n);
+        } else {
+          globalThis.defineDeclaredProperty(variableName, type, n);
+        }
+      }
 
-    /**
-     * Functions that we found in the global scope and not in externs.
-     */
-    private final List<Node> nonExternFunctions = Lists.newArrayList();
+      if (isGlobalVar && "Window".equals(variableName)
+          && type != null
+          && type.isFunctionType()
+          && type.isConstructor()) {
+        FunctionType globalThisCtor =
+            typeRegistry.getNativeObjectType(GLOBAL_THIS).getConstructor();
+        globalThisCtor.getInstanceType().clearCachedValues();
+        globalThisCtor.getPrototype().clearCachedValues();
+        globalThisCtor
+            .setPrototypeBasedOn((type.toMaybeFunctionType()).getInstanceType());
+      }
+    }
 
     /**
-     * Type-less stubs in the global scope.
-     *
-     * If at the end of traversal, we still don't have types for these
-     * stubs, then we should declare UNKNOWN types.
+     * Check if the given node is a property of a name in the global scope.
      */
-    private final List<StubDeclaration> stubDeclarations =
-        Lists.newArrayList();
-
-    private GlobalScopeBuilder(Scope scope) {
-      super(scope);
+    private boolean isQnameRootedInGlobalScope(Node n) {
+      Node root = NodeUtil.getRootOfQualifiedName(n);
+      if (root.isName()) {
+        Var var = scope.getVar(root.getString());
+        if (var != null) {
+          return var.isGlobal();
+        }
+      }
+      return false;
     }
 
     /**
-     * Visit a node in the global scope, and add anything it declares to the
-     * global symbol table.
+     * Look for a type declaration on a property assignment
+     * (in an ASSIGN or an object literal key).
      *
-     * @param t The current traversal.
-     * @param n The node being visited.
-     * @param parent The parent of n
+     * @param info The doc info for this property.
+     * @param lValue The l-value node.
+     * @param rValue The node that {@code n} is being initialized to,
+     *     or {@code null} if this is a stub declaration.
      */
-    @Override public void visit(NodeTraversal t, Node n, Node parent) {
-      attachLiteralTypes(n);
-
-      switch (n.getType()) {
-        case Token.CALL:
-          checkForClassDefiningCalls(t, n, parent);
-          break;
-
-        case Token.FUNCTION:
-          if (!t.getInput().isExtern()) {
-            nonExternFunctions.add(n);
-          }
-
-          // VARs and ASSIGNs are handled separately.
-          if (parent.getType() == Token.ASSIGN ||
-              parent.getType() == Token.NAME) {
-            return;
+    private JSType getDeclaredType(String sourceName, JSDocInfo info,
+        Node lValue, @Nullable Node rValue) {
+      if (info != null && info.hasType()) {
+        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
+      } else if (rValue != null && rValue.isFunction() &&
+          shouldUseFunctionLiteralType(
+              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
+        return rValue.getJSType();
+      } else if (info != null) {
+        if (info.hasEnumParameterType()) {
+          if (rValue != null && rValue.isObjectLit()) {
+            return rValue.getJSType();
+          } else {
+            return createEnumTypeFromNodes(
+                rValue, lValue.getQualifiedName(), info, lValue);
           }
-
-          defineDeclaredFunction(n, parent);
-          break;
-
-        case Token.ASSIGN:
-          // Handle constructor and enum definitions.
-          defineNamedTypeAssign(n, parent);
-
-          // Handle typedefs.
-          checkForOldStyleTypedef(t, n);
-
-          // Handle initialization of properties.
-          Node firstChild = n.getFirstChild();
-          if (firstChild.getType() == Token.GETPROP &&
-              firstChild.isQualifiedName()) {
-            maybeDeclareQualifiedName(t, n.getJSDocInfo(),
-                firstChild, n, firstChild.getNext());
+        } else if (info.isConstructor() || info.isInterface()) {
+          return createFunctionTypeFromNodes(
+              rValue, lValue.getQualifiedName(), info, lValue);
+        } else {
+          // Check if this is constant, and if it has a known type.
+          if (info.isConstant()) {
+            JSType knownType = null;
+            if (rValue != null) {
+              if (rValue.getJSType() != null
+                  && !rValue.getJSType().isUnknownType()) {
+                return rValue.getJSType();
+              } else if (rValue.isOr()) {
+                // Check for a very specific JS idiom:
+                // var x = x || TYPE;
+                // This is used by Closure's base namespace for esoteric
+                // reasons.
+                Node firstClause = rValue.getFirstChild();
+                Node secondClause = firstClause.getNext();
+                boolean namesMatch = firstClause.isName()
+                    && lValue.isName()
+                    && firstClause.getString().equals(lValue.getString());
+                if (namesMatch && secondClause.getJSType() != null
+                    && !secondClause.getJSType().isUnknownType()) {
+                  return secondClause.getJSType();
+                }
+              }
+            }
           }
-          break;
-
-        case Token.CATCH:
-          defineCatch(n, parent);
-          break;
+        }
+      }
 
-        case Token.VAR:
-          defineVar(n, parent);
+      return getDeclaredTypeInAnnotation(sourceName, lValue, info);
+    }
 
-          // Handle typedefs.
-          if (n.hasOneChild()) {
-            checkForOldStyleTypedef(t, n);
-            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());
-          }
-          break;
+    private FunctionType getFunctionType(@Nullable Var v) {
+      JSType t = v == null ? null : v.getType();
+      ObjectType o = t == null ? null : t.dereference();
+      return JSType.toMaybeFunctionType(o);
+    }
 
-        case Token.GETPROP:
-          // Handle stubbed properties.
-          if (parent.getType() == Token.EXPR_RESULT &&
-              n.isQualifiedName()) {
-            checkForTypedef(t, n, n.getJSDocInfo());
-            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
-          }
-          break;
-      }
+    /**
+     * Look for calls that set a delegate method's calling convention.
+     */
+    private void checkForCallingConventionDefiningCalls(
+        Node n, Map<String, String> delegateCallingConventions) {
+      codingConvention.checkForCallingConventionDefiningCalls(n,
+          delegateCallingConventions);
     }
 
     /**
@@ -970,15 +1288,23 @@
       SubclassRelationship relationship =
           codingConvention.getClassesDefinedByCall(n);
       if (relationship != null) {
-        ObjectType superClass = ObjectType.cast(
-            typeRegistry.getType(relationship.superclassName));
-        ObjectType subClass = ObjectType.cast(
-            typeRegistry.getType(relationship.subclassName));
-        if (superClass != null && subClass != null) {
-          FunctionType superCtor = superClass.getConstructor();
-          FunctionType subCtor = subClass.getConstructor();
+        FunctionType superCtor = getFunctionType(
+            scope.getVar(relationship.superclassName));
+        FunctionType subCtor = getFunctionType(
+            scope.getVar(relationship.subclassName));
+        if (superCtor != null && superCtor.isConstructor() &&
+            subCtor != null && subCtor.isConstructor()) {
+          ObjectType superClass = superCtor.getInstanceType();
+          ObjectType subClass = subCtor.getInstanceType();
+
+          // superCtor and subCtor might be structural constructors
+          // (like {function(new:Object)}) so we need to resolve them back
+          // to the original ctor objects.
+          superCtor = superClass.getConstructor();
+          subCtor = subClass.getConstructor();
 
-          if (relationship.type == SubclassType.INHERITS) {
+          if (relationship.type == SubclassType.INHERITS &&
+              !superClass.isEmptyType() && !subClass.isEmptyType()) {
             validator.expectSuperType(t, n, superClass, subClass);
           }
 
@@ -1068,76 +1394,6 @@
     }
 
     /**
-     * Handle typedefs.
-     * @param t The current traversal.
-     * @param candidate A qualified name node.
-     * @param info JSDoc comments.
-     */
-    private void checkForTypedef(
-        NodeTraversal t, Node candidate, JSDocInfo info) {
-      if (info == null || !info.hasTypedefType()) {
-        return;
-      }
-
-      String typedef = candidate.getQualifiedName();
-      if (typedef == null) {
-        return;
-      }
-
-      // TODO(nicksantos|user): This is a terrible, terrible hack
-      // to bail out on recusive typedefs. We'll eventually need
-      // to handle these properly.
-      typeRegistry.forwardDeclareType(typedef);
-
-      JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);
-      if (realType == null) {
-        compiler.report(
-            JSError.make(
-                t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));
-      }
-
-      typeRegistry.declareType(typedef, realType);
-      if (candidate.getType() == Token.GETPROP) {
-        defineSlot(candidate, candidate.getParent(),
-            getNativeType(NO_TYPE), false);
-      }
-    }
-
-    /**
-     * Handle typedefs.
-     * @param t The current traversal.
-     * @param candidate An ASSIGN or VAR node.
-     */
-    // TODO(nicksantos): Kill this.
-    private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) {
-      // old-style typedefs
-      String typedef = codingConvention.identifyTypeDefAssign(candidate);
-      if (typedef != null) {
-        // TODO(nicksantos|user): This is a terrible, terrible hack
-        // to bail out on recusive typedefs. We'll eventually need
-        // to handle these properly.
-        typeRegistry.forwardDeclareType(typedef);
-
-        JSDocInfo info = candidate.getJSDocInfo();
-        JSType realType = null;
-        if (info != null && info.getType() != null) {
-          realType = info.getType().evaluate(scope, typeRegistry);
-        }
-
-        if (realType == null) {
-          compiler.report(
-              JSError.make(
-                  t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));
-        }
-
-        typeRegistry.declareType(typedef, realType);
-
-        // Duplicate typedefs get handled when we try to register
-        // this typedef in the scope.
-      }
-    }
-
-    /**
      * Declare the symbol for a qualified name in the global scope.
      *
      * @param info The doc info for this property.
@@ -1147,7 +1403,7 @@
      * @param rhsValue The node that {@code n} is being initialized to,
      *     or {@code null} if this is a stub declaration.
      */
-    private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
+    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
         Node n, Node parent, Node rhsValue) {
       Node ownerNode = n.getFirstChild();
       String ownerName = ownerNode.getQualifiedName();
@@ -1155,6 +1411,25 @@
       String propName = n.getLastChild().getString();
       Preconditions.checkArgument(qName != null && ownerName != null);
 
+      // Precedence of type information on GETPROPs:
+      // 1) @type annnotation / @enum annotation
+      // 2) ASSIGN to FUNCTION literal
+      // 3) @param/@return annotation (with no function literal)
+      // 4) ASSIGN to something marked @const
+      // 5) ASSIGN to anything else
+      //
+      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
+      // the function has jsdoc or has not been declared before.
+      //
+      // FUNCTION literals are special because TypedScopeCreator is very smart
+      // about getting as much type information as possible for them.
+
+      // Determining type for #1 + #2 + #3 + #4
+      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
+      if (valueType == null && rhsValue != null) {
+        // Determining type for #5
+        valueType = rhsValue.getJSType();
+      }
       // Function prototypes are special.
       // It's a common JS idiom to do:
       // F.prototype = { ... };
@@ -1163,37 +1438,37 @@
       if ("prototype".equals(propName)) {
         Var qVar = scope.getVar(qName);
         if (qVar != null) {
-          if (!qVar.isTypeInferred()) {
-            // Just ignore assigns to declared prototypes.
+          // If the programmer has declared that F inherits from Super,
+          // and they assign F.prototype to an object literal,
+          // then they are responsible for making sure that the object literal's
+          // implicit prototype is set up appropriately. We just obey
+          // the @extends tag.
+          ObjectType qVarType = ObjectType.cast(qVar.getType());
+          if (qVarType != null &&
+              rhsValue != null &&
+              rhsValue.isObjectLit()) {
+            typeRegistry.resetImplicitPrototype(
+                rhsValue.getJSType(), qVarType.getImplicitPrototype());
+          } else if (!qVar.isTypeInferred()) {
+            // If the programmer has declared that F inherits from Super,
+            // and they assign F.prototype to some arbitrary expression,
+            // there's not much we can do. We just ignore the expression,
+            // and hope they've annotated their code in a way to tell us
+            // what props are going to be on that prototype.
             return;
           }
-          scope.undeclare(qVar);
+          if (qVar.getScope() == scope) {
+            scope.undeclare(qVar);
+          }
         }
       }
 
-      // Precedence of type information on GETPROPs:
-      // 1) @type annotation / @enum annotation
-      // 2) ASSIGN to FUNCTION literal
-      // 3) @param/@return annotation (with no function literal)
-      // 4) ASSIGN to anything else
-      //
-      // 1 and 3 are declarations, 4 is inferred, and 2 is a declaration iff
-      // the function has not been declared before.
-      //
-      // FUNCTION literals are special because TypedScopeCreator is very smart
-      // about getting as much type information as possible for them.
-
-      // Determining type for #1 + #2 + #3
-      JSType valueType = getDeclaredGetPropType(t, info, n, rhsValue);
-      if (valueType == null && rhsValue != null) {
-        // Determining type for #4
-        valueType = rhsValue.getJSType();
-      }
-
       if (valueType == null) {
-        if (parent.getType() == Token.EXPR_RESULT) {
+        if (parent.isExprResult()) {
           stubDeclarations.add(new StubDeclaration(
-              n, t.getInput().isExtern(), ownerName));
+              n,
+              t.getInput() != null && t.getInput().isExtern(),
+              ownerName));
         }
 
         return;
@@ -1201,16 +1476,19 @@
 
       boolean inferred = true;
       if (info != null) {
-        // Determining declaration for #1 + #3
-        inferred = !(info.hasType() || info.hasEnumParameterType() ||
-            FunctionTypeBuilder.isFunctionTypeDeclaration(info));
+        // Determining declaration for #1 + #3 + #4
+        inferred = !(info.hasType()
+            || info.hasEnumParameterType()
+            || (info.isConstant() && valueType != null
+                && !valueType.isUnknownType())
+            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
       if (inferred) {
         // Determining declaration for #2
         inferred = !(rhsValue != null &&
-            rhsValue.getType() == Token.FUNCTION &&
-            !scope.isDeclared(qName, false));
+            rhsValue.isFunction() &&
+            (info != null || !scope.isDeclared(qName, false)));
       }
 
       if (!inferred) {
@@ -1218,13 +1496,13 @@
         if (ownerType != null) {
           // Only declare this as an official property if it has not been
           // declared yet.
-          boolean isExtern = t.getInput().isExtern();
+          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
           if ((!ownerType.hasOwnProperty(propName) ||
                ownerType.isPropertyTypeInferred(propName)) &&
               ((isExtern && !ownerType.isNativeObjectType()) ||
                !ownerType.isInstanceType())) {
             // If the property is undeclared or inferred, declare it now.
-            ownerType.defineDeclaredProperty(propName, valueType, isExtern);
+            ownerType.defineDeclaredProperty(propName, valueType, n);
           }
         }
 
@@ -1232,18 +1510,18 @@
         // caught when we try to declare it in the current scope.
         defineSlot(n, parent, valueType, inferred);
       } else if (rhsValue != null &&
-          rhsValue.getType() == Token.TRUE) {
+          rhsValue.isTrue()) {
         // We declare these for delegate proxy method properties.
-        ObjectType ownerType = getObjectSlot(ownerName);
-        if (ownerType instanceof FunctionType) {
-          JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis();
+        FunctionType ownerType =
+            JSType.toMaybeFunctionType(getObjectSlot(ownerName));
+        if (ownerType != null) {
+          JSType ownerTypeOfThis = ownerType.getTypeOfThis();
           String delegateName = codingConvention.getDelegateSuperclassName();
           JSType delegateType = delegateName == null ?
               null : typeRegistry.getType(delegateName);
           if (delegateType != null &&
               ownerTypeOfThis.isSubtype(delegateType)) {
-            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE),
-                true);
+            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
           }
         }
       }
@@ -1265,33 +1543,10 @@
     }
 
     /**
-     * Look for a type declaration on a GETPROP node.
-     *
-     * @param info The doc info for this property.
-     * @param n A top-level GETPROP node (it should not be contained inside
-     *     another GETPROP).
-     * @param rhsValue The node that {@code n} is being initialized to,
-     *     or {@code null} if this is a stub declaration.
-     */
-    private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,
-        Node n, Node rhsValue) {
-      if (info != null && info.hasType()) {
-        return getDeclaredTypeInAnnotation(t, n, info);
-      } else if (info != null && info.hasEnumParameterType()) {
-        return n.getJSType();
-      } else if (rhsValue != null &&
-          rhsValue.getType() == Token.FUNCTION) {
-        return rhsValue.getJSType();
-      } else {
-        return getDeclaredTypeInAnnotation(t, n, info);
-      }
-    }
-
-    /**
      * Resolve any stub delcarations to unknown types if we could not
      * find types for them during traversal.
      */
-    private void resolveStubDeclarations() {
+    void resolveStubDeclarations() {
       for (StubDeclaration stub : stubDeclarations) {
         Node n = stub.node;
         Node parent = n.getParent();
@@ -1315,7 +1570,7 @@
           // If this is a stub for a prototype, just declare it
           // as an unknown type. These are seen often in externs.
           ownerType.defineInferredProperty(
-              propName, unknownType, isExtern);
+              propName, unknownType, n);
         } else {
           typeRegistry.registerPropertyOnType(
               propName, ownerType == null ? unknownType : ownerType);
@@ -1324,47 +1579,35 @@
     }
 
     /**
-     * A stub declaration without any type information.
-     */
-    private final class StubDeclaration {
-      private final Node node;
-      private final boolean isExtern;
-      private final String ownerName;
-
-      private StubDeclaration(Node node, boolean isExtern, String ownerName) {
-        this.node = node;
-        this.isExtern = isExtern;
-        this.ownerName = ownerName;
-      }
-    }
-
-    /**
      * Collects all declared properties in a function, and
      * resolves them relative to the global scope.
      */
     private final class CollectProperties
-        extends AbstractShallowCallback {
+        extends AbstractShallowStatementCallback {
       private final ObjectType thisType;
 
       CollectProperties(ObjectType thisType) {
         this.thisType = thisType;
       }
 
+      @Override
       public void visit(NodeTraversal t, Node n, Node parent) {
-        if (parent != null && parent.getType() == Token.EXPR_RESULT) {
-          switch (n.getType()) {
+        if (n.isExprResult()) {
+          Node child = n.getFirstChild();
+          switch (child.getType()) {
             case Token.ASSIGN:
-              maybeCollectMember(t, n.getFirstChild(), n);
+              maybeCollectMember(t, child.getFirstChild(), child,
+                  child.getLastChild());
               break;
             case Token.GETPROP:
-              maybeCollectMember(t, n, n);
+              maybeCollectMember(t, child, child, null);
               break;
           }
         }
       }
 
       private void maybeCollectMember(NodeTraversal t,
-          Node member, Node nodeWithJsDocInfo) {
+          Node member, Node nodeWithJsDocInfo, @Nullable Node value) {
         JSDocInfo info = nodeWithJsDocInfo.getJSDocInfo();
 
         // Do nothing if there is no JSDoc type info, or
@@ -1377,17 +1620,109 @@
         }
 
         member.getFirstChild().setJSType(thisType);
-        JSType jsType = getDeclaredTypeInAnnotation(t, member, info);
+        JSType jsType = getDeclaredType(t.getSourceName(), info, member, value);
         Node name = member.getLastChild();
         if (jsType != null &&
-            (name.getType() == Token.NAME || name.getType() == Token.STRING)) {
+            (name.isName() || name.isString())) {
           thisType.defineDeclaredProperty(
               name.getString(),
               jsType,
-              false /* functions with implementations are not in externs */);
+              member);
         }
       }
     } // end CollectProperties
+  }
+
+  /**
+   * A stub declaration without any type information.
+   */
+  private static final class StubDeclaration {
+    private final Node node;
+    private final boolean isExtern;
+    private final String ownerName;
+
+    private StubDeclaration(Node node, boolean isExtern, String ownerName) {
+      this.node = node;
+      this.isExtern = isExtern;
+      this.ownerName = ownerName;
+    }
+  }
+
+  /**
+   * A shallow traversal of the global scope to build up all classes,
+   * functions, and methods.
+   */
+  private final class GlobalScopeBuilder extends AbstractScopeBuilder {
+
+    private GlobalScopeBuilder(Scope scope) {
+      super(scope);
+    }
+
+    /**
+     * Visit a node in the global scope, and add anything it declares to the
+     * global symbol table.
+     *
+     * @param t The current traversal.
+     * @param n The node being visited.
+     * @param parent The parent of n
+     */
+    @Override public void visit(NodeTraversal t, Node n, Node parent) {
+      super.visit(t, n, parent);
+
+      switch (n.getType()) {
+
+        case Token.VAR:
+          // Handle typedefs.
+          if (n.hasOneChild()) {
+            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());
+          }
+          break;
+      }
+    }
+
+    @Override
+    void maybeDeclareQualifiedName(
+        NodeTraversal t, JSDocInfo info,
+        Node n, Node parent, Node rhsValue) {
+      checkForTypedef(t, n, info);
+      super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);
+    }
+
+    /**
+     * Handle typedefs.
+     * @param t The current traversal.
+     * @param candidate A qualified name node.
+     * @param info JSDoc comments.
+     */
+    private void checkForTypedef(
+        NodeTraversal t, Node candidate, JSDocInfo info) {
+      if (info == null || !info.hasTypedefType()) {
+        return;
+      }
+
+      String typedef = candidate.getQualifiedName();
+      if (typedef == null) {
+        return;
+      }
+
+      // TODO(nicksantos|user): This is a terrible, terrible hack
+      // to bail out on recusive typedefs. We'll eventually need
+      // to handle these properly.
+      typeRegistry.declareType(typedef, getNativeType(UNKNOWN_TYPE));
+
+      JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);
+      if (realType == null) {
+        compiler.report(
+            JSError.make(
+                t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));
+      }
+
+      typeRegistry.overwriteDeclaredType(typedef, realType);
+      if (candidate.isGetProp()) {
+        defineSlot(candidate, candidate.getParent(),
+            getNativeType(NO_TYPE), false);
+      }
+    }
   } // end GlobalScopeBuilder
 
   /**
@@ -1407,6 +1742,16 @@
      */
     void build() {
       NodeTraversal.traverse(compiler, scope.getRootNode(), this);
+
+      AstFunctionContents contents =
+          getFunctionAnalysisResults(scope.getRootNode());
+      if (contents != null) {
+        for (String varName : contents.getEscapedVarNames()) {
+          Var v = scope.getVar(varName);
+          Preconditions.checkState(v.getScope() == scope);
+          v.markEscaped();
+        }
+      }
     }
 
     /**
@@ -1420,29 +1765,12 @@
     @Override public void visit(NodeTraversal t, Node n, Node parent) {
       if (n == scope.getRootNode()) return;
 
-      if (n.getType() == Token.LP && parent == scope.getRootNode()) {
+      if (n.isParamList() && parent == scope.getRootNode()) {
         handleFunctionInputs(parent);
         return;
       }
 
-      attachLiteralTypes(n);
-      switch (n.getType()) {
-        case Token.FUNCTION:
-          // VARs and ASSIGNs are handled separately.
-          if (parent.getType() == Token.NAME) {
-            return;
-          }
-          defineDeclaredFunction(n, parent);
-          break;
-
-        case Token.CATCH:
-          defineCatch(n, parent);
-          break;
-
-        case Token.VAR:
-          defineVar(n, parent);
-          break;
-      }
+      super.visit(t, n, parent);
     }
 
     /** Handle bleeding functions and function parameters. */
@@ -1473,7 +1801,8 @@
     private void declareArguments(Node functionNode) {
       Node astParameters = functionNode.getFirstChild().getNext();
       Node body = astParameters.getNext();
-      FunctionType functionType = (FunctionType) functionNode.getJSType();
+      FunctionType functionType =
+          JSType.toMaybeFunctionType(functionNode.getJSType());
       if (functionType != null) {
         Node jsDocParameters = functionType.getParametersNode();
         if (jsDocParameters != null) {
@@ -1481,7 +1810,7 @@
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
-                  jsDocParameter.getJSType(), true);
+                  jsDocParameter.getJSType(), false);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
@@ -1491,4 +1820,66 @@
       }
     } // end declareArguments
   } // end LocalScopeBuilder
+
+  /**
+   * Does a first-order function analysis that just looks at simple things
+   * like what variables are escaped, and whether 'this' is used.
+   */
+  private static class FirstOrderFunctionAnalyzer
+      extends AbstractScopedCallback implements CompilerPass {
+    private final AbstractCompiler compiler;
+    private final Map<Node, AstFunctionContents> data;
+
+    FirstOrderFunctionAnalyzer(
+        AbstractCompiler compiler, Map<Node, AstFunctionContents> outParam) {
+      this.compiler = compiler;
+      this.data = outParam;
+    }
+
+    @Override public void process(Node externs, Node root) {
+      if (externs == null) {
+        NodeTraversal.traverse(compiler, root, this);
+      } else {
+        NodeTraversal.traverseRoots(
+            compiler, ImmutableList.of(externs, root), this);
+      }
+    }
+
+    @Override public void enterScope(NodeTraversal t) {
+      if (!t.inGlobalScope()) {
+        Node n = t.getScopeRoot();
+        data.put(n, new AstFunctionContents(n));
+      }
+    }
+
+    @Override public void visit(NodeTraversal t, Node n, Node parent) {
+      if (t.inGlobalScope()) {
+        return;
+      }
+
+      if (n.isReturn() && n.getFirstChild() != null) {
+        data.get(t.getScopeRoot()).recordNonEmptyReturn();
+      } else if (n.isName() && NodeUtil.isLValue(n)) {
+        String name = n.getString();
+        Scope scope = t.getScope();
+        Var var = scope.getVar(name);
+        if (var != null) {
+          Scope ownerScope = var.getScope();
+          if (scope != ownerScope && ownerScope.isLocal()) {
+            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);
+          }
+        }
+      }
+    }
+  }
+
+  private AstFunctionContents getFunctionAnalysisResults(@Nullable Node n) {
+    if (n == null) {
+      return null;
+    }
+
+    // Sometimes this will return null in things like
+    // NameReferenceGraphConstruction that build partial scopes.
+    return functionAnalysisResults.get(n);
+  }
 }
diff -r -u original/test/com/google/javascript/jscomp/TypeCheckTest.java buggy/test/com/google/javascript/jscomp/TypeCheckTest.java
--- original/test/com/google/javascript/jscomp/TypeCheckTest.java	2023-06-13 15:31:40.139085026 +0800
+++ buggy/test/com/google/javascript/jscomp/TypeCheckTest.java	2023-06-12 11:40:20.870974375 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006 Google Inc.
+ * Copyright 2006 The Closure Compiler Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,8 +18,8 @@
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
 import com.google.javascript.jscomp.Scope.Var;
+import com.google.javascript.rhino.InputId;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.jstype.FunctionType;
@@ -28,6 +28,7 @@
 import com.google.javascript.rhino.jstype.ObjectType;
 
 import java.util.Arrays;
+import java.util.List;
 
 /**
  * Tests {@link TypeCheck}.
@@ -37,6 +38,7 @@
 
   private CheckLevel reportMissingOverrides = CheckLevel.WARNING;
 
+  @Override
   public void setUp() throws Exception {
     super.setUp();
     reportMissingOverrides = CheckLevel.WARNING;
@@ -44,7 +46,7 @@
 
   public void testInitialTypingScope() {
     Scope s = new TypedScopeCreator(compiler,
-        new DefaultCodingConvention()).createInitialScope(
+        CodingConventions.getDefault()).createInitialScope(
             new Node(Token.BLOCK));
 
     assertEquals(ARRAY_FUNCTION_TYPE, s.getVar("Array").getType());
@@ -77,7 +79,7 @@
   }
 
   public void testTypeCheck2() throws Exception {
-    testTypes("/**@return {void}*/function foo(){ foo()--; }",
+    testTypes("/**@return {void}*/function foo(){ var x=foo(); x--; }",
         "increment/decrement\n" +
         "found   : undefined\n" +
         "required: number");
@@ -100,11 +102,6 @@
         "/** @type {undefined|number} */var a;if (a == foo())return;}");
   }
 
-  public void testTypeCheck7() throws Exception {
-    testTypes("function foo() {delete 'abc';}",
-        TypeCheck.BAD_DELETE);
-  }
-
   public void testTypeCheck8() throws Exception {
     testTypes("/**@return {void}*/function foo(){do {} while (foo());}");
   }
@@ -321,6 +318,16 @@
         "required: E.<string>");
   }
 
+  public void testParameterizedObject5() throws Exception {
+    testTypes("/** @constructor */ function F() {" +
+        "  /** @type {Object.<number, string>} */ this.numbers = {};" +
+        "}" +
+        "(new F()).numbers['ten'] = '10';",
+        "restricted index type\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
   public void testUnionOfFunctionAndType() throws Exception {
     testTypes("/** @type {null|(function(Number):void)} */ var a;" +
         "/** @type {(function(Number):void)|null} */ var b = null; a = b;");
@@ -371,8 +378,8 @@
   }
 
   public void testOptionalArgFunctionParamError() throws Exception {
-    String expectedWarning = "Parse error. variable length argument must be " +
-        "last";
+    String expectedWarning =
+        "Bad type annotation. variable length argument must be last";
     testTypes("/** @param {function(...[number], number=)} a */" +
               "function f(a) {};", expectedWarning, false);
   }
@@ -611,7 +618,7 @@
     // Don't do type inference on GETELEMs.
     testClosureTypes(
         CLOSURE_DEFS +
-        "function f(arguments) { " +
+        "function f(x) { " +
         "  return goog.isString(arguments[0]) ? arguments[0] : 0;" +
         "}", null);
   }
@@ -620,7 +627,7 @@
     // Don't do type inference on GETELEMs.
     testClosureTypes(
         CLOSURE_DEFS +
-        "function f(arguments) { " +
+        "function f(x) { " +
         "  return typeof arguments[0] == 'string' ? arguments[0] : 0;" +
         "}", null);
   }
@@ -654,6 +661,169 @@
         "return goog.isString(this.a) ? this.a : 'a'; }", null);
   }
 
+  public void testQualifiedNameReduction5a() throws Exception {
+    testTypes("var x = {/** @type {string} */ a:'b' };\n" +
+        "/** @return {string} */ var f = function() {\n" +
+        "return x.a; }");
+  }
+
+  public void testQualifiedNameReduction5b() throws Exception {
+    testTypes(
+        "var x = {/** @type {number} */ a:12 };\n" +
+        "/** @return {string} */\n" +
+        "var f = function() {\n" +
+        "  return x.a;\n" +
+        "}",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testQualifiedNameReduction5c() throws Exception {
+    testTypes(
+        "/** @return {string} */ var f = function() {\n" +
+        "var x = {/** @type {number} */ a:0 };\n" +
+        "return (x.a) ? (x.a) : 'a'; }",
+        "inconsistent return type\n" +
+        "found   : (number|string)\n" +
+        "required: string");
+  }
+
+  public void testQualifiedNameReduction6() throws Exception {
+    testTypes(
+        "/** @return {string} */ var f = function() {\n" +
+        "var x = {/** @return {string?} */ get a() {return 'a'}};\n" +
+        "return x.a ? x.a : 'a'; }");
+  }
+
+  public void testQualifiedNameReduction7() throws Exception {
+    testTypes(
+        "/** @return {string} */ var f = function() {\n" +
+        "var x = {/** @return {number} */ get a() {return 12}};\n" +
+        "return x.a; }",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testQualifiedNameReduction7a() throws Exception {
+    // It would be nice to find a way to make this an error.
+    testTypes(
+        "/** @return {string} */ var f = function() {\n" +
+        "var x = {get a() {return 12}};\n" +
+        "return x.a; }");
+  }
+
+  public void testQualifiedNameReduction8() throws Exception {
+    testTypes(
+        "/** @return {string} */ var f = function() {\n" +
+        "var x = {get a() {return 'a'}};\n" +
+        "return x.a ? x.a : 'a'; }");
+  }
+
+  public void testQualifiedNameReduction9() throws Exception {
+    testTypes(
+        "/** @return {string} */ var f = function() {\n" +
+        "var x = { /** @param {string} b */ set a(b) {}};\n" +
+        "return x.a ? x.a : 'a'; }");
+  }
+
+  public void testQualifiedNameReduction10() throws Exception {
+    // TODO(johnlenz): separate setter property types from getter property
+    // types.
+    testTypes(
+        "/** @return {string} */ var f = function() {\n" +
+        "var x = { /** @param {number} b */ set a(b) {}};\n" +
+        "return x.a ? x.a : 'a'; }",
+        "inconsistent return type\n" +
+        "found   : (number|string)\n" +
+        "required: string");
+  }
+
+  public void testObjLitDef1a() throws Exception {
+    testTypes(
+        "var x = {/** @type {number} */ a:12 };\n" +
+        "x.a = 'a';",
+        "assignment to property a of x\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testObjLitDef1b() throws Exception {
+    testTypes(
+        "function f(){" +
+          "var x = {/** @type {number} */ a:12 };\n" +
+          "x.a = 'a';" +
+        "};\n" +
+        "f();",
+        "assignment to property a of x\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testObjLitDef2a() throws Exception {
+    testTypes(
+        "var x = {/** @param {number} b */ set a(b){} };\n" +
+        "x.a = 'a';",
+        "assignment to property a of x\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testObjLitDef2b() throws Exception {
+    testTypes(
+        "function f(){" +
+          "var x = {/** @param {number} b */ set a(b){} };\n" +
+          "x.a = 'a';" +
+        "};\n" +
+        "f();",
+        "assignment to property a of x\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testObjLitDef3a() throws Exception {
+    testTypes(
+        "/** @type {string} */ var y;\n" +
+        "var x = {/** @return {number} */ get a(){} };\n" +
+        "y = x.a;",
+        "assignment\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testObjLitDef3b() throws Exception {
+    testTypes(
+      "/** @type {string} */ var y;\n" +
+        "function f(){" +
+          "var x = {/** @return {number} */ get a(){} };\n" +
+          "y = x.a;" +
+        "};\n" +
+        "f();",
+        "assignment\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testObjLitDef4() throws Exception {
+    testTypes(
+        "var x = {" +
+          "/** @return {number} */ a:12 };\n",
+          "assignment to property a of {a: function (): number}\n" +
+          "found   : number\n" +
+          "required: function (): number");
+  }
+
+  public void testObjLitDef5() throws Exception {
+    testTypes(
+        "var x = {};\n" +
+        "/** @return {number} */ x.a = 12;\n",
+        "assignment to property a of x\n" +
+        "found   : number\n" +
+        "required: function (): number");
+  }
+
+
   public void testInstanceOfReduction1() throws Exception {
     testTypes("/** @constructor */ var T = function() {};\n" +
         "/** @param {T|string} x\n@return {T} */\n" +
@@ -670,6 +840,37 @@
         "};");
   }
 
+  public void testUndeclaredGlobalProperty1() throws Exception {
+    testTypes("/** @const */ var x = {}; x.y = null;" +
+        "function f(a) { x.y = a; }" +
+        "/** @param {string} a */ function g(a) { }" +
+        "function h() { g(x.y); }");
+  }
+
+  public void testUndeclaredGlobalProperty2() throws Exception {
+    testTypes("/** @const */ var x = {}; x.y = null;" +
+        "function f() { x.y = 3; }" +
+        "/** @param {string} a */ function g(a) { }" +
+        "function h() { g(x.y); }",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : (null|number)\n" +
+        "required: string");
+  }
+
+  public void testLocallyInferredGlobalProperty1() throws Exception {
+    // We used to have a bug where x.y.z leaked from f into h.
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** @type {number} */ F.prototype.z;" +
+        "/** @const */ var x = {}; /** @type {F} */ x.y;" +
+        "function f() { x.y.z = 'abc'; }" +
+        "/** @param {number} x */ function g(x) {}" +
+        "function h() { g(x.y.z); }",
+        "assignment to property z of F\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
   public void testPropertyInferredPropagation() throws Exception {
     testTypes("/** @return {Object} */function f() { return {}; }\n" +
          "function g() { var x = f(); if (x.p) x.a = 'a'; else x.a = 'b'; }\n" +
@@ -1051,7 +1252,7 @@
   }
 
   public void testNumericComparison6() throws Exception {
-    testTypes("/**@return void*/ function foo() { if (3 >= foo()) return; }",
+    testTypes("/**@return {void} */ function foo() { if (3 >= foo()) return; }",
         "right side of numeric comparison\n" +
         "found   : undefined\n" +
         "required: number");
@@ -1080,7 +1281,8 @@
   }
 
   public void testStringComparison6() throws Exception {
-    testTypes("/**@return void*/ function foo() { if ('a' >= foo()) return; }",
+    testTypes("/**@return {void} */ " +
+        "function foo() { if ('a' >= foo()) return; }",
         "right side of comparison\n" +
         "found   : undefined\n" +
         "required: string");
@@ -1246,36 +1448,51 @@
     // named function expressions create a binding in their body only
     // the return is wrong but the assignment is ok since the type of b is ?
     testTypes(
-        "/** @return number */var a = function b(){ return b };",
+        "/** @return {number} */var a = function b(){ return b };",
         "inconsistent return type\n" +
         "found   : function (): number\n" +
         "required: number");
   }
 
+  public void testScoping12() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** @type {number} */ F.prototype.bar = 3;" +
+        "/** @param {!F} f */ function g(f) {" +
+        "  /** @return {string} */" +
+        "  function h() {" +
+        "    return f.bar;" +
+        "  }" +
+        "}",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testFunctionArguments1() throws Exception {
     testFunctionType(
-        "/** @param {number} a\n@return string */" +
+        "/** @param {number} a\n@return {string} */" +
         "function f(a) {}",
         "function (number): string");
   }
 
   public void testFunctionArguments2() throws Exception {
     testFunctionType(
-        "/** @param {number} opt_a\n@return string */" +
+        "/** @param {number} opt_a\n@return {string} */" +
         "function f(opt_a) {}",
         "function ((number|undefined)): string");
   }
 
   public void testFunctionArguments3() throws Exception {
     testFunctionType(
-        "/** @param {number} b\n@return string */" +
+        "/** @param {number} b\n@return {string} */" +
         "function f(a,b) {}",
         "function (?, number): string");
   }
 
   public void testFunctionArguments4() throws Exception {
     testFunctionType(
-        "/** @param {number} opt_a\n@return string */" +
+        "/** @param {number} opt_a\n@return {string} */" +
         "function f(a,opt_a) {}",
         "function (?, (number|undefined)): string");
   }
@@ -1294,7 +1511,7 @@
 
   public void testFunctionArguments7() throws Exception {
     testTypes(
-        "/** @param {number} opt_a\n@return string */" +
+        "/** @param {number} opt_a\n@return {string} */" +
         "function a(a,opt_a,var_args) {}");
   }
 
@@ -1330,13 +1547,13 @@
   }
 
   public void testFunctionArguments13() throws Exception {
-    // verifying that the argument type have inferable types
+    // verifying that the argument type have non-inferrable types
     testTypes(
         "/** @return {boolean} */ function u() { return true; }" +
-        "/** @param {boolean} b\n@return boolean */" +
+        "/** @param {boolean} b\n@return {?boolean} */" +
         "function f(b) { if (u()) { b = null; } return b; }",
-        "inconsistent return type\n" +
-        "found   : (boolean|null)\n" +
+        "assignment\n" +
+        "found   : null\n" +
         "required: boolean");
   }
 
@@ -1414,13 +1631,13 @@
 
   public void testFunctionInference5() throws Exception {
     testFunctionType(
-        "/** @this Date\n@return string */function f(a) {}",
+        "/** @this Date\n@return {string} */function f(a) {}",
         "function (this:Date, ?): string");
   }
 
   public void testFunctionInference6() throws Exception {
     testFunctionType(
-        "/** @this Date\n@return string */function f(opt_a) {}",
+        "/** @this Date\n@return {string} */function f(opt_a) {}",
         "function (this:Date, ?): string");
   }
 
@@ -1444,7 +1661,7 @@
 
   public void testFunctionInference10() throws Exception {
     testFunctionType(
-        "/** @this Date\n@param {boolean} b\n@return string */" +
+        "/** @this Date\n@param {boolean} b\n@return {string} */" +
         "var f = function(a,b) {};",
         "function (this:Date, ?, boolean): string");
   }
@@ -1452,7 +1669,7 @@
   public void testFunctionInference11() throws Exception {
     testFunctionType(
         "var goog = {};" +
-        "/** @return number*/goog.f = function(){};",
+        "/** @return {number}*/goog.f = function(){};",
         "goog.f",
         "function (): number");
   }
@@ -1647,6 +1864,43 @@
         "}");
   }
 
+  public void testInnerFunction10() throws Exception {
+    testTypes(
+        "function f() {" +
+        "  /** @type {?number} */ var x = null;" +
+        "  /** @return {string} */" +
+        "  function g() {" +
+        "    if (!x) {" +
+        "      x = 1;" +
+        "    }" +
+        "    return x;" +
+        "  }" +
+        "}",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testInnerFunction11() throws Exception {
+    // TODO(nicksantos): This is actually bad inference, because
+    // h sets x to null. We should fix this, but for now we do it
+    // this way so that we don't break existing binaries. We will
+    // need to change TypeInference#isUnflowable to fix this.
+    testTypes(
+        "function f() {" +
+        "  /** @type {?number} */ var x = null;" +
+        "  /** @return {number} */" +
+        "  function g() {" +
+        "    x = 1;" +
+        "    h();" +
+        "    return x;" +
+        "  }" +
+        "  function h() {" +
+        "    x = null;" +
+        "  }" +
+        "}");
+  }
+
   public void testAbstractMethodHandling1() throws Exception {
     testTypes(
         "/** @type {Function} */ var abstractFn = function() {};" +
@@ -1681,7 +1935,7 @@
 
   public void testAbstractMethodHandling5() throws Exception {
     testTypes(
-        "/** @type {Function} */ var abstractFn = function() {};" +
+        "/** @type {!Function} */ var abstractFn = function() {};" +
         "/** @param {number} x */ var f = abstractFn;" +
         "f('x');",
         "actual parameter 1 of f does not match formal parameter\n" +
@@ -1851,7 +2105,8 @@
         "/** @param {number} x */ goog.foo = function(x) {};" +
         "/** @param {number} x */ goog.foo = function(x) {};",
         "variable goog.foo redefined with type function (number): undefined, " +
-        "original definition at [testcode]:1 with type function (number): undefined");
+        "original definition at [testcode]:1 " +
+        "with type function (number): undefined");
   }
 
   public void testDuplicateStaticMethodDecl2() throws Exception {
@@ -1962,12 +2217,63 @@
         "/** @constructor */ function EventCopy() {}");
   }
 
-  public void testDuplicateLocalVarDecl() throws Exception {
+  public void testDuplicateStaticPropertyDec20() throws Exception {
     testTypes(
+        "/**\n" +
+        " * @fileoverview\n" +
+        " * @suppress {duplicate}\n" +
+        " */" +
+        "var goog = goog || {};" +
+        "/** @type {string} */ goog.foo = 'y';" +
+        "/** @type {string} */ goog.foo = 'x';");
+  }
+
+  public void testDuplicateLocalVarDecl() throws Exception {
+    testClosureTypesMultipleWarnings(
         "/** @param {number} x */\n" +
         "function f(x) { /** @type {string} */ var x = ''; }",
-        "variable x redefined with type string, " +
-        "original definition at [testcode]:2 with type number");
+        Lists.newArrayList(
+            "variable x redefined with type string, original definition" +
+            " at  [testcode] :2 with type number",
+            "initializing variable\n" +
+            "found   : string\n" +
+            "required: number"));
+  }
+
+  public void testDuplicateInstanceMethod1() throws Exception {
+    // If there's no jsdoc on the methods, then we treat them like
+    // any other inferred properties.
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "F.prototype.bar = function() {};" +
+        "F.prototype.bar = function() {};");
+  }
+
+  public void testDuplicateInstanceMethod2() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** jsdoc */ F.prototype.bar = function() {};" +
+        "/** jsdoc */ F.prototype.bar = function() {};",
+        "variable F.prototype.bar redefined with type " +
+        "function (this:F): undefined, original definition at " +
+        "[testcode]:1 with type function (this:F): undefined");
+  }
+
+  public void testDuplicateInstanceMethod3() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "F.prototype.bar = function() {};" +
+        "/** jsdoc */ F.prototype.bar = function() {};",
+        "variable F.prototype.bar redefined with type " +
+        "function (this:F): undefined, original definition at " +
+        "[testcode]:1 with type function (this:F): undefined");
+  }
+
+  public void testDuplicateInstanceMethod4() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** jsdoc */ F.prototype.bar = function() {};" +
+        "F.prototype.bar = function() {};");
   }
 
   public void testStubFunctionDeclaration1() throws Exception {
@@ -1980,11 +2286,12 @@
   }
 
   public void testStubFunctionDeclaration2() throws Exception {
-    testFunctionType(
+    testExternFunctionType(
+        // externs
         "/** @constructor */ function f() {};" +
         "/** @constructor \n * @extends {f} */ f.subclass;",
         "f.subclass",
-        "function (this:f.subclass): ?");
+        "function (new:f.subclass): ?");
   }
 
   public void testStubFunctionDeclaration3() throws Exception {
@@ -2030,13 +2337,10 @@
   }
 
   public void testStubFunctionDeclaration8() throws Exception {
-    /** TODO(user): This is not exactly correct yet. The var
-            itself is nullable. */
     testFunctionType(
         "/** @type {Function} */ var f = function() {}; ",
         "f",
-        createNullableType(U2U_CONSTRUCTOR_TYPE).
-          restrictByNotNullOrUndefined().toString());
+        createNullableType(U2U_CONSTRUCTOR_TYPE).toString());
   }
 
   public void testStubFunctionDeclaration9() throws Exception {
@@ -2085,10 +2389,25 @@
         "required: number");
   }
 
+  /**
+   * Tests the type of a function definition in externs.
+   * The function defined by {@code functionDef} should be
+   * named {@code functionName}.
+   */
+  private void testExternFunctionType(String functionDef, String functionName,
+      String functionType) throws Exception {
+    testTypes(
+        functionDef,
+        "/** @type number */var a=" + functionName + ";",
+        "initializing variable\n" +
+        "found   : " + functionType + "\n" +
+        "required: number", false);
+  }
+
   public void testTypeRedefinition() throws Exception {
     testTypes("a={};/**@enum {string}*/ a.A = {ZOR:'b'};"
         + "/** @constructor */ a.A = function() {}",
-        "variable a.A redefined with type function (this:a.A): undefined, " +
+        "variable a.A redefined with type function (new:a.A): undefined, " +
         "original definition at [testcode]:1 with type enum{a.A}");
   }
 
@@ -2107,7 +2426,7 @@
   public void testIn4() throws Exception {
     testTypes("Date in Object",
         "left side of 'in'\n" +
-        "found   : function (this:Date, ?, ?, ?, ?, ?, ?, ?): string\n" +
+        "found   : function (new:Date, ?, ?, ?, ?, ?, ?, ?): string\n" +
         "required: string");
   }
 
@@ -2146,6 +2465,69 @@
         "required: number");
   }
 
+  public void testForIn1() throws Exception {
+    testTypes(
+        "/** @param {boolean} x */ function f(x) {}" +
+        "for (var k in {}) {" +
+        "  f(k);" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : string\n" +
+        "required: boolean");
+  }
+
+  public void testForIn2() throws Exception {
+    testTypes(
+        "/** @param {boolean} x */ function f(x) {}" +
+        "/** @enum {string} */ var E = {FOO: 'bar'};" +
+        "/** @type {Object.<E, string>} */ var obj = {};" +
+        "var k = null;" +
+        "for (k in obj) {" +
+        "  f(k);" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : E.<string>\n" +
+        "required: boolean");
+  }
+
+  public void testForIn3() throws Exception {
+    testTypes(
+        "/** @param {boolean} x */ function f(x) {}" +
+        "/** @type {Object.<number>} */ var obj = {};" +
+        "for (var k in obj) {" +
+        "  f(obj[k]);" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: boolean");
+  }
+
+  public void testForIn4() throws Exception {
+    testTypes(
+        "/** @param {boolean} x */ function f(x) {}" +
+        "/** @enum {string} */ var E = {FOO: 'bar'};" +
+        "/** @type {Object.<E, Array>} */ var obj = {};" +
+        "for (var k in obj) {" +
+        "  f(obj[k]);" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : (Array|null)\n" +
+        "required: boolean");
+  }
+
+  public void testForIn5() throws Exception {
+    testTypes(
+        "/** @param {boolean} x */ function f(x) {}" +
+        "/** @constructor */ var E = function(){};" +
+        "/** @type {Object.<E, number>} */ var obj = {};" +
+        "for (var k in obj) {" +
+        "  f(k);" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : string\n" +
+        "required: boolean");
+  }
+
   // TODO(nicksantos): change this to something that makes sense.
 //   public void testComparison1() throws Exception {
 //     testTypes("/**@type null */var a;" +
@@ -2246,6 +2628,29 @@
         "right: boolean");
   }
 
+  public void testDeleteOperator1() throws Exception {
+    testTypes(
+        "var x = {};" +
+        "/** @return {string} */ function f() { return delete x['a']; }",
+        "inconsistent return type\n" +
+        "found   : boolean\n" +
+        "required: string");
+  }
+
+  public void testDeleteOperator2() throws Exception {
+    testTypes(
+        "var obj = {};" +
+        "/** \n" +
+        " * @param {string} x\n" +
+        " * @return {Object} */ function f(x) { return obj; }" +
+        "/** @param {?number} x */ function g(x) {" +
+        "  if (x) { delete f(x)['a']; }" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testEnumStaticMethod1() throws Exception {
     testTypes(
         "/** @enum */ var Foo = {AAA: 1};" +
@@ -2278,19 +2683,20 @@
 
   public void testEnum3() throws Exception {
     testTypes("/**@enum*/var a={BB:1,BB:2}",
-        "enum element BB already defined", true);
+        "variable a.BB redefined with type a.<number>, " +
+        "original definition at [testcode]:1 with type a.<number>");
   }
 
   public void testEnum4() throws Exception {
     testTypes("/**@enum*/var a={BB:'string'}",
-        "element type must match enum's type\n" +
+        "assignment to property BB of enum{a}\n" +
         "found   : string\n" +
         "required: number");
   }
 
   public void testEnum5() throws Exception {
     testTypes("/**@enum {String}*/var a={BB:'string'}",
-        "element type must match enum's type\n" +
+        "assignment to property BB of enum{a}\n" +
         "found   : string\n" +
         "required: (String|null)");
   }
@@ -2309,15 +2715,23 @@
   }
 
   public void testEnum8() throws Exception {
-    testTypes("/** @enum */var a=8;",
-        "enum initializer must be an object literal or an enum");
+    testClosureTypesMultipleWarnings("/** @enum */var a=8;",
+        Lists.newArrayList(
+            "enum initializer must be an object literal or an enum",
+            "initializing variable\n" +
+            "found   : number\n" +
+            "required: enum{a}"));
   }
 
   public void testEnum9() throws Exception {
-    testTypes(
+    testClosureTypesMultipleWarnings(
         "var goog = {};" +
         "/** @enum */goog.a=8;",
-        "enum initializer must be an object literal or an enum");
+        Lists.newArrayList(
+            "assignment to property a of goog\n" +
+            "found   : number\n" +
+            "required: enum{goog.a}",
+            "enum initializer must be an object literal or an enum"));
   }
 
   public void testEnum10() throws Exception {
@@ -2364,14 +2778,15 @@
 
   public void testEnum16() throws Exception {
     testTypes("var goog = {};" +
-        "/**@enum*/goog.a={BB:1,BB:2}",
-        "enum element BB already defined", true);
+        "/**@enum*/goog .a={BB:1,BB:2}",
+        "variable goog.a.BB redefined with type goog.a.<number>, " +
+        "original definition at [testcode]:1 with type goog.a.<number>");
   }
 
   public void testEnum17() throws Exception {
     testTypes("var goog = {};" +
         "/**@enum*/goog.a={BB:'string'}",
-        "element type must match enum's type\n" +
+        "assignment to property BB of enum{goog.a}\n" +
         "found   : string\n" +
         "required: number");
   }
@@ -2527,6 +2942,23 @@
         "required: number");
   }
 
+  public void testEnum41() throws Exception {
+    testTypes(
+        "/** @enum {number} */ var MyEnum = {/** @const */ FOO: 1};" +
+        "/** @return {string} */" +
+        "function f() { return MyEnum.FOO; }",
+        "inconsistent return type\n" +
+        "found   : MyEnum.<number>\n" +
+        "required: string");
+  }
+
+  public void testEnum42() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @enum {Object} */ var MyEnum = {FOO: {newProperty: 1, b: 2}};" +
+        "f(MyEnum.FOO.newProperty);");
+  }
+
   public void testAliasedEnum1() throws Exception {
     testTypes(
         "/** @enum */ var YourEnum = {FOO: 3};" +
@@ -2605,6 +3037,87 @@
         "element BAR does not exist on this enum");
   }
 
+  public void testBackwardsTypedefUse1() throws Exception {
+    testTypes(
+        "/** @this {MyTypedef} */ function f() {}" +
+        "/** @typedef {string} */ var MyTypedef;",
+        "@this type of a function must be an object\n" +
+        "Actual type: string");
+  }
+
+  public void testBackwardsTypedefUse2() throws Exception {
+    testTypes(
+        "/** @this {MyTypedef} */ function f() {}" +
+        "/** @typedef {!(Date|Array)} */ var MyTypedef;");
+  }
+
+  public void testBackwardsTypedefUse3() throws Exception {
+    testTypes(
+        "/** @this {MyTypedef} */ function f() {}" +
+        "/** @typedef {(Date|string)} */ var MyTypedef;",
+        "@this type of a function must be an object\n" +
+        "Actual type: (Date|null|string)");
+  }
+
+  public void testBackwardsTypedefUse4() throws Exception {
+    testTypes(
+        "/** @return {MyTypedef} */ function f() { return null; }" +
+        "/** @typedef {string} */ var MyTypedef;",
+        "inconsistent return type\n" +
+        "found   : null\n" +
+        "required: string");
+  }
+
+  public void testBackwardsTypedefUse6() throws Exception {
+    testTypes(
+        "/** @return {goog.MyTypedef} */ function f() { return null; }" +
+        "var goog = {};" +
+        "/** @typedef {string} */ goog.MyTypedef;",
+        "inconsistent return type\n" +
+        "found   : null\n" +
+        "required: string");
+  }
+
+  public void testBackwardsTypedefUse7() throws Exception {
+    testTypes(
+        "/** @return {goog.MyTypedef} */ function f() { return null; }" +
+        "var goog = {};" +
+        "/** @typedef {Object} */ goog.MyTypedef;");
+  }
+
+  public void testBackwardsTypedefUse8() throws Exception {
+    // Tehnically, this isn't quite right, because the JS runtime
+    // will coerce null -> the global object. But we'll punt on that for now.
+    testTypes(
+        "/** @param {!Array} x */ function g(x) {}" +
+        "/** @this {goog.MyTypedef} */ function f() { g(this); }" +
+        "var goog = {};" +
+        "/** @typedef {(Array|null|undefined)} */ goog.MyTypedef;");
+  }
+
+  public void testBackwardsTypedefUse9() throws Exception {
+    testTypes(
+        "/** @param {!Array} x */ function g(x) {}" +
+        "/** @this {goog.MyTypedef} */ function f() { g(this); }" +
+        "var goog = {};" +
+        "/** @typedef {(Error|null|undefined)} */ goog.MyTypedef;",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : Error\n" +
+        "required: Array");
+  }
+
+  public void testBackwardsTypedefUse10() throws Exception {
+    testTypes(
+        "/** @param {goog.MyEnum} x */ function g(x) {}" +
+        "var goog = {};" +
+        "/** @enum {goog.MyTypedef} */ goog.MyEnum = {FOO: 1};" +
+        "/** @typedef {number} */ goog.MyTypedef;" +
+        "g(1);",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: goog.MyEnum.<number>");
+  }
+
   public void testBackwardsConstructor1() throws Exception {
     testTypes(
         "function f() { (new Foo(true)); }" +
@@ -2692,7 +3205,7 @@
         "/** @extends {base}\n * @constructor */function derived() {}\n" +
         "derived.inherits(base);",
         "(new derived).constructor",
-        "function (this:derived): undefined");
+        "function (new:derived): undefined");
   }
 
   public void testGoodExtends8() throws Exception {
@@ -2735,10 +3248,70 @@
         "required: boolean");
   }
 
+  public void testGoodExtends12() throws Exception {
+    testTypes(
+        "/** @constructor \n * @extends {Super} */ function Sub() {}" +
+        "/** @constructor \n * @extends {Sub} */ function Sub2() {}" +
+        "/** @constructor */ function Super() {}" +
+        "/** @param {Super} x */ function foo(x) {}" +
+        "foo(new Sub2());");
+  }
+
+  public void testGoodExtends13() throws Exception {
+    testTypes(
+        "/** @constructor \n * @extends {B}  */ function C() {}" +
+        "/** @constructor \n * @extends {D}  */ function E() {}" +
+        "/** @constructor \n * @extends {C}  */ function D() {}" +
+        "/** @constructor \n * @extends {A} */ function B() {}" +
+        "/** @constructor */ function A() {}" +
+        "/** @param {number} x */ function f(x) {} f(new E());",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : E\n" +
+        "required: number");
+  }
+
+  public void testGoodExtends14() throws Exception {
+    testTypes(
+        CLOSURE_DEFS +
+        "/** @param {Function} f */ function g(f) {" +
+        "  /** @constructor */ function NewType() {};" +
+        "  goog.inherits(NewType, f);" +
+        "  (new NewType());" +
+        "}");
+  }
+
+  public void testGoodExtends15() throws Exception {
+    testTypes(
+        CLOSURE_DEFS +
+        "/** @constructor */ function OldType() {}" +
+        "/** @param {?function(new:OldType)} f */ function g(f) {" +
+        "  /**\n" +
+        "    * @constructor\n" +
+        "    * @extends {OldType}\n" +
+        "    */\n" +
+        "  function NewType() {};" +
+        "  goog.inherits(NewType, f);" +
+        "  NewType.prototype.method = function() {" +
+        "    NewType.superClass_.foo.call(this);" +
+        "  };" +
+        "}",
+        "Property foo never defined on OldType.prototype");
+  }
+
+  public void testGoodExtends16() throws Exception {
+    testTypes(
+        CLOSURE_DEFS +
+        "/** @param {Function} f */ function g(f) {" +
+        "  /** @constructor */ function NewType() {};" +
+        "  goog.inherits(f, NewType);" +
+        "  (new NewType());" +
+        "}");
+  }
+
   public void testBadExtends1() throws Exception {
     testTypes("/** @constructor */function base() {}\n" +
         "/** @constructor\n * @extends {not_base} */function derived() {}\n",
-        "Parse error. Unknown type not_base");
+        "Bad type annotation. Unknown type not_base");
   }
 
   public void testBadExtends2() throws Exception {
@@ -2762,6 +3335,17 @@
         "@extends used without @constructor or @interface for base");
   }
 
+  public void testBadExtends4() throws Exception {
+    // If there's a subclass of a class with a bad extends,
+    // we only want to warn about the first one.
+    testTypes(
+        "/** @constructor \n * @extends {bad} */ function Sub() {}" +
+        "/** @constructor \n * @extends {Sub} */ function Sub2() {}" +
+        "/** @param {Sub} x */ function foo(x) {}" +
+        "foo(new Sub2());",
+        "Bad type annotation. Unknown type bad");
+  }
+
   public void testLateExtends() throws Exception {
     testTypes(
         CLOSURE_DEFS +
@@ -2850,6 +3434,20 @@
         "/** @return {string} */ function foo() { return (new Base).foo; }");
   }
 
+  public void testDirectPrototypeAssignment3() throws Exception {
+    // This verifies that the compiler doesn't crash if the user
+    // overwrites the prototype of a global variable in a local scope.
+    testTypes(
+        "/** @constructor */ var MainWidgetCreator = function() {};" +
+        "/** @param {Function} ctor */" +
+        "function createMainWidget(ctor) {" +
+        "  /** @constructor */ function tempCtor() {};" +
+        "  tempCtor.prototype = ctor.prototype;" +
+        "  MainWidgetCreator.superClass_ = ctor.prototype;" +
+        "  MainWidgetCreator.prototype = new tempCtor();" +
+        "}");
+  }
+
   public void testGoodImplements1() throws Exception {
     testTypes("/** @interface */function Disposable() {}\n" +
         "/** @implements {Disposable}\n * @constructor */function f() {}");
@@ -2866,7 +3464,20 @@
 
   public void testGoodImplements3() throws Exception {
     testTypes("/** @interface */function Disposable() {}\n" +
-        "/** @implements {Disposable}\n * @interface */function f() {}");
+        "/** @constructor \n @implements {Disposable} */function f() {}");
+  }
+
+  public void testGoodImplements4() throws Exception {
+    testTypes("var goog = {};" +
+        "/** @type {!Function} */" +
+        "goog.abstractMethod = function() {};" +
+        "/** @interface */\n" +
+        "goog.Disposable = goog.abstractMethod;" +
+        "goog.Disposable.prototype.dispose = goog.abstractMethod;" +
+        "/** @implements {goog.Disposable}\n * @constructor */" +
+        "goog.SubDisposable = function() {};" +
+        "/** @inheritDoc */ " +
+        "goog.SubDisposable.prototype.dispose = function() {};");
   }
 
   public void testBadImplements1() throws Exception {
@@ -2876,7 +3487,7 @@
         " * @implements {nonExistent}\n" +
         " * @implements {Base2}\n" +
         " */ function derived() {}",
-        "Parse error. Unknown type nonExistent");
+        "Bad type annotation. Unknown type nonExistent");
   }
 
   public void testBadImplements2() throws Exception {
@@ -2885,6 +3496,23 @@
         "@implements used without @constructor or @interface for f");
   }
 
+  public void testBadImplements3() throws Exception {
+    testTypes(
+        "var goog = {};" +
+        "/** @type {!Function} */ goog.abstractMethod = function(){};" +
+        "/** @interface */ var Disposable = goog.abstractMethod;" +
+        "Disposable.prototype.method = goog.abstractMethod;" +
+        "/** @implements {Disposable}\n * @constructor */function f() {}",
+        "property method on interface Disposable is not implemented by type f");
+  }
+
+  public void testBadImplements4() throws Exception {
+    testTypes("/** @interface */function Disposable() {}\n" +
+        "/** @implements {Disposable}\n * @interface */function f() {}",
+        "f cannot implement this type; an interface can only extend, " +
+        "but not implement interfaces");
+  }
+
   public void testInterfaceExtends() throws Exception {
     testTypes("/** @interface */function A() {}\n" +
         "/** @interface \n * @extends {A} */function B() {}\n" +
@@ -2895,7 +3523,7 @@
 
   public void testBadInterfaceExtends1() throws Exception {
     testTypes("/** @interface \n * @extends {nonExistent} */function A() {}",
-        "Parse error. Unknown type nonExistent");
+        "Bad type annotation. Unknown type nonExistent");
   }
 
   public void testBadInterfaceExtends2() throws Exception {
@@ -3012,7 +3640,8 @@
   public void testInterfaceAssignment8() throws Exception {
     testTypes("/** @interface */var I = function() {};\n" +
         "/** @type {I} */var i;\n" +
-        "/** @type {Object} */var o = i;");
+        "/** @type {Object} */var o = i;\n" +
+        "new Object().prototype = i.prototype;");
   }
 
   public void testInterfaceAssignment9() throws Exception {
@@ -3066,11 +3695,28 @@
 
   public void testGetprop1() throws Exception {
     testTypes("/** @return {void}*/function foo(){foo().bar;}",
-        "undefined has no properties\n" +
+        "No properties on this expression\n" +
         "found   : undefined\n" +
         "required: Object");
   }
 
+  public void testGetprop2() throws Exception {
+    testTypes("var x = null; x.alert();",
+        "No properties on this expression\n" +
+        "found   : null\n" +
+        "required: Object");
+  }
+
+  public void testGetprop3() throws Exception {
+    testTypes(
+        "/** @constructor */ " +
+        "function Foo() { /** @type {?Object} */ this.x = null; }" +
+        "Foo.prototype.initX = function() { this.x = {foo: 1}; };" +
+        "Foo.prototype.bar = function() {" +
+        "  if (this.x == null) { this.initX(); alert(this.x.foo); }" +
+        "};");
+  }
+
   public void testArrayAccess1() throws Exception {
     testTypes("var a = []; var b = a['hi'];");
   }
@@ -3121,6 +3767,14 @@
         "required: Object");
   }
 
+  public void testArrayAccess9() throws Exception {
+    testTypes("/** @return {?Array} */ function f() { return []; }" +
+        "f()[{}]",
+        "array access\n" +
+        "found   : {}\n" +
+        "required: number");
+  }
+
   public void testPropAccess() throws Exception {
     testTypes("/** @param {*} x */var f = function(x) {\n" +
         "var o = String(x);\n" +
@@ -3131,7 +3785,7 @@
 
   public void testPropAccess2() throws Exception {
     testTypes("var bar = void 0; bar.baz;",
-        "undefined has no properties\n" +
+        "No properties on this expression\n" +
         "found   : undefined\n" +
         "required: Object");
   }
@@ -3140,7 +3794,7 @@
     // Verifies that we don't emit two warnings, because
     // the var has been dereferenced after the first one.
     testTypes("var bar = void 0; bar.baz; bar.bax;",
-        "undefined has no properties\n" +
+        "No properties on this expression\n" +
         "found   : undefined\n" +
         "required: Object");
   }
@@ -3508,6 +4162,16 @@
         "cannot instantiate non-constructor");
   }
 
+  public void testHigherOrderFunctions5() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function g(x) {}" +
+        "/** @type {function(new:Error,...[number]):Date} */ var f;" +
+        "g(new f());",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : Error\n" +
+        "required: number");
+  }
+
   public void testConstructorAlias1() throws Exception {
     testTypes(
         "/** @constructor */ var Foo = function() {};" +
@@ -3587,8 +4251,10 @@
   public void testConstructorAlias8() throws Exception {
     testTypes(
         "var goog = {};" +
-        "/**\n * @param {number} x \n * @constructor */ goog.Foo = function(x) {};" +
-        "/**\n * @param {number} x \n * @constructor */ goog.FooAlias = goog.Foo;" +
+        "/**\n * @param {number} x \n * @constructor */ " +
+        "goog.Foo = function(x) {};" +
+        "/**\n * @param {number} x \n * @constructor */ " +
+        "goog.FooAlias = goog.Foo;" +
         "/** @return {number} */ function foo() { " +
         "  return new goog.FooAlias(1); }",
         "inconsistent return type\n" +
@@ -3599,7 +4265,8 @@
   public void testConstructorAlias9() throws Exception {
     testTypes(
         "var goog = {};" +
-        "/**\n * @param {number} x \n * @constructor */ goog.Foo = function(x) {};" +
+        "/**\n * @param {number} x \n * @constructor */ " +
+        "goog.Foo = function(x) {};" +
         "/** @constructor */ goog.FooAlias = goog.Foo;" +
         "/** @return {number} */ function foo() { " +
         "  return new goog.FooAlias(1); }",
@@ -3610,7 +4277,8 @@
 
   public void testConstructorAlias10() throws Exception {
     testTypes(
-        "/**\n * @param {number} x \n * @constructor */ var Foo = function(x) {};" +
+        "/**\n * @param {number} x \n * @constructor */ " +
+        "var Foo = function(x) {};" +
         "/** @constructor */ var FooAlias = Foo;" +
         "/** @return {number} */ function foo() { " +
         "  return new FooAlias(1); }",
@@ -3676,8 +4344,6 @@
   public void testClosure7() throws Exception {
     testClosureTypes(
         CLOSURE_DEFS +
-        "goog.asserts = {};" +
-        "/** @return {*} */ goog.asserts.assert = function(x) { return x; };" +
         "/** @type {string|null|undefined} */ var a = foo();" +
         "/** @type {number} */" +
         "var b = goog.asserts.assert(a);",
@@ -3721,7 +4387,7 @@
 
   public void testReturn6() throws Exception {
     testTypes(
-        "/** @param {number} opt_a\n@return string */" +
+        "/** @param {number} opt_a\n@return {string} */" +
         "function a(opt_a) { return opt_a }",
         "inconsistent return type\n" +
         "found   : (number|undefined)\n" +
@@ -3956,7 +4622,8 @@
   public void testThis1() throws Exception {
     testTypes("var goog = {};" +
         "/** @constructor */goog.A = function(){};" +
-        "/** @return number */goog.A.prototype.n = function() { return this };",
+        "/** @return {number} */" +
+        "goog.A.prototype.n = function() { return this };",
         "inconsistent return type\n" +
         "found   : goog.A\n" +
         "required: number");
@@ -3967,7 +4634,7 @@
         "/** @constructor */goog.A = function(){" +
         "  this.foo = null;" +
         "};" +
-        "/** @return number */" +
+        "/** @return {number} */" +
         "goog.A.prototype.n = function() { return this.foo };",
         "inconsistent return type\n" +
         "found   : null\n" +
@@ -3987,7 +4654,7 @@
         "/** @constructor */goog.A = function(){" +
         "  /** @type {string?} */this.foo = null;" +
         "};" +
-        "/** @return number */goog.A.prototype.n = function() {" +
+        "/** @return {number} */goog.A.prototype.n = function() {" +
         "  return this.foo };",
         "inconsistent return type\n" +
         "found   : (null|string)\n" +
@@ -3995,7 +4662,7 @@
   }
 
   public void testThis5() throws Exception {
-    testTypes("/** @this Date\n@return number*/function h() { return this }",
+    testTypes("/** @this Date\n@return {number}*/function h() { return this }",
         "inconsistent return type\n" +
         "found   : Date\n" +
         "required: number");
@@ -4003,7 +4670,7 @@
 
   public void testThis6() throws Exception {
     testTypes("var goog = {};" +
-        "/** @constructor\n@return !Date */" +
+        "/** @constructor\n@return {!Date} */" +
         "goog.A = function(){ return this };",
         "inconsistent return type\n" +
         "found   : goog.A\n" +
@@ -4012,7 +4679,7 @@
 
   public void testThis7() throws Exception {
     testTypes("/** @constructor */function A(){};" +
-        "/** @return number */A.prototype.n = function() { return this };",
+        "/** @return {number} */A.prototype.n = function() { return this };",
         "inconsistent return type\n" +
         "found   : A\n" +
         "required: number");
@@ -4022,7 +4689,7 @@
     testTypes("/** @constructor */function A(){" +
         "  /** @type {string?} */this.foo = null;" +
         "};" +
-        "/** @return number */A.prototype.n = function() {" +
+        "/** @return {number} */A.prototype.n = function() {" +
         "  return this.foo };",
         "inconsistent return type\n" +
         "found   : (null|string)\n" +
@@ -4047,6 +4714,94 @@
         "required: string");
   }
 
+  public void testThis11() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @constructor */ function Ctor() {" +
+        "  /** @this {Date} */" +
+        "  this.method = function() {" +
+        "    f(this);" +
+        "  };" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : Date\n" +
+        "required: number");
+  }
+
+  public void testThis12() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @constructor */ function Ctor() {}" +
+        "Ctor.prototype['method'] = function() {" +
+        "  f(this);" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : Ctor\n" +
+        "required: number");
+  }
+
+  public void testThis13() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @constructor */ function Ctor() {}" +
+        "Ctor.prototype = {" +
+        "  method: function() {" +
+        "    f(this);" +
+        "  }" +
+        "};",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : Ctor\n" +
+        "required: number");
+  }
+
+  public void testThis14() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "f(this.Object);",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : function (new:Object, *): ?\n" +
+        "required: number");
+  }
+
+  public void testThisTypeOfFunction1() throws Exception {
+    testTypes(
+        "/** @type {function(this:Object)} */ function f() {}" +
+        "f();");
+  }
+
+  public void testThisTypeOfFunction2() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** @type {function(this:F)} */ function f() {}" +
+        "f();",
+        "\"function (this:F): ?\" must be called with a \"this\" type");
+  }
+
+  public void testThisTypeOfFunction3() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "F.prototype.bar = function() {};" +
+        "var f = (new F()).bar; f();",
+        "\"function (this:F): undefined\" must be called with a \"this\" type");
+  }
+
+  public void testThisTypeOfFunction4() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "F.prototype.moveTo = function(x, y) {};" +
+        "F.prototype.lineTo = function(x, y) {};" +
+        "function demo() {" +
+        "  var path = new F();" +
+        "  var points = [[1,1], [2,2]];" +
+        "  for (var i = 0; i < points.length; i++) {" +
+        "    (i == 0 ? path.moveTo : path.lineTo)(" +
+        "       points[i][0], points[i][1]);" +
+        "  }" +
+        "}",
+        "\"function (this:F, ?, ?): undefined\" " +
+        "must be called with a \"this\" type");
+  }
+
   public void testGlobalThis1() throws Exception {
     testTypes("/** @constructor */ function Window() {}" +
         "/** @param {string} msg */ " +
@@ -4059,11 +4814,21 @@
   }
 
   public void testGlobalThis2() throws Exception {
+    // this.alert = 3 doesn't count as a declaration, so this isn't a warning.
     testTypes("/** @constructor */ function Bindow() {}" +
         "/** @param {string} msg */ " +
         "Bindow.prototype.alert = function(msg) {};" +
         "this.alert = 3;" +
-        "(new Bindow()).alert(this.alert)",
+        "(new Bindow()).alert(this.alert)");
+  }
+
+
+  public void testGlobalThis2b() throws Exception {
+    testTypes("/** @constructor */ function Bindow() {}" +
+        "/** @param {string} msg */ " +
+        "Bindow.prototype.alert = function(msg) {};" +
+        "/** @return {number} */ this.alert = function() { return 3; };" +
+        "(new Bindow()).alert(this.alert())",
         "actual parameter 1 of Bindow.prototype.alert " +
         "does not match formal parameter\n" +
         "found   : number\n" +
@@ -4075,7 +4840,7 @@
         "/** @param {string} msg */ " +
         "function alert(msg) {};" +
         "this.alert(3);",
-        "actual parameter 1 of this.alert " +
+        "actual parameter 1 of global this.alert " +
         "does not match formal parameter\n" +
         "found   : number\n" +
         "required: string");
@@ -4086,7 +4851,7 @@
         "/** @param {string} msg */ " +
         "var alert = function(msg) {};" +
         "this.alert(3);",
-        "actual parameter 1 of this.alert " +
+        "actual parameter 1 of global this.alert " +
         "does not match formal parameter\n" +
         "found   : number\n" +
         "required: string");
@@ -4099,7 +4864,7 @@
         "  var alert = function(msg) {};" +
         "}" +
         "this.alert(3);",
-        "Property alert never defined on this");
+        "Property alert never defined on global this");
   }
 
   public void testGlobalThis6() throws Exception {
@@ -4111,6 +4876,35 @@
         "this.alert(this.x);");
   }
 
+  public void testGlobalThis7() throws Exception {
+    testTypes(
+        "/** @constructor */ function Window() {}" +
+        "/** @param {Window} msg */ " +
+        "var foo = function(msg) {};" +
+        "foo(this);");
+  }
+
+  public void testGlobalThis8() throws Exception {
+    testTypes(
+        "/** @constructor */ function Window() {}" +
+        "/** @param {number} msg */ " +
+        "var foo = function(msg) {};" +
+        "foo(this);",
+        "actual parameter 1 of foo does not match formal parameter\n" +
+        "found   : global this\n" +
+        "required: number");
+  }
+
+  public void testGlobalThis9() throws Exception {
+    testTypes(
+        // Window is not marked as a constructor, so the
+        // inheritance doesn't happen.
+        "function Window() {}" +
+        "Window.prototype.alert = function() {};" +
+        "this.alert();",
+        "Property alert never defined on global this");
+  }
+
   public void testControlFlowRestrictsType1() throws Exception {
     testTypes("/** @return {String?} */ function f() { return null; }" +
         "/** @type {String?} */ var a = f();" +
@@ -4191,6 +4985,41 @@
         "};");
   }
 
+  public void testControlFlowRestrictsType10() throws Exception {
+    // We should correctly infer that y will be (null|{}) because
+    // the loop wraps around.
+    testTypes("/** @param {number} x */ function f(x) {}" +
+        "function g() {" +
+        "  var y = null;" +
+        "  for (var i = 0; i < 10; i++) {" +
+        "    f(y);" +
+        "    if (y != null) {" +
+        "      // y is None the first time it goes thru this branch\n" +
+        "    } else {" +
+        "      y = {};" +
+        "    }" +
+        "  }" +
+        "};",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : (null|{})\n" +
+        "required: number");
+  }
+
+  public void testControlFlowRestrictsType11() throws Exception {
+    testTypes("/** @param {boolean} x */ function f(x) {}" +
+        "function g() {" +
+        "  var y = null;" +
+        "  if (y != null) {" +
+        "    for (var i = 0; i < 10; i++) {" +
+        "      f(y);" +
+        "    }" +
+        "  }" +
+        "};",
+        "condition always evaluates to false\n" +
+        "left : null\n" +
+        "right: null");
+  }
+
   public void testSwitchCase3() throws Exception {
     testTypes("/** @type String */" +
         "var a = new String('foo');" +
@@ -4348,7 +5177,8 @@
              "Element.prototype.innerHTML;" +
              "/** @constructor \n @extends Element */" +
              "function DIVElement() {};",
-             "(new DIVElement).innerHTML = new Array();", null, false);
+             "(new DIVElement).innerHTML = new Array();",
+             null, false);
   }
 
   public void testImplicitCastNotInExterns() throws Exception {
@@ -4473,6 +5303,142 @@
         "right: null");
   }
 
+  public void testIssue259() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @constructor */" +
+        "var Clock = function() {" +
+        "  /** @constructor */" +
+        "  this.Date = function() {};" +
+        "  f(new this.Date());" +
+        "};",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : this.Date\n" +
+        "required: number");
+  }
+
+  public void testIssue301() throws Exception {
+    testTypes(
+        "Array.indexOf = function() {};" +
+        "var s = 'hello';" +
+        "alert(s.toLowerCase.indexOf('1'));",
+        "Property indexOf never defined on String.prototype.toLowerCase");
+  }
+
+  public void testIssue380() throws Exception {
+    testTypes(
+        "/** @type { function(string): {innerHTML: string} } */" +
+        "document.getElementById;" +
+        "var list = /** @type {!Array.<string>} */ ['hello', 'you'];\n" +
+        "list.push('?');\n" +
+        "document.getElementById('node').innerHTML = list.toString();");
+  }
+
+  public void testIssue483() throws Exception {
+    testTypes(
+        "/** @constructor */ function C() {" +
+        "  /** @type {?Array} */ this.a = [];" +
+        "}" +
+        "C.prototype.f = function() {" +
+        "  if (this.a.length > 0) {" +
+        "    g(this.a);" +
+        "  }" +
+        "};" +
+        "/** @param {number} a */ function g(a) {}",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : Array\n" +
+        "required: number");
+  }
+
+  public void testIssue537a() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype = {method: function() {}};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {" +
+        "  Foo.call(this);" +
+        "  if (this.baz()) this.method(1);" +
+        "}" +
+        "Bar.prototype = {" +
+        "  baz: function() {" +
+        "    return true;" +
+        "  }" +
+        "};" +
+        "Bar.prototype.__proto__ = Foo.prototype;",
+        "Function Foo.prototype.method: called with 1 argument(s). " +
+        "Function requires at least 0 argument(s) " +
+        "and no more than 0 argument(s).");
+  }
+
+  public void testIssue537b() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype = {method: function() {}};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {" +
+        "  Foo.call(this);" +
+        "  if (this.baz(1)) this.method();" +
+        "}" +
+        "Bar.prototype = {" +
+        "  baz: function() {" +
+        "    return true;" +
+        "  }" +
+        "};" +
+        "Bar.prototype.__proto__ = Foo.prototype;",
+        "Function Bar.prototype.baz: called with 1 argument(s). " +
+        "Function requires at least 0 argument(s) " +
+        "and no more than 0 argument(s).");
+  }
+
+  public void testIssue537c() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {" +
+        "  Foo.call(this);" +
+        "  if (this.baz2()) alert(1);" +
+        "}" +
+        "Bar.prototype = {" +
+        "  baz: function() {" +
+        "    return true;" +
+        "  }" +
+        "};" +
+        "Bar.prototype.__proto__ = Foo.prototype;",
+        "Property baz2 never defined on Bar");
+  }
+
+  public void testIssue537d() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype = {" +
+        "  /** @return {Bar} */ x: function() { new Bar(); }," +
+        "  /** @return {Foo} */ y: function() { new Bar(); }" +
+        "};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {" +
+        "  this.xy = 3;" +
+        "}" +
+        "/** @return {Bar} */ function f() { return new Bar(); }" +
+        "/** @return {Foo} */ function g() { return new Bar(); }" +
+        "Bar.prototype = {" +
+        "  /** @return {Bar} */ x: function() { new Bar(); }," +
+        "  /** @return {Foo} */ y: function() { new Bar(); }" +
+        "};" +
+        "Bar.prototype.__proto__ = Foo.prototype;");
+  }
+
   /**
    * Tests that the || operator is type checked correctly, that is of
    * the type of the first argument or of the second argument. See
@@ -4537,7 +5503,7 @@
   public void testBug909000() throws Exception {
     testTypes("/** @constructor */function A(){}\n" +
         "/** @param {!A} a\n" +
-        "@return boolean*/\n" +
+        "@return {boolean}*/\n" +
         "function y(a) { return a }",
         "inconsistent return type\n" +
         "found   : A\n" +
@@ -4676,7 +5642,7 @@
         "function foo(x) { return x.index; }");
   }
 
-  public void testScopedConstructors() throws Exception {
+  public void testScopedConstructors1() throws Exception {
     testTypes(
         "function foo1() { " +
         "  /** @constructor */ function Bar() { " +
@@ -4698,6 +5664,15 @@
         "required: number");
   }
 
+  public void testScopedConstructors2() throws Exception {
+    testTypes(
+        "/** @param {Function} f */" +
+        "function foo1(f) {" +
+        "  /** @param {Function} g */" +
+        "  f.prototype.bar = function(g) {};" +
+        "}");
+  }
+
   public void testQualifiedNameInference1() throws Exception {
     testTypes(
         "/** @constructor */ function Foo() {}" +
@@ -4757,11 +5732,88 @@
         "};");
   }
 
+  public void testQualifiedNameInference5() throws Exception {
+    testTypes(
+        "var ns = {}; " +
+        "(function() { " +
+        "    /** @param {number} x */ ns.foo = function(x) {}; })();" +
+        "(function() { ns.foo(true); })();",
+        "actual parameter 1 of ns.foo does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testQualifiedNameInference6() throws Exception {
+    testTypes(
+        "var ns = {}; " +
+        "/** @param {number} x */ ns.foo = function(x) {};" +
+        "(function() { " +
+        "    ns.foo = function(x) {};" +
+        "    ns.foo(true); })();",
+        "actual parameter 1 of ns.foo does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testQualifiedNameInference7() throws Exception {
+    testTypes(
+        "var ns = {}; " +
+        "(function() { " +
+        "  /** @constructor \n * @param {number} x */ " +
+        "  ns.Foo = function(x) {};" +
+        "  /** @param {ns.Foo} x */ function f(x) {}" +
+        "  f(new ns.Foo(true));" +
+        "})();",
+        "actual parameter 1 of ns.Foo does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testQualifiedNameInference8() throws Exception {
+    testTypes(
+        "var ns = {}; " +
+        "(function() { " +
+        "  /** @constructor \n * @param {number} x */ " +
+        "  ns.Foo = function(x) {};" +
+        "})();" +
+        "/** @param {ns.Foo} x */ function f(x) {}" +
+        "f(new ns.Foo(true));",
+        "Bad type annotation. Unknown type ns.Foo");
+  }
+
+  public void testQualifiedNameInference9() throws Exception {
+    testTypes(
+        "var ns = {}; " +
+        "ns.ns2 = {}; " +
+        "(function() { " +
+        "  /** @constructor \n * @param {number} x */ " +
+        "  ns.ns2.Foo = function(x) {};" +
+        "  /** @param {ns.ns2.Foo} x */ function f(x) {}" +
+        "  f(new ns.ns2.Foo(true));" +
+        "})();",
+        "actual parameter 1 of ns.ns2.Foo does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testQualifiedNameInference10() throws Exception {
+    testTypes(
+        "var ns = {}; " +
+        "ns.ns2 = {}; " +
+        "(function() { " +
+        "  /** @interface */ " +
+        "  ns.ns2.Foo = function() {};" +
+        "  /** @constructor \n * @implements {ns.ns2.Foo} */ " +
+        "  function F() {}" +
+        "  (new F());" +
+        "})();");
+  }
+
   public void testSheqRefinedScope() throws Exception {
     Node n = parseAndTypeCheck(
         "/** @constructor */function A() {}\n" +
         "/** @constructor \n @extends A */ function B() {}\n" +
-        "/** @return number */\n" +
+        "/** @return {number} */\n" +
         "B.prototype.p = function() { return 1; }\n" +
         "/** @param {A} a\n @param {B} b */\n" +
         "function f(a, b) {\n" +
@@ -4919,6 +5971,17 @@
         "required: string");
   }
 
+  public void testNew17() throws Exception {
+    testTypes("var goog = {}; goog.x = 3; new goog.x",
+              "cannot instantiate non-constructor");
+  }
+
+  public void testNew18() throws Exception {
+    testTypes("var goog = {};" +
+              "/** @constructor */ goog.F = function() {};" +
+              "/** @constructor */ goog.G = goog.F;");
+  }
+
   public void testName1() throws Exception {
     assertEquals(VOID_TYPE, testNameNode("undefined"));
   }
@@ -4945,8 +6008,11 @@
   private JSType testNameNode(String name) {
     Node node = Node.newString(Token.NAME, name);
     Node parent = new Node(Token.SCRIPT, node);
+    parent.setInputId(new InputId("code"));
+
+    Node externs = new Node(Token.SCRIPT);
+    externs.setInputId(new InputId("externs"));
 
-    Node externs = new Node(Token.BLOCK);
     Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);
     externAndJsRoot.setIsSyntheticBlock(true);
 
@@ -5019,7 +6085,7 @@
         "/** @type {some.unknown.type} */var f1;" +
         "var f2 = opt_f || f1;" +
         "f2();",
-        "Parse error. Unknown type some.unknown.type");
+        "Bad type annotation. Unknown type some.unknown.type");
   }
 
   public void testCall4() throws Exception {
@@ -5189,36 +6255,36 @@
 
   public void testCast7() throws Exception {
     testTypes("var x = /** @type {foo} */ (new Object());",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast8() throws Exception {
     testTypes("function f() { return /** @type {foo} */ (new Object()); }",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast9() throws Exception {
     testTypes("var foo = {};" +
         "function f() { return /** @type {foo} */ (new Object()); }",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast10() throws Exception {
     testTypes("var foo = function() {};" +
         "function f() { return /** @type {foo} */ (new Object()); }",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast11() throws Exception {
     testTypes("var goog = {}; goog.foo = {};" +
         "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        "Parse error. Unknown type goog.foo");
+        "Bad type annotation. Unknown type goog.foo");
   }
 
   public void testCast12() throws Exception {
     testTypes("var goog = {}; goog.foo = function() {};" +
         "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        "Parse error. Unknown type goog.foo");
+        "Bad type annotation. Unknown type goog.foo");
   }
 
   public void testCast13() throws Exception {
@@ -5228,7 +6294,7 @@
         "goog.addDependency('zzz.js', ['goog.foo'], []);" +
         "goog.foo = function() {};" +
         "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        "Parse error. Unknown type goog.foo");
+        "Bad type annotation. Unknown type goog.foo");
   }
 
   public void testCast14() throws Exception {
@@ -5240,6 +6306,49 @@
         null);
   }
 
+  public void testCast15() throws Exception {
+    // This fixes a bug where a type cast on an object literal
+    // would cause a runtime cast exception if the node was visited
+    // more than once.
+    //
+    // Some code assumes that an object literal must have a object type,
+    // while because of the cast, it could have any type (including
+    // a union).
+    testTypes(
+        "for (var i = 0; i < 10; i++) {" +
+          "var x = /** @type {Object|number} */ ({foo: 3});" +
+          "/** @param {boolean} x */ function f(x) {}" +
+          "f(x.foo);" +
+          "f([].foo);" +
+        "}",
+        "Property foo never defined on Array");
+  }
+
+  public void testCast16() throws Exception {
+    // A type cast should not invalidate the checks on the members
+    testTypes(
+        "for (var i = 0; i < 10; i++) {" +
+          "var x = /** @type {Object|number} */ (" +
+          "  {/** @type {string} */ foo: 3});" +
+        "}",
+        "assignment to property foo of Object\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testCast17() throws Exception {
+    // Mostly verifying that rhino actually understands these JsDocs.
+    testTypes("/** @constructor */ function Foo() {} \n" +
+        "/** @type {Foo} */ var x = /** @type {Foo} */ ({})");
+
+    testTypes("/** @constructor */ function Foo() {} \n" +
+        "/** @type {Foo} */ var x = (/** @type {Foo} */ {})");
+
+    // Not really encourage because of possible ambiguity but it works.
+    testTypes("/** @constructor */ function Foo() {} \n" +
+        "/** @type {Foo} */ var x = /** @type {Foo} */ {}");
+  }
+
   public void testNestedCasts() throws Exception {
     testTypes("/** @constructor */var T = function() {};\n" +
         "/** @constructor */var V = function() {};\n" +
@@ -5253,7 +6362,7 @@
         "* @return {boolean|undefined}\n" +
         "*/\n" +
         "function g(b) { return b ? true : undefined; }\n" +
-        "/* @return {T} */\n" +
+        "/** @return {T} */\n" +
         "function h() {\n" +
         "return /** @type {T} */ (f(/** @type {boolean} */ (g(true))));\n" +
         "}");
@@ -5299,7 +6408,7 @@
     testTypes(
         "/** @constructor */ function Foo() {}" +
         "Foo();",
-        "Constructor function (this:Foo): undefined should be called " +
+        "Constructor function (new:Foo): undefined should be called " +
         "with the \"new\" keyword");
   }
 
@@ -5368,6 +6477,67 @@
     assertEquals("A", fType.getReferenceName());
   }
 
+  public void testConstructorType8() throws Exception {
+    testTypes(
+        "var ns = {};" +
+        "ns.create = function() { return function() {}; };" +
+        "/** @constructor */ ns.Foo = ns.create();" +
+        "ns.Foo.prototype = {x: 0, y: 0};" +
+        "/**\n" +
+        " * @param {ns.Foo} foo\n" +
+        " * @return {string}\n" +
+        " */\n" +
+        "function f(foo) {" +
+        "  return foo.x;" +
+        "}",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testConstructorType9() throws Exception {
+    testTypes(
+        "var ns = {};" +
+        "ns.create = function() { return function() {}; };" +
+        "ns.extend = function(x) { return x; };" +
+        "/** @constructor */ ns.Foo = ns.create();" +
+        "ns.Foo.prototype = ns.extend({x: 0, y: 0});" +
+        "/**\n" +
+        " * @param {ns.Foo} foo\n" +
+        " * @return {string}\n" +
+        " */\n" +
+        "function f(foo) {" +
+        "  return foo.x;" +
+        "}");
+  }
+
+  public void testAnonymousPrototype1() throws Exception {
+    testTypes(
+        "var ns = {};" +
+        "/** @constructor */ ns.Foo = function() {" +
+        "  this.bar(3, 5);" +
+        "};" +
+        "ns.Foo.prototype = {" +
+        "  bar: function(x) {}" +
+        "};",
+        "Function ns.Foo.prototype.bar: called with 2 argument(s). " +
+        "Function requires at least 1 argument(s) and no more " +
+        "than 1 argument(s).");
+  }
+
+  public void testAnonymousPrototype2() throws Exception {
+    testTypes(
+        "/** @interface */ var Foo = function() {};" +
+        "Foo.prototype = {" +
+        "  foo: function(x) {}" +
+        "};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @implements {Foo}\n" +
+        " */ var Bar = function() {};",
+        "property foo on interface Foo is not implemented by type Bar");
+  }
+
   public void testAnonymousType1() throws Exception {
     testTypes("function f() {}" +
         "/** @constructor */\n" +
@@ -5445,7 +6615,7 @@
   }
 
   public void testUnknownConstructorInstanceType1() throws Exception {
-    testTypes("/** @return Array */ function g(f) { return new f(); }");
+    testTypes("/** @return {Array} */ function g(f) { return new f(); }");
   }
 
   public void testUnknownConstructorInstanceType2() throws Exception {
@@ -5804,14 +6974,15 @@
         "/** @constructor */function Super() {};" +
         "Super.prototype.foo = function() { return 3; };" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
-        "/** @override\n @return number */Sub.prototype.foo =\n" +
+        "/** @override\n @return {number} */Sub.prototype.foo =\n" +
         "function() { return 1; };");
   }
 
   public void testInheritanceCheck9_2() throws Exception {
     testTypes(
         "/** @constructor */function Super() {};" +
-        "/** @return number */Super.prototype.foo = function() { return 1; };" +
+        "/** @return {number} */" +
+        "Super.prototype.foo = function() { return 1; };" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
         "/** @override */Sub.prototype.foo =\n" +
         "function() {};");
@@ -5820,9 +6991,10 @@
   public void testInheritanceCheck9_3() throws Exception {
     testTypes(
         "/** @constructor */function Super() {};" +
-        "/** @return number */Super.prototype.foo = function() { return 1; };" +
+        "/** @return {number} */" +
+        "Super.prototype.foo = function() { return 1; };" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
-        "/** @override\n @return string */Sub.prototype.foo =\n" +
+        "/** @override\n @return {string} */Sub.prototype.foo =\n" +
         "function() { return \"some string\" };",
         "mismatch of the foo property type and the type of the property it " +
         "overrides from superclass Super\n" +
@@ -5836,14 +7008,15 @@
         "Root.prototype.foo = function() { return 3; };" +
         "/** @constructor\n @extends {Root} */function Super() {};" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
-        "/** @override\n @return number */Sub.prototype.foo =\n" +
+        "/** @override\n @return {number} */Sub.prototype.foo =\n" +
         "function() { return 1; };");
   }
 
   public void testInheritanceCheck10_2() throws Exception {
     testTypes(
         "/** @constructor */function Root() {};" +
-        "/** @return number */Root.prototype.foo = function() { return 1; };" +
+        "/** @return {number} */" +
+        "Root.prototype.foo = function() { return 1; };" +
         "/** @constructor\n @extends {Root} */function Super() {};" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
         "/** @override */Sub.prototype.foo =\n" +
@@ -5853,10 +7026,11 @@
   public void testInheritanceCheck10_3() throws Exception {
     testTypes(
         "/** @constructor */function Root() {};" +
-        "/** @return number */Root.prototype.foo = function() { return 1; };" +
+        "/** @return {number} */" +
+        "Root.prototype.foo = function() { return 1; };" +
         "/** @constructor\n @extends {Root} */function Super() {};" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
-        "/** @override\n @return string */Sub.prototype.foo =\n" +
+        "/** @override\n @return {string} */Sub.prototype.foo =\n" +
         "function() { return \"some string\" };",
         "mismatch of the foo property type and the type of the property it " +
         "overrides from superclass Root\n" +
@@ -5895,17 +7069,17 @@
         "var goog = {};\n" +
         "/** @constructor\n @extends {goog.Missing} */function Sub() {};" +
         "/** @override */Sub.prototype.foo = function() {};",
-        "Parse error. Unknown type goog.Missing");
+        "Bad type annotation. Unknown type goog.Missing");
   }
 
   public void testInheritanceCheck14() throws Exception {
-    testTypes(
+    testClosureTypes(
         "var goog = {};\n" +
         "/** @constructor\n @extends {goog.Missing} */\n" +
         "goog.Super = function() {};\n" +
         "/** @constructor\n @extends {goog.Super} */function Sub() {};" +
         "/** @override */Sub.prototype.foo = function() {};",
-        "Parse error. Unknown type goog.Missing");
+        "Bad type annotation. Unknown type goog.Missing");
   }
 
   // TODO(user): We should support this way of declaring properties as it is
@@ -5980,9 +7154,9 @@
   public void testInterfaceInheritanceCheck5() throws Exception {
     testTypes(
         "/** @interface */function Super() {};" +
-        "/** @return string */Super.prototype.foo = function() {};" +
+        "/** @return {string} */Super.prototype.foo = function() {};" +
         "/** @constructor\n @implements {Super} */function Sub() {};" +
-        "/** @override\n @return number */Sub.prototype.foo =\n" +
+        "/** @override\n @return {number} */Sub.prototype.foo =\n" +
         "function() { return 1; };",
         "mismatch of the foo property type and the type of the property it " +
         "overrides from interface Super\n" +
@@ -5993,10 +7167,10 @@
   public void testInterfaceInheritanceCheck6() throws Exception {
     testTypes(
         "/** @interface */function Root() {};" +
-        "/** @return string */Root.prototype.foo = function() {};" +
+        "/** @return {string} */Root.prototype.foo = function() {};" +
         "/** @interface\n @extends {Root} */function Super() {};" +
         "/** @constructor\n @implements {Super} */function Sub() {};" +
-        "/** @override\n @return number */Sub.prototype.foo =\n" +
+        "/** @override\n @return {number} */Sub.prototype.foo =\n" +
         "function() { return 1; };",
         "mismatch of the foo property type and the type of the property it " +
         "overrides from interface Root\n" +
@@ -6022,11 +7196,67 @@
         "/** @constructor\n @implements {Super} */function Sub() {};" +
         "/** @override */Sub.prototype.foo = function() {};",
         new String[] {
-          "Parse error. Unknown type Super",
+          "Bad type annotation. Unknown type Super",
           "property foo not defined on any superclass of Sub"
         });
   }
 
+  public void testInterfaceInheritanceCheck9() throws Exception {
+    testTypes(
+        "/** @interface */ function I() {}" +
+        "/** @return {number} */ I.prototype.bar = function() {};" +
+        "/** @constructor */ function F() {}" +
+        "/** @return {number} */ F.prototype.bar = function() {return 3; };" +
+        "/** @return {number} */ F.prototype.foo = function() {return 3; };" +
+        "/** @constructor \n * @extends {F} \n * @implements {I} */ " +
+        "function G() {}" +
+        "/** @return {string} */ function f() { return new G().bar(); }",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testInterfaceInheritanceCheck10() throws Exception {
+    testTypes(
+        "/** @interface */ function I() {}" +
+        "/** @return {number} */ I.prototype.bar = function() {};" +
+        "/** @constructor */ function F() {}" +
+        "/** @return {number} */ F.prototype.foo = function() {return 3; };" +
+        "/** @constructor \n * @extends {F} \n * @implements {I} */ " +
+        "function G() {}" +
+        "/** @return {number} \n * @override */ " +
+        "G.prototype.bar = G.prototype.foo;" +
+        "/** @return {string} */ function f() { return new G().bar(); }",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testInterfaceInheritanceCheck12() throws Exception {
+    testTypes(
+        "/** @interface */ function I() {};\n" +
+        "/** @type {string} */ I.prototype.foobar;\n" +
+        "/** \n * @constructor \n * @implements {I} */\n" +
+        "function C() {\n" +
+        "/** \n * @type {number} */ this.foobar = 2;};\n" +
+        "/** @type {I} */ \n var test = new C(); alert(test.foobar);",
+        "mismatch of the foobar property type and the type of the property" +
+        " it overrides from interface I\n" +
+        "original: string\n" +
+        "override: number");
+  }
+
+  public void testInterfaceInheritanceCheck13() throws Exception {
+    testTypes(
+        "function abstractMethod() {};\n" +
+        "/** @interface */var base = function() {};\n" +
+        "/** @extends {base} \n @interface */ var Int = function() {}\n" +
+        "/** @type {{bar : !Function}} */ var x; \n" +
+        "/** @type {!Function} */ base.prototype.bar = abstractMethod; \n" +
+        "/** @type {Int} */ foo;\n" +
+        "foo.bar();");
+  }
+
   public void testInterfacePropertyNotImplemented() throws Exception {
     testTypes(
         "/** @interface */function Int() {};" +
@@ -6047,9 +7277,12 @@
   public void testStubConstructorImplementingInterface() throws Exception {
     // This does not throw a warning for unimplemented property because Foo is
     // just a stub.
-    testTypes("/** @interface */ function Int() {}\n" +
+    testTypes(
+        // externs
+        "/** @interface */ function Int() {}\n" +
         "/** @desc description */Int.prototype.foo = function() {};" +
-        "/** @constructor \n @implements {Int} */ var Foo;\n");
+        "/** @constructor \n @implements {Int} */ var Foo;\n",
+        "", null, false);
   }
 
   public void testObjectLiteral() throws Exception {
@@ -6081,6 +7314,82 @@
         "};");
   }
 
+  public void testObjectLiteralDeclaration2() throws Exception {
+    testTypes(
+        "var x = {" +
+        "  /** @type {boolean} */ abc: true" +
+        "};" +
+        "x.abc = 0;",
+        "assignment to property abc of x\n" +
+        "found   : number\n" +
+        "required: boolean");
+  }
+
+  public void testObjectLiteralDeclaration3() throws Exception {
+    testTypes(
+        "/** @param {{foo: !Function}} x */ function f(x) {}" +
+        "f({foo: function() {}});");
+  }
+
+  public void testObjectLiteralDeclaration4() throws Exception {
+    testClosureTypes(
+        "var x = {" +
+        "  /** @param {boolean} x */ abc: function(x) {}" +
+        "};" +
+        "/**\n" +
+        " * @param {string} x\n" +
+        " * @suppress {duplicate}\n" +
+        " */ x.abc = function(x) {};",
+        "assignment to property abc of x\n" +
+        "found   : function (string): undefined\n" +
+        "required: function (boolean): undefined");
+    // TODO(user): suppress {duplicate} currently also silence the
+    // redefining type error in the TypeValidator. May be it needs
+    // a new suppress name instead?
+  }
+
+  public void testObjectLiteralDeclaration5() throws Exception {
+    testTypes(
+        "var x = {" +
+        "  /** @param {boolean} x */ abc: function(x) {}" +
+        "};" +
+        "/**\n" +
+        " * @param {boolean} x\n" +
+        " * @suppress {duplicate}\n" +
+        " */ x.abc = function(x) {};");
+  }
+
+  public void testObjectLiteralDeclaration6() throws Exception {
+    testTypes(
+        "var x = {};" +
+        "/**\n" +
+        " * @param {boolean} x\n" +
+        " * @suppress {duplicate}\n" +
+        " */ x.abc = function(x) {};" +
+        "x = {" +
+        "  /**\n" +
+        "   * @param {boolean} x\n" +
+        "   * @suppress {duplicate}\n" +
+        "   */" +
+        "  abc: function(x) {}" +
+        "};");
+  }
+
+  public void testObjectLiteralDeclaration7() throws Exception {
+    testTypes(
+        "var x = {};" +
+        "/**\n" +
+        " * @type {function(boolean): undefined}\n" +
+        " */ x.abc = function(x) {};" +
+        "x = {" +
+        "  /**\n" +
+        "   * @param {boolean} x\n" +
+        "   * @suppress {duplicate}\n" +
+        "   */" +
+        "  abc: function(x) {}" +
+        "};");
+  }
+
   public void testCallDateConstructorAsFunction() throws Exception {
     // ECMA-262 15.9.2: When Date is called as a function rather than as a
     // constructor, it returns a string.
@@ -6201,11 +7510,54 @@
   //      "interface members can only be plain functions");
   //}
 
-  public void testDataPropertyOnInterface2() throws Exception {
+  public void testDataPropertyOnInterface1() throws Exception {
     testTypes("/** @interface */ function T() {};\n" +
         "/** @type {number} */T.prototype.x;");
   }
 
+  public void testDataPropertyOnInterface2() throws Exception {
+    reportMissingOverrides = CheckLevel.OFF;
+    testTypes("/** @interface */ function T() {};\n" +
+        "/** @type {number} */T.prototype.x;\n" +
+        "/** @constructor \n" +
+        " *  @implements {T} \n" +
+        " */\n" +
+        "function C() {}\n" +
+        "C.prototype.x = 'foo';",
+        "mismatch of the x property type and the type of the property it " +
+        "overrides from interface T\n" +
+        "original: number\n" +
+        "override: string");
+  }
+
+  public void testDataPropertyOnInterface3() throws Exception {
+    testTypes("/** @interface */ function T() {};\n" +
+        "/** @type {number} */T.prototype.x;\n" +
+        "/** @constructor \n" +
+        " *  @implements {T} \n" +
+        " */\n" +
+        "function C() {}\n" +
+        "/** @override */\n" +
+        "C.prototype.x = 'foo';",
+        "mismatch of the x property type and the type of the property it " +
+        "overrides from interface T\n" +
+        "original: number\n" +
+        "override: string");
+  }
+
+  public void testDataPropertyOnInterface4() throws Exception {
+    testTypes("/** @interface */ function T() {};\n" +
+        "/** @type {number} */T.prototype.x;\n" +
+        "/** @constructor \n" +
+        " *  @implements {T} \n" +
+        " */\n" +
+        "function C() { /** @type {string} */ \n this.x = 'foo'; }\n",
+        "mismatch of the x property type and the type of the property it " +
+        "overrides from interface T\n" +
+        "original: number\n" +
+        "override: string");
+  }
+
   public void testWarnDataPropertyOnInterface3() throws Exception {
     testTypes("/** @interface */ u.T = function () {};\n" +
         "/** @type {number} */u.T.prototype.x = 1;",
@@ -6292,16 +7644,18 @@
   }
 
   public void testInterfaceInstantiation() throws Exception {
-    testTypes("/** @interface */var f; new f",
+    testTypes("/** @interface */var f = function(){}; new f",
               "cannot instantiate non-constructor");
   }
 
   public void testPrototypeLoop() throws Exception {
-    testTypes(
+    testClosureTypesMultipleWarnings(
         suppressMissingProperty("foo") +
         "/** @constructor \n * @extends {T} */var T = function() {};" +
         "alert((new T).foo);",
-        "Parse error. Cycle detected in inheritance chain of type T");
+        Lists.newArrayList(
+            "Parse error. Cycle detected in inheritance chain of type T",
+            "Could not resolve type in @extends tag of T"));
   }
 
   public void testDirectPrototypeAssign() throws Exception {
@@ -6387,7 +7741,7 @@
     ObjectType objectType = (ObjectType) type;
     assertFalse(objectType.hasProperty("x"));
     assertEquals(
-        Sets.newHashSet(objectType),
+        Lists.newArrayList(objectType),
         registry.getTypesWithProperty("x"));
   }
 
@@ -6403,7 +7757,7 @@
     ObjectType objectType = (ObjectType) type;
     assertFalse(objectType.hasProperty("x"));
     assertEquals(
-        Sets.newHashSet(OBJECT_TYPE),
+        Lists.newArrayList(OBJECT_TYPE),
         registry.getTypesWithProperty("x"));
   }
 
@@ -6578,6 +7932,57 @@
         "right: number");
   }
 
+  public void testTypeInferenceWithNoEntry1() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype.init = function() {" +
+        "  /** @type {?{baz: number}} */ this.bar = {baz: 3};" +
+        "};" +
+        "/**\n" +
+        " * @extends {Foo}\n" +
+        " * @constructor\n" +
+        " */" +
+        "function SubFoo() {}" +
+        "/** Method */" +
+        "SubFoo.prototype.method = function() {" +
+        "  for (var i = 0; i < 10; i++) {" +
+        "    f(this.bar);" +
+        "    f(this.bar.baz);" +
+        "  }" +
+        "};",
+        "actual parameter 1 of f does not match formal parameter\n"+
+        "found   : (null|{baz: number})\n" +
+        "required: number");
+  }
+
+  public void testTypeInferenceWithNoEntry2() throws Exception {
+    testClosureTypes(
+        CLOSURE_DEFS +
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @param {!Object} x */ function g(x) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype.init = function() {" +
+        "  /** @type {?{baz: number}} */ this.bar = {baz: 3};" +
+        "};" +
+        "/**\n" +
+        " * @extends {Foo}\n" +
+        " * @constructor\n" +
+        " */" +
+        "function SubFoo() {}" +
+        "/** Method */" +
+        "SubFoo.prototype.method = function() {" +
+        "  for (var i = 0; i < 10; i++) {" +
+        "    f(this.bar);" +
+        "    goog.asserts.assert(this.bar);" +
+        "    g(this.bar);" +
+        "  }" +
+        "};",
+        "actual parameter 1 of f does not match formal parameter\n"+
+        "found   : (null|{baz: number})\n" +
+        "required: number");
+  }
+
   public void testForwardPropertyReference() throws Exception {
     testTypes("/** @constructor */ var Foo = function() { this.init(); };" +
         "/** @return {string} */" +
@@ -6596,12 +8001,10 @@
   public void testNoForwardTypeDeclaration() throws Exception {
     testTypes(
         "/** @param {MyType} x */ function f(x) {}",
-        "Parse error. Unknown type MyType");
+        "Bad type annotation. Unknown type MyType");
   }
 
   public void testNoForwardTypeDeclarationAndNoBraces() throws Exception {
-    // To better support third-party code, we do not warn when
-    // there are no braces around an unknown type name.
     testTypes("/** @return The result. */ function f() {}");
   }
 
@@ -6613,14 +8016,17 @@
 
         "goog.addDependency('zzz.js', ['MyType'], []);" +
         "/** @param {MyType} x \n * @return {number} */" +
-        "function f(x) { return x; }", null);
+        "function f(x) { return 3; }", null);
   }
 
   public void testForwardTypeDeclaration2() throws Exception {
-    testClosureTypes(
-        "goog.addDependency('zzz.js', ['MyType'], []);" +
-        "/** @param {MyType} x */ function f(x) { }" +
-        "f(3);", null);
+    String f = "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/** @param {MyType} x */ function f(x) { }";
+    testClosureTypes(f, null);
+    testClosureTypes(f + "f(3);",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: (MyType|null)");
   }
 
   public void testForwardTypeDeclaration3() throws Exception {
@@ -6634,66 +8040,69 @@
         "required: (MyType|null)");
   }
 
-  public void testMalformedOldTypeDef() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "goog.Bar = goog.typedef",
-        "Typedef for goog.Bar does not have any type information");
+  public void testForwardTypeDeclaration4() throws Exception {
+    testClosureTypes(
+        "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/** @param {MyType} x */ function f(x) { return x; }" +
+        "/** @constructor */ var MyType = function() {};" +
+        "f(new MyType());",
+        null);
   }
 
-  public void testMalformedOldTypeDef2() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @typedef {boolean} */ goog.Bar = goog.typedef",
-        "Typedef for goog.Bar does not have any type information");
+  public void testForwardTypeDeclaration5() throws Exception {
+    testClosureTypes(
+        "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {MyType}\n" +
+        " */ var YourType = function() {};" +
+        "/** @override */ YourType.prototype.method = function() {};",
+        "Could not resolve type in @extends tag of YourType");
   }
 
-  public void testDuplicateOldTypeDef() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @constructor */ goog.Bar = function() {};" +
-        "/** @type {number} */ goog.Bar = goog.typedef",
-        "variable goog.Bar redefined with type number, " +
-        "original definition at [testcode]:1 " +
-        "with type function (this:goog.Bar): undefined");
+  public void testForwardTypeDeclaration6() throws Exception {
+    testClosureTypesMultipleWarnings(
+        "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @implements {MyType}\n" +
+        " */ var YourType = function() {};" +
+        "/** @override */ YourType.prototype.method = function() {};",
+        Lists.newArrayList(
+            "Could not resolve type in @implements tag of YourType",
+            "property method not defined on any superclass of YourType"));
   }
 
-  public void testOldTypeDef1() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @type {number} */ goog.Bar = goog.typedef;" +
-        "/** @param {goog.Bar} x */ function f(x) {}" +
-        "f(3);");
+  public void testForwardTypeDeclaration7() throws Exception {
+    testClosureTypes(
+        "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/** @param {MyType=} x */" +
+        "function f(x) { return x == undefined; }", null);
   }
 
-  public void testOldTypeDef2() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @type {number} */ goog.Bar = goog.typedef;" +
-        "/** @param {goog.Bar} x */ function f(x) {}" +
-        "f('3');",
-        "actual parameter 1 of f does not match formal parameter\n" +
-        "found   : string\n" +
-        "required: number");
+  public void testForwardTypeDeclaration8() throws Exception {
+    testClosureTypes(
+        "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/** @param {MyType} x */" +
+        "function f(x) { return x.name == undefined; }", null);
   }
 
-  public void testOldTypeDef3() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @type {number} */ var Bar = goog.typedef;" +
-        "/** @param {Bar} x */ function f(x) {}" +
-        "f('3');",
-        "actual parameter 1 of f does not match formal parameter\n" +
-        "found   : string\n" +
-        "required: number");
+  public void testForwardTypeDeclaration9() throws Exception {
+    testClosureTypes(
+        "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/** @param {MyType} x */" +
+        "function f(x) { x.name = 'Bob'; }", null);
   }
 
-  public void testCircularOldTypeDef() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @type {number|Array.<goog.Bar>} */ goog.Bar = goog.typedef;" +
-        "/** @param {goog.Bar} x */ function f(x) {}" +
-        "f(3); f([3]); f([[3]]);");
+  public void testForwardTypeDeclaration10() throws Exception {
+    String f = "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/** @param {MyType|number} x */ function f(x) { }";
+    testClosureTypes(f, null);
+    testClosureTypes(f + "f(3);", null);
+    testClosureTypes(f + "f('3');",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : string\n" +
+        "required: (MyType|null|number)");
   }
 
   public void testDuplicateTypeDef() throws Exception {
@@ -6703,7 +8112,7 @@
         "/** @typedef {number} */ goog.Bar;",
         "variable goog.Bar redefined with type None, " +
         "original definition at [testcode]:1 " +
-        "with type function (this:goog.Bar): undefined");
+        "with type function (new:goog.Bar): undefined");
   }
 
   public void testTypeDef1() throws Exception {
@@ -6736,6 +8145,34 @@
         "required: number");
   }
 
+  public void testTypeDef4() throws Exception {
+    testTypes(
+        "/** @constructor */ function A() {}" +
+        "/** @constructor */ function B() {}" +
+        "/** @typedef {(A|B)} */ var AB;" +
+        "/** @param {AB} x */ function f(x) {}" +
+        "f(new A()); f(new B()); f(1);",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: (A|B|null)");
+  }
+
+  public void testTypeDef5() throws Exception {
+    // Notice that the error message is slightly different than
+    // the one for testTypeDef4, even though they should be the same.
+    // This is an implementation detail necessary for NamedTypes work out
+    // ok, and it should change if NamedTypes ever go away.
+    testTypes(
+        "/** @param {AB} x */ function f(x) {}" +
+        "/** @constructor */ function A() {}" +
+        "/** @constructor */ function B() {}" +
+        "/** @typedef {(A|B)} */ var AB;" +
+        "f(new A()); f(new B()); f(1);",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: (A|B|null)");
+  }
+
   public void testCircularTypeDef() throws Exception {
     testTypes(
         "var goog = {};" +
@@ -6766,6 +8203,16 @@
     assertEquals(100.0, getTypedPercent(js), 0.1);
   }
 
+  public void testGetTypedPercent5() throws Exception {
+    String js = "/** @enum {number} */ keys = {A: 1,B: 2,C: 3};";
+    assertEquals(100.0, getTypedPercent(js), 0.1);
+  }
+
+  public void testGetTypedPercent6() throws Exception {
+    String js = "a = {TRUE: 1, FALSE: 0};";
+    assertEquals(100.0, getTypedPercent(js), 0.1);
+  }
+
   private double getTypedPercent(String js) throws Exception {
     Node n = compiler.parseTestCode(js);
 
@@ -7089,6 +8536,172 @@
         "Foo.prototype.baz = function() { this.b = 3; };");
   }
 
+  public void testMissingProperty35() throws Exception {
+    // Bar has specialProp defined, so Bar|Baz may have specialProp defined.
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @constructor */ function Bar() {}" +
+        "/** @constructor */ function Baz() {}" +
+        "/** @param {Foo|Bar} x */ function f(x) { x.specialProp = 1; }" +
+        "/** @param {Bar|Baz} x */ function g(x) { return x.specialProp; }");
+  }
+
+  public void testMissingProperty36() throws Exception {
+    // Foo has baz defined, and SubFoo has bar defined, so some objects with
+    // bar may have baz.
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype.baz = 0;" +
+        "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" +
+        "SubFoo.prototype.bar = 0;" +
+        "/** @param {{bar: number}} x */ function f(x) { return x.baz; }");
+  }
+
+  public void testMissingProperty37() throws Exception {
+    // This used to emit a missing property warning because we couldn't
+    // determine that the inf(Foo, {isVisible:boolean}) == SubFoo.
+    testTypes(
+        "/** @param {{isVisible: boolean}} x */ function f(x){" +
+        "  x.isVisible = false;" +
+        "}" +
+        "/** @constructor */ function Foo() {}" +
+        "/**\n" +
+        " * @constructor \n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/** @type {boolean} */ SubFoo.prototype.isVisible = true;" +
+        "/**\n" +
+        " * @param {Foo} x\n" +
+        " * @return {boolean}\n" +
+        " */\n" +
+        "function g(x) { return x.isVisible; }");
+  }
+
+  public void testMissingProperty38() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @constructor */ function Bar() {}" +
+        "/** @return {Foo|Bar} */ function f() { return new Foo(); }" +
+        "f().missing;",
+        "Property missing never defined on (Bar|Foo|null)");
+  }
+
+  public void testMissingProperty39() throws Exception {
+    testTypes(
+        "/** @return {string|number} */ function f() { return 3; }" +
+        "f().length;");
+  }
+
+  public void testMissingProperty40() throws Exception {
+    testClosureTypes(
+        "goog.addDependency('zzz.js', ['MissingType'], []);" +
+        "/** @param {(Array|MissingType)} x */" +
+        "function f(x) { x.impossible(); }", null);
+  }
+
+  public void testMissingProperty41() throws Exception {
+    testTypes(
+        "/** @param {(Array|Date)} x */" +
+        "function f(x) { if (x.impossible) x.impossible(); }");
+  }
+
+  public void testReflectObject1() throws Exception {
+    testClosureTypes(
+        "var goog = {}; goog.reflect = {}; " +
+        "goog.reflect.object = function(x, y){};" +
+        "/** @constructor */ function A() {}" +
+        "goog.reflect.object(A, {x: 3});",
+        null);
+  }
+
+  public void testReflectObject2() throws Exception {
+    testClosureTypes(
+        "var goog = {}; goog.reflect = {}; " +
+        "goog.reflect.object = function(x, y){};" +
+        "/** @param {string} x */ function f(x) {}" +
+        "/** @constructor */ function A() {}" +
+        "goog.reflect.object(A, {x: f(1 + 1)});",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testLends1() throws Exception {
+    testTypes(
+        "function extend(x, y) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "extend(Foo, /** @lends */ ({bar: 1}));",
+        "Bad type annotation. missing object name in @lends tag");
+  }
+
+  public void testLends2() throws Exception {
+    testTypes(
+        "function extend(x, y) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "extend(Foo, /** @lends {Foob} */ ({bar: 1}));",
+        "Variable Foob not declared before @lends annotation.");
+  }
+
+  public void testLends3() throws Exception {
+    testTypes(
+        "function extend(x, y) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "extend(Foo, {bar: 1});" +
+        "alert(Foo.bar);",
+        "Property bar never defined on Foo");
+  }
+
+  public void testLends4() throws Exception {
+    testTypes(
+        "function extend(x, y) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "extend(Foo, /** @lends {Foo} */ ({bar: 1}));" +
+        "alert(Foo.bar);");
+  }
+
+  public void testLends5() throws Exception {
+    testTypes(
+        "function extend(x, y) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "extend(Foo, {bar: 1});" +
+        "alert((new Foo()).bar);",
+        "Property bar never defined on Foo");
+  }
+
+  public void testLends6() throws Exception {
+    testTypes(
+        "function extend(x, y) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "extend(Foo, /** @lends {Foo.prototype} */ ({bar: 1}));" +
+        "alert((new Foo()).bar);");
+  }
+
+  public void testLends7() throws Exception {
+    testTypes(
+        "function extend(x, y) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "extend(Foo, /** @lends {Foo.prototype|Foo} */ ({bar: 1}));",
+        "Bad type annotation. expected closing }");
+  }
+
+  public void testLends8() throws Exception {
+    testTypes(
+        "function extend(x, y) {}" +
+        "/** @type {number} */ var Foo = 3;" +
+        "extend(Foo, /** @lends {Foo} */ ({bar: 1}));",
+        "May only lend properties to object types. Foo has type number.");
+  }
+
+  public void testLends9() throws Exception {
+    testClosureTypesMultipleWarnings(
+        "function extend(x, y) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "extend(Foo, /** @lends {!Foo} */ ({bar: 1}));",
+        Lists.newArrayList(
+            "Bad type annotation. expected closing }",
+            "Bad type annotation. missing object name in @lends tag"));
+  }
+
   public void testDeclaredNativeTypeEquality() throws Exception {
     Node n = parseAndTypeCheck("/** @constructor */ function Object() {};");
     assertEquals(registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE),
@@ -7170,6 +8783,34 @@
         compiler.getWarnings()[0].description);
   }
 
+  public void testUpdateParameterTypeOnClosure() throws Exception {
+    testTypes(
+        "/**\n" +
+        "* @constructor\n" +
+        "* @param {*=} opt_value\n" +
+        "* @return {?}\n" +
+        "*/\n" +
+        "function Object(opt_value) {}\n" +
+        "/**\n" +
+        "* @constructor\n" +
+        "* @param {...*} var_args\n" +
+        "*/\n" +
+        "function Function(var_args) {}\n" +
+        "/**\n" +
+        "* @type {Function}\n" +
+        "*/\n" +
+        // The line below sets JSDocInfo on Object so that the type of the
+        // argument to function f has JSDoc through its prototype chain.
+        "Object.prototype.constructor = function() {};\n",
+        "/**\n" +
+        "* @param {function(): boolean} fn\n" +
+        "*/\n" +
+        "function f(fn) {}\n" +
+        "f(function(g) { });\n",
+        null,
+        false);
+  }
+
   public void testBadTemplateType1() throws Exception {
     testTypes(
         "/**\n" +
@@ -7179,8 +8820,8 @@
         "* @template T\n" +
         "*/\n" +
         "function f(x, y, z) {}\n" +
-        "f(this, this, function() {});",
-        FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format(), true);
+        "f(this, this, function() { this });",
+        FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format());
   }
 
   public void testBadTemplateType2() throws Exception {
@@ -7192,7 +8833,7 @@
         "*/\n" +
         "function f(x, y) {}\n" +
         "f(0, function() {});",
-        TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format(), true);
+        TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format("number"));
   }
 
   public void testBadTemplateType3() throws Exception {
@@ -7203,7 +8844,7 @@
         "*/\n" +
         "function f(x) {}\n" +
         "f(this);",
-        TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format(), true);
+        TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format());
   }
 
   public void testBadTemplateType4() throws Exception {
@@ -7213,7 +8854,7 @@
         "*/\n" +
         "function f() {}\n" +
         "f();",
-        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);
+        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());
   }
 
   public void testBadTemplateType5() throws Exception {
@@ -7224,7 +8865,58 @@
         "*/\n" +
         "function f() {}\n" +
         "f();",
-        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);
+        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());
+  }
+
+  public void testFunctionLiteralUndefinedThisArgument() throws Exception {
+    testTypes(""
+        + "/**\n"
+        + " * @param {function(this:T, ...)?} fn\n"
+        + " * @param {?T} opt_obj\n"
+        + " * @template T\n"
+        + " */\n"
+        + "function baz(fn, opt_obj) {}\n"
+        + "baz(function() { this; });",
+        "Function literal argument refers to undefined this argument");
+  }
+
+  public void testFunctionLiteralDefinedThisArgument() throws Exception {
+    testTypes(""
+        + "/**\n"
+        + " * @param {function(this:T, ...)?} fn\n"
+        + " * @param {?T} opt_obj\n"
+        + " * @template T\n"
+        + " */\n"
+        + "function baz(fn, opt_obj) {}\n"
+        + "baz(function() { this; }, {});");
+  }
+
+  public void testFunctionLiteralUnreadNullThisArgument() throws Exception {
+    testTypes(""
+        + "/**\n"
+        + " * @param {function(this:T, ...)?} fn\n"
+        + " * @param {?T} opt_obj\n"
+        + " * @template T\n"
+        + " */\n"
+        + "function baz(fn, opt_obj) {}\n"
+        + "baz(function() {}, null);");
+  }
+
+  public void testUnionTemplateThisType() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** @return {F|Array} */ function g() { return []; }" +
+        "/** @param {F} x */ function h(x) { }" +
+        "/**\n" +
+        "* @param {T} x\n" +
+        "* @param {function(this:T, ...)} y\n" +
+        "* @template T\n" +
+        "*/\n" +
+        "function f(x, y) {}\n" +
+        "f(g(), function() { h(this); });",
+        "actual parameter 1 of h does not match formal parameter\n" +
+        "found   : Object\n" +
+        "required: (F|null)");
   }
 
   public void testActiveXObject() throws Exception {
@@ -7233,6 +8925,198 @@
         "/** @type { {impossibleProperty} } */ var y = new ActiveXObject();");
   }
 
+  public void testRecordType1() throws Exception {
+    testTypes(
+        "/** @param {{prop: number}} x */" +
+        "function f(x) {}" +
+        "f({});",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : {prop: (number|undefined)}\n" +
+        "required: {prop: number}");
+  }
+
+  public void testRecordType2() throws Exception {
+    testTypes(
+        "/** @param {{prop: (number|undefined)}} x */" +
+        "function f(x) {}" +
+        "f({});");
+  }
+
+  public void testRecordType3() throws Exception {
+    testTypes(
+        "/** @param {{prop: number}} x */" +
+        "function f(x) {}" +
+        "f({prop: 'x'});",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : {prop: (number|string)}\n" +
+        "required: {prop: number}");
+  }
+
+  public void testRecordType4() throws Exception {
+    // Notice that we do not do flow-based inference on the object type:
+    // We don't try to prove that x.prop may not be string until x
+    // gets passed to g.
+    testClosureTypesMultipleWarnings(
+        "/** @param {{prop: (number|undefined)}} x */" +
+        "function f(x) {}" +
+        "/** @param {{prop: (string|undefined)}} x */" +
+        "function g(x) {}" +
+        "var x = {}; f(x); g(x);",
+        Lists.newArrayList(
+            "actual parameter 1 of f does not match formal parameter\n" +
+            "found   : {prop: (number|string|undefined)}\n" +
+            "required: {prop: (number|undefined)}",
+            "actual parameter 1 of g does not match formal parameter\n" +
+            "found   : {prop: (number|string|undefined)}\n" +
+            "required: {prop: (string|undefined)}"));
+  }
+
+  public void testRecordType5() throws Exception {
+    testTypes(
+        "/** @param {{prop: (number|undefined)}} x */" +
+        "function f(x) {}" +
+        "/** @param {{otherProp: (string|undefined)}} x */" +
+        "function g(x) {}" +
+        "var x = {}; f(x); g(x);");
+  }
+
+  public void testDuplicateRecordFields1() throws Exception {
+    testTypes("/**"
+         + "* @param {{x:string, x:number}} a"
+         + "*/"
+         + "function f(a) {};",
+         "Parse error. Duplicate record field x");
+  }
+
+  public void testDuplicateRecordFields2() throws Exception {
+    testTypes("/**"
+         + "* @param {{name:string,number:x,number:y}} a"
+         + " */"
+         + "function f(a) {};",
+         new String[] {"Bad type annotation. Unknown type x",
+           "Parse error. Duplicate record field number",
+           "Bad type annotation. Unknown type y"});
+  }
+
+  public void testMultipleExtendsInterface1() throws Exception {
+    testTypes("/** @interface */ function base1() {}\n"
+        + "/** @interface */ function base2() {}\n"
+        + "/** @interface\n"
+        + "* @extends {base1}\n"
+        + "* @extends {base2}\n"
+        + "*/\n"
+        + "function derived() {}");
+  }
+
+  public void testMultipleExtendsInterface2() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @desc description */Int0.prototype.foo = function() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
+        "function Int2() {};" +
+        "/** @constructor\n @implements {Int2} */function Foo() {};",
+        "property foo on interface Int0 is not implemented by type Foo");
+  }
+
+  public void testMultipleExtendsInterface3() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @desc description */Int1.prototype.foo = function() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
+        "function Int2() {};" +
+        "/** @constructor\n @implements {Int2} */function Foo() {};",
+        "property foo on interface Int1 is not implemented by type Foo");
+  }
+
+  public void testMultipleExtendsInterface4() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} \n" +
+        " @extends {number} */" +
+        "function Int2() {};" +
+        "/** @constructor\n @implements {Int2} */function Foo() {};",
+        "Int2 @extends non-object type number");
+  }
+
+  public void testMultipleExtendsInterface5() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @constructor */function Int1() {};" +
+        "/** @desc description @ return {string} x */" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
+        "function Int2() {};",
+        "Int2 cannot extend this type; a constructor can only extend " +
+        "objects and an interface can only extend interfaces");
+  }
+
+  public void testMultipleExtendsInterface6() throws Exception {
+    testTypes(
+        "/** @interface */function Super1() {};" +
+        "/** @interface */function Super2() {};" +
+        "/** @param {number} bar */Super2.prototype.foo = function(bar) {};" +
+        "/** @interface\n @extends {Super1}\n " +
+        "@extends {Super2} */function Sub() {};" +
+        "/** @override\n @param {string} bar */Sub.prototype.foo =\n" +
+        "function(bar) {};",
+        "mismatch of the foo property type and the type of the property it " +
+        "overrides from superclass Super2\n" +
+        "original: function (this:Super2, number): undefined\n" +
+        "override: function (this:Sub, string): undefined");
+  }
+
+  public void testMultipleExtendsInterfaceAssignment() throws Exception {
+    testTypes("/** @interface */var I1 = function() {};\n" +
+        "/** @interface */ var I2 = function() {}\n" +
+        "/** @interface\n@extends {I1}\n@extends {I2}*/" +
+        "var I3 = function() {};\n" +
+        "/** @constructor\n@implements {I3}*/var T = function() {};\n" +
+        "var t = new T();\n" +
+         "/** @type {I1} */var i1 = t;\n" +
+         "/** @type {I2} */var i2 = t;\n" +
+         "/** @type {I3} */var i3 = t;\n" +
+         "i1 = i3;\n" +
+         "i2 = i3;\n");
+  }
+
+  public void testMultipleExtendsInterfaceParamPass() throws Exception {
+    testTypes("/** @interface */var I1 = function() {};\n" +
+        "/** @interface */ var I2 = function() {}\n" +
+        "/** @interface\n@extends {I1}\n@extends {I2}*/" +
+        "var I3 = function() {};\n" +
+        "/** @constructor\n@implements {I3}*/var T = function() {};\n" +
+        "var t = new T();\n" +
+        "/** @param x I1 \n@param y I2\n@param z I3*/function foo(x,y,z){};\n" +
+        "foo(t,t,t)\n");
+  }
+
+  public void testBadMultipleExtendsClass() throws Exception {
+    testTypes("/** @constructor */ function base1() {}\n"
+        + "/** @constructor */ function base2() {}\n"
+        + "/** @constructor\n"
+        + "* @extends {base1}\n"
+        + "* @extends {base2}\n"
+        + "*/\n"
+        + "function derived() {}",
+        "Bad type annotation. type annotation incompatible "
+        + "with other annotations");
+  }
+
+  public void testInterfaceExtendsResolution() throws Exception {
+    testTypes("/** @interface \n @extends {A} */ function B() {};\n" +
+        "/** @constructor \n @implements {B} */ function C() {};\n" +
+        "/** @interface */ function A() {};");
+  }
+
+  public void testPropertyCanBeDefinedInObject() throws Exception {
+    testTypes("/** @interface */ function I() {};" +
+        "I.prototype.bar = function() {};" +
+        "/** @type {Object} */ var foo;" +
+        "foo.bar();");
+  }
+
   private void checkObjectType(ObjectType objectType, String propertyName,
         JSType expectedType) {
     assertTrue("Expected " + objectType.getReferenceName() +
@@ -7244,6 +9128,164 @@
         expectedType, objectType.getPropertyType(propertyName));
   }
 
+  public void testExtendedInterfacePropertiesCompatibility1() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
+        "function Int2() {};",
+        "Interface Int2 has a property foo with incompatible types in its " +
+        "super interfaces Int0 and Int1");
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility2() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @interface */function Int2() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @type {Object} */" +
+        "Int2.prototype.foo;" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} \n" +
+        "@extends {Int2}*/" +
+        "function Int3() {};",
+        new String[] {
+            "Interface Int3 has a property foo with incompatible types in " +
+            "its super interfaces Int0 and Int1",
+            "Interface Int3 has a property foo with incompatible types in " +
+            "its super interfaces Int1 and Int2"
+        });
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility3() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};",
+        "Interface Int3 has a property foo with incompatible types in its " +
+        "super interfaces Int0 and Int1");
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility4() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface \n @extends {Int0} */ function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @interface */function Int2() {};" +
+        "/** @interface \n @extends {Int2} */ function Int3() {};" +
+        "/** @type {string} */" +
+        "Int2.prototype.foo;" +
+        "/** @interface \n @extends {Int1} \n @extends {Int3} */" +
+        "function Int4() {};",
+        "Interface Int4 has a property foo with incompatible types in its " +
+        "super interfaces Int0 and Int2");
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility5() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};" +
+        "/** @interface */function Int4() {};" +
+        "/** @type {number} */" +
+        "Int4.prototype.foo;" +
+        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
+        "function Int5() {};",
+        new String[] {
+            "Interface Int3 has a property foo with incompatible types in its" +
+            " super interfaces Int0 and Int1",
+            "Interface Int5 has a property foo with incompatible types in its" +
+            " super interfaces Int1 and Int4"});
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility6() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};" +
+        "/** @interface */function Int4() {};" +
+        "/** @type {string} */" +
+        "Int4.prototype.foo;" +
+        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
+        "function Int5() {};",
+        "Interface Int3 has a property foo with incompatible types in its" +
+        " super interfaces Int0 and Int1");
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility7() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};" +
+        "/** @interface */function Int4() {};" +
+        "/** @type {Object} */" +
+        "Int4.prototype.foo;" +
+        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
+        "function Int5() {};",
+        new String[] {
+            "Interface Int3 has a property foo with incompatible types in its" +
+            " super interfaces Int0 and Int1",
+            "Interface Int5 has a property foo with incompatible types in its" +
+            " super interfaces Int1 and Int4"});
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility8() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.bar;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};" +
+        "/** @interface */function Int4() {};" +
+        "/** @type {Object} */" +
+        "Int4.prototype.foo;" +
+        "/** @type {Null} */" +
+        "Int4.prototype.bar;" +
+        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
+        "function Int5() {};",
+        new String[] {
+            "Interface Int5 has a property bar with incompatible types in its" +
+            " super interfaces Int1 and Int4",
+            "Interface Int5 has a property foo with incompatible types in its" +
+            " super interfaces Int0 and Int4"});
+  }
+
   private void testTypes(String js) throws Exception {
     testTypes(js, (String) null);
   }
@@ -7258,6 +9300,12 @@
 
   private void testClosureTypes(String js, String description)
       throws Exception {
+    testClosureTypesMultipleWarnings(js,
+        description == null ? null : Lists.newArrayList(description));
+  }
+
+  private void testClosureTypesMultipleWarnings(
+      String js, List<String> descriptions) throws Exception {
     Node n = compiler.parseTestCode(js);
     Node externs = new Node(Token.BLOCK);
     Node externAndJsRoot = new Node(Token.BLOCK, externs, n);
@@ -7268,7 +9316,7 @@
         0, compiler.getErrorCount());
 
     // For processing goog.addDependency for forward typedefs.
-    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)
+    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)
         .process(null, n);
 
     CodingConvention convention = compiler.getCodingConvention();
@@ -7281,16 +9329,25 @@
         registry)
         .processForTesting(null, n);
 
-    assertEquals(0, compiler.getErrorCount());
+    assertEquals(
+        "unexpected error(s) : " +
+        Joiner.on(", ").join(compiler.getErrors()),
+        0, compiler.getErrorCount());
 
-    if (description == null) {
+    if (descriptions == null) {
       assertEquals(
           "unexpected warning(s) : " +
           Joiner.on(", ").join(compiler.getWarnings()),
           0, compiler.getWarningCount());
     } else {
-      assertEquals(1, compiler.getWarningCount());
-      assertEquals(description, compiler.getWarnings()[0].description);
+      assertEquals(
+          "unexpected warning(s) : " +
+          Joiner.on(", ").join(compiler.getWarnings()),
+          descriptions.size(), compiler.getWarningCount());
+      for (int i = 0; i < descriptions.size(); i++) {
+        assertEquals(descriptions.get(i),
+            compiler.getWarnings()[i].description);
+      }
     }
   }
 
@@ -7352,8 +9409,9 @@
         Lists.newArrayList(JSSourceFile.fromCode("[testcode]", js)),
         compiler.getOptions());
 
-    Node n = compiler.getInput("[testcode]").getAstRoot(compiler);
-    Node externsNode = compiler.getInput("[externs]").getAstRoot(compiler);
+    Node n = compiler.getInput(new InputId("[testcode]")).getAstRoot(compiler);
+    Node externsNode = compiler.getInput(new InputId("[externs]"))
+        .getAstRoot(compiler);
     Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);
     externAndJsRoot.setIsSyntheticBlock(true);
 
