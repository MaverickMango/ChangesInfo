===
insert-node
---
Javadoc [855,2728]
to
TypeDeclaration [856,2882]
at 0
===
insert-node
---
TagElement [862,2690]
to
Javadoc [855,2728]
at 0
===
move-tree
---
TagElement [1554,1564]
    TextElement:  3.0 [1560,1564]
to
Javadoc [855,2728]
at 1
===
move-tree
---
TagElement [1568,1581]
    TextElement:  $Id$ [1576,1581]
to
Javadoc [855,2728]
at 2
===
move-tree
---
TextElement: Implements the <em>Regula Falsi</em> or <em>False position</em> method for [863,937]
to
TagElement [862,2690]
at 0
===
move-tree
---
TextElement: root-finding (approximating a zero of a univariate real function). It is a [941,1015]
to
TagElement [862,2690]
at 1
===
move-tree
---
TextElement: modified  [1019,1028]
to
TagElement [862,2690]
at 2
===
move-tree
---
TagElement [1028,1064]
    SimpleName: SecantSolver [1035,1047]
    TextElement:  <em>Secant</em> [1047,1063]
to
TagElement [862,2690]
at 3
===
insert-node
---
TextElement:  method. [1063,1071]
to
TagElement [862,2690]
at 4
===
insert-node
---
TextElement: <p>The <em>Regula Falsi</em> method is included for completeness, for [1078,1147]
to
TagElement [862,2690]
at 5
===
insert-node
---
TextElement: testing purposes, for educational purposes, for comparison to other [1151,1218]
to
TagElement [862,2690]
at 6
===
insert-node
---
TextElement: algorithms, etc. It is however <strong>not</strong> intended to be used [1222,1293]
to
TagElement [862,2690]
at 7
===
insert-node
---
TextElement: for actual problems, as one of the bounds often remains fixed, resulting [1297,1369]
to
TagElement [862,2690]
at 8
===
insert-node
---
TextElement: in very slow convergence. Instead, one of the well-known modified [1373,1438]
to
TagElement [862,2690]
at 9
===
insert-node
---
TextElement: <em>Regula Falsi</em> algorithms can be used ( [1442,1488]
to
TagElement [862,2690]
at 10
===
insert-tree
---
TagElement [1488,1531]
    SimpleName: IllinoisSolver [1495,1509]
    TextElement: <em>Illinois</em> [1513,1530]
to
TagElement [862,2690]
at 11
===
insert-node
---
TextElement:  or  [1531,1535]
to
TagElement [862,2690]
at 12
===
insert-tree
---
TagElement [1535,1573]
    SimpleName: PegasusSolver [1542,1555]
    TextElement:  <em>Pegasus</em> [1555,1572]
to
TagElement [862,2690]
at 13
===
insert-node
---
TextElement: ). These two [1573,1585]
to
TagElement [862,2690]
at 14
===
insert-node
---
TextElement: algorithms solve the fundamental issues of the original <em>Regula [1589,1655]
to
TagElement [862,2690]
at 15
===
insert-node
---
TextElement: Falsi</em> algorithm, and greatly out-performs it for most, if not all, [1659,1730]
to
TagElement [862,2690]
at 16
===
insert-node
---
TextElement: (practical) functions. [1734,1756]
to
TagElement [862,2690]
at 17
===
insert-node
---
TextElement: <p>Unlike the <em>Secant</em> method, the <em>Regula Falsi</em> guarantees [1763,1837]
to
TagElement [862,2690]
at 18
===
insert-node
---
TextElement: convergence, by maintaining a bracketed solution. Note however, that due to [1841,1916]
to
TagElement [862,2690]
at 19
===
insert-node
---
TextElement: the finite/limited precision of Java's  [1920,1959]
to
TagElement [862,2690]
at 20
===
insert-tree
---
TagElement [1959,1980]
    SimpleName: Double [1966,1972]
    TextElement:  double [1972,1979]
to
TagElement [862,2690]
at 21
===
insert-node
---
TextElement:  type, which is [1980,1995]
to
TagElement [862,2690]
at 22
===
insert-node
---
TextElement: used in this implementation, the algorithm may get stuck in a situation [1999,2070]
to
TagElement [862,2690]
at 23
===
insert-node
---
TextElement: where it no longer makes any progress. Such cases are detected and result [2074,2147]
to
TagElement [862,2690]
at 24
===
insert-node
---
TextElement: in a  [2151,2156]
to
TagElement [862,2690]
at 25
===
insert-tree
---
TagElement [2156,2184]
    TextElement:  ConvergenceException [2162,2183]
to
TagElement [862,2690]
at 26
===
insert-node
---
TextElement:  exception being thrown. In other words, [2184,2224]
to
TagElement [862,2690]
at 27
===
insert-node
---
TextElement: the algorithm theoretically guarantees convergence, but the implementation [2228,2302]
to
TagElement [862,2690]
at 28
===
insert-node
---
TextElement: does not.</p> [2306,2319]
to
TagElement [862,2690]
at 29
===
move-tree
---
TextElement: <p>The <em>Regula Falsi</em> method assumes that the function is continuous, [1183,1259]
to
TagElement [862,2690]
at 30
===
move-tree
---
TextElement: but not necessarily smooth.</p> [1263,1294]
to
TagElement [862,2690]
at 31
===
move-tree
---
TextElement: <p>Implementation based on the following article: M. Dowell and P. Jarratt, [1301,1376]
to
TagElement [862,2690]
at 32
===
move-tree
---
TextElement: <em>A modified regula falsi method for computing the root of an [1380,1443]
to
TagElement [862,2690]
at 33
===
move-tree
---
TextElement: equation</em>, BIT Numerical Mathematics, volume 11, number 2, [1447,1509]
to
TagElement [862,2690]
at 34
===
move-tree
---
TextElement: pages 168-174, Springer, 1971.</p> [1513,1547]
to
TagElement [862,2690]
at 35
===
update-node
---
TextElement:  absolute accuracy [1880,1898]
replace  absolute accuracy by  Absolute accuracy.
===
update-node
---
TextElement:  relative accuracy [2102,2120]
replace  relative accuracy by  Relative accuracy.
===
update-node
---
TextElement:  absolute accuracy [2151,2169]
replace  absolute accuracy by  Absolute accuracy.
===
update-node
---
TextElement:  relative accuracy [2451,2469]
replace  relative accuracy by  Relative accuracy.
===
update-node
---
TextElement:  absolute accuracy [2500,2518]
replace  absolute accuracy by  Absolute accuracy.
===
delete-node
---
TextElement:  method. Unlike the [1064,1083]
===
===
delete-node
---
TextElement: <em>Secant</em> method, convergence is guaranteed by maintaining a [1087,1153]
===
===
delete-node
---
TextElement: bracketed solution. [1157,1176]
===
===
delete-node
---
TagElement [863,1547]
===
===
delete-node
---
Javadoc [856,1585]
===
