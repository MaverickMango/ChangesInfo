Only in inducing/: javadoc
diff -r -u inducing/src/com/google/javascript/jscomp/TypeCheck.java buggy/src/com/google/javascript/jscomp/TypeCheck.java
--- inducing/src/com/google/javascript/jscomp/TypeCheck.java	2023-06-12 11:40:32.502438586 +0800
+++ buggy/src/com/google/javascript/jscomp/TypeCheck.java	2023-06-12 11:40:32.250450041 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006 Google Inc.
+ * Copyright 2006 The Closure Compiler Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,13 +24,13 @@
 import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;
 import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE;
 import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;
-import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;
 import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;
 import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;
 
 import com.google.common.base.Preconditions;
-import com.google.javascript.jscomp.CheckLevel;
+import com.google.common.collect.ImmutableSet;
 import com.google.javascript.jscomp.Scope.Var;
+import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
 import com.google.javascript.rhino.JSDocInfo;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
@@ -40,9 +40,15 @@
 import com.google.javascript.rhino.jstype.JSTypeNative;
 import com.google.javascript.rhino.jstype.JSTypeRegistry;
 import com.google.javascript.rhino.jstype.ObjectType;
+import com.google.javascript.rhino.jstype.TemplateTypeMap;
+import com.google.javascript.rhino.jstype.TemplateTypeMapReplacer;
 import com.google.javascript.rhino.jstype.TernaryValue;
+import com.google.javascript.rhino.jstype.UnionType;
 
+import java.lang.reflect.Method;
+import java.util.HashMap;
 import java.util.Iterator;
+import java.util.Set;
 
 /**
  * <p>Checks the types of JS expressions against any declared type
@@ -60,16 +66,6 @@
 
 
   //
-  // User errors
-  //
-  static final DiagnosticType BAD_DELETE =
-      // TODO(user): make this an error
-      DiagnosticType.warning(
-          "JSC_BAD_DELETE_OPERAND",
-          "delete operator needs a reference operand");
-
-
-  //
   // User warnings
   //
 
@@ -85,13 +81,6 @@
           "left : {0}\n" +
           "right: {1}");
 
-  static final DiagnosticType DETERMINISTIC_TEST_NO_RESULT =
-      DiagnosticType.warning(
-          "JSC_DETERMINISTIC_TEST_NO_RESULT",
-          "condition always evaluates to the same value\n" +
-          "left : {0}\n" +
-          "right: {1}");
-
   static final DiagnosticType INEXISTENT_ENUM_ELEMENT =
       DiagnosticType.warning(
           "JSC_INEXISTENT_ENUM_ELEMENT",
@@ -104,6 +93,11 @@
           "JSC_INEXISTENT_PROPERTY",
           "Property {0} never defined on {1}");
 
+  static final DiagnosticType INEXISTENT_PROPERTY_WITH_SUGGESTION =
+      DiagnosticType.disabled(
+          "JSC_INEXISTENT_PROPERTY",
+          "Property {0} never defined on {1}. Did you mean {2}?");
+
   protected static final DiagnosticType NOT_A_CONSTRUCTOR =
       DiagnosticType.warning(
           "JSC_NOT_A_CONSTRUCTOR",
@@ -151,12 +145,21 @@
           "JSC_INTERFACE_FUNCTION_NOT_EMPTY",
           "interface member functions must have an empty body");
 
+  static final DiagnosticType CONFLICTING_SHAPE_TYPE =
+      DiagnosticType.warning(
+          "JSC_CONFLICTING_SHAPE_TYPE",
+          "{1} cannot extend this type; {0}s can only extend {0}s");
+
   static final DiagnosticType CONFLICTING_EXTENDED_TYPE =
       DiagnosticType.warning(
           "JSC_CONFLICTING_EXTENDED_TYPE",
-          "{0} cannot extend this type; " +
-          "a constructor can only extend objects " +
-          "and an interface can only extend interfaces");
+          "{1} cannot extend this type; {0}s can only extend {0}s");
+
+  static final DiagnosticType CONFLICTING_IMPLEMENTED_TYPE =
+    DiagnosticType.warning(
+        "JSC_CONFLICTING_IMPLEMENTED_TYPE",
+        "{0} cannot implement this type; " +
+        "an interface can only extend, but not implement interfaces");
 
   static final DiagnosticType BAD_IMPLEMENTED_TYPE =
       DiagnosticType.warning(
@@ -182,14 +185,6 @@
           "original: {2}\n" +
           "override: {3}");
 
-  static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH =
-      DiagnosticType.warning(
-          "JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH",
-          "mismatch of the {0} property type and the type " +
-          "of the property it overrides from interface {1}\n" +
-          "original: {2}\n" +
-          "override: {3}");
-
   static final DiagnosticType UNKNOWN_OVERRIDE =
       DiagnosticType.warning(
           "JSC_UNKNOWN_OVERRIDE",
@@ -201,7 +196,7 @@
           "property {0} is already defined by the {1} extended interface");
 
   static final DiagnosticType UNKNOWN_EXPR_TYPE =
-      DiagnosticType.warning("JSC_UNKNOWN_EXPR_TYPE",
+      DiagnosticType.disabled("JSC_UNKNOWN_EXPR_TYPE",
           "could not determine the type of this expression");
 
   static final DiagnosticType UNRESOLVED_TYPE =
@@ -220,9 +215,36 @@
           "Illegal annotation on {0}. @implicitCast may only be used in " +
           "externs.");
 
+  static final DiagnosticType INCOMPATIBLE_EXTENDED_PROPERTY_TYPE =
+      DiagnosticType.warning(
+          "JSC_INCOMPATIBLE_EXTENDED_PROPERTY_TYPE",
+          "Interface {0} has a property {1} with incompatible types in " +
+          "its super interfaces {2} and {3}");
+
+  static final DiagnosticType EXPECTED_THIS_TYPE =
+      DiagnosticType.warning(
+          "JSC_EXPECTED_THIS_TYPE",
+          "\"{0}\" must be called with a \"this\" type");
+
+  static final DiagnosticType IN_USED_WITH_STRUCT =
+      DiagnosticType.warning("JSC_IN_USED_WITH_STRUCT",
+                             "Cannot use the IN operator with structs");
+
+  static final DiagnosticType ILLEGAL_PROPERTY_CREATION =
+      DiagnosticType.warning("JSC_ILLEGAL_PROPERTY_CREATION",
+                             "Cannot add a property to a struct instance " +
+                             "after it is constructed.");
+
+  static final DiagnosticType ILLEGAL_OBJLIT_KEY =
+      DiagnosticType.warning(
+          "ILLEGAL_OBJLIT_KEY",
+          "Illegal key, the object literal is a {0}");
+
+  // If a diagnostic is disabled by default, do not add it in this list
+  // TODO(user): Either INEXISTENT_PROPERTY shouldn't be here, or we should
+  // change DiagnosticGroups.setWarningLevel to not accidentally enable it.
   static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup(
       DETERMINISTIC_TEST,
-      DETERMINISTIC_TEST_NO_RESULT,
       INEXISTENT_ENUM_ELEMENT,
       INEXISTENT_PROPERTY,
       NOT_A_CONSTRUCTOR,
@@ -235,18 +257,29 @@
       ENUM_NOT_CONSTANT,
       INVALID_INTERFACE_MEMBER_DECLARATION,
       INTERFACE_FUNCTION_NOT_EMPTY,
+      CONFLICTING_SHAPE_TYPE,
       CONFLICTING_EXTENDED_TYPE,
+      CONFLICTING_IMPLEMENTED_TYPE,
       BAD_IMPLEMENTED_TYPE,
       HIDDEN_SUPERCLASS_PROPERTY,
       HIDDEN_INTERFACE_PROPERTY,
       HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,
-      HIDDEN_INTERFACE_PROPERTY_MISMATCH,
       UNKNOWN_OVERRIDE,
       INTERFACE_METHOD_OVERRIDE,
-      UNKNOWN_EXPR_TYPE,
       UNRESOLVED_TYPE,
       WRONG_ARGUMENT_COUNT,
-      ILLEGAL_IMPLICIT_CAST);
+      ILLEGAL_IMPLICIT_CAST,
+      INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,
+      EXPECTED_THIS_TYPE,
+      IN_USED_WITH_STRUCT,
+      ILLEGAL_PROPERTY_CREATION,
+      ILLEGAL_OBJLIT_KEY,
+      RhinoErrorReporter.TYPE_PARSE_ERROR,
+      TypedScopeCreator.UNKNOWN_LENDS,
+      TypedScopeCreator.LENDS_ON_NON_OBJECT,
+      TypedScopeCreator.CTOR_INITIALIZER,
+      TypedScopeCreator.IFACE_INITIALIZER,
+      FunctionTypeBuilder.THIS_TYPE_NON_OBJECT);
 
   private final AbstractCompiler compiler;
   private final TypeValidator validator;
@@ -256,10 +289,10 @@
   private final JSTypeRegistry typeRegistry;
   private Scope topScope;
 
-  private ScopeCreator scopeCreator;
+  private MemoizedScopeCreator scopeCreator;
 
   private final CheckLevel reportMissingOverride;
-  private final CheckLevel reportUnknownTypes;
+  private final boolean reportUnknownTypes;
 
   // This may be expensive, so don't emit these warnings if they're
   // explicitly turned off.
@@ -277,13 +310,23 @@
   // code.
   private int noTypeCheckSection = 0;
 
+  private Method editDistance;
+
+  private static final class SuggestionPair {
+    private final String suggestion;
+    final int distance;
+    private SuggestionPair(String suggestion, int distance) {
+      this.suggestion = suggestion;
+      this.distance = distance;
+    }
+  }
+
   public TypeCheck(AbstractCompiler compiler,
       ReverseAbstractInterpreter reverseInterpreter,
       JSTypeRegistry typeRegistry,
       Scope topScope,
-      ScopeCreator scopeCreator,
-      CheckLevel reportMissingOverride,
-      CheckLevel reportUnknownTypes) {
+      MemoizedScopeCreator scopeCreator,
+      CheckLevel reportMissingOverride) {
     this.compiler = compiler;
     this.validator = compiler.getTypeValidator();
     this.reverseInterpreter = reverseInterpreter;
@@ -291,24 +334,34 @@
     this.topScope = topScope;
     this.scopeCreator = scopeCreator;
     this.reportMissingOverride = reportMissingOverride;
-    this.reportUnknownTypes = reportUnknownTypes;
+    this.reportUnknownTypes = ((Compiler) compiler).getOptions().enables(
+        DiagnosticGroups.REPORT_UNKNOWN_TYPES);
     this.inferJSDocInfo = new InferJSDocInfo(compiler);
+
+    ClassLoader classLoader = TypeCheck.class.getClassLoader();
+    try {
+      Class<?> c = classLoader.loadClass(
+          "com.google.common.string.EditDistance");
+      editDistance = c.getDeclaredMethod(
+          "getEditDistance", String.class, String.class, boolean.class);
+    } catch (Exception ignored) {
+      editDistance = null;
+    }
   }
 
   public TypeCheck(AbstractCompiler compiler,
       ReverseAbstractInterpreter reverseInterpreter,
       JSTypeRegistry typeRegistry,
-      CheckLevel reportMissingOverride,
-      CheckLevel reportUnknownTypes) {
+      CheckLevel reportMissingOverride) {
     this(compiler, reverseInterpreter, typeRegistry, null, null,
-        reportMissingOverride, reportUnknownTypes);
+        reportMissingOverride);
   }
 
   TypeCheck(AbstractCompiler compiler,
       ReverseAbstractInterpreter reverseInterpreter,
       JSTypeRegistry typeRegistry) {
     this(compiler, reverseInterpreter, typeRegistry, null, null,
-         CheckLevel.WARNING, CheckLevel.OFF);
+         CheckLevel.WARNING);
   }
 
   /** Turn on the missing property check. Returns this for easy chaining. */
@@ -324,6 +377,7 @@
    * @param externsRoot The root of the externs parse tree.
    * @param jsRoot The root of the input parse tree to be checked.
    */
+  @Override
   public void process(Node externsRoot, Node jsRoot) {
     Preconditions.checkNotNull(scopeCreator);
     Preconditions.checkNotNull(topScope);
@@ -401,15 +455,14 @@
     }
   }
 
+  @Override
   public boolean shouldTraverse(
       NodeTraversal t, Node n, Node parent) {
     checkNoTypeCheckSection(n, true);
     switch (n.getType()) {
       case Token.FUNCTION:
         // normal type checking
-        final TypeCheck outerThis = this;
         final Scope outerScope = t.getScope();
-        final FunctionType functionType = (FunctionType) n.getJSType();
         final String functionPrivateName = n.getFirstChild().getString();
         if (functionPrivateName != null && functionPrivateName.length() > 0 &&
             outerScope.isDeclared(functionPrivateName, false) &&
@@ -439,6 +492,7 @@
    * @param n The node being visited.
    * @param parent The parent of the node n.
    */
+  @Override
   public void visit(NodeTraversal t, Node n, Node parent) {
     JSType childType;
     JSType leftType, rightType;
@@ -447,18 +501,29 @@
     boolean typeable = true;
 
     switch (n.getType()) {
+      case Token.CAST:
+        Node expr = n.getFirstChild();
+        JSType exprType = getJSType(expr);
+        JSType castType = getJSType(n);
+
+        // TODO(johnlenz): determine if we can limit object literals in some
+        // way.
+        if (!expr.isObjectLit()) {
+          validator.expectCanCast(t, n, castType, exprType);
+        }
+        ensureTyped(t, n, castType);
+
+        if (castType.isSubtype(exprType) || expr.isObjectLit()) {
+          expr.setJSType(castType);
+        }
+        break;
+
       case Token.NAME:
         typeable = visitName(t, n, parent);
         break;
 
-      case Token.LP:
-        // If this is under a FUNCTION node, it is a parameter list and can be
-        // ignored here.
-        if (parent.getType() != Token.FUNCTION) {
-          ensureTyped(t, n, getJSType(n.getFirstChild()));
-        } else {
-          typeable = false;
-        }
+      case Token.PARAM_LIST:
+        typeable = false;
         break;
 
       case Token.COMMA:
@@ -474,36 +539,29 @@
         ensureTyped(t, n, t.getScope().getTypeOfThis());
         break;
 
-      case Token.REF_SPECIAL:
-        ensureTyped(t, n);
+      case Token.NULL:
+        ensureTyped(t, n, NULL_TYPE);
         break;
 
-      case Token.GET_REF:
-        ensureTyped(t, n, getJSType(n.getFirstChild()));
+      case Token.NUMBER:
+        ensureTyped(t, n, NUMBER_TYPE);
         break;
 
-      case Token.NULL:
-        ensureTyped(t, n, NULL_TYPE);
+      case Token.STRING:
+        ensureTyped(t, n, STRING_TYPE);
         break;
 
-      case Token.NUMBER:
-        if (n.getParent().getType() != Token.OBJECTLIT) {
-          ensureTyped(t, n, NUMBER_TYPE);
-        } else {
-          typeable = false;
-        }
+      case Token.STRING_KEY:
+        typeable = false;
         break;
 
-      case Token.ARRAYLIT:
-        ensureTyped(t, n, ARRAY_TYPE);
+      case Token.GETTER_DEF:
+      case Token.SETTER_DEF:
+        // Object literal keys are handled with OBJECTLIT
         break;
 
-      case Token.STRING:
-        if (n.getParent().getType() != Token.OBJECTLIT) {
-          ensureTyped(t, n, STRING_TYPE);
-        } else {
-          typeable = false;
-        }
+      case Token.ARRAYLIT:
+        ensureTyped(t, n, ARRAY_TYPE);
         break;
 
       case Token.REGEXP:
@@ -512,7 +570,7 @@
 
       case Token.GETPROP:
         visitGetProp(t, n, parent);
-        typeable = !(parent.getType() == Token.ASSIGN &&
+        typeable = !(parent.isAssign() &&
                      parent.getFirstChild() == n);
         break;
 
@@ -531,12 +589,11 @@
 
       case Token.NEW:
         visitNew(t, n);
-        typeable = true;
         break;
 
       case Token.CALL:
         visitCall(t, n);
-        typeable = !NodeUtil.isExpressionNode(parent);
+        typeable = !parent.isExprResult();
         break;
 
       case Token.RETURN:
@@ -547,8 +604,8 @@
       case Token.DEC:
       case Token.INC:
         left = n.getFirstChild();
-        validator.expectNumber(
-            t, left, getJSType(left), "increment/decrement");
+        checkPropCreation(t, left);
+        validator.expectNumber(t, left, getJSType(left), "increment/decrement");
         ensureTyped(t, n, NUMBER_TYPE);
         break;
 
@@ -581,36 +638,53 @@
         break;
 
       case Token.EQ:
-      case Token.NE: {
-        leftType = getJSType(n.getFirstChild());
-        rightType = getJSType(n.getLastChild());
+      case Token.NE:
+      case Token.SHEQ:
+      case Token.SHNE: {
+        left = n.getFirstChild();
+        right = n.getLastChild();
 
-        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
-        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
-        TernaryValue result =
-            leftTypeRestricted.testForEquality(rightTypeRestricted);
-        if (result != TernaryValue.UNKNOWN) {
-          if (n.getType() == Token.NE) {
-            result = result.not();
+        if (left.isTypeOf()) {
+          if (right.isString()) {
+            checkTypeofString(t, right, right.getString());
           }
-          report(t, n, DETERMINISTIC_TEST, leftType.toString(),
-              rightType.toString(), result.toString());
+        } else if (right.isTypeOf() && left.isString()) {
+          checkTypeofString(t, left, left.getString());
         }
-        ensureTyped(t, n, BOOLEAN_TYPE);
-        break;
-      }
 
-      case Token.SHEQ:
-      case Token.SHNE: {
-        leftType = getJSType(n.getFirstChild());
-        rightType = getJSType(n.getLastChild());
+        leftType = getJSType(left);
+        rightType = getJSType(right);
 
+        // We do not want to warn about explicit comparisons to VOID. People
+        // often do this if they think their type annotations screwed up.
+        //
+        // We do want to warn about cases where people compare things like
+        // (Array|null) == (Function|null)
+        // because it probably means they screwed up.
+        //
+        // This heuristic here is not perfect, but should catch cases we
+        // care about without too many false negatives.
         JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
         JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
-        if (!leftTypeRestricted.canTestForShallowEqualityWith(
-                rightTypeRestricted)) {
-          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
-              rightType.toString());
+
+        TernaryValue result = TernaryValue.UNKNOWN;
+        if (n.getType() == Token.EQ || n.getType() == Token.NE) {
+          result = leftTypeRestricted.testForEquality(rightTypeRestricted);
+          if (n.isNE()) {
+            result = result.not();
+          }
+        } else {
+          // SHEQ or SHNE
+          if (!leftTypeRestricted.canTestForShallowEqualityWith(
+                  rightTypeRestricted)) {
+            result = n.getType() == Token.SHEQ ?
+                TernaryValue.FALSE : TernaryValue.TRUE;
+          }
+        }
+
+        if (result != TernaryValue.UNKNOWN) {
+          report(t, n, DETERMINISTIC_TEST, leftType.toString(),
+              rightType.toString(), result.toString());
         }
         ensureTyped(t, n, BOOLEAN_TYPE);
         break;
@@ -637,11 +711,11 @@
           // should match a string context.
           String message = "left side of comparison";
           validator.expectString(t, n, leftType, message);
-          validator.expectNotVoid(
+          validator.expectNotNullOrUndefined(
               t, n, leftType, message, getNativeType(STRING_TYPE));
           message = "right side of comparison";
           validator.expectString(t, n, rightType, message);
-          validator.expectNotVoid(
+          validator.expectNotNullOrUndefined(
               t, n, rightType, message, getNativeType(STRING_TYPE));
         }
         ensureTyped(t, n, BOOLEAN_TYPE);
@@ -650,21 +724,21 @@
       case Token.IN:
         left = n.getFirstChild();
         right = n.getLastChild();
-        leftType = getJSType(left);
         rightType = getJSType(right);
+        validator.expectString(t, left, getJSType(left), "left side of 'in'");
         validator.expectObject(t, n, rightType, "'in' requires an object");
-        validator.expectString(t, left, leftType, "left side of 'in'");
+        if (rightType.isStruct()) {
+          report(t, right, IN_USED_WITH_STRUCT);
+        }
         ensureTyped(t, n, BOOLEAN_TYPE);
         break;
 
       case Token.INSTANCEOF:
         left = n.getFirstChild();
         right = n.getLastChild();
-        leftType = getJSType(left);
         rightType = getJSType(right).restrictByNotNullOrUndefined();
-
         validator.expectAnyObject(
-            t, left, leftType, "deterministic instanceof yields false");
+            t, left, getJSType(left), "deterministic instanceof yields false");
         validator.expectActualObject(
             t, right, rightType, "instanceof requires an object");
         ensureTyped(t, n, BOOLEAN_TYPE);
@@ -686,6 +760,9 @@
       case Token.ASSIGN_SUB:
       case Token.ASSIGN_ADD:
       case Token.ASSIGN_MUL:
+        checkPropCreation(t, n.getFirstChild());
+        // fall through
+
       case Token.LSH:
       case Token.RSH:
       case Token.URSH:
@@ -701,9 +778,6 @@
         break;
 
       case Token.DELPROP:
-        if (!isReference(n.getFirstChild())) {
-          report(t, n, BAD_DELETE);
-        }
         ensureTyped(t, n, BOOLEAN_TYPE);
         break;
 
@@ -717,8 +791,7 @@
       case Token.WITH: {
         Node child = n.getFirstChild();
         childType = getJSType(child);
-        validator.expectObject(
-            t, child, childType, "with requires an object");
+        validator.expectObject(t, child, childType, "with requires an object");
         typeable = false;
         break;
       }
@@ -738,7 +811,7 @@
       case Token.EXPR_RESULT:
       case Token.BLOCK:
       case Token.EMPTY:
-      case Token.DEFAULT:
+      case Token.DEFAULT_CASE:
       case Token.CONTINUE:
       case Token.DEBUGGER:
       case Token.THROW:
@@ -747,12 +820,21 @@
 
       // These nodes require data flow analysis.
       case Token.DO:
-      case Token.FOR:
       case Token.IF:
       case Token.WHILE:
         typeable = false;
         break;
 
+      case Token.FOR:
+        if (NodeUtil.isForIn(n)) {
+          Node obj = n.getChildAtIndex(1);
+          if (getJSType(obj).isStruct()) {
+            report(t, obj, IN_USED_WITH_STRUCT);
+          }
+        }
+        typeable = false;
+        break;
+
       // These nodes are typed during the type inference.
       case Token.AND:
       case Token.HOOK:
@@ -762,13 +844,19 @@
           ensureTyped(t, n);
         } else {
           // If this is an enum, then give that type to the objectlit as well.
-          if ((n.getType() == Token.OBJECTLIT)
+          if ((n.isObjectLit())
               && (parent.getJSType() instanceof EnumType)) {
             ensureTyped(t, n, parent.getJSType());
           } else {
             ensureTyped(t, n);
           }
         }
+        if (n.isObjectLit()) {
+          JSType typ = getJSType(n);
+          for (Node key : n.children()) {
+            visitObjLitKey(t, key, n, typ);
+          }
+        }
         break;
 
       default:
@@ -787,6 +875,14 @@
     checkNoTypeCheckSection(n, false);
   }
 
+  private void checkTypeofString(NodeTraversal t, Node n, String s) {
+    if (!(s.equals("number") || s.equals("string") || s.equals("boolean") ||
+          s.equals("undefined") || s.equals("function") ||
+          s.equals("object") || s.equals("unknown"))) {
+      validator.expectValidTypeofName(t, n, s);
+    }
+  }
+
   /**
    * Counts the given node in the typed statistics.
    * @param n a node that should be typed
@@ -796,9 +892,8 @@
     if (type == null) {
       nullCount++;
     } else if (type.isUnknownType()) {
-      if (reportUnknownTypes.isOn()) {
-        compiler.report(
-            t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE));
+      if (reportUnknownTypes) {
+        compiler.report(t.makeError(n, UNKNOWN_EXPR_TYPE));
       }
       unknownCount++;
     } else {
@@ -812,105 +907,109 @@
    * of the object type it is referring to.
    * @param t the traversal
    * @param assign the assign node
-   * (<code>assign.getType() == Token.ASSIGN</code> is an implicit invariant)
+   * (<code>assign.isAssign()</code> is an implicit invariant)
    */
   private void visitAssign(NodeTraversal t, Node assign) {
     JSDocInfo info = assign.getJSDocInfo();
     Node lvalue = assign.getFirstChild();
     Node rvalue = assign.getLastChild();
 
-    if (lvalue.getType() == Token.GETPROP) {
+    // Check property sets to 'object.property' when 'object' is known.
+    if (lvalue.isGetProp()) {
       Node object = lvalue.getFirstChild();
       JSType objectJsType = getJSType(object);
-      String property = lvalue.getLastChild().getString();
+      Node property = lvalue.getLastChild();
+      String pname = property.getString();
 
       // the first name in this getprop refers to an interface
       // we perform checks in addition to the ones below
-      if (object.getType() == Token.GETPROP) {
+      if (object.isGetProp()) {
         JSType jsType = getJSType(object.getFirstChild());
         if (jsType.isInterface() &&
             object.getLastChild().getString().equals("prototype")) {
-          visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);
+          visitInterfaceGetprop(t, assign, object, pname, lvalue, rvalue);
         }
       }
 
-      // /** @type ... */object.name = ...;
-      if (info != null && info.hasType()) {
-        visitAnnotatedAssignGetprop(t, assign,
-            info.getType().evaluate(t.getScope(), typeRegistry), object,
-            property, rvalue);
-        return;
-      }
-
-      // /** @enum ... */object.name = ...;
-      if (info != null && info.hasEnumParameterType()) {
-        checkEnumInitializer(
-            t, rvalue, info.getEnumParameterType().evaluate(
-                t.getScope(), typeRegistry));
-        return;
-      }
+      checkEnumAlias(t, info, rvalue);
+      checkPropCreation(t, lvalue);
 
+      // Prototype assignments are special, because they actually affect
+      // the definition of a class. These are mostly validated
+      // during TypedScopeCreator, and we only look for the "dumb" cases here.
       // object.prototype = ...;
-      if (property.equals("prototype")) {
-        if (objectJsType instanceof FunctionType) {
-          FunctionType functionType = (FunctionType) objectJsType;
+      if (pname.equals("prototype")) {
+        if (objectJsType != null && objectJsType.isFunctionType()) {
+          FunctionType functionType = objectJsType.toMaybeFunctionType();
           if (functionType.isConstructor()) {
             JSType rvalueType = rvalue.getJSType();
             validator.expectObject(t, rvalue, rvalueType,
                 OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);
-          }
-        } else {
-          // TODO(user): might want to flag that
-        }
-        return;
-      }
-
-      // object.prototype.property = ...;
-      if (object.getType() == Token.GETPROP) {
-        Node object2 = object.getFirstChild();
-        String property2 = NodeUtil.getStringValue(object.getLastChild());
-
-        if ("prototype".equals(property2)) {
-          JSType jsType = object2.getJSType();
-          if (jsType instanceof FunctionType) {
-            FunctionType functionType = (FunctionType) jsType;
-            if (functionType.isConstructor() || functionType.isInterface()) {
-              checkDeclaredPropertyInheritance(
-                  t, assign, functionType, property, info, getJSType(rvalue));
+            // Only assign structs to the prototype of a @struct constructor
+            if (functionType.makesStructs() && !rvalueType.isStruct()) {
+              String funName = functionType.getTypeOfThis().toString();
+              compiler.report(t.makeError(assign, CONFLICTING_SHAPE_TYPE,
+                                          "struct", funName));
             }
-          } else {
-            // TODO(user): might want to flag that
+            return;
           }
-          return;
         }
       }
 
+      // The generic checks for 'object.property' when 'object' is known,
+      // and 'property' is declared on it.
       // object.property = ...;
       ObjectType type = ObjectType.cast(
           objectJsType.restrictByNotNullOrUndefined());
       if (type != null) {
-        if (type.hasProperty(property) &&
-            !type.isPropertyTypeInferred(property) &&
-            !propertyIsImplicitCast(type, property)) {
-          validator.expectCanAssignToPropertyOf(
-              t, assign, getJSType(rvalue),
-              type.getPropertyType(property), object, property);
+        if (type.hasProperty(pname) &&
+            !type.isPropertyTypeInferred(pname) &&
+            !propertyIsImplicitCast(type, pname)) {
+          JSType expectedType = type.getPropertyType(pname);
+          if (!expectedType.isUnknownType()) {
+            validator.expectCanAssignToPropertyOf(
+                t, assign, getJSType(rvalue),
+                expectedType, object, pname);
+            checkPropertyInheritanceOnGetpropAssign(
+                t, assign, object, pname, info, expectedType);
+            return;
+          }
         }
-        return;
       }
-    } else if (lvalue.getType() == Token.NAME) {
+
+      // If we couldn't get the property type with normal object property
+      // lookups, then check inheritance anyway with the unknown type.
+      checkPropertyInheritanceOnGetpropAssign(
+          t, assign, object, pname, info, getNativeType(UNKNOWN_TYPE));
+    }
+
+    // Check qualified name sets to 'object' and 'object.property'.
+    // This can sometimes handle cases when the type of 'object' is not known.
+    // e.g.,
+    // var obj = createUnknownType();
+    // /** @type {number} */ obj.foo = true;
+    JSType leftType = getJSType(lvalue);
+    if (lvalue.isQualifiedName()) {
       // variable with inferred type case
-      JSType rvalueType = getJSType(assign.getLastChild());
-      Var var = t.getScope().getVar(lvalue.getString());
+      Var var = t.getScope().getVar(lvalue.getQualifiedName());
       if (var != null) {
         if (var.isTypeInferred()) {
           return;
         }
+
+        if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() &&
+            t.getScope() != var.getScope()) {
+          // Don't look at "this.foo" variables from other scopes.
+          return;
+        }
+
+        if (var.getType() != null) {
+          leftType = var.getType();
+        }
       }
     }
 
-    // fall through case
-    JSType leftType = getJSType(lvalue);
+    // Fall through case for arbitrary LHS and arbitrary RHS.
     Node rightChild = assign.getLastChild();
     JSType rightType = getJSType(rightChild);
     if (validator.expectCanAssignTo(
@@ -922,7 +1021,159 @@
   }
 
   /**
-   * Returns true if any type in the chain has an implictCast annotation for
+   * After a struct object is created, we can't add new properties to it, with
+   * one exception. We allow creation of "static" properties like
+   * Foo.prototype.bar = baz;
+   * where Foo.prototype is a struct, if the assignment happens at the top level
+   * and the constructor Foo is defined in the same file.
+   */
+  private void checkPropCreation(NodeTraversal t, Node lvalue) {
+    if (lvalue.isGetProp()) {
+      Node obj = lvalue.getFirstChild();
+      Node prop = lvalue.getLastChild();
+      JSType objType = getJSType(obj);
+      String pname = prop.getString();
+
+      if (!objType.isStruct() || objType.hasProperty(pname)) {
+        return;
+      }
+      Scope s = t.getScope();
+      if (obj.isThis() && getJSType(s.getRootNode()).isConstructor()) {
+        return;
+      }
+      // Prop created outside ctor, check that it's a static prop
+      Node assgnExp = lvalue.getParent();
+      Node assgnStm = assgnExp.getParent();
+      if (objType instanceof ObjectType &&
+          s.isGlobal() &&
+          NodeUtil.isPrototypePropertyDeclaration(assgnStm)) {
+        ObjectType instance =
+            objType.toObjectType().getOwnerFunction().getInstanceType();
+        String file = lvalue.getSourceFileName();
+        Node ctor = instance.getConstructor().getSource();
+        if (ctor != null && ctor.getSourceFileName().equals(file)) {
+          JSType rvalueType = assgnExp.getLastChild().getJSType();
+          instance.defineInferredProperty(pname, rvalueType, lvalue);
+          return;
+        }
+      }
+      report(t, prop, ILLEGAL_PROPERTY_CREATION);
+    }
+  }
+
+  private void checkPropertyInheritanceOnGetpropAssign(
+      NodeTraversal t, Node assign, Node object, String property,
+      JSDocInfo info, JSType propertyType) {
+    // Inheritance checks for prototype properties.
+    //
+    // TODO(nicksantos): This isn't the right place to do this check. We
+    // really want to do this when we're looking at the constructor.
+    // We'd find all its properties and make sure they followed inheritance
+    // rules, like we currently do for @implements to make sure
+    // all the methods are implemented.
+    //
+    // As-is, this misses many other ways to override a property.
+    //
+    // object.prototype.property = ...;
+    if (object.isGetProp()) {
+      Node object2 = object.getFirstChild();
+      String property2 = NodeUtil.getStringValue(object.getLastChild());
+
+      if ("prototype".equals(property2)) {
+        JSType jsType = getJSType(object2);
+        if (jsType.isFunctionType()) {
+          FunctionType functionType = jsType.toMaybeFunctionType();
+          if (functionType.isConstructor() || functionType.isInterface()) {
+            checkDeclaredPropertyInheritance(
+                t, assign, functionType, property, info, propertyType);
+          }
+        }
+      }
+    }
+  }
+
+  /**
+   * Visits an object literal field definition <code>key : value</code>.
+   *
+   * If the <code>lvalue</code> is a prototype modification, we change the
+   * schema of the object type it is referring to.
+   *
+   * @param t the traversal
+   * @param key the assign node
+   */
+  private void visitObjLitKey(
+      NodeTraversal t, Node key, Node objlit, JSType litType) {
+    // Do not validate object lit value types in externs. We don't really care,
+    // and it makes it easier to generate externs.
+    if (objlit.isFromExterns()) {
+      ensureTyped(t, key);
+      return;
+    }
+
+    // Structs must have unquoted keys and dicts must have quoted keys
+    if (litType.isStruct() && key.isQuotedString()) {
+      report(t, key, ILLEGAL_OBJLIT_KEY, "struct");
+    } else if (litType.isDict() && !key.isQuotedString()) {
+      report(t, key, ILLEGAL_OBJLIT_KEY, "dict");
+    }
+
+    // TODO(johnlenz): Validate get and set function declarations are valid
+    // as is the functions can have "extraneous" bits.
+
+    // For getter and setter property definitions the
+    // r-value type != the property type.
+    Node rvalue = key.getFirstChild();
+    JSType rightType = NodeUtil.getObjectLitKeyTypeFromValueType(
+        key, getJSType(rvalue));
+    if (rightType == null) {
+      rightType = getNativeType(UNKNOWN_TYPE);
+    }
+
+    Node owner = objlit;
+
+    // Validate value is assignable to the key type.
+
+    JSType keyType = getJSType(key);
+
+    JSType allowedValueType = keyType;
+    if (allowedValueType.isEnumElementType()) {
+      allowedValueType =
+          allowedValueType.toMaybeEnumElementType().getPrimitiveType();
+    }
+
+    boolean valid = validator.expectCanAssignToPropertyOf(t, key,
+        rightType, allowedValueType,
+        owner, NodeUtil.getObjectLitKeyName(key));
+    if (valid) {
+      ensureTyped(t, key, rightType);
+    } else {
+      ensureTyped(t, key);
+    }
+
+    // Validate that the key type is assignable to the object property type.
+    // This is necessary as the objlit may have been cast to a non-literal
+    // object type.
+    // TODO(johnlenz): consider introducing a CAST node to the AST (or
+    // perhaps a parentheses node).
+
+    JSType objlitType = getJSType(objlit);
+    ObjectType type = ObjectType.cast(
+        objlitType.restrictByNotNullOrUndefined());
+    if (type != null) {
+      String property = NodeUtil.getObjectLitKeyName(key);
+      if (type.hasProperty(property) &&
+          !type.isPropertyTypeInferred(property) &&
+          !propertyIsImplicitCast(type, property)) {
+        validator.expectCanAssignToPropertyOf(
+            t, key, keyType,
+            type.getPropertyType(property), owner, property);
+      }
+      return;
+    }
+  }
+
+  /**
+   * Returns true if any type in the chain has an implicitCast annotation for
    * the given property.
    */
   private boolean propertyIsImplicitCast(ObjectType type, String prop) {
@@ -944,87 +1195,123 @@
   private void checkDeclaredPropertyInheritance(
       NodeTraversal t, Node n, FunctionType ctorType, String propertyName,
       JSDocInfo info, JSType propertyType) {
-    // TODO(user): We're not 100% confident that type-checking works,
-    // so we return quietly if the unknown type is a superclass of this type.
-    // Remove this check as we become more confident. We should flag a warning
-    // when the unknown type is on the inheritance chain, as it is likely
-    // because of a programmer error.
-    if (ctorType.hasUnknownSupertype()) {
+    // If the supertype doesn't resolve correctly, we've warned about this
+    // already.
+    if (hasUnknownOrEmptySupertype(ctorType)) {
       return;
     }
 
     FunctionType superClass = ctorType.getSuperClassConstructor();
     boolean superClassHasProperty = superClass != null &&
-        superClass.getPrototype().hasProperty(propertyName);
+        superClass.getInstanceType().hasProperty(propertyName);
+    boolean superClassHasDeclaredProperty = superClass != null &&
+        superClass.getInstanceType().isPropertyTypeDeclared(propertyName);
+
+    // For interface
+    boolean superInterfaceHasProperty = false;
+    boolean superInterfaceHasDeclaredProperty = false;
+    if (ctorType.isInterface()) {
+      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {
+        superInterfaceHasProperty =
+            superInterfaceHasProperty ||
+            interfaceType.hasProperty(propertyName);
+        superInterfaceHasDeclaredProperty =
+            superInterfaceHasDeclaredProperty ||
+            interfaceType.isPropertyTypeDeclared(propertyName);
+      }
+    }
     boolean declaredOverride = info != null && info.isOverride();
 
     boolean foundInterfaceProperty = false;
     if (ctorType.isConstructor()) {
-      for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {
-        if (implementedInterface.isUnknownType()) {
+      for (JSType implementedInterface :
+          ctorType.getAllImplementedInterfaces()) {
+        if (implementedInterface.isUnknownType() ||
+            implementedInterface.isEmptyType()) {
           continue;
         }
         FunctionType interfaceType =
             implementedInterface.toObjectType().getConstructor();
+        Preconditions.checkNotNull(interfaceType);
+
         boolean interfaceHasProperty =
             interfaceType.getPrototype().hasProperty(propertyName);
-        foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;
-        if (reportMissingOverride.isOn() && !declaredOverride &&
-            interfaceHasProperty) {
+        foundInterfaceProperty = foundInterfaceProperty ||
+            interfaceHasProperty;
+        if (reportMissingOverride.isOn()
+            && !declaredOverride
+            && interfaceHasProperty) {
           // @override not present, but the property does override an interface
           // property
           compiler.report(t.makeError(n, reportMissingOverride,
               HIDDEN_INTERFACE_PROPERTY, propertyName,
               interfaceType.getTopMostDefiningType(propertyName).toString()));
         }
-        if (!declaredOverride) {
-          continue;
-        }
-        // @override is present and we have to check that it is ok
-        if (interfaceHasProperty) {
-          JSType interfacePropType =
-              interfaceType.getPrototype().getPropertyType(propertyName);
-          if (!propertyType.canAssignTo(interfacePropType)) {
-            compiler.report(t.makeError(n,
-                HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName,
-                interfaceType.getTopMostDefiningType(propertyName).toString(),
-                interfacePropType.toString(), propertyType.toString()));
-          }
-        }
       }
     }
 
-    if (!declaredOverride && !superClassHasProperty) {
+    if (!declaredOverride
+        && !superClassHasProperty
+        && !superInterfaceHasProperty) {
       // nothing to do here, it's just a plain new property
       return;
     }
 
-    JSType topInstanceType = superClassHasProperty ?
+    ObjectType topInstanceType = superClassHasDeclaredProperty ?
         superClass.getTopMostDefiningType(propertyName) : null;
-    if (reportMissingOverride.isOn() && ctorType.isConstructor() &&
-        !declaredOverride && superClassHasProperty) {
+    boolean declaredLocally =
+        ctorType.isConstructor() &&
+        (ctorType.getPrototype().hasOwnProperty(propertyName) ||
+         ctorType.getInstanceType().hasOwnProperty(propertyName));
+    if (reportMissingOverride.isOn()
+        && !declaredOverride
+        && superClassHasDeclaredProperty
+        && declaredLocally) {
       // @override not present, but the property does override a superclass
       // property
       compiler.report(t.makeError(n, reportMissingOverride,
           HIDDEN_SUPERCLASS_PROPERTY, propertyName,
           topInstanceType.toString()));
     }
-    if (!declaredOverride) {
-      // there's no @override to check
-      return;
-    }
+
     // @override is present and we have to check that it is ok
-    if (superClassHasProperty) {
+    if (superClassHasDeclaredProperty) {
       // there is a superclass implementation
       JSType superClassPropType =
-          superClass.getPrototype().getPropertyType(propertyName);
-      if (!propertyType.canAssignTo(superClassPropType)) {
+          superClass.getInstanceType().getPropertyType(propertyName);
+      TemplateTypeMap ctorTypeMap =
+          ctorType.getTypeOfThis().getTemplateTypeMap();
+      if (!ctorTypeMap.isEmpty()) {
+        superClassPropType = superClassPropType.visit(
+            new TemplateTypeMapReplacer(typeRegistry, ctorTypeMap));
+      }
+
+      if (!propertyType.isSubtype(superClassPropType)) {
         compiler.report(
             t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,
                 propertyName, topInstanceType.toString(),
                 superClassPropType.toString(), propertyType.toString()));
       }
-    } else if (!foundInterfaceProperty) {
+    } else if (superInterfaceHasDeclaredProperty) {
+      // there is an super interface property
+      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {
+        if (interfaceType.hasProperty(propertyName)) {
+          JSType superPropertyType =
+              interfaceType.getPropertyType(propertyName);
+          if (!propertyType.isSubtype(superPropertyType)) {
+            topInstanceType = interfaceType.getConstructor().
+                getTopMostDefiningType(propertyName);
+            compiler.report(
+                t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,
+                    propertyName, topInstanceType.toString(),
+                    superPropertyType.toString(),
+                    propertyType.toString()));
+          }
+        }
+      }
+    } else if (!foundInterfaceProperty
+        && !superClassHasProperty
+        && !superInterfaceHasProperty) {
       // there is no superclass nor interface implementation
       compiler.report(
           t.makeError(n, UNKNOWN_OVERRIDE,
@@ -1033,6 +1320,34 @@
   }
 
   /**
+   * Given a constructor or an interface type, find out whether the unknown
+   * type is a supertype of the current type.
+   */
+  private static boolean hasUnknownOrEmptySupertype(FunctionType ctor) {
+    Preconditions.checkArgument(ctor.isConstructor() || ctor.isInterface());
+    Preconditions.checkArgument(!ctor.isUnknownType());
+
+    // The type system should notice inheritance cycles on its own
+    // and break the cycle.
+    while (true) {
+      ObjectType maybeSuperInstanceType =
+          ctor.getPrototype().getImplicitPrototype();
+      if (maybeSuperInstanceType == null) {
+        return false;
+      }
+      if (maybeSuperInstanceType.isUnknownType() ||
+          maybeSuperInstanceType.isEmptyType()) {
+        return true;
+      }
+      ctor = maybeSuperInstanceType.getConstructor();
+      if (ctor == null) {
+        return false;
+      }
+      Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());
+    }
+  }
+
+  /**
    * Visits an ASSIGN node for cases such as
    * <pre>
    * interface.property2.property = ...;
@@ -1051,9 +1366,7 @@
 
     String abstractMethodName =
         compiler.getCodingConvention().getAbstractMethodName();
-    if (!rvalueType.isOrdinaryFunction() &&
-        !(rvalue.isQualifiedName() &&
-          rvalue.getQualifiedName().equals(abstractMethodName))) {
+    if (!rvalueType.isFunctionType()) {
       // This is bad i18n style but we don't localize our compiler errors.
       String abstractMethodMessage = (abstractMethodName != null)
          ? ", or " + abstractMethodName
@@ -1063,7 +1376,7 @@
               abstractMethodMessage));
     }
 
-    if (assign.getLastChild().getType() == Token.FUNCTION
+    if (assign.getLastChild().isFunction()
         && !NodeUtil.isEmptyBlock(assign.getLastChild().getLastChild())) {
       compiler.report(
           t.makeError(object, INTERFACE_FUNCTION_NOT_EMPTY,
@@ -1072,20 +1385,6 @@
   }
 
   /**
-   * Visits an ASSIGN node for cases such as
-   * <pre>
-   * object.property = ...;
-   * </pre>
-   * that have an {@code @type} annotation.
-   */
-  private void visitAnnotatedAssignGetprop(NodeTraversal t,
-      Node assign, JSType type, Node object, String property, Node rvalue) {
-    // verifying that the rvalue has the correct type
-    validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type,
-        object, property);
-  }
-
-  /**
    * Visits a NAME node.
    *
    * @param t The node traversal object that supplies context, such as the
@@ -1105,7 +1404,7 @@
     int parentNodeType = parent.getType();
     if (parentNodeType == Token.FUNCTION ||
         parentNodeType == Token.CATCH ||
-        parentNodeType == Token.LP ||
+        parentNodeType == Token.PARAM_LIST ||
         parentNodeType == Token.VAR) {
       return false;
     }
@@ -1134,13 +1433,6 @@
    * @param parent The parent of <code>n</code>
    */
   private void visitGetProp(NodeTraversal t, Node n, Node parent) {
-    // GETPROP nodes have an assigned type on their node by the scope creator
-    // if this is an enum declaration. The only namespaced enum declarations
-    // that we allow are of the form object.name = ...;
-    if (n.getJSType() != null && parent.getType() == Token.ASSIGN) {
-      return;
-    }
-
     // obj.prop or obj.method()
     // Lots of types can appear on the left, a call to a void function can
     // never be on the left. getPropertyType will decide what is acceptable
@@ -1149,45 +1441,127 @@
     Node objNode = n.getFirstChild();
     JSType childType = getJSType(objNode);
 
-    // TODO(user): remove in favor of flagging every property access on
-    // non-object.
-    if (!validator.expectNotVoid(t, n, childType,
-            "undefined has no properties", getNativeType(OBJECT_TYPE))) {
-      ensureTyped(t, n);
-      return;
+    if (childType.isDict()) {
+      report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");
+    } else if (validator.expectNotNullOrUndefined(t, n, childType,
+        "No properties on this expression", getNativeType(OBJECT_TYPE))) {
+      checkPropertyAccess(childType, property.getString(), t, n);
     }
-
-    checkPropertyAccess(childType, property.getString(), t, n);
     ensureTyped(t, n);
   }
 
   /**
-   * Make sure that the access of this property is ok.
+   * Emit a warning if we can prove that a property cannot possibly be
+   * defined on an object. Note the difference between JS and a strictly
+   * statically typed language: we're checking if the property
+   * *cannot be defined*, whereas a java compiler would check if the
+   * property *can be undefined*.
    */
   private void checkPropertyAccess(JSType childType, String propName,
       NodeTraversal t, Node n) {
-    ObjectType objectType = childType.dereference();
-    if (objectType != null) {
-      JSType propType = getJSType(n);
-      if ((!objectType.hasProperty(propName) ||
-           objectType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) &&
-          propType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) {
-        if (objectType instanceof EnumType) {
-          report(t, n, INEXISTENT_ENUM_ELEMENT, propName);
-        } else if (!objectType.isEmptyType() &&
-            reportMissingProperties && !isPropertyTest(n)) {
-          if (!typeRegistry.canPropertyBeDefined(objectType, propName)) {
-            report(t, n, INEXISTENT_PROPERTY, propName,
-                validator.getReadableJSTypeName(n.getFirstChild(), true));
+    // If the property type is unknown, check the object type to see if it
+    // can ever be defined. We explicitly exclude CHECKED_UNKNOWN (for
+    // properties where we've checked that it exists, or for properties on
+    // objects that aren't in this binary).
+    JSType propType = getJSType(n);
+    if (propType.isEquivalentTo(typeRegistry.getNativeType(UNKNOWN_TYPE))) {
+      childType = childType.autobox();
+      ObjectType objectType = ObjectType.cast(childType);
+      if (objectType != null) {
+        // We special-case object types so that checks on enums can be
+        // much stricter, and so that we can use hasProperty (which is much
+        // faster in most cases).
+        if (!objectType.hasProperty(propName) ||
+            objectType.isEquivalentTo(
+                typeRegistry.getNativeType(UNKNOWN_TYPE))) {
+          if (objectType instanceof EnumType) {
+            report(t, n, INEXISTENT_ENUM_ELEMENT, propName);
+          } else {
+            checkPropertyAccessHelper(objectType, propName, t, n);
           }
         }
+
+      } else {
+        checkPropertyAccessHelper(childType, propName, t, n);
       }
-    } else {
-      // TODO(nicksantos): might want to flag the access on a non object when
-      // it's impossible to get a property from this type.
     }
   }
 
+  private void checkPropertyAccessHelper(JSType objectType, String propName,
+      NodeTraversal t, Node n) {
+    if (!objectType.isEmptyType() &&
+        reportMissingProperties &&
+        (!isPropertyTest(n) || objectType.isStruct())) {
+      if (!typeRegistry.canPropertyBeDefined(objectType, propName)) {
+        SuggestionPair pair =
+            getClosestPropertySuggestion(objectType, propName);
+        if (pair != null && pair.distance * 4 < propName.length()) {
+          report(t, n, INEXISTENT_PROPERTY_WITH_SUGGESTION, propName,
+              validator.getReadableJSTypeName(n.getFirstChild(), true),
+              pair.suggestion);
+        } else {
+          report(t, n, INEXISTENT_PROPERTY, propName,
+              validator.getReadableJSTypeName(n.getFirstChild(), true));
+        }
+      }
+    }
+  }
+
+  private SuggestionPair getClosestPropertySuggestion(
+      JSType objectType, String propName) {
+    if (editDistance == null) {
+      return null;
+    }
+
+    String bestSoFar = null;
+    int shortest = Integer.MAX_VALUE;
+    if (objectType instanceof ObjectType) {
+      ObjectType type = (ObjectType) objectType;
+      for (String alt : type.getPropertyNames()) {
+        int distance;
+        try {
+          distance = (Integer) editDistance.invoke(null, propName, alt, false);
+        } catch (Exception e) {
+          return null;
+        }
+        if (distance <= shortest) {
+          if (distance == shortest) {
+            // To make warning determistic across runs we 'tie-break' by
+            // alphabetical order ignore-case.
+            if (bestSoFar != null && alt.compareToIgnoreCase(bestSoFar) > 0) {
+              continue;
+            }
+          }
+          shortest = distance;
+          bestSoFar = alt;
+        }
+      }
+    } else if (objectType.isUnionType()) {
+      UnionType type = (UnionType) objectType;
+      for (JSType alt : type.getAlternates()) {
+        SuggestionPair pair = getClosestPropertySuggestion(alt, propName);
+        if (pair != null) {
+          if (pair.distance <= shortest) {
+            if (pair.distance  == shortest) {
+              if (bestSoFar != null &&
+                  pair.suggestion.compareToIgnoreCase(bestSoFar) > 0) {
+                continue;
+              }
+            }
+            shortest = pair.distance;
+            bestSoFar = pair.suggestion;
+          }
+        }
+      }
+    }
+
+    if (bestSoFar != null) {
+      return new SuggestionPair(bestSoFar, shortest);
+    }
+
+    return null;
+  }
+
   /**
    * Determines whether this node is testing for the existence of a property.
    * If true, we will not emit warnings about a missing property.
@@ -1216,8 +1590,11 @@
         return parent.getFirstChild() == getProp;
 
       case Token.NOT:
-        return parent.getParent().getType() == Token.OR &&
+        return parent.getParent().isOr() &&
             parent.getParent().getFirstChild() == parent;
+
+      case Token.CAST:
+        return isPropertyTest(parent);
     }
     return false;
   }
@@ -1230,9 +1607,8 @@
    * @param n The node being visited.
    */
   private void visitGetElem(NodeTraversal t, Node n) {
-    Node left = n.getFirstChild();
-    Node right = n.getLastChild();
-    validator.expectIndexMatch(t, n, getJSType(left), getJSType(right));
+    validator.expectIndexMatch(
+        t, n, getJSType(n.getFirstChild()), getJSType(n.getLastChild()));
     ensureTyped(t, n);
   }
 
@@ -1262,13 +1638,9 @@
         if (info == null) {
           info = varInfo;
         }
-        if (info != null && info.hasEnumParameterType()) {
-          // var.getType() can never be null, this would indicate a bug in the
-          // scope creation logic.
-          checkEnumInitializer(
-              t, value,
-              info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));
-        } else if (var.isTypeInferred()) {
+
+        checkEnumAlias(t, info, value);
+        if (var.isTypeInferred()) {
           ensureTyped(t, name, valueType);
         } else {
           validator.expectCanAssignTo(
@@ -1283,29 +1655,66 @@
    */
   private void visitNew(NodeTraversal t, Node n) {
     Node constructor = n.getFirstChild();
-    FunctionType type = getFunctionType(constructor);
-    if (type != null && type.isConstructor()) {
-      visitParameterList(t, n, type);
-      ensureTyped(t, n, type.getInstanceType());
-    } else {
-      // TODO(user): add support for namespaced objects.
-      if (constructor.getType() != Token.GETPROP) {
-        // TODO(user): make the constructor node have lineno/charno
-        // and use constructor for a more precise error indication.
-        // It seems that GETPROP nodes are missing this information.
-        Node line;
-        if (constructor.getLineno() < 0 || constructor.getCharno() < 0) {
-          line = n;
-        } else {
-          line = constructor;
-        }
-        report(t, line, NOT_A_CONSTRUCTOR);
+    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
+    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
+      FunctionType fnType = type.toMaybeFunctionType();
+      if (fnType != null) {
+        visitParameterList(t, n, fnType);
+        ensureTyped(t, n, fnType.getInstanceType());
+      } else {
+        ensureTyped(t, n);
       }
+    } else {
+      report(t, n, NOT_A_CONSTRUCTOR);
       ensureTyped(t, n);
     }
   }
 
   /**
+   * Check whether there's any property conflict for for a particular super
+   * interface
+   * @param t The node traversal object that supplies context
+   * @param n The node being visited
+   * @param functionName The function name being checked
+   * @param properties The property names in the super interfaces that have
+   * been visited
+   * @param currentProperties The property names in the super interface
+   * that have been visited
+   * @param interfaceType The super interface that is being visited
+   */
+  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,
+      String functionName, HashMap<String, ObjectType> properties,
+      HashMap<String, ObjectType> currentProperties,
+      ObjectType interfaceType) {
+    ObjectType implicitProto = interfaceType.getImplicitPrototype();
+    Set<String> currentPropertyNames;
+    if (implicitProto == null) {
+      // This can be the case if interfaceType is proxy to a non-existent
+      // object (which is a bad type annotation, but shouldn't crash).
+      currentPropertyNames = ImmutableSet.of();
+    } else {
+      currentPropertyNames = implicitProto.getOwnPropertyNames();
+    }
+    for (String name : currentPropertyNames) {
+      ObjectType oType = properties.get(name);
+      if (oType != null) {
+        if (!interfaceType.getPropertyType(name).isEquivalentTo(
+            oType.getPropertyType(name))) {
+          compiler.report(
+              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,
+                  functionName, name, oType.toString(),
+                  interfaceType.toString()));
+        }
+      }
+      currentProperties.put(name, interfaceType);
+    }
+    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {
+      checkInterfaceConflictProperties(t, n, functionName, properties,
+          currentProperties, iType);
+    }
+  }
+
+  /**
    * Visits a {@link Token#FUNCTION} node.
    *
    * @param t The node traversal object that supplies context, such as the
@@ -1313,40 +1722,72 @@
    * @param n The node being visited.
    */
   private void visitFunction(NodeTraversal t, Node n) {
-    JSDocInfo info = n.getJSDocInfo();
-
-    FunctionType functionType = (FunctionType) n.getJSType();
+    FunctionType functionType = JSType.toMaybeFunctionType(n.getJSType());
     String functionPrivateName = n.getFirstChild().getString();
-    if (functionType.isInterface() || functionType.isConstructor()) {
-      FunctionType baseConstructor = functionType.
-          getPrototype().getImplicitPrototype().getConstructor();
-      if (baseConstructor != null &&
-          baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&
-          (baseConstructor.isConstructor() && functionType.isInterface() ||
-           baseConstructor.isInterface() && functionType.isConstructor())) {
+    if (functionType.isConstructor()) {
+      FunctionType baseConstructor = functionType.getSuperClassConstructor();
+      if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&
+          baseConstructor != null &&
+          baseConstructor.isInterface()) {
         compiler.report(
-            t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName));
-      }
-
-      for (JSType baseInterface : functionType.getImplementedInterfaces()) {
-        boolean badImplementedType = false;
-        ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);
-        if (baseInterfaceObj != null) {
-          FunctionType interfaceConstructor =
+            t.makeError(n, CONFLICTING_EXTENDED_TYPE,
+                        "constructor", functionPrivateName));
+      } else {
+        if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE)) {
+          ObjectType proto = functionType.getPrototype();
+          if (functionType.makesStructs() && !proto.isStruct()) {
+            compiler.report(t.makeError(n, CONFLICTING_SHAPE_TYPE,
+                                        "struct", functionPrivateName));
+          } else if (functionType.makesDicts() && !proto.isDict()) {
+            compiler.report(t.makeError(n, CONFLICTING_SHAPE_TYPE,
+                                        "dict", functionPrivateName));
+          }
+        }
+        // All interfaces are properly implemented by a class
+        for (JSType baseInterface : functionType.getImplementedInterfaces()) {
+          boolean badImplementedType = false;
+          ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);
+          if (baseInterfaceObj != null) {
+            FunctionType interfaceConstructor =
               baseInterfaceObj.getConstructor();
-          if (interfaceConstructor != null &&
-              !interfaceConstructor.isInterface()) {
+            if (interfaceConstructor != null &&
+                !interfaceConstructor.isInterface()) {
+              badImplementedType = true;
+            }
+          } else {
             badImplementedType = true;
           }
-        } else {
-          badImplementedType = true;
+          if (badImplementedType) {
+            report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName);
+          }
         }
-        if (badImplementedType) {
-          report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName);
+        // check properties
+        validator.expectAllInterfaceProperties(t, n, functionType);
+      }
+    } else if (functionType.isInterface()) {
+      // Interface must extend only interfaces
+      for (ObjectType extInterface : functionType.getExtendedInterfaces()) {
+        if (extInterface.getConstructor() != null
+            && !extInterface.getConstructor().isInterface()) {
+          compiler.report(
+              t.makeError(n, CONFLICTING_EXTENDED_TYPE,
+                          "interface", functionPrivateName));
         }
       }
-      if (functionType.isConstructor()) {
-        validator.expectAllInterfacePropertiesImplemented(functionType);
+
+      // Check whether the extended interfaces have any conflicts
+      if (functionType.getExtendedInterfacesCount() > 1) {
+        // Only check when extending more than one interfaces
+        HashMap<String, ObjectType> properties
+            = new HashMap<String, ObjectType>();
+        HashMap<String, ObjectType> currentProperties
+            = new HashMap<String, ObjectType>();
+        for (ObjectType interfaceType : functionType.getExtendedInterfaces()) {
+          currentProperties.clear();
+          checkInterfaceConflictProperties(t, n, functionPrivateName,
+              properties, currentProperties, interfaceType);
+          properties.putAll(currentProperties);
+        }
       }
     }
   }
@@ -1370,24 +1811,47 @@
 
     // A couple of types can be called as if they were functions.
     // If it is a function type, then validate parameters.
-    if (childType instanceof FunctionType) {
-      FunctionType functionType = (FunctionType) childType;
+    if (childType.isFunctionType()) {
+      FunctionType functionType = childType.toMaybeFunctionType();
 
-      // Non-native constructors should never be called directly.
+      boolean isExtern = false;
+      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
+      if (functionJSDocInfo != null  &&
+          functionJSDocInfo.getAssociatedNode() != null) {
+        isExtern = functionJSDocInfo.getAssociatedNode().isFromExterns();
+      }
+
+      // Non-native constructors should not be called directly
+      // unless they specify a return type and are defined
+      // in an extern.
       if (functionType.isConstructor() &&
-          !functionType.isNativeObjectType()) {
+          !functionType.isNativeObjectType() &&
+          (functionType.getReturnType().isUnknownType() ||
+           functionType.getReturnType().isVoidType() ||
+           !isExtern)) {
         report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
       }
 
+      // Functions with explicit 'this' types must be called in a GETPROP
+      // or GETELEM.
+      if (functionType.isOrdinaryFunction() &&
+          !functionType.getTypeOfThis().isUnknownType() &&
+          !(functionType.getTypeOfThis().toObjectType() != null &&
+          functionType.getTypeOfThis().toObjectType().isNativeObjectType()) &&
+          !(child.isGetElem() ||
+            child.isGetProp())) {
+        report(t, n, EXPECTED_THIS_TYPE, functionType.toString());
+      }
+
       visitParameterList(t, n, functionType);
       ensureTyped(t, n, functionType.getReturnType());
     } else {
       ensureTyped(t, n);
     }
 
-    // TODO: Add something to check for calls of RegExp objects, which is not
-    // supported by IE.  Either say something about the return type or warn
-    // about the non-portability of the call or both.
+    // TODO(nicksantos): Add something to check for calls of RegExp objects,
+    // which is not supported by IE. Either say something about the return type
+    // or warn about the non-portability of the call or both.
   }
 
   /**
@@ -1437,17 +1901,10 @@
    * @param n The node being visited.
    */
   private void visitReturn(NodeTraversal t, Node n) {
-    Node function = t.getEnclosingFunction();
+    JSType jsType = getJSType(t.getEnclosingFunction());
 
-    // This is a misplaced return, but the real JS will fail to compile,
-    // so let it go.
-    if (function == null) {
-      return;
-    }
-    JSType jsType = getJSType(function);
-
-    if (jsType instanceof FunctionType) {
-      FunctionType functionType = (FunctionType) jsType;
+    if (jsType.isFunctionType()) {
+      FunctionType functionType = jsType.toMaybeFunctionType();
 
       JSType returnType = functionType.getReturnType();
 
@@ -1534,77 +1991,43 @@
         break;
 
       default:
-        report(t, n, UNEXPECTED_TOKEN, Node.tokenToName(op));
+        report(t, n, UNEXPECTED_TOKEN, Token.name(op));
     }
     ensureTyped(t, n);
   }
 
+
   /**
-   * <p>Checks the initializer of an enum. An enum can be initialized with an
-   * object literal whose values must be subtypes of the declared enum element
-   * type, or by copying another enum.</p>
+   * <p>Checks enum aliases.
    *
-   * <p>In the case of an enum copy, we verify that the enum element type of the
-   * enum used for initialization is a subtype of the enum element type of
+   * <p>We verify that the enum element type of the enum used
+   * for initialization is a subtype of the enum element type of
    * the enum the value is being copied in.</p>
    *
-   * <p>Examples:</p>
-   * <pre>var myEnum = {FOO: ..., BAR: ...};
-   * var myEnum = myOtherEnum;</pre>
+   * <p>Example:</p>
+   * <pre>var myEnum = myOtherEnum;</pre>
+   *
+   * <p>Enum aliases are irregular, so we need special code for this :(</p>
    *
    * @param value the value used for initialization of the enum
-   * @param primitiveType The type of each element of the enum.
    */
-  private void checkEnumInitializer(
-      NodeTraversal t, Node value, JSType primitiveType) {
-    if (value.getType() == Token.OBJECTLIT) {
-      // re-using value as the value of the object literal and advancing twice
-      value = value.getFirstChild();
-      value = (value == null) ? null : value.getNext();
-      while (value != null) {
-        // the value's type must be assignable to the enum's primitive type
-        validator.expectCanAssignTo(t, value, getJSType(value), primitiveType,
-            "element type must match enum's type");
-
-        // advancing twice
-        value = value.getNext();
-        value = (value == null) ? null : value.getNext();
-      }
-    } else if (value.getJSType() instanceof EnumType) {
-      // TODO(user): Remove the instanceof check in favor
-      // of a type.isEnumType() predicate. Currently, not all enum types are
-      // implemented by the EnumClass, e.g. the unknown type and the any
-      // type. The types need to be defined by interfaces such that an
-      // implementation can implement multiple types interface.
-      EnumType valueEnumType = (EnumType) value.getJSType();
-      JSType valueEnumPrimitiveType =
-          valueEnumType.getElementsType().getPrimitiveType();
-      validator.expectCanAssignTo(t, value, valueEnumPrimitiveType,
-          primitiveType, "incompatible enum element types");
-    } else {
-      // The error condition is handled in TypedScopeCreator.
+  private void checkEnumAlias(
+      NodeTraversal t, JSDocInfo declInfo, Node value) {
+    if (declInfo == null || !declInfo.hasEnumParameterType()) {
+      return;
     }
-  }
-
 
-  /**
-   * This predicate is used to determine if the node represents an expression
-   * that is a Reference according to JavaScript definitions.
-   *
-   * @param n The node being checked.
-   * @return true if the sub-tree n is a reference, false otherwise.
-   */
-  private static boolean isReference(Node n) {
-    switch (n.getType()) {
-      case Token.GETELEM:
-      case Token.GETPROP:
-      case Token.NAME:
-        return true;
-
-      default:
-        return false;
+    JSType valueType = getJSType(value);
+    if (!valueType.isEnumType()) {
+      return;
     }
 
+    EnumType valueEnumType = valueType.toMaybeEnumType();
+    JSType valueEnumPrimitiveType =
+        valueEnumType.getElementsType().getPrimitiveType();
+    validator.expectCanAssignTo(t, value, valueEnumPrimitiveType,
+        declInfo.getEnumParameterType().evaluate(t.getScope(), typeRegistry),
+        "incompatible enum element types");
   }
 
   /**
@@ -1624,21 +2047,6 @@
     }
   }
 
-  /**
-   * Gets the type of the node or {@code null} if the node's type is not a
-   * function.
-   */
-  private FunctionType getFunctionType(Node n) {
-    JSType type = getJSType(n).restrictByNotNullOrUndefined();
-    if (type.isUnknownType()) {
-      return typeRegistry.getNativeFunctionType(U2U_CONSTRUCTOR_TYPE);
-    } else if (type instanceof FunctionType) {
-      return (FunctionType) type;
-    } else {
-      return null;
-    }
-  }
-
   // TODO(nicksantos): TypeCheck should never be attaching types to nodes.
   // All types should be attached by TypeInference. This is not true today
   // for legacy reasons. There are a number of places where TypeInference
@@ -1677,19 +2085,14 @@
    */
   private void ensureTyped(NodeTraversal t, Node n, JSType type) {
     // Make sure FUNCTION nodes always get function type.
-    Preconditions.checkState(n.getType() != Token.FUNCTION ||
-            type instanceof FunctionType ||
+    Preconditions.checkState(!n.isFunction() ||
+            type.isFunctionType() ||
             type.isUnknownType());
+    // TODO(johnlenz): this seems like a strange place to check "@implicitCast"
     JSDocInfo info = n.getJSDocInfo();
     if (info != null) {
-      if (info.hasType()) {
-        JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);
-        validator.expectCanCast(t, n, infoType, type);
-        type = infoType;
-      }
-
       if (info.isImplicitCast() && !inExterns) {
-        String propName = n.getType() == Token.GETPROP ?
+        String propName = n.isGetProp() ?
             n.getLastChild().getString() : "(missing)";
         compiler.report(
             t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));
@@ -1707,11 +2110,7 @@
    */
   double getTypedPercent() {
     int total = nullCount + unknownCount + typedCount;
-    if (total == 0) {
-      return 0.0;
-    } else {
-      return (100.0 * typedCount) / total;
-    }
+    return (total == 0) ? 0.0 : (100.0 * typedCount) / total;
   }
 
   private JSType getNativeType(JSTypeNative typeId) {
diff -r -u inducing/test/com/google/javascript/jscomp/TypeCheckTest.java buggy/test/com/google/javascript/jscomp/TypeCheckTest.java
--- inducing/test/com/google/javascript/jscomp/TypeCheckTest.java	2023-06-12 11:40:32.502438586 +0800
+++ buggy/test/com/google/javascript/jscomp/TypeCheckTest.java	2023-06-12 11:40:32.258449678 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006 Google Inc.
+ * Copyright 2006 The Closure Compiler Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,14 +20,20 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.google.javascript.jscomp.Scope.Var;
+import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
+import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
+import com.google.javascript.rhino.InputId;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.jstype.FunctionType;
 import com.google.javascript.rhino.jstype.JSType;
 import com.google.javascript.rhino.jstype.JSTypeNative;
 import com.google.javascript.rhino.jstype.ObjectType;
+import com.google.javascript.rhino.testing.Asserts;
 
 import java.util.Arrays;
+import java.util.List;
+import java.util.Set;
 
 /**
  * Tests {@link TypeCheck}.
@@ -37,6 +43,14 @@
 
   private CheckLevel reportMissingOverrides = CheckLevel.WARNING;
 
+  private static final String SUGGESTION_CLASS =
+      "/** @constructor\n */\n" +
+      "function Suggest() {}\n" +
+      "Suggest.prototype.a = 1;\n" +
+      "Suggest.prototype.veryPossible = 1;\n" +
+      "Suggest.prototype.veryPossible2 = 1;\n";
+
+  @Override
   public void setUp() throws Exception {
     super.setUp();
     reportMissingOverrides = CheckLevel.WARNING;
@@ -44,40 +58,48 @@
 
   public void testInitialTypingScope() {
     Scope s = new TypedScopeCreator(compiler,
-        new DefaultCodingConvention()).createInitialScope(
+        CodingConventions.getDefault()).createInitialScope(
             new Node(Token.BLOCK));
 
-    assertEquals(ARRAY_FUNCTION_TYPE, s.getVar("Array").getType());
-    assertEquals(BOOLEAN_OBJECT_FUNCTION_TYPE,
+    assertTypeEquals(ARRAY_FUNCTION_TYPE, s.getVar("Array").getType());
+    assertTypeEquals(BOOLEAN_OBJECT_FUNCTION_TYPE,
         s.getVar("Boolean").getType());
-    assertEquals(DATE_FUNCTION_TYPE, s.getVar("Date").getType());
-    assertEquals(ERROR_FUNCTION_TYPE, s.getVar("Error").getType());
-    assertEquals(EVAL_ERROR_FUNCTION_TYPE,
+    assertTypeEquals(DATE_FUNCTION_TYPE, s.getVar("Date").getType());
+    assertTypeEquals(ERROR_FUNCTION_TYPE, s.getVar("Error").getType());
+    assertTypeEquals(EVAL_ERROR_FUNCTION_TYPE,
         s.getVar("EvalError").getType());
-    assertEquals(NUMBER_OBJECT_FUNCTION_TYPE,
+    assertTypeEquals(NUMBER_OBJECT_FUNCTION_TYPE,
         s.getVar("Number").getType());
-    assertEquals(OBJECT_FUNCTION_TYPE, s.getVar("Object").getType());
-    assertEquals(RANGE_ERROR_FUNCTION_TYPE,
+    assertTypeEquals(OBJECT_FUNCTION_TYPE, s.getVar("Object").getType());
+    assertTypeEquals(RANGE_ERROR_FUNCTION_TYPE,
         s.getVar("RangeError").getType());
-    assertEquals(REFERENCE_ERROR_FUNCTION_TYPE,
+    assertTypeEquals(REFERENCE_ERROR_FUNCTION_TYPE,
         s.getVar("ReferenceError").getType());
-    assertEquals(REGEXP_FUNCTION_TYPE, s.getVar("RegExp").getType());
-    assertEquals(STRING_OBJECT_FUNCTION_TYPE,
+    assertTypeEquals(REGEXP_FUNCTION_TYPE, s.getVar("RegExp").getType());
+    assertTypeEquals(STRING_OBJECT_FUNCTION_TYPE,
         s.getVar("String").getType());
-    assertEquals(SYNTAX_ERROR_FUNCTION_TYPE,
+    assertTypeEquals(SYNTAX_ERROR_FUNCTION_TYPE,
         s.getVar("SyntaxError").getType());
-    assertEquals(TYPE_ERROR_FUNCTION_TYPE,
+    assertTypeEquals(TYPE_ERROR_FUNCTION_TYPE,
         s.getVar("TypeError").getType());
-    assertEquals(URI_ERROR_FUNCTION_TYPE,
+    assertTypeEquals(URI_ERROR_FUNCTION_TYPE,
         s.getVar("URIError").getType());
   }
 
+  public void testPrivateType() throws Exception {
+    testTypes(
+        "/** @private {number} */ var x = false;",
+        "initializing variable\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
   public void testTypeCheck1() throws Exception {
     testTypes("/**@return {void}*/function foo(){ if (foo()) return; }");
   }
 
   public void testTypeCheck2() throws Exception {
-    testTypes("/**@return {void}*/function foo(){ foo()--; }",
+    testTypes("/**@return {void}*/function foo(){ var x=foo(); x--; }",
         "increment/decrement\n" +
         "found   : undefined\n" +
         "required: number");
@@ -100,11 +122,6 @@
         "/** @type {undefined|number} */var a;if (a == foo())return;}");
   }
 
-  public void testTypeCheck7() throws Exception {
-    testTypes("function foo() {delete 'abc';}",
-        TypeCheck.BAD_DELETE);
-  }
-
   public void testTypeCheck8() throws Exception {
     testTypes("/**@return {void}*/function foo(){do {} while (foo());}");
   }
@@ -229,7 +246,18 @@
         "required: string", false);
   }
 
-  public void testParameterizedArray1() throws Exception {
+
+  public void testTypeCheckCustomExterns2() throws Exception {
+    testTypes(
+        DEFAULT_EXTERNS + "/** @enum {string} */ var Enum = {FOO: 1, BAR: 1};",
+        "/** @param {Enum} x */ function f(x) {} f(Enum.FOO); f(true);",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: Enum.<string>",
+        false);
+  }
+
+  public void testTemplatizedArray1() throws Exception {
     testTypes("/** @param {!Array.<number>} a\n" +
         "* @return {string}\n" +
         "*/ var f = function(a) { return a[0]; };",
@@ -238,22 +266,22 @@
         "required: string");
   }
 
-  public void testParameterizedArray2() throws Exception {
+  public void testTemplatizedArray2() throws Exception {
     testTypes("/** @param {!Array.<!Array.<number>>} a\n" +
         "* @return {number}\n" +
         "*/ var f = function(a) { return a[0]; };",
         "inconsistent return type\n" +
-        "found   : Array\n" +
+        "found   : Array.<number>\n" +
         "required: number");
   }
 
-  public void testParameterizedArray3() throws Exception {
+  public void testTemplatizedArray3() throws Exception {
     testTypes("/** @param {!Array.<number>} a\n" +
         "* @return {number}\n" +
         "*/ var f = function(a) { a[1] = 0; return a[0]; };");
   }
 
-  public void testParameterizedArray4() throws Exception {
+  public void testTemplatizedArray4() throws Exception {
     testTypes("/** @param {!Array.<number>} a\n" +
         "*/ var f = function(a) { a[0] = 'a'; };",
         "assignment\n" +
@@ -261,12 +289,12 @@
         "required: number");
   }
 
-  public void testParameterizedArray5() throws Exception {
+  public void testTemplatizedArray5() throws Exception {
     testTypes("/** @param {!Array.<*>} a\n" +
         "*/ var f = function(a) { a[0] = 'a'; };");
   }
 
-  public void testParameterizedArray6() throws Exception {
+  public void testTemplatizedArray6() throws Exception {
     testTypes("/** @param {!Array.<*>} a\n" +
         "* @return {string}\n" +
         "*/ var f = function(a) { return a[0]; };",
@@ -275,7 +303,7 @@
         "required: string");
   }
 
-  public void testParameterizedArray7() throws Exception {
+  public void testTemplatizedArray7() throws Exception {
     testTypes("/** @param {?Array.<number>} a\n" +
         "* @return {string}\n" +
         "*/ var f = function(a) { return a[0]; };",
@@ -284,7 +312,7 @@
         "required: string");
   }
 
-  public void testParameterizedObject1() throws Exception {
+  public void testTemplatizedObject1() throws Exception {
     testTypes("/** @param {!Object.<number>} a\n" +
         "* @return {string}\n" +
         "*/ var f = function(a) { return a[0]; };",
@@ -293,7 +321,7 @@
         "required: string");
   }
 
-  public void testParameterizedObject2() throws Exception {
+  public void testTemplatizedObject2() throws Exception {
     testTypes("/** @param {!Object.<string,number>} a\n" +
         "* @return {string}\n" +
         "*/ var f = function(a) { return a['x']; };",
@@ -302,7 +330,7 @@
         "required: string");
   }
 
-  public void testParameterizedObject3() throws Exception {
+  public void testTemplatizedObject3() throws Exception {
     testTypes("/** @param {!Object.<number,string>} a\n" +
         "* @return {string}\n" +
         "*/ var f = function(a) { return a['x']; };",
@@ -311,7 +339,7 @@
         "required: number");
   }
 
-  public void testParameterizedObject4() throws Exception {
+  public void testTemplatizedObject4() throws Exception {
     testTypes("/** @enum {string} */ var E = {A: 'a', B: 'b'};\n" +
         "/** @param {!Object.<E,string>} a\n" +
         "* @return {string}\n" +
@@ -321,6 +349,16 @@
         "required: E.<string>");
   }
 
+  public void testTemplatizedObject5() throws Exception {
+    testTypes("/** @constructor */ function F() {" +
+        "  /** @type {Object.<number, string>} */ this.numbers = {};" +
+        "}" +
+        "(new F()).numbers['ten'] = '10';",
+        "restricted index type\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
   public void testUnionOfFunctionAndType() throws Exception {
     testTypes("/** @type {null|(function(Number):void)} */ var a;" +
         "/** @type {(function(Number):void)|null} */ var b = null; a = b;");
@@ -371,8 +409,8 @@
   }
 
   public void testOptionalArgFunctionParamError() throws Exception {
-    String expectedWarning = "Parse error. variable length argument must be " +
-        "last";
+    String expectedWarning =
+        "Bad type annotation. variable length argument must be last";
     testTypes("/** @param {function(...[number], number=)} a */" +
               "function f(a) {};", expectedWarning, false);
   }
@@ -611,7 +649,7 @@
     // Don't do type inference on GETELEMs.
     testClosureTypes(
         CLOSURE_DEFS +
-        "function f(arguments) { " +
+        "function f(x) { " +
         "  return goog.isString(arguments[0]) ? arguments[0] : 0;" +
         "}", null);
   }
@@ -620,11 +658,27 @@
     // Don't do type inference on GETELEMs.
     testClosureTypes(
         CLOSURE_DEFS +
-        "function f(arguments) { " +
+        "function f(x) { " +
         "  return typeof arguments[0] == 'string' ? arguments[0] : 0;" +
         "}", null);
   }
 
+  public void testTypeOfReduction16() throws Exception {
+    testClosureTypes(
+        CLOSURE_DEFS +
+        "/** @interface */ function I() {}\n" +
+        "/**\n" +
+        " * @param {*} x\n" +
+        " * @return {I}\n" +
+        " */\n" +
+        "function f(x) { " +
+        "  if(goog.isObject(x)) {" +
+        "    return /** @type {I} */(x);" +
+        "  }" +
+        "  return null;" +
+        "}", null);
+  }
+
   public void testQualifiedNameReduction1() throws Exception {
     testTypes("var x = {}; /** @type {string?} */ x.a = 'a';\n" +
         "/** @return {string} */ var f = function() {\n" +
@@ -654,6 +708,178 @@
         "return goog.isString(this.a) ? this.a : 'a'; }", null);
   }
 
+  public void testQualifiedNameReduction5a() throws Exception {
+    testTypes("var x = {/** @type {string} */ a:'b' };\n" +
+        "/** @return {string} */ var f = function() {\n" +
+        "return x.a; }");
+  }
+
+  public void testQualifiedNameReduction5b() throws Exception {
+    testTypes(
+        "var x = {/** @type {number} */ a:12 };\n" +
+        "/** @return {string} */\n" +
+        "var f = function() {\n" +
+        "  return x.a;\n" +
+        "}",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testQualifiedNameReduction5c() throws Exception {
+    testTypes(
+        "/** @return {string} */ var f = function() {\n" +
+        "var x = {/** @type {number} */ a:0 };\n" +
+        "return (x.a) ? (x.a) : 'a'; }",
+        "inconsistent return type\n" +
+        "found   : (number|string)\n" +
+        "required: string");
+  }
+
+  public void testQualifiedNameReduction6() throws Exception {
+    testTypes(
+        "/** @return {string} */ var f = function() {\n" +
+        "var x = {/** @return {string?} */ get a() {return 'a'}};\n" +
+        "return x.a ? x.a : 'a'; }");
+  }
+
+  public void testQualifiedNameReduction7() throws Exception {
+    testTypes(
+        "/** @return {string} */ var f = function() {\n" +
+        "var x = {/** @return {number} */ get a() {return 12}};\n" +
+        "return x.a; }",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testQualifiedNameReduction7a() throws Exception {
+    // It would be nice to find a way to make this an error.
+    testTypes(
+        "/** @return {string} */ var f = function() {\n" +
+        "var x = {get a() {return 12}};\n" +
+        "return x.a; }");
+  }
+
+  public void testQualifiedNameReduction8() throws Exception {
+    testTypes(
+        "/** @return {string} */ var f = function() {\n" +
+        "var x = {get a() {return 'a'}};\n" +
+        "return x.a ? x.a : 'a'; }");
+  }
+
+  public void testQualifiedNameReduction9() throws Exception {
+    testTypes(
+        "/** @return {string} */ var f = function() {\n" +
+        "var x = { /** @param {string} b */ set a(b) {}};\n" +
+        "return x.a ? x.a : 'a'; }");
+  }
+
+  public void testQualifiedNameReduction10() throws Exception {
+    // TODO(johnlenz): separate setter property types from getter property
+    // types.
+    testTypes(
+        "/** @return {string} */ var f = function() {\n" +
+        "var x = { /** @param {number} b */ set a(b) {}};\n" +
+        "return x.a ? x.a : 'a'; }",
+        "inconsistent return type\n" +
+        "found   : (number|string)\n" +
+        "required: string");
+  }
+
+  public void testObjLitDef1a() throws Exception {
+    testTypes(
+        "var x = {/** @type {number} */ a:12 };\n" +
+        "x.a = 'a';",
+        "assignment to property a of x\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testObjLitDef1b() throws Exception {
+    testTypes(
+        "function f(){" +
+          "var x = {/** @type {number} */ a:12 };\n" +
+          "x.a = 'a';" +
+        "};\n" +
+        "f();",
+        "assignment to property a of x\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testObjLitDef2a() throws Exception {
+    testTypes(
+        "var x = {/** @param {number} b */ set a(b){} };\n" +
+        "x.a = 'a';",
+        "assignment to property a of x\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testObjLitDef2b() throws Exception {
+    testTypes(
+        "function f(){" +
+          "var x = {/** @param {number} b */ set a(b){} };\n" +
+          "x.a = 'a';" +
+        "};\n" +
+        "f();",
+        "assignment to property a of x\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testObjLitDef3a() throws Exception {
+    testTypes(
+        "/** @type {string} */ var y;\n" +
+        "var x = {/** @return {number} */ get a(){} };\n" +
+        "y = x.a;",
+        "assignment\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testObjLitDef3b() throws Exception {
+    testTypes(
+      "/** @type {string} */ var y;\n" +
+        "function f(){" +
+          "var x = {/** @return {number} */ get a(){} };\n" +
+          "y = x.a;" +
+        "};\n" +
+        "f();",
+        "assignment\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testObjLitDef4() throws Exception {
+    testTypes(
+        "var x = {" +
+          "/** @return {number} */ a:12 };\n",
+          "assignment to property a of {a: function (): number}\n" +
+          "found   : number\n" +
+          "required: function (): number");
+  }
+
+  public void testObjLitDef5() throws Exception {
+    testTypes(
+        "var x = {};\n" +
+        "/** @return {number} */ x.a = 12;\n",
+        "assignment to property a of x\n" +
+        "found   : number\n" +
+        "required: function (): number");
+  }
+
+  public void testObjLitDef6() throws Exception {
+    testTypes("var lit = /** @struct */ { 'x': 1 };",
+        "Illegal key, the object literal is a struct");
+  }
+
+  public void testObjLitDef7() throws Exception {
+    testTypes("var lit = /** @dict */ { x: 1 };",
+        "Illegal key, the object literal is a dict");
+  }
+
   public void testInstanceOfReduction1() throws Exception {
     testTypes("/** @constructor */ var T = function() {};\n" +
         "/** @param {T|string} x\n@return {T} */\n" +
@@ -670,6 +896,37 @@
         "};");
   }
 
+  public void testUndeclaredGlobalProperty1() throws Exception {
+    testTypes("/** @const */ var x = {}; x.y = null;" +
+        "function f(a) { x.y = a; }" +
+        "/** @param {string} a */ function g(a) { }" +
+        "function h() { g(x.y); }");
+  }
+
+  public void testUndeclaredGlobalProperty2() throws Exception {
+    testTypes("/** @const */ var x = {}; x.y = null;" +
+        "function f() { x.y = 3; }" +
+        "/** @param {string} a */ function g(a) { }" +
+        "function h() { g(x.y); }",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : (null|number)\n" +
+        "required: string");
+  }
+
+  public void testLocallyInferredGlobalProperty1() throws Exception {
+    // We used to have a bug where x.y.z leaked from f into h.
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** @type {number} */ F.prototype.z;" +
+        "/** @const */ var x = {}; /** @type {F} */ x.y;" +
+        "function f() { x.y.z = 'abc'; }" +
+        "/** @param {number} x */ function g(x) {}" +
+        "function h() { g(x.y.z); }",
+        "assignment to property z of F\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
   public void testPropertyInferredPropagation() throws Exception {
     testTypes("/** @return {Object} */function f() { return {}; }\n" +
          "function g() { var x = f(); if (x.p) x.a = 'a'; else x.a = 'b'; }\n" +
@@ -759,6 +1016,38 @@
         "required: string");
   }
 
+  public void testPropertyInference9() throws Exception {
+    testTypes(
+        "/** @constructor */ function A() {}" +
+        "/** @return {function(): ?} */ function f() { " +
+        "  return function() {};" +
+        "}" +
+        "var g = f();" +
+        "/** @type {number} */ g.prototype.bar_ = null;",
+        "assignment\n" +
+        "found   : null\n" +
+        "required: number");
+  }
+
+  public void testPropertyInference10() throws Exception {
+    // NOTE(nicksantos): There used to be a bug where a property
+    // on the prototype of one structural function would leak onto
+    // the prototype of other variables with the same structural
+    // function type.
+    testTypes(
+        "/** @constructor */ function A() {}" +
+        "/** @return {function(): ?} */ function f() { " +
+        "  return function() {};" +
+        "}" +
+        "var g = f();" +
+        "/** @type {number} */ g.prototype.bar_ = 1;" +
+        "var h = f();" +
+        "/** @type {string} */ h.prototype.bar_ = 1;",
+        "assignment\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testNoPersistentTypeInferenceForObjectProperties()
       throws Exception {
     testTypes("/** @param {Object} o\n@param {string} x */\n" +
@@ -1051,7 +1340,7 @@
   }
 
   public void testNumericComparison6() throws Exception {
-    testTypes("/**@return void*/ function foo() { if (3 >= foo()) return; }",
+    testTypes("/**@return {void} */ function foo() { if (3 >= foo()) return; }",
         "right side of numeric comparison\n" +
         "found   : undefined\n" +
         "required: number");
@@ -1080,7 +1369,8 @@
   }
 
   public void testStringComparison6() throws Exception {
-    testTypes("/**@return void*/ function foo() { if ('a' >= foo()) return; }",
+    testTypes("/**@return {void} */ " +
+        "function foo() { if ('a' >= foo()) return; }",
         "right side of comparison\n" +
         "found   : undefined\n" +
         "required: string");
@@ -1244,40 +1534,55 @@
 
   public void testScoping11() throws Exception {
     // named function expressions create a binding in their body only
-    // the return is wrong but the assignment is ok since the type of b is ?
+    // the return is wrong but the assignment is OK since the type of b is ?
     testTypes(
-        "/** @return number */var a = function b(){ return b };",
+        "/** @return {number} */var a = function b(){ return b };",
         "inconsistent return type\n" +
         "found   : function (): number\n" +
         "required: number");
   }
 
+  public void testScoping12() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** @type {number} */ F.prototype.bar = 3;" +
+        "/** @param {!F} f */ function g(f) {" +
+        "  /** @return {string} */" +
+        "  function h() {" +
+        "    return f.bar;" +
+        "  }" +
+        "}",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testFunctionArguments1() throws Exception {
     testFunctionType(
-        "/** @param {number} a\n@return string */" +
+        "/** @param {number} a\n@return {string} */" +
         "function f(a) {}",
         "function (number): string");
   }
 
   public void testFunctionArguments2() throws Exception {
     testFunctionType(
-        "/** @param {number} opt_a\n@return string */" +
+        "/** @param {number} opt_a\n@return {string} */" +
         "function f(opt_a) {}",
-        "function ((number|undefined)): string");
+        "function (number=): string");
   }
 
   public void testFunctionArguments3() throws Exception {
     testFunctionType(
-        "/** @param {number} b\n@return string */" +
+        "/** @param {number} b\n@return {string} */" +
         "function f(a,b) {}",
         "function (?, number): string");
   }
 
   public void testFunctionArguments4() throws Exception {
     testFunctionType(
-        "/** @param {number} opt_a\n@return string */" +
+        "/** @param {number} opt_a\n@return {string} */" +
         "function f(a,opt_a) {}",
-        "function (?, (number|undefined)): string");
+        "function (?, number=): string");
   }
 
   public void testFunctionArguments5() throws Exception {
@@ -1294,7 +1599,7 @@
 
   public void testFunctionArguments7() throws Exception {
     testTypes(
-        "/** @param {number} opt_a\n@return string */" +
+        "/** @param {number} opt_a\n@return {string} */" +
         "function a(a,opt_a,var_args) {}");
   }
 
@@ -1330,13 +1635,13 @@
   }
 
   public void testFunctionArguments13() throws Exception {
-    // verifying that the argument type have inferable types
+    // verifying that the argument type have non-inferable types
     testTypes(
         "/** @return {boolean} */ function u() { return true; }" +
-        "/** @param {boolean} b\n@return boolean */" +
+        "/** @param {boolean} b\n@return {?boolean} */" +
         "function f(b) { if (u()) { b = null; } return b; }",
-        "inconsistent return type\n" +
-        "found   : (boolean|null)\n" +
+        "assignment\n" +
+        "found   : null\n" +
         "required: boolean");
   }
 
@@ -1368,6 +1673,26 @@
         "required: (number|undefined)");
   }
 
+  public void testFunctionArguments17() throws Exception {
+    testClosureTypesMultipleWarnings(
+        "/** @param {booool|string} x */" +
+        "function f(x) { g(x) }" +
+        "/** @param {number} x */" +
+        "function g(x) {}",
+        Lists.newArrayList(
+            "Bad type annotation. Unknown type booool",
+            "actual parameter 1 of g does not match formal parameter\n" +
+            "found   : (booool|null|string)\n" +
+            "required: number"));
+  }
+
+  public void testFunctionArguments18() throws Exception {
+    testTypes(
+        "function f(x) {}" +
+        "f(/** @param {number} y */ (function() {}));",
+        "parameter y does not appear in <anonymous>'s parameter list");
+  }
+
   public void testPrintFunctionName1() throws Exception {
     // Ensures that the function name is pretty.
     testTypes(
@@ -1414,14 +1739,14 @@
 
   public void testFunctionInference5() throws Exception {
     testFunctionType(
-        "/** @this Date\n@return string */function f(a) {}",
+        "/** @this Date\n@return {string} */function f(a) {}",
         "function (this:Date, ?): string");
   }
 
   public void testFunctionInference6() throws Exception {
     testFunctionType(
-        "/** @this Date\n@return string */function f(opt_a) {}",
-        "function (this:Date, ?): string");
+        "/** @this Date\n@return {string} */function f(opt_a) {}",
+        "function (this:Date, ?=): string");
   }
 
   public void testFunctionInference7() throws Exception {
@@ -1444,7 +1769,7 @@
 
   public void testFunctionInference10() throws Exception {
     testFunctionType(
-        "/** @this Date\n@param {boolean} b\n@return string */" +
+        "/** @this Date\n@param {boolean} b\n@return {string} */" +
         "var f = function(a,b) {};",
         "function (this:Date, ?, boolean): string");
   }
@@ -1452,7 +1777,7 @@
   public void testFunctionInference11() throws Exception {
     testFunctionType(
         "var goog = {};" +
-        "/** @return number*/goog.f = function(){};",
+        "/** @return {number}*/goog.f = function(){};",
         "goog.f",
         "function (): number");
   }
@@ -1530,6 +1855,34 @@
         "function (this:Date): ?");
   }
 
+  public void testFunctionInference21() throws Exception {
+    testTypes(
+        "var f = function() { throw 'x' };" +
+        "/** @return {boolean} */ var g = f;");
+    testFunctionType(
+        "var f = function() { throw 'x' };",
+        "f",
+        "function (): ?");
+  }
+
+  public void testFunctionInference22() throws Exception {
+    testTypes(
+        "/** @type {!Function} */ var f = function() { g(this); };" +
+        "/** @param {boolean} x */ var g = function(x) {};");
+  }
+
+  public void testFunctionInference23() throws Exception {
+    // We want to make sure that 'prop' isn't declared on all objects.
+    testTypes(
+        "/** @type {!Function} */ var f = function() {\n" +
+        "  /** @type {number} */ this.prop = 3;\n" +
+        "};" +
+        "/**\n" +
+        " * @param {Object} x\n" +
+        " * @return {string}\n" +
+        " */ var g = function(x) { return x.prop; };");
+  }
+
   public void testInnerFunction1() throws Exception {
     testTypes(
         "function f() {" +
@@ -1607,7 +1960,10 @@
         " var x = 0 || function() {};\n" +
         " function g() { if (goog.isFunction(x)) { x(1); } }" +
         " g();" +
-        "}", null);
+        "}",
+        "Function x: called with 1 argument(s). " +
+        "Function requires at least 0 argument(s) " +
+        "and no more than 0 argument(s).");
   }
 
   public void testInnerFunction7() throws Exception {
@@ -1647,6 +2003,43 @@
         "}");
   }
 
+  public void testInnerFunction10() throws Exception {
+    testTypes(
+        "function f() {" +
+        "  /** @type {?number} */ var x = null;" +
+        "  /** @return {string} */" +
+        "  function g() {" +
+        "    if (!x) {" +
+        "      x = 1;" +
+        "    }" +
+        "    return x;" +
+        "  }" +
+        "}",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testInnerFunction11() throws Exception {
+    // TODO(nicksantos): This is actually bad inference, because
+    // h sets x to null. We should fix this, but for now we do it
+    // this way so that we don't break existing binaries. We will
+    // need to change TypeInference#isUnflowable to fix this.
+    testTypes(
+        "function f() {" +
+        "  /** @type {?number} */ var x = null;" +
+        "  /** @return {number} */" +
+        "  function g() {" +
+        "    x = 1;" +
+        "    h();" +
+        "    return x;" +
+        "  }" +
+        "  function h() {" +
+        "    x = null;" +
+        "  }" +
+        "}");
+  }
+
   public void testAbstractMethodHandling1() throws Exception {
     testTypes(
         "/** @type {Function} */ var abstractFn = function() {};" +
@@ -1681,7 +2074,7 @@
 
   public void testAbstractMethodHandling5() throws Exception {
     testTypes(
-        "/** @type {Function} */ var abstractFn = function() {};" +
+        "/** @type {!Function} */ var abstractFn = function() {};" +
         "/** @param {number} x */ var f = abstractFn;" +
         "f('x');",
         "actual parameter 1 of f does not match formal parameter\n" +
@@ -1776,10 +2169,7 @@
         "/** @constructor \n * @extends {F} */ " +
         "function G() {}" +
         "/** @override */ G.prototype.foo = function() { };" +
-        "(new G()).foo(1);",
-        "Function G.prototype.foo: called with 1 argument(s). " +
-        "Function requires at least 0 argument(s) " +
-        "and no more than 0 argument(s).");
+        "(new G()).foo(1);");
   }
 
   public void testMethodInference7() throws Exception {
@@ -1788,11 +2178,11 @@
         "F.prototype.foo = function() { };" +
         "/** @constructor \n * @extends {F} */ " +
         "function G() {}" +
-        "/** @override */ G.prototype.foo = function(x, y) { };" +
-        "(new G()).foo();",
-        "Function G.prototype.foo: called with 0 argument(s). " +
-        "Function requires at least 2 argument(s) " +
-        "and no more than 2 argument(s).");
+        "/** @override */ G.prototype.foo = function(x, y) { };",
+        "mismatch of the foo property type and the type of the property " +
+        "it overrides from superclass F\n" +
+        "original: function (this:F): undefined\n" +
+        "override: function (this:G, ?, ?): undefined");
   }
 
   public void testMethodInference8() throws Exception {
@@ -1802,10 +2192,8 @@
         "/** @constructor \n * @extends {F} */ " +
         "function G() {}" +
         "/** @override */ " +
-        "G.prototype.foo = function(a, opt_b, var_args) { };" +
-        "(new G()).foo();",
-        "Function G.prototype.foo: called with 0 argument(s). " +
-        "Function requires at least 1 argument(s).");
+        "G.prototype.foo = function(opt_b, var_args) { };" +
+        "(new G()).foo(1, 2, 3);");
   }
 
   public void testMethodInference9() throws Exception {
@@ -1815,7 +2203,7 @@
         "/** @constructor \n * @extends {F} */ " +
         "function G() {}" +
         "/** @override */ " +
-        "G.prototype.foo = function(a, var_args, opt_b) { };",
+        "G.prototype.foo = function(var_args, opt_b) { };",
         "variable length argument must be last");
   }
 
@@ -1851,7 +2239,8 @@
         "/** @param {number} x */ goog.foo = function(x) {};" +
         "/** @param {number} x */ goog.foo = function(x) {};",
         "variable goog.foo redefined with type function (number): undefined, " +
-        "original definition at [testcode]:1 with type function (number): undefined");
+        "original definition at [testcode]:1 " +
+        "with type function (number): undefined");
   }
 
   public void testDuplicateStaticMethodDecl2() throws Exception {
@@ -1886,6 +2275,20 @@
         "function (?): undefined");
   }
 
+  public void testDuplicateStaticMethodDecl6() throws Exception {
+    // Make sure the CAST node doesn't interfere with the @suppress
+    // annotation.
+    testTypes(
+        "var goog = goog || {};" +
+        "goog.foo = function(x) {};" +
+        "/**\n" +
+        " * @suppress {duplicate}\n" +
+        " * @return {undefined}\n" +
+        " */\n" +
+        "goog.foo = " +
+        "   /** @type {!Function} */ (function(x) {});");
+  }
+
   public void testDuplicateStaticPropertyDecl1() throws Exception {
     testTypes(
         "var goog = goog || {};" +
@@ -1913,23 +2316,31 @@
   }
 
   public void testDuplicateStaticPropertyDecl4() throws Exception {
-    testTypes(
+    testClosureTypesMultipleWarnings(
         "var goog = goog || {};" +
         "/** @type {!Foo} */ goog.foo;" +
         "/** @type {string} */ goog.foo = 'x';" +
         "/** @constructor */ function Foo() {}",
-        "variable goog.foo redefined with type string, " +
-        "original definition at [testcode]:1 with type Foo");
+        Lists.newArrayList(
+            "assignment to property foo of goog\n" +
+            "found   : string\n" +
+            "required: Foo",
+            "variable goog.foo redefined with type string, " +
+            "original definition at [testcode]:1 with type Foo"));
   }
 
   public void testDuplicateStaticPropertyDecl5() throws Exception {
-    testTypes(
+    testClosureTypesMultipleWarnings(
         "var goog = goog || {};" +
         "/** @type {!Foo} */ goog.foo;" +
         "/** @type {string}\n * @suppress {duplicate} */ goog.foo = 'x';" +
         "/** @constructor */ function Foo() {}",
-        "variable goog.foo redefined with type string, " +
-        "original definition at [testcode]:1 with type Foo");
+        Lists.newArrayList(
+            "assignment to property foo of goog\n" +
+            "found   : string\n" +
+            "required: Foo",
+            "variable goog.foo redefined with type string, " +
+            "original definition at [testcode]:1 with type Foo"));
   }
 
   public void testDuplicateStaticPropertyDecl6() throws Exception {
@@ -1962,12 +2373,89 @@
         "/** @constructor */ function EventCopy() {}");
   }
 
-  public void testDuplicateLocalVarDecl() throws Exception {
+  public void testDuplicateStaticPropertyDec20() throws Exception {
     testTypes(
+        "/**\n" +
+        " * @fileoverview\n" +
+        " * @suppress {duplicate}\n" +
+        " */" +
+        "var goog = goog || {};" +
+        "/** @type {string} */ goog.foo = 'y';" +
+        "/** @type {string} */ goog.foo = 'x';");
+  }
+
+  public void testDuplicateLocalVarDecl() throws Exception {
+    testClosureTypesMultipleWarnings(
         "/** @param {number} x */\n" +
         "function f(x) { /** @type {string} */ var x = ''; }",
-        "variable x redefined with type string, " +
-        "original definition at [testcode]:2 with type number");
+        Lists.newArrayList(
+            "variable x redefined with type string, original definition" +
+            " at [testcode]:2 with type number",
+            "initializing variable\n" +
+            "found   : string\n" +
+            "required: number"));
+  }
+
+  public void testDuplicateInstanceMethod1() throws Exception {
+    // If there's no jsdoc on the methods, then we treat them like
+    // any other inferred properties.
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "F.prototype.bar = function() {};" +
+        "F.prototype.bar = function() {};");
+  }
+
+  public void testDuplicateInstanceMethod2() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** jsdoc */ F.prototype.bar = function() {};" +
+        "/** jsdoc */ F.prototype.bar = function() {};",
+        "variable F.prototype.bar redefined with type " +
+        "function (this:F): undefined, original definition at " +
+        "[testcode]:1 with type function (this:F): undefined");
+  }
+
+  public void testDuplicateInstanceMethod3() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "F.prototype.bar = function() {};" +
+        "/** jsdoc */ F.prototype.bar = function() {};",
+        "variable F.prototype.bar redefined with type " +
+        "function (this:F): undefined, original definition at " +
+        "[testcode]:1 with type function (this:F): undefined");
+  }
+
+  public void testDuplicateInstanceMethod4() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** jsdoc */ F.prototype.bar = function() {};" +
+        "F.prototype.bar = function() {};");
+  }
+
+  public void testDuplicateInstanceMethod5() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** jsdoc \n * @return {number} */ F.prototype.bar = function() {" +
+        "  return 3;" +
+        "};" +
+        "/** jsdoc \n * @suppress {duplicate} */ " +
+        "F.prototype.bar = function() { return ''; };",
+        "inconsistent return type\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testDuplicateInstanceMethod6() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** jsdoc \n * @return {number} */ F.prototype.bar = function() {" +
+        "  return 3;" +
+        "};" +
+        "/** jsdoc \n * @return {string} * \n @suppress {duplicate} */ " +
+        "F.prototype.bar = function() { return ''; };",
+        "assignment to property bar of F.prototype\n" +
+        "found   : function (this:F): string\n" +
+        "required: function (this:F): number");
   }
 
   public void testStubFunctionDeclaration1() throws Exception {
@@ -1980,11 +2468,12 @@
   }
 
   public void testStubFunctionDeclaration2() throws Exception {
-    testFunctionType(
+    testExternFunctionType(
+        // externs
         "/** @constructor */ function f() {};" +
         "/** @constructor \n * @extends {f} */ f.subclass;",
         "f.subclass",
-        "function (this:f.subclass): ?");
+        "function (new:f.subclass): ?");
   }
 
   public void testStubFunctionDeclaration3() throws Exception {
@@ -2030,13 +2519,10 @@
   }
 
   public void testStubFunctionDeclaration8() throws Exception {
-    /** TODO(user): This is not exactly correct yet. The var
-            itself is nullable. */
     testFunctionType(
         "/** @type {Function} */ var f = function() {}; ",
         "f",
-        createNullableType(U2U_CONSTRUCTOR_TYPE).
-          restrictByNotNullOrUndefined().toString());
+        createNullableType(U2U_CONSTRUCTOR_TYPE).toString());
   }
 
   public void testStubFunctionDeclaration9() throws Exception {
@@ -2085,11 +2571,30 @@
         "required: number");
   }
 
+  /**
+   * Tests the type of a function definition in externs.
+   * The function defined by {@code functionDef} should be
+   * named {@code functionName}.
+   */
+  private void testExternFunctionType(String functionDef, String functionName,
+      String functionType) throws Exception {
+    testTypes(
+        functionDef,
+        "/** @type number */var a=" + functionName + ";",
+        "initializing variable\n" +
+        "found   : " + functionType + "\n" +
+        "required: number", false);
+  }
+
   public void testTypeRedefinition() throws Exception {
-    testTypes("a={};/**@enum {string}*/ a.A = {ZOR:'b'};"
+    testClosureTypesMultipleWarnings("a={};/**@enum {string}*/ a.A = {ZOR:'b'};"
         + "/** @constructor */ a.A = function() {}",
-        "variable a.A redefined with type function (this:a.A): undefined, " +
-        "original definition at [testcode]:1 with type enum{a.A}");
+        Lists.newArrayList(
+            "variable a.A redefined with type function (new:a.A): undefined, " +
+            "original definition at [testcode]:1 with type enum{a.A}",
+            "assignment to property A of a\n" +
+            "found   : function (new:a.A): undefined\n" +
+            "required: enum{a.A}"));
   }
 
   public void testIn1() throws Exception {
@@ -2107,7 +2612,7 @@
   public void testIn4() throws Exception {
     testTypes("Date in Object",
         "left side of 'in'\n" +
-        "found   : function (this:Date, ?, ?, ?, ?, ?, ?, ?): string\n" +
+        "found   : function (new:Date, ?=, ?=, ?=, ?=, ?=, ?=, ?=): string\n" +
         "required: string");
   }
 
@@ -2146,6 +2651,69 @@
         "required: number");
   }
 
+  public void testForIn1() throws Exception {
+    testTypes(
+        "/** @param {boolean} x */ function f(x) {}" +
+        "for (var k in {}) {" +
+        "  f(k);" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : string\n" +
+        "required: boolean");
+  }
+
+  public void testForIn2() throws Exception {
+    testTypes(
+        "/** @param {boolean} x */ function f(x) {}" +
+        "/** @enum {string} */ var E = {FOO: 'bar'};" +
+        "/** @type {Object.<E, string>} */ var obj = {};" +
+        "var k = null;" +
+        "for (k in obj) {" +
+        "  f(k);" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : E.<string>\n" +
+        "required: boolean");
+  }
+
+  public void testForIn3() throws Exception {
+    testTypes(
+        "/** @param {boolean} x */ function f(x) {}" +
+        "/** @type {Object.<number>} */ var obj = {};" +
+        "for (var k in obj) {" +
+        "  f(obj[k]);" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: boolean");
+  }
+
+  public void testForIn4() throws Exception {
+    testTypes(
+        "/** @param {boolean} x */ function f(x) {}" +
+        "/** @enum {string} */ var E = {FOO: 'bar'};" +
+        "/** @type {Object.<E, Array>} */ var obj = {};" +
+        "for (var k in obj) {" +
+        "  f(obj[k]);" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : (Array|null)\n" +
+        "required: boolean");
+  }
+
+  public void testForIn5() throws Exception {
+    testTypes(
+        "/** @param {boolean} x */ function f(x) {}" +
+        "/** @constructor */ var E = function(){};" +
+        "/** @type {Object.<E, number>} */ var obj = {};" +
+        "for (var k in obj) {" +
+        "  f(k);" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : string\n" +
+        "required: boolean");
+  }
+
   // TODO(nicksantos): change this to something that makes sense.
 //   public void testComparison1() throws Exception {
 //     testTypes("/**@type null */var a;" +
@@ -2160,7 +2728,7 @@
     testTypes("/**@type number*/var a;" +
         "/**@type !Date */var b;" +
         "if (a!==b) {}",
-        "condition always evaluates to the same value\n" +
+        "condition always evaluates to true\n" +
         "left : number\n" +
         "right: Date");
   }
@@ -2246,6 +2814,60 @@
         "right: boolean");
   }
 
+  public void testComparison14() throws Exception {
+    testTypes("/** @type {function((Array|string), Object): number} */" +
+        "function f(x, y) { return x === y; }",
+        "inconsistent return type\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testComparison15() throws Exception {
+    testClosureTypes(
+        CLOSURE_DEFS +
+        "/** @constructor */ function F() {}" +
+        "/**\n" +
+        " * @param {number} x\n" +
+        " * @constructor\n" +
+        " * @extends {F}\n" +
+        " */\n" +
+        "function G(x) {}\n" +
+        "goog.inherits(G, F);\n" +
+        "/**\n" +
+        " * @param {number} x\n" +
+        " * @constructor\n" +
+        " * @extends {G}\n" +
+        " */\n" +
+        "function H(x) {}\n" +
+        "goog.inherits(H, G);\n" +
+        "/** @param {G} x */" +
+        "function f(x) { return x.constructor === H; }",
+        null);
+  }
+
+  public void testDeleteOperator1() throws Exception {
+    testTypes(
+        "var x = {};" +
+        "/** @return {string} */ function f() { return delete x['a']; }",
+        "inconsistent return type\n" +
+        "found   : boolean\n" +
+        "required: string");
+  }
+
+  public void testDeleteOperator2() throws Exception {
+    testTypes(
+        "var obj = {};" +
+        "/** \n" +
+        " * @param {string} x\n" +
+        " * @return {Object} */ function f(x) { return obj; }" +
+        "/** @param {?number} x */ function g(x) {" +
+        "  if (x) { delete f(x)['a']; }" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testEnumStaticMethod1() throws Exception {
     testTypes(
         "/** @enum */ var Foo = {AAA: 1};" +
@@ -2278,19 +2900,20 @@
 
   public void testEnum3() throws Exception {
     testTypes("/**@enum*/var a={BB:1,BB:2}",
-        "enum element BB already defined", true);
+        "variable a.BB redefined with type a.<number>, " +
+        "original definition at [testcode]:1 with type a.<number>");
   }
 
   public void testEnum4() throws Exception {
     testTypes("/**@enum*/var a={BB:'string'}",
-        "element type must match enum's type\n" +
+        "assignment to property BB of enum{a}\n" +
         "found   : string\n" +
         "required: number");
   }
 
   public void testEnum5() throws Exception {
     testTypes("/**@enum {String}*/var a={BB:'string'}",
-        "element type must match enum's type\n" +
+        "assignment to property BB of enum{a}\n" +
         "found   : string\n" +
         "required: (String|null)");
   }
@@ -2309,15 +2932,23 @@
   }
 
   public void testEnum8() throws Exception {
-    testTypes("/** @enum */var a=8;",
-        "enum initializer must be an object literal or an enum");
+    testClosureTypesMultipleWarnings("/** @enum */var a=8;",
+        Lists.newArrayList(
+            "enum initializer must be an object literal or an enum",
+            "initializing variable\n" +
+            "found   : number\n" +
+            "required: enum{a}"));
   }
 
   public void testEnum9() throws Exception {
-    testTypes(
+    testClosureTypesMultipleWarnings(
         "var goog = {};" +
         "/** @enum */goog.a=8;",
-        "enum initializer must be an object literal or an enum");
+        Lists.newArrayList(
+            "assignment to property a of goog\n" +
+            "found   : number\n" +
+            "required: enum{goog.a}",
+            "enum initializer must be an object literal or an enum"));
   }
 
   public void testEnum10() throws Exception {
@@ -2364,14 +2995,15 @@
 
   public void testEnum16() throws Exception {
     testTypes("var goog = {};" +
-        "/**@enum*/goog.a={BB:1,BB:2}",
-        "enum element BB already defined", true);
+        "/**@enum*/goog .a={BB:1,BB:2}",
+        "variable goog.a.BB redefined with type goog.a.<number>, " +
+        "original definition at [testcode]:1 with type goog.a.<number>");
   }
 
   public void testEnum17() throws Exception {
     testTypes("var goog = {};" +
         "/**@enum*/goog.a={BB:'string'}",
-        "element type must match enum's type\n" +
+        "assignment to property BB of enum{goog.a}\n" +
         "found   : string\n" +
         "required: number");
   }
@@ -2527,6 +3159,23 @@
         "required: number");
   }
 
+  public void testEnum41() throws Exception {
+    testTypes(
+        "/** @enum {number} */ var MyEnum = {/** @const */ FOO: 1};" +
+        "/** @return {string} */" +
+        "function f() { return MyEnum.FOO; }",
+        "inconsistent return type\n" +
+        "found   : MyEnum.<number>\n" +
+        "required: string");
+  }
+
+  public void testEnum42() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @enum {Object} */ var MyEnum = {FOO: {newProperty: 1, b: 2}};" +
+        "f(MyEnum.FOO.newProperty);");
+  }
+
   public void testAliasedEnum1() throws Exception {
     testTypes(
         "/** @enum */ var YourEnum = {FOO: 3};" +
@@ -2605,6 +3254,71 @@
         "element BAR does not exist on this enum");
   }
 
+  public void testBackwardsTypedefUse2() throws Exception {
+    testTypes(
+        "/** @this {MyTypedef} */ function f() {}" +
+        "/** @typedef {!(Date|Array)} */ var MyTypedef;");
+  }
+
+  public void testBackwardsTypedefUse4() throws Exception {
+    testTypes(
+        "/** @return {MyTypedef} */ function f() { return null; }" +
+        "/** @typedef {string} */ var MyTypedef;",
+        "inconsistent return type\n" +
+        "found   : null\n" +
+        "required: string");
+  }
+
+  public void testBackwardsTypedefUse6() throws Exception {
+    testTypes(
+        "/** @return {goog.MyTypedef} */ function f() { return null; }" +
+        "var goog = {};" +
+        "/** @typedef {string} */ goog.MyTypedef;",
+        "inconsistent return type\n" +
+        "found   : null\n" +
+        "required: string");
+  }
+
+  public void testBackwardsTypedefUse7() throws Exception {
+    testTypes(
+        "/** @return {goog.MyTypedef} */ function f() { return null; }" +
+        "var goog = {};" +
+        "/** @typedef {Object} */ goog.MyTypedef;");
+  }
+
+  public void testBackwardsTypedefUse8() throws Exception {
+    // Technically, this isn't quite right, because the JS runtime
+    // will coerce null -> the global object. But we'll punt on that for now.
+    testTypes(
+        "/** @param {!Array} x */ function g(x) {}" +
+        "/** @this {goog.MyTypedef} */ function f() { g(this); }" +
+        "var goog = {};" +
+        "/** @typedef {(Array|null|undefined)} */ goog.MyTypedef;");
+  }
+
+  public void testBackwardsTypedefUse9() throws Exception {
+    testTypes(
+        "/** @param {!Array} x */ function g(x) {}" +
+        "/** @this {goog.MyTypedef} */ function f() { g(this); }" +
+        "var goog = {};" +
+        "/** @typedef {(Error|null|undefined)} */ goog.MyTypedef;",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : Error\n" +
+        "required: Array");
+  }
+
+  public void testBackwardsTypedefUse10() throws Exception {
+    testTypes(
+        "/** @param {goog.MyEnum} x */ function g(x) {}" +
+        "var goog = {};" +
+        "/** @enum {goog.MyTypedef} */ goog.MyEnum = {FOO: 1};" +
+        "/** @typedef {number} */ goog.MyTypedef;" +
+        "g(1);",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: goog.MyEnum.<number>");
+  }
+
   public void testBackwardsConstructor1() throws Exception {
     testTypes(
         "function f() { (new Foo(true)); }" +
@@ -2692,7 +3406,7 @@
         "/** @extends {base}\n * @constructor */function derived() {}\n" +
         "derived.inherits(base);",
         "(new derived).constructor",
-        "function (this:derived): undefined");
+        "function (new:derived, ...[?]): ?");
   }
 
   public void testGoodExtends8() throws Exception {
@@ -2735,10 +3449,81 @@
         "required: boolean");
   }
 
+  public void testGoodExtends12() throws Exception {
+    testTypes(
+        "/** @constructor \n * @extends {Super} */ function Sub() {}" +
+        "/** @constructor \n * @extends {Sub} */ function Sub2() {}" +
+        "/** @constructor */ function Super() {}" +
+        "/** @param {Super} x */ function foo(x) {}" +
+        "foo(new Sub2());");
+  }
+
+  public void testGoodExtends13() throws Exception {
+    testTypes(
+        "/** @constructor \n * @extends {B}  */ function C() {}" +
+        "/** @constructor \n * @extends {D}  */ function E() {}" +
+        "/** @constructor \n * @extends {C}  */ function D() {}" +
+        "/** @constructor \n * @extends {A} */ function B() {}" +
+        "/** @constructor */ function A() {}" +
+        "/** @param {number} x */ function f(x) {} f(new E());",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : E\n" +
+        "required: number");
+  }
+
+  public void testGoodExtends14() throws Exception {
+    testTypes(
+        CLOSURE_DEFS +
+        "/** @param {Function} f */ function g(f) {" +
+        "  /** @constructor */ function NewType() {};" +
+        "  goog.inherits(NewType, f);" +
+        "  (new NewType());" +
+        "}");
+  }
+
+  public void testGoodExtends15() throws Exception {
+    testTypes(
+        CLOSURE_DEFS +
+        "/** @constructor */ function OldType() {}" +
+        "/** @param {?function(new:OldType)} f */ function g(f) {" +
+        "  /**\n" +
+        "    * @constructor\n" +
+        "    * @extends {OldType}\n" +
+        "    */\n" +
+        "  function NewType() {};" +
+        "  goog.inherits(NewType, f);" +
+        "  NewType.prototype.method = function() {" +
+        "    NewType.superClass_.foo.call(this);" +
+        "  };" +
+        "}",
+        "Property foo never defined on OldType.prototype");
+  }
+
+  public void testGoodExtends16() throws Exception {
+    testTypes(
+        CLOSURE_DEFS +
+        "/** @param {Function} f */ function g(f) {" +
+        "  /** @constructor */ function NewType() {};" +
+        "  goog.inherits(f, NewType);" +
+        "  (new NewType());" +
+        "}");
+  }
+
+  public void testGoodExtends17() throws Exception {
+    testFunctionType(
+        "Function.prototype.inherits = function(x) {};" +
+        "/** @constructor */function base() {}\n" +
+        "/** @param {number} x */ base.prototype.bar = function(x) {};\n" +
+        "/** @extends {base}\n * @constructor */function derived() {}\n" +
+        "derived.inherits(base);",
+        "(new derived).constructor.prototype.bar",
+        "function (this:base, number): undefined");
+  }
+
   public void testBadExtends1() throws Exception {
     testTypes("/** @constructor */function base() {}\n" +
         "/** @constructor\n * @extends {not_base} */function derived() {}\n",
-        "Parse error. Unknown type not_base");
+        "Bad type annotation. Unknown type not_base");
   }
 
   public void testBadExtends2() throws Exception {
@@ -2762,6 +3547,17 @@
         "@extends used without @constructor or @interface for base");
   }
 
+  public void testBadExtends4() throws Exception {
+    // If there's a subclass of a class with a bad extends,
+    // we only want to warn about the first one.
+    testTypes(
+        "/** @constructor \n * @extends {bad} */ function Sub() {}" +
+        "/** @constructor \n * @extends {Sub} */ function Sub2() {}" +
+        "/** @param {Sub} x */ function foo(x) {}" +
+        "foo(new Sub2());",
+        "Bad type annotation. Unknown type bad");
+  }
+
   public void testLateExtends() throws Exception {
     testTypes(
         CLOSURE_DEFS +
@@ -2850,6 +3646,20 @@
         "/** @return {string} */ function foo() { return (new Base).foo; }");
   }
 
+  public void testDirectPrototypeAssignment3() throws Exception {
+    // This verifies that the compiler doesn't crash if the user
+    // overwrites the prototype of a global variable in a local scope.
+    testTypes(
+        "/** @constructor */ var MainWidgetCreator = function() {};" +
+        "/** @param {Function} ctor */" +
+        "function createMainWidget(ctor) {" +
+        "  /** @constructor */ function tempCtor() {};" +
+        "  tempCtor.prototype = ctor.prototype;" +
+        "  MainWidgetCreator.superClass_ = ctor.prototype;" +
+        "  MainWidgetCreator.prototype = new tempCtor();" +
+        "}");
+  }
+
   public void testGoodImplements1() throws Exception {
     testTypes("/** @interface */function Disposable() {}\n" +
         "/** @implements {Disposable}\n * @constructor */function f() {}");
@@ -2866,7 +3676,58 @@
 
   public void testGoodImplements3() throws Exception {
     testTypes("/** @interface */function Disposable() {}\n" +
-        "/** @implements {Disposable}\n * @interface */function f() {}");
+        "/** @constructor \n @implements {Disposable} */function f() {}");
+  }
+
+  public void testGoodImplements4() throws Exception {
+    testTypes("var goog = {};" +
+        "/** @type {!Function} */" +
+        "goog.abstractMethod = function() {};" +
+        "/** @interface */\n" +
+        "goog.Disposable = goog.abstractMethod;" +
+        "goog.Disposable.prototype.dispose = goog.abstractMethod;" +
+        "/** @implements {goog.Disposable}\n * @constructor */" +
+        "goog.SubDisposable = function() {};" +
+        "/** @inheritDoc */ " +
+        "goog.SubDisposable.prototype.dispose = function() {};");
+  }
+
+  public void testGoodImplements5() throws Exception {
+    testTypes(
+        "/** @interface */\n" +
+        "goog.Disposable = function() {};" +
+        "/** @type {Function} */" +
+        "goog.Disposable.prototype.dispose = function() {};" +
+        "/** @implements {goog.Disposable}\n * @constructor */" +
+        "goog.SubDisposable = function() {};" +
+        "/** @param {number} key \n @override */ " +
+        "goog.SubDisposable.prototype.dispose = function(key) {};");
+  }
+
+  public void testGoodImplements6() throws Exception {
+    testTypes(
+        "var myNullFunction = function() {};" +
+        "/** @interface */\n" +
+        "goog.Disposable = function() {};" +
+        "/** @return {number} */" +
+        "goog.Disposable.prototype.dispose = myNullFunction;" +
+        "/** @implements {goog.Disposable}\n * @constructor */" +
+        "goog.SubDisposable = function() {};" +
+        "/** @return {number} \n @override */ " +
+        "goog.SubDisposable.prototype.dispose = function() { return 0; };");
+  }
+
+  public void testGoodImplements7() throws Exception {
+    testTypes(
+        "var myNullFunction = function() {};" +
+        "/** @interface */\n" +
+        "goog.Disposable = function() {};" +
+        "/** @return {number} */" +
+        "goog.Disposable.prototype.dispose = function() {};" +
+        "/** @implements {goog.Disposable}\n * @constructor */" +
+        "goog.SubDisposable = function() {};" +
+        "/** @return {number} \n @override */ " +
+        "goog.SubDisposable.prototype.dispose = function() { return 0; };");
   }
 
   public void testBadImplements1() throws Exception {
@@ -2876,13 +3737,54 @@
         " * @implements {nonExistent}\n" +
         " * @implements {Base2}\n" +
         " */ function derived() {}",
-        "Parse error. Unknown type nonExistent");
+        "Bad type annotation. Unknown type nonExistent");
   }
 
   public void testBadImplements2() throws Exception {
     testTypes("/** @interface */function Disposable() {}\n" +
         "/** @implements {Disposable}\n */function f() {}",
-        "@implements used without @constructor or @interface for f");
+        "@implements used without @constructor for f");
+  }
+
+  public void testBadImplements3() throws Exception {
+    testTypes(
+        "var goog = {};" +
+        "/** @type {!Function} */ goog.abstractMethod = function(){};" +
+        "/** @interface */ var Disposable = goog.abstractMethod;" +
+        "Disposable.prototype.method = goog.abstractMethod;" +
+        "/** @implements {Disposable}\n * @constructor */function f() {}",
+        "property method on interface Disposable is not implemented by type f");
+  }
+
+  public void testBadImplements4() throws Exception {
+    testTypes("/** @interface */function Disposable() {}\n" +
+        "/** @implements {Disposable}\n * @interface */function f() {}",
+        "f cannot implement this type; an interface can only extend, " +
+        "but not implement interfaces");
+  }
+
+  public void testBadImplements5() throws Exception {
+    testTypes("/** @interface */function Disposable() {}\n" +
+        "/** @type {number} */ Disposable.prototype.bar = function() {};",
+        "assignment to property bar of Disposable.prototype\n" +
+        "found   : function (): undefined\n" +
+        "required: number");
+  }
+
+  public void testBadImplements6() throws Exception {
+    testClosureTypesMultipleWarnings(
+        "/** @interface */function Disposable() {}\n" +
+        "/** @type {function()} */ Disposable.prototype.bar = 3;",
+        Lists.newArrayList(
+            "assignment to property bar of Disposable.prototype\n" +
+            "found   : number\n" +
+            "required: function (): ?",
+            "interface members can only be empty property declarations, " +
+            "empty functions, or goog.abstractMethod"));
+  }
+
+  public void testConstructorClassTemplate() throws Exception {
+    testTypes("/** @constructor \n @template S,T */ function A() {}\n");
   }
 
   public void testInterfaceExtends() throws Exception {
@@ -2895,21 +3797,31 @@
 
   public void testBadInterfaceExtends1() throws Exception {
     testTypes("/** @interface \n * @extends {nonExistent} */function A() {}",
-        "Parse error. Unknown type nonExistent");
+        "Bad type annotation. Unknown type nonExistent");
+  }
+
+  public void testBadInterfaceExtendsNonExistentInterfaces() throws Exception {
+    String js = "/** @interface \n" +
+        " * @extends {nonExistent1} \n" +
+        " * @extends {nonExistent2} \n" +
+        " */function A() {}";
+    String[] expectedWarnings = {
+      "Bad type annotation. Unknown type nonExistent1",
+      "Bad type annotation. Unknown type nonExistent2"
+    };
+    testTypes(js, expectedWarnings);
   }
 
   public void testBadInterfaceExtends2() throws Exception {
     testTypes("/** @constructor */function A() {}\n" +
         "/** @interface \n * @extends {A} */function B() {}",
-        "B cannot extend this type; a constructor can only extend objects " +
-        "and an interface can only extend interfaces");
+        "B cannot extend this type; interfaces can only extend interfaces");
   }
 
   public void testBadInterfaceExtends3() throws Exception {
     testTypes("/** @interface */function A() {}\n" +
         "/** @constructor \n * @extends {A} */function B() {}",
-        "B cannot extend this type; a constructor can only extend objects " +
-        "and an interface can only extend interfaces");
+        "B cannot extend this type; constructors can only extend constructors");
   }
 
   public void testBadInterfaceExtends4() throws Exception {
@@ -2946,6 +3858,40 @@
         "can only implement interfaces");
   }
 
+  public void testBadImplementsDuplicateInterface1() throws Exception {
+    // verify that the same base (not templatized) interface cannot be
+    // @implemented more than once.
+    testTypes(
+        "/** @interface \n" +
+        " * @template T\n" +
+        " */\n" +
+        "function Foo() {}\n" +
+        "/** @constructor \n" +
+        " * @implements {Foo.<?>}\n" +
+        " * @implements {Foo}\n" +
+        " */\n" +
+        "function A() {}\n",
+        "Cannot @implement the same interface more than once\n" +
+        "Repeated interface: Foo");
+  }
+
+  public void testBadImplementsDuplicateInterface2() throws Exception {
+    // verify that the same base (not templatized) interface cannot be
+    // @implemented more than once.
+    testTypes(
+        "/** @interface \n" +
+        " * @template T\n" +
+        " */\n" +
+        "function Foo() {}\n" +
+        "/** @constructor \n" +
+        " * @implements {Foo.<string>}\n" +
+        " * @implements {Foo.<number>}\n" +
+        " */\n" +
+        "function A() {}\n",
+        "Cannot @implement the same interface more than once\n" +
+        "Repeated interface: Foo");
+  }
+
   public void testInterfaceAssignment1() throws Exception {
     testTypes("/** @interface */var I = function() {};\n" +
         "/** @constructor\n@implements {I} */var T = function() {};\n" +
@@ -3012,7 +3958,8 @@
   public void testInterfaceAssignment8() throws Exception {
     testTypes("/** @interface */var I = function() {};\n" +
         "/** @type {I} */var i;\n" +
-        "/** @type {Object} */var o = i;");
+        "/** @type {Object} */var o = i;\n" +
+        "new Object().prototype = i.prototype;");
   }
 
   public void testInterfaceAssignment9() throws Exception {
@@ -3066,11 +4013,428 @@
 
   public void testGetprop1() throws Exception {
     testTypes("/** @return {void}*/function foo(){foo().bar;}",
-        "undefined has no properties\n" +
+        "No properties on this expression\n" +
         "found   : undefined\n" +
         "required: Object");
   }
 
+  public void testGetprop2() throws Exception {
+    testTypes("var x = null; x.alert();",
+        "No properties on this expression\n" +
+        "found   : null\n" +
+        "required: Object");
+  }
+
+  public void testGetprop3() throws Exception {
+    testTypes(
+        "/** @constructor */ " +
+        "function Foo() { /** @type {?Object} */ this.x = null; }" +
+        "Foo.prototype.initX = function() { this.x = {foo: 1}; };" +
+        "Foo.prototype.bar = function() {" +
+        "  if (this.x == null) { this.initX(); alert(this.x.foo); }" +
+        "};");
+  }
+
+  public void testGetprop4() throws Exception {
+    testTypes("var x = null; x.prop = 3;",
+        "No properties on this expression\n" +
+        "found   : null\n" +
+        "required: Object");
+  }
+
+  public void testSetprop1() throws Exception {
+    // Create property on struct in the constructor
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */\n" +
+              "function Foo() { this.x = 123; }");
+  }
+
+  public void testSetprop2() throws Exception {
+    // Create property on struct outside the constructor
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */\n" +
+              "function Foo() {}\n" +
+              "(new Foo()).x = 123;",
+              "Cannot add a property to a struct instance " +
+              "after it is constructed.");
+  }
+
+  public void testSetprop3() throws Exception {
+    // Create property on struct outside the constructor
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */\n" +
+              "function Foo() {}\n" +
+              "(function() { (new Foo()).x = 123; })();",
+              "Cannot add a property to a struct instance " +
+              "after it is constructed.");
+  }
+
+  public void testSetprop4() throws Exception {
+    // Assign to existing property of struct outside the constructor
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */\n" +
+              "function Foo() { this.x = 123; }\n" +
+              "(new Foo()).x = \"asdf\";");
+  }
+
+  public void testSetprop5() throws Exception {
+    // Create a property on union that includes a struct
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */\n" +
+              "function Foo() {}\n" +
+              "(true ? new Foo() : {}).x = 123;",
+              "Cannot add a property to a struct instance " +
+              "after it is constructed.");
+  }
+
+  public void testSetprop6() throws Exception {
+    // Create property on struct in another constructor
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */\n" +
+              "function Foo() {}\n" +
+              "/**\n" +
+              " * @constructor\n" +
+              " * @param{Foo} f\n" +
+              " */\n" +
+              "function Bar(f) { f.x = 123; }",
+              "Cannot add a property to a struct instance " +
+              "after it is constructed.");
+  }
+
+  public void testSetprop7() throws Exception {
+    //Bug b/c we require THIS when creating properties on structs for simplicity
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */\n" +
+              "function Foo() {\n" +
+              "  var t = this;\n" +
+              "  t.x = 123;\n" +
+              "}",
+              "Cannot add a property to a struct instance " +
+              "after it is constructed.");
+  }
+
+  public void testSetprop8() throws Exception {
+    // Create property on struct using DEC
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */\n" +
+              "function Foo() {}\n" +
+              "(new Foo()).x--;",
+              new String[] {
+                "Property x never defined on Foo",
+                "Cannot add a property to a struct instance " +
+                "after it is constructed."
+              });
+  }
+
+  public void testSetprop9() throws Exception {
+    // Create property on struct using ASSIGN_ADD
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */\n" +
+              "function Foo() {}\n" +
+              "(new Foo()).x += 123;",
+              new String[] {
+                "Property x never defined on Foo",
+                "Cannot add a property to a struct instance " +
+                "after it is constructed."
+              });
+  }
+
+  public void testSetprop10() throws Exception {
+    // Create property on object literal that is a struct
+    testTypes("/** \n" +
+              " * @constructor \n" +
+              " * @struct \n" +
+              " */ \n" +
+              "function Square(side) { \n" +
+              "  this.side = side; \n" +
+              "} \n" +
+              "Square.prototype = /** @struct */ {\n" +
+              "  area: function() { return this.side * this.side; }\n" +
+              "};\n" +
+              "Square.prototype.id = function(x) { return x; };");
+  }
+
+  public void testSetprop11() throws Exception {
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */\n" +
+              "function Foo() {}\n" +
+              "/** @constructor */\n" +
+              "function Bar() {}\n" +
+              "Bar.prototype = new Foo();\n" +
+              "Bar.prototype.someprop = 123;");
+  }
+
+  public void testSetprop12() throws Exception {
+    // Create property on a constructor of structs (which isn't itself a struct)
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */\n" +
+              "function Foo() {}\n" +
+              "Foo.someprop = 123;");
+  }
+
+  public void testSetprop13() throws Exception {
+    // Create static property on struct
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */\n" +
+              "function Parent() {}\n" +
+              "/**\n" +
+              " * @constructor\n" +
+              " * @extends {Parent}\n" +
+              " */\n" +
+              "function Kid() {}\n" +
+              "Kid.prototype.foo = 123;\n" +
+              "var x = (new Kid()).foo;");
+  }
+
+  public void testSetprop14() throws Exception {
+    // Create static property on struct
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */\n" +
+              "function Top() {}\n" +
+              "/**\n" +
+              " * @constructor\n" +
+              " * @extends {Top}\n" +
+              " */\n" +
+              "function Mid() {}\n" +
+              "/** blah blah */\n" +
+              "Mid.prototype.foo = function() { return 1; };\n" +
+              "/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " * @extends {Mid}\n" +
+              " */\n" +
+              "function Bottom() {}\n" +
+              "/** @override */\n" +
+              "Bottom.prototype.foo = function() { return 3; };");
+  }
+
+  public void testGetpropDict1() throws Exception {
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @dict\n" +
+              " */" +
+              "function Dict1(){ this['prop'] = 123; }" +
+              "/** @param{Dict1} x */" +
+              "function takesDict(x) { return x.prop; }",
+              "Cannot do '.' access on a dict");
+  }
+
+  public void testGetpropDict2() throws Exception {
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @dict\n" +
+              " */" +
+              "function Dict1(){ this['prop'] = 123; }" +
+              "/**\n" +
+              " * @constructor\n" +
+              " * @extends {Dict1}\n" +
+              " */" +
+              "function Dict1kid(){ this['prop'] = 123; }" +
+              "/** @param{Dict1kid} x */" +
+              "function takesDict(x) { return x.prop; }",
+              "Cannot do '.' access on a dict");
+  }
+
+  public void testGetpropDict3() throws Exception {
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @dict\n" +
+              " */" +
+              "function Dict1() { this['prop'] = 123; }" +
+              "/** @constructor */" +
+              "function NonDict() { this.prop = 321; }" +
+              "/** @param{(NonDict|Dict1)} x */" +
+              "function takesDict(x) { return x.prop; }",
+              "Cannot do '.' access on a dict");
+  }
+
+  public void testGetpropDict4() throws Exception {
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @dict\n" +
+              " */" +
+              "function Dict1() { this['prop'] = 123; }" +
+              "/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */" +
+              "function Struct1() { this.prop = 123; }" +
+              "/** @param{(Struct1|Dict1)} x */" +
+              "function takesNothing(x) { return x.prop; }",
+              "Cannot do '.' access on a dict");
+  }
+
+  public void testGetpropDict5() throws Exception {
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @dict\n" +
+              " */" +
+              "function Dict1(){ this.prop = 123; }",
+              "Cannot do '.' access on a dict");
+  }
+
+  public void testGetpropDict6() throws Exception {
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @dict\n" +
+              " */\n" +
+              "function Foo() {}\n" +
+              "function Bar() {}\n" +
+              "Bar.prototype = new Foo();\n" +
+              "Bar.prototype.someprop = 123;\n",
+              "Cannot do '.' access on a dict");
+  }
+
+  public void testGetpropDict7() throws Exception {
+    testTypes("(/** @dict */ {'x': 123}).x = 321;",
+              "Cannot do '.' access on a dict");
+  }
+
+  public void testGetelemStruct1() throws Exception {
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */" +
+              "function Struct1(){ this.prop = 123; }" +
+              "/** @param{Struct1} x */" +
+              "function takesStruct(x) {" +
+              "  var z = x;" +
+              "  return z['prop'];" +
+              "}",
+              "Cannot do '[]' access on a struct");
+  }
+
+  public void testGetelemStruct2() throws Exception {
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */" +
+              "function Struct1(){ this.prop = 123; }" +
+              "/**\n" +
+              " * @constructor\n" +
+              " * @extends {Struct1}" +
+              " */" +
+              "function Struct1kid(){ this.prop = 123; }" +
+              "/** @param{Struct1kid} x */" +
+              "function takesStruct2(x) { return x['prop']; }",
+              "Cannot do '[]' access on a struct");
+  }
+
+  public void testGetelemStruct3() throws Exception {
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */" +
+              "function Struct1(){ this.prop = 123; }" +
+              "/**\n" +
+              " * @constructor\n" +
+              " * @extends {Struct1}\n" +
+              " */" +
+              "function Struct1kid(){ this.prop = 123; }" +
+              "var x = (new Struct1kid())['prop'];",
+              "Cannot do '[]' access on a struct");
+  }
+
+  public void testGetelemStruct4() throws Exception {
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */" +
+              "function Struct1() { this.prop = 123; }" +
+              "/** @constructor */" +
+              "function NonStruct() { this.prop = 321; }" +
+              "/** @param{(NonStruct|Struct1)} x */" +
+              "function takesStruct(x) { return x['prop']; }",
+              "Cannot do '[]' access on a struct");
+  }
+
+  public void testGetelemStruct5() throws Exception {
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */" +
+              "function Struct1() { this.prop = 123; }" +
+              "/**\n" +
+              " * @constructor\n" +
+              " * @dict\n" +
+              " */" +
+              "function Dict1() { this['prop'] = 123; }" +
+              "/** @param{(Struct1|Dict1)} x */" +
+              "function takesNothing(x) { return x['prop']; }",
+              "Cannot do '[]' access on a struct");
+  }
+
+  public void testGetelemStruct6() throws Exception {
+    // By casting Bar to Foo, the illegal bracket access is not detected
+    testTypes("/** @interface */ function Foo(){}\n" +
+              "/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " * @implements {Foo}\n" +
+              " */" +
+              "function Bar(){ this.x = 123; }\n" +
+              "var z = /** @type {Foo} */(new Bar)['x'];");
+  }
+
+  public void testGetelemStruct7() throws Exception {
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */\n" +
+              "function Foo() {}\n" +
+              "/** @constructor */\n" +
+              "function Bar() {}\n" +
+              "Bar.prototype = new Foo();\n" +
+              "Bar.prototype['someprop'] = 123;\n",
+              "Cannot do '[]' access on a struct");
+  }
+
+  public void testInOnStruct() throws Exception {
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */" +
+              "function Foo() {}\n" +
+              "if ('prop' in (new Foo())) {}",
+              "Cannot use the IN operator with structs");
+  }
+
+  public void testForinOnStruct() throws Exception {
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */" +
+              "function Foo() {}\n" +
+              "for (var prop in (new Foo())) {}",
+              "Cannot use the IN operator with structs");
+  }
+
   public void testArrayAccess1() throws Exception {
     testTypes("var a = []; var b = a['hi'];");
   }
@@ -3121,6 +4485,14 @@
         "required: Object");
   }
 
+  public void testArrayAccess9() throws Exception {
+    testTypes("/** @return {?Array} */ function f() { return []; }" +
+        "f()[{}]",
+        "array access\n" +
+        "found   : {}\n" +
+        "required: number");
+  }
+
   public void testPropAccess() throws Exception {
     testTypes("/** @param {*} x */var f = function(x) {\n" +
         "var o = String(x);\n" +
@@ -3131,7 +4503,7 @@
 
   public void testPropAccess2() throws Exception {
     testTypes("var bar = void 0; bar.baz;",
-        "undefined has no properties\n" +
+        "No properties on this expression\n" +
         "found   : undefined\n" +
         "required: Object");
   }
@@ -3140,7 +4512,7 @@
     // Verifies that we don't emit two warnings, because
     // the var has been dereferenced after the first one.
     testTypes("var bar = void 0; bar.baz; bar.bax;",
-        "undefined has no properties\n" +
+        "No properties on this expression\n" +
         "found   : undefined\n" +
         "required: Object");
   }
@@ -3166,7 +4538,7 @@
     TypeCheckResult p =
         parseAndTypeCheckWithScope("/** @type {(string,null)} */var a = null");
 
-    assertEquals(createUnionType(STRING_TYPE, NULL_TYPE),
+    assertTypeEquals(createUnionType(STRING_TYPE, NULL_TYPE),
         p.scope.getVar("a").getType());
   }
 
@@ -3177,14 +4549,14 @@
   public void testVar3() throws Exception {
     TypeCheckResult p = parseAndTypeCheckWithScope("var a = 3;");
 
-    assertEquals(NUMBER_TYPE, p.scope.getVar("a").getType());
+    assertTypeEquals(NUMBER_TYPE, p.scope.getVar("a").getType());
   }
 
   public void testVar4() throws Exception {
     TypeCheckResult p = parseAndTypeCheckWithScope(
         "var a = 3; a = 'string';");
 
-    assertEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),
+    assertTypeEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),
         p.scope.getVar("a").getType());
   }
 
@@ -3508,6 +4880,16 @@
         "cannot instantiate non-constructor");
   }
 
+  public void testHigherOrderFunctions5() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function g(x) {}" +
+        "/** @type {function(new:Error,...[number]):Date} */ var f;" +
+        "g(new f());",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : Error\n" +
+        "required: number");
+  }
+
   public void testConstructorAlias1() throws Exception {
     testTypes(
         "/** @constructor */ var Foo = function() {};" +
@@ -3587,8 +4969,10 @@
   public void testConstructorAlias8() throws Exception {
     testTypes(
         "var goog = {};" +
-        "/**\n * @param {number} x \n * @constructor */ goog.Foo = function(x) {};" +
-        "/**\n * @param {number} x \n * @constructor */ goog.FooAlias = goog.Foo;" +
+        "/**\n * @param {number} x \n * @constructor */ " +
+        "goog.Foo = function(x) {};" +
+        "/**\n * @param {number} x \n * @constructor */ " +
+        "goog.FooAlias = goog.Foo;" +
         "/** @return {number} */ function foo() { " +
         "  return new goog.FooAlias(1); }",
         "inconsistent return type\n" +
@@ -3599,7 +4983,8 @@
   public void testConstructorAlias9() throws Exception {
     testTypes(
         "var goog = {};" +
-        "/**\n * @param {number} x \n * @constructor */ goog.Foo = function(x) {};" +
+        "/**\n * @param {number} x \n * @constructor */ " +
+        "goog.Foo = function(x) {};" +
         "/** @constructor */ goog.FooAlias = goog.Foo;" +
         "/** @return {number} */ function foo() { " +
         "  return new goog.FooAlias(1); }",
@@ -3610,7 +4995,8 @@
 
   public void testConstructorAlias10() throws Exception {
     testTypes(
-        "/**\n * @param {number} x \n * @constructor */ var Foo = function(x) {};" +
+        "/**\n * @param {number} x \n * @constructor */ " +
+        "var Foo = function(x) {};" +
         "/** @constructor */ var FooAlias = Foo;" +
         "/** @return {number} */ function foo() { " +
         "  return new FooAlias(1); }",
@@ -3676,8 +5062,6 @@
   public void testClosure7() throws Exception {
     testClosureTypes(
         CLOSURE_DEFS +
-        "goog.asserts = {};" +
-        "/** @return {*} */ goog.asserts.assert = function(x) { return x; };" +
         "/** @type {string|null|undefined} */ var a = foo();" +
         "/** @type {number} */" +
         "var b = goog.asserts.assert(a);",
@@ -3721,7 +5105,7 @@
 
   public void testReturn6() throws Exception {
     testTypes(
-        "/** @param {number} opt_a\n@return string */" +
+        "/** @param {number} opt_a\n@return {string} */" +
         "function a(opt_a) { return opt_a }",
         "inconsistent return type\n" +
         "found   : (number|undefined)\n" +
@@ -3926,6 +5310,144 @@
         "required: string");
   }
 
+  public void testInferredParam7() throws Exception {
+    testTypes(
+        "/** @param {string} x */ function f(x) {}" +
+        "var bar = /** @type {function(number=,number=)} */ (" +
+        "    function(x, y) { f(y); });",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : (number|undefined)\n" +
+        "required: string");
+  }
+
+  public void testOverriddenParams1() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @param {...?} var_args */" +
+        "Foo.prototype.bar = function(var_args) {};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @param {number} x\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function(x) {};");
+  }
+
+  public void testOverriddenParams2() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @type {function(...[?])} */" +
+        "Foo.prototype.bar = function(var_args) {};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @type {function(number)}\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function(x) {};");
+  }
+
+  public void testOverriddenParams3() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @param {...number} var_args */" +
+        "Foo.prototype.bar = function(var_args) { };" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @param {number} x\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function(x) {};",
+        "mismatch of the bar property type and the type of the " +
+        "property it overrides from superclass Foo\n" +
+        "original: function (this:Foo, ...[number]): undefined\n" +
+        "override: function (this:SubFoo, number): undefined");
+  }
+
+  public void testOverriddenParams4() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @type {function(...[number])} */" +
+        "Foo.prototype.bar = function(var_args) {};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @type {function(number)}\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function(x) {};",
+        "mismatch of the bar property type and the type of the " +
+        "property it overrides from superclass Foo\n" +
+        "original: function (...[number]): ?\n" +
+        "override: function (number): ?");
+  }
+
+  public void testOverriddenParams5() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @param {number} x */" +
+        "Foo.prototype.bar = function(x) { };" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function() {};" +
+        "(new SubFoo()).bar();");
+  }
+
+  public void testOverriddenParams6() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @param {number} x */" +
+        "Foo.prototype.bar = function(x) { };" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function() {};" +
+        "(new SubFoo()).bar(true);",
+        "actual parameter 1 of SubFoo.prototype.bar " +
+        "does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testOverriddenParams7() throws Exception {
+    testTypes(
+        "/** @constructor\n * @template T */ function Foo() {}" +
+        "/** @param {T} x */" +
+        "Foo.prototype.bar = function(x) { };" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo.<string>}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @param {number} x\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function(x) {};",
+        "mismatch of the bar property type and the type of the " +
+        "property it overrides from superclass Foo\n" +
+        "original: function (this:Foo, string): undefined\n" +
+        "override: function (this:SubFoo, number): undefined");
+  }
+
   public void testOverriddenReturn1() throws Exception {
     testTypes(
         "/** @constructor */ function Foo() {}" +
@@ -3953,21 +5475,136 @@
         "override: function (this:SubFoo): (Foo|null)");
   }
 
+  public void testOverriddenReturn3() throws Exception {
+    testTypes(
+        "/** @constructor \n * @template T */ function Foo() {}" +
+        "/** @return {T} */ Foo.prototype.bar = " +
+        "    function() { return null; };" +
+        "/** @constructor \n * @extends {Foo.<string>} */ function SubFoo() {}" +
+        "/** @override */ SubFoo.prototype.bar = " +
+        "    function() { return 3; }",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testOverriddenReturn4() throws Exception {
+    testTypes(
+        "/** @constructor \n * @template T */ function Foo() {}" +
+        "/** @return {T} */ Foo.prototype.bar = " +
+        "    function() { return null; };" +
+        "/** @constructor \n * @extends {Foo.<string>} */ function SubFoo() {}" +
+        "/** @return {number}\n * @override */ SubFoo.prototype.bar = " +
+        "    function() { return 3; }",
+        "mismatch of the bar property type and the type of the " +
+        "property it overrides from superclass Foo\n" +
+        "original: function (this:Foo): string\n" +
+        "override: function (this:SubFoo): number");
+  }
+
   public void testThis1() throws Exception {
     testTypes("var goog = {};" +
         "/** @constructor */goog.A = function(){};" +
-        "/** @return number */goog.A.prototype.n = function() { return this };",
+        "/** @return {number} */" +
+        "goog.A.prototype.n = function() { return this };",
         "inconsistent return type\n" +
         "found   : goog.A\n" +
         "required: number");
   }
 
+  public void testOverriddenProperty1() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @type {Object} */" +
+        "Foo.prototype.bar = {};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @type {Array}\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = [];");
+  }
+
+  public void testOverriddenProperty2() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {" +
+        "  /** @type {Object} */" +
+        "  this.bar = {};" +
+        "}" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @type {Array}\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = [];");
+  }
+
+  public void testOverriddenProperty3() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {" +
+        "}" +
+        "/** @type {string} */ Foo.prototype.data;" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/** @type {string|Object} \n @override */ " +
+        "SubFoo.prototype.data = null;",
+        "mismatch of the data property type and the type " +
+        "of the property it overrides from superclass Foo\n" +
+        "original: string\n" +
+        "override: (Object|null|string)");
+  }
+
+  public void testOverriddenProperty4() throws Exception {
+    // These properties aren't declared, so there should be no warning.
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype.bar = null;" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "SubFoo.prototype.bar = 3;");
+  }
+
+  public void testOverriddenProperty5() throws Exception {
+    // An override should be OK if the superclass property wasn't declared.
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype.bar = null;" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/** @override */ SubFoo.prototype.bar = 3;");
+  }
+
+  public void testOverriddenProperty6() throws Exception {
+    // The override keyword shouldn't be neccessary if the subclass property
+    // is inferred.
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @type {?number} */ Foo.prototype.bar = null;" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "SubFoo.prototype.bar = 3;");
+  }
+
   public void testThis2() throws Exception {
     testTypes("var goog = {};" +
         "/** @constructor */goog.A = function(){" +
         "  this.foo = null;" +
         "};" +
-        "/** @return number */" +
+        "/** @return {number} */" +
         "goog.A.prototype.n = function() { return this.foo };",
         "inconsistent return type\n" +
         "found   : null\n" +
@@ -3987,7 +5624,7 @@
         "/** @constructor */goog.A = function(){" +
         "  /** @type {string?} */this.foo = null;" +
         "};" +
-        "/** @return number */goog.A.prototype.n = function() {" +
+        "/** @return {number} */goog.A.prototype.n = function() {" +
         "  return this.foo };",
         "inconsistent return type\n" +
         "found   : (null|string)\n" +
@@ -3995,7 +5632,7 @@
   }
 
   public void testThis5() throws Exception {
-    testTypes("/** @this Date\n@return number*/function h() { return this }",
+    testTypes("/** @this Date\n@return {number}*/function h() { return this }",
         "inconsistent return type\n" +
         "found   : Date\n" +
         "required: number");
@@ -4003,7 +5640,7 @@
 
   public void testThis6() throws Exception {
     testTypes("var goog = {};" +
-        "/** @constructor\n@return !Date */" +
+        "/** @constructor\n@return {!Date} */" +
         "goog.A = function(){ return this };",
         "inconsistent return type\n" +
         "found   : goog.A\n" +
@@ -4012,7 +5649,7 @@
 
   public void testThis7() throws Exception {
     testTypes("/** @constructor */function A(){};" +
-        "/** @return number */A.prototype.n = function() { return this };",
+        "/** @return {number} */A.prototype.n = function() { return this };",
         "inconsistent return type\n" +
         "found   : A\n" +
         "required: number");
@@ -4022,7 +5659,7 @@
     testTypes("/** @constructor */function A(){" +
         "  /** @type {string?} */this.foo = null;" +
         "};" +
-        "/** @return number */A.prototype.n = function() {" +
+        "/** @return {number} */A.prototype.n = function() {" +
         "  return this.foo };",
         "inconsistent return type\n" +
         "found   : (null|string)\n" +
@@ -4047,6 +5684,94 @@
         "required: string");
   }
 
+  public void testThis11() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @constructor */ function Ctor() {" +
+        "  /** @this {Date} */" +
+        "  this.method = function() {" +
+        "    f(this);" +
+        "  };" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : Date\n" +
+        "required: number");
+  }
+
+  public void testThis12() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @constructor */ function Ctor() {}" +
+        "Ctor.prototype['method'] = function() {" +
+        "  f(this);" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : Ctor\n" +
+        "required: number");
+  }
+
+  public void testThis13() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @constructor */ function Ctor() {}" +
+        "Ctor.prototype = {" +
+        "  method: function() {" +
+        "    f(this);" +
+        "  }" +
+        "};",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : Ctor\n" +
+        "required: number");
+  }
+
+  public void testThis14() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "f(this.Object);",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : function (new:Object, *=): ?\n" +
+        "required: number");
+  }
+
+  public void testThisTypeOfFunction1() throws Exception {
+    testTypes(
+        "/** @type {function(this:Object)} */ function f() {}" +
+        "f();");
+  }
+
+  public void testThisTypeOfFunction2() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** @type {function(this:F)} */ function f() {}" +
+        "f();",
+        "\"function (this:F): ?\" must be called with a \"this\" type");
+  }
+
+  public void testThisTypeOfFunction3() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "F.prototype.bar = function() {};" +
+        "var f = (new F()).bar; f();",
+        "\"function (this:F): undefined\" must be called with a \"this\" type");
+  }
+
+  public void testThisTypeOfFunction4() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "F.prototype.moveTo = function(x, y) {};" +
+        "F.prototype.lineTo = function(x, y) {};" +
+        "function demo() {" +
+        "  var path = new F();" +
+        "  var points = [[1,1], [2,2]];" +
+        "  for (var i = 0; i < points.length; i++) {" +
+        "    (i == 0 ? path.moveTo : path.lineTo)(" +
+        "       points[i][0], points[i][1]);" +
+        "  }" +
+        "}",
+        "\"function (this:F, ?, ?): undefined\" " +
+        "must be called with a \"this\" type");
+  }
+
   public void testGlobalThis1() throws Exception {
     testTypes("/** @constructor */ function Window() {}" +
         "/** @param {string} msg */ " +
@@ -4059,11 +5784,21 @@
   }
 
   public void testGlobalThis2() throws Exception {
+    // this.alert = 3 doesn't count as a declaration, so this isn't a warning.
     testTypes("/** @constructor */ function Bindow() {}" +
         "/** @param {string} msg */ " +
         "Bindow.prototype.alert = function(msg) {};" +
         "this.alert = 3;" +
-        "(new Bindow()).alert(this.alert)",
+        "(new Bindow()).alert(this.alert)");
+  }
+
+
+  public void testGlobalThis2b() throws Exception {
+    testTypes("/** @constructor */ function Bindow() {}" +
+        "/** @param {string} msg */ " +
+        "Bindow.prototype.alert = function(msg) {};" +
+        "/** @return {number} */ this.alert = function() { return 3; };" +
+        "(new Bindow()).alert(this.alert())",
         "actual parameter 1 of Bindow.prototype.alert " +
         "does not match formal parameter\n" +
         "found   : number\n" +
@@ -4075,7 +5810,7 @@
         "/** @param {string} msg */ " +
         "function alert(msg) {};" +
         "this.alert(3);",
-        "actual parameter 1 of this.alert " +
+        "actual parameter 1 of global this.alert " +
         "does not match formal parameter\n" +
         "found   : number\n" +
         "required: string");
@@ -4086,7 +5821,7 @@
         "/** @param {string} msg */ " +
         "var alert = function(msg) {};" +
         "this.alert(3);",
-        "actual parameter 1 of this.alert " +
+        "actual parameter 1 of global this.alert " +
         "does not match formal parameter\n" +
         "found   : number\n" +
         "required: string");
@@ -4099,7 +5834,7 @@
         "  var alert = function(msg) {};" +
         "}" +
         "this.alert(3);",
-        "Property alert never defined on this");
+        "Property alert never defined on global this");
   }
 
   public void testGlobalThis6() throws Exception {
@@ -4111,6 +5846,35 @@
         "this.alert(this.x);");
   }
 
+  public void testGlobalThis7() throws Exception {
+    testTypes(
+        "/** @constructor */ function Window() {}" +
+        "/** @param {Window} msg */ " +
+        "var foo = function(msg) {};" +
+        "foo(this);");
+  }
+
+  public void testGlobalThis8() throws Exception {
+    testTypes(
+        "/** @constructor */ function Window() {}" +
+        "/** @param {number} msg */ " +
+        "var foo = function(msg) {};" +
+        "foo(this);",
+        "actual parameter 1 of foo does not match formal parameter\n" +
+        "found   : global this\n" +
+        "required: number");
+  }
+
+  public void testGlobalThis9() throws Exception {
+    testTypes(
+        // Window is not marked as a constructor, so the
+        // inheritance doesn't happen.
+        "function Window() {}" +
+        "Window.prototype.alert = function() {};" +
+        "this.alert();",
+        "Property alert never defined on global this");
+  }
+
   public void testControlFlowRestrictsType1() throws Exception {
     testTypes("/** @return {String?} */ function f() { return null; }" +
         "/** @type {String?} */ var a = f();" +
@@ -4191,6 +5955,41 @@
         "};");
   }
 
+  public void testControlFlowRestrictsType10() throws Exception {
+    // We should correctly infer that y will be (null|{}) because
+    // the loop wraps around.
+    testTypes("/** @param {number} x */ function f(x) {}" +
+        "function g() {" +
+        "  var y = null;" +
+        "  for (var i = 0; i < 10; i++) {" +
+        "    f(y);" +
+        "    if (y != null) {" +
+        "      // y is None the first time it goes through this branch\n" +
+        "    } else {" +
+        "      y = {};" +
+        "    }" +
+        "  }" +
+        "};",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : (null|{})\n" +
+        "required: number");
+  }
+
+  public void testControlFlowRestrictsType11() throws Exception {
+    testTypes("/** @param {boolean} x */ function f(x) {}" +
+        "function g() {" +
+        "  var y = null;" +
+        "  if (y != null) {" +
+        "    for (var i = 0; i < 10; i++) {" +
+        "      f(y);" +
+        "    }" +
+        "  }" +
+        "};",
+        "condition always evaluates to false\n" +
+        "left : null\n" +
+        "right: null");
+  }
+
   public void testSwitchCase3() throws Exception {
     testTypes("/** @type String */" +
         "var a = new String('foo');" +
@@ -4348,7 +6147,8 @@
              "Element.prototype.innerHTML;" +
              "/** @constructor \n @extends Element */" +
              "function DIVElement() {};",
-             "(new DIVElement).innerHTML = new Array();", null, false);
+             "(new DIVElement).innerHTML = new Array();",
+             null, false);
   }
 
   public void testImplicitCastNotInExterns() throws Exception {
@@ -4368,25 +6168,25 @@
   public void testNumberNode() throws Exception {
     Node n = typeCheck(Node.newNumber(0));
 
-    assertEquals(NUMBER_TYPE, n.getJSType());
+    assertTypeEquals(NUMBER_TYPE, n.getJSType());
   }
 
   public void testStringNode() throws Exception {
     Node n = typeCheck(Node.newString("hello"));
 
-    assertEquals(STRING_TYPE, n.getJSType());
+    assertTypeEquals(STRING_TYPE, n.getJSType());
   }
 
   public void testBooleanNodeTrue() throws Exception {
     Node trueNode = typeCheck(new Node(Token.TRUE));
 
-    assertEquals(BOOLEAN_TYPE, trueNode.getJSType());
+    assertTypeEquals(BOOLEAN_TYPE, trueNode.getJSType());
   }
 
   public void testBooleanNodeFalse() throws Exception {
     Node falseNode = typeCheck(new Node(Token.FALSE));
 
-    assertEquals(BOOLEAN_TYPE, falseNode.getJSType());
+    assertTypeEquals(BOOLEAN_TYPE, falseNode.getJSType());
   }
 
   public void testUndefinedNode() throws Exception {
@@ -4396,7 +6196,7 @@
     p.addChildToBack(Node.newNumber(5));
     typeCheck(p);
 
-    assertEquals(VOID_TYPE, n.getJSType());
+    assertTypeEquals(VOID_TYPE, n.getJSType());
   }
 
   public void testNumberAutoboxing() throws Exception {
@@ -4441,6 +6241,115 @@
         "required: boolean");
   }
 
+  public void testIIFE1() throws Exception {
+    testTypes(
+        "var namespace = {};" +
+        "/** @type {number} */ namespace.prop = 3;" +
+        "(function(ns) {" +
+        "  ns.prop = true;" +
+        "})(namespace);",
+        "assignment to property prop of ns\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testIIFE2() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "(function(ctor) {" +
+        "  /** @type {boolean} */ ctor.prop = true;" +
+        "})(Foo);" +
+        "/** @return {number} */ function f() { return Foo.prop; }",
+        "inconsistent return type\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testIIFE3() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "(function(ctor) {" +
+        "  /** @type {boolean} */ ctor.prop = true;" +
+        "})(Foo);" +
+        "/** @param {number} x */ function f(x) {}" +
+        "f(Foo.prop);",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testIIFE4() throws Exception {
+    testTypes(
+        "/** @const */ var namespace = {};" +
+        "(function(ns) {" +
+        "  /**\n" +
+        "   * @constructor\n" +
+        "   * @param {number} x\n" +
+        "   */\n" +
+        "   ns.Ctor = function(x) {};" +
+        "})(namespace);" +
+        "new namespace.Ctor(true);",
+        "actual parameter 1 of namespace.Ctor " +
+        "does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testIIFE5() throws Exception {
+    // TODO(nicksantos): This behavior is currently incorrect.
+    // To handle this case properly, we'll need to change how we handle
+    // type resolution.
+    testTypes(
+        "/** @const */ var namespace = {};" +
+        "(function(ns) {" +
+        "  /**\n" +
+        "   * @constructor\n" +
+        "   */\n" +
+        "   ns.Ctor = function() {};" +
+        "   /** @type {boolean} */ ns.Ctor.prototype.bar = true;" +
+        "})(namespace);" +
+        "/** @param {namespace.Ctor} x\n" +
+        "  * @return {number} */ function f(x) { return x.bar; }",
+        "inconsistent return type\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testNotIIFE1() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @param {...?} x */ function g(x) {}" +
+        "g(function(y) { f(y); }, true);");
+  }
+
+  public void testIssue61() throws Exception {
+    testTypes(
+        "var ns = {};" +
+        "(function() {" +
+        "  /** @param {string} b */" +
+        "  ns.a = function(b) {};" +
+        "})();" +
+        "function d() {" +
+        "  ns.a(123);" +
+        "}",
+        "actual parameter 1 of ns.a does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testIssue61b() throws Exception {
+    testTypes(
+        "var ns = {};" +
+        "(function() {" +
+        "  /** @param {string} b */" +
+        "  ns.a = function(b) {};" +
+        "})();" +
+        "ns.a(123);",
+        "actual parameter 1 of ns.a does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testIssue86() throws Exception {
     testTypes(
         "/** @interface */ function I() {}" +
@@ -4473,6 +6382,361 @@
         "right: null");
   }
 
+  public void testIssue259() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @constructor */" +
+        "var Clock = function() {" +
+        "  /** @constructor */" +
+        "  this.Date = function() {};" +
+        "  f(new this.Date());" +
+        "};",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : this.Date\n" +
+        "required: number");
+  }
+
+  public void testIssue301() throws Exception {
+    testTypes(
+        "Array.indexOf = function() {};" +
+        "var s = 'hello';" +
+        "alert(s.toLowerCase.indexOf('1'));",
+        "Property indexOf never defined on String.prototype.toLowerCase");
+  }
+
+  public void testIssue368() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo(){}" +
+        "/**\n" +
+        " * @param {number} one\n" +
+        " * @param {string} two\n" +
+        " */\n" +
+        "Foo.prototype.add = function(one, two) {};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar(){}" +
+        "/** @override */\n" +
+        "Bar.prototype.add = function(ignored) {};" +
+        "(new Bar()).add(1, 2);",
+        "actual parameter 2 of Bar.prototype.add does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testIssue380() throws Exception {
+    testTypes(
+        "/** @type { function(string): {innerHTML: string} } */\n" +
+        "document.getElementById;\n" +
+        "var list = /** @type {!Array.<string>} */ ['hello', 'you'];\n" +
+        "list.push('?');\n" +
+        "document.getElementById('node').innerHTML = list.toString();",
+        // Parse warning, but still applied.
+        "Type annotations are not allowed here. " +
+        "Are you missing parentheses?");
+  }
+
+  public void testIssue483() throws Exception {
+    testTypes(
+        "/** @constructor */ function C() {" +
+        "  /** @type {?Array} */ this.a = [];" +
+        "}" +
+        "C.prototype.f = function() {" +
+        "  if (this.a.length > 0) {" +
+        "    g(this.a);" +
+        "  }" +
+        "};" +
+        "/** @param {number} a */ function g(a) {}",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : Array\n" +
+        "required: number");
+  }
+
+  public void testIssue537a() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype = {method: function() {}};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {" +
+        "  Foo.call(this);" +
+        "  if (this.baz()) this.method(1);" +
+        "}" +
+        "Bar.prototype = {" +
+        "  baz: function() {" +
+        "    return true;" +
+        "  }" +
+        "};" +
+        "Bar.prototype.__proto__ = Foo.prototype;",
+        "Function Foo.prototype.method: called with 1 argument(s). " +
+        "Function requires at least 0 argument(s) " +
+        "and no more than 0 argument(s).");
+  }
+
+  public void testIssue537b() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype = {method: function() {}};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {" +
+        "  Foo.call(this);" +
+        "  if (this.baz(1)) this.method();" +
+        "}" +
+        "Bar.prototype = {" +
+        "  baz: function() {" +
+        "    return true;" +
+        "  }" +
+        "};" +
+        "Bar.prototype.__proto__ = Foo.prototype;",
+        "Function Bar.prototype.baz: called with 1 argument(s). " +
+        "Function requires at least 0 argument(s) " +
+        "and no more than 0 argument(s).");
+  }
+
+  public void testIssue537c() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {" +
+        "  Foo.call(this);" +
+        "  if (this.baz2()) alert(1);" +
+        "}" +
+        "Bar.prototype = {" +
+        "  baz: function() {" +
+        "    return true;" +
+        "  }" +
+        "};" +
+        "Bar.prototype.__proto__ = Foo.prototype;",
+        "Property baz2 never defined on Bar");
+  }
+
+  public void testIssue537d() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype = {" +
+        "  /** @return {Bar} */ x: function() { new Bar(); }," +
+        "  /** @return {Foo} */ y: function() { new Bar(); }" +
+        "};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {" +
+        "  this.xy = 3;" +
+        "}" +
+        "/** @return {Bar} */ function f() { return new Bar(); }" +
+        "/** @return {Foo} */ function g() { return new Bar(); }" +
+        "Bar.prototype = {" +
+        "  /** @return {Bar} */ x: function() { new Bar(); }," +
+        "  /** @return {Foo} */ y: function() { new Bar(); }" +
+        "};" +
+        "Bar.prototype.__proto__ = Foo.prototype;");
+  }
+
+  public void testIssue586() throws Exception {
+    testTypes(
+        "/** @constructor */" +
+        "var MyClass = function() {};" +
+        "/** @param {boolean} success */" +
+        "MyClass.prototype.fn = function(success) {};" +
+        "MyClass.prototype.test = function() {" +
+        "  this.fn();" +
+        "  this.fn = function() {};" +
+        "};",
+        "Function MyClass.prototype.fn: called with 0 argument(s). " +
+        "Function requires at least 1 argument(s) " +
+        "and no more than 1 argument(s).");
+  }
+
+  public void testIssue635() throws Exception {
+    // TODO(nicksantos): Make this emit a warning, because of the 'this' type.
+    testTypes(
+        "/** @constructor */" +
+        "function F() {}" +
+        "F.prototype.bar = function() { this.baz(); };" +
+        "F.prototype.baz = function() {};" +
+        "/** @constructor */" +
+        "function G() {}" +
+        "G.prototype.bar = F.prototype.bar;");
+  }
+
+  public void testIssue635b() throws Exception {
+    testTypes(
+        "/** @constructor */" +
+        "function F() {}" +
+        "/** @constructor */" +
+        "function G() {}" +
+        "/** @type {function(new:G)} */ var x = F;",
+        "initializing variable\n" +
+        "found   : function (new:F): undefined\n" +
+        "required: function (new:G): ?");
+  }
+
+  public void testIssue669() throws Exception {
+    testTypes(
+        "/** @return {{prop1: (Object|undefined)}} */" +
+         "function f(a) {" +
+         "  var results;" +
+         "  if (a) {" +
+         "    results = {};" +
+         "    results.prop1 = {a: 3};" +
+         "  } else {" +
+         "    results = {prop2: 3};" +
+         "  }" +
+         "  return results;" +
+         "}");
+  }
+
+  public void testIssue688() throws Exception {
+    testTypes(
+        "/** @const */ var SOME_DEFAULT =\n" +
+        "    /** @type {TwoNumbers} */ ({first: 1, second: 2});\n" +
+        "/**\n" +
+        "* Class defining an interface with two numbers.\n" +
+        "* @interface\n" +
+        "*/\n" +
+        "function TwoNumbers() {}\n" +
+        "/** @type number */\n" +
+        "TwoNumbers.prototype.first;\n" +
+        "/** @type number */\n" +
+        "TwoNumbers.prototype.second;\n" +
+        "/** @return {number} */ function f() { return SOME_DEFAULT; }",
+        "inconsistent return type\n" +
+        "found   : (TwoNumbers|null)\n" +
+        "required: number");
+  }
+
+  public void testIssue700() throws Exception {
+    testTypes(
+        "/**\n" +
+        " * @param {{text: string}} opt_data\n" +
+        " * @return {string}\n" +
+        " */\n" +
+        "function temp1(opt_data) {\n" +
+        "  return opt_data.text;\n" +
+        "}\n" +
+        "\n" +
+        "/**\n" +
+        " * @param {{activity: (boolean|number|string|null|Object)}} opt_data\n" +
+        " * @return {string}\n" +
+        " */\n" +
+        "function temp2(opt_data) {\n" +
+        "  /** @notypecheck */\n" +
+        "  function __inner() {\n" +
+        "    return temp1(opt_data.activity);\n" +
+        "  }\n" +
+        "  return __inner();\n" +
+        "}\n" +
+        "\n" +
+        "/**\n" +
+        " * @param {{n: number, text: string, b: boolean}} opt_data\n" +
+        " * @return {string}\n" +
+        " */\n" +
+        "function temp3(opt_data) {\n" +
+        "  return 'n: ' + opt_data.n + ', t: ' + opt_data.text + '.';\n" +
+        "}\n" +
+        "\n" +
+        "function callee() {\n" +
+        "  var output = temp3({\n" +
+        "    n: 0,\n" +
+        "    text: 'a string',\n" +
+        "    b: true\n" +
+        "  })\n" +
+        "  alert(output);\n" +
+        "}\n" +
+        "\n" +
+        "callee();");
+  }
+
+  public void testIssue725() throws Exception {
+    testTypes(
+        "/** @typedef {{name: string}} */ var RecordType1;" +
+        "/** @typedef {{name2222: string}} */ var RecordType2;" +
+        "/** @param {RecordType1} rec */ function f(rec) {" +
+        "  alert(rec.name2222);" +
+        "}",
+        "Property name2222 never defined on rec");
+  }
+
+  public void testIssue726() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @param {number} x */ Foo.prototype.bar = function(x) {};" +
+        "/** @return {!Function} */ " +
+        "Foo.prototype.getDeferredBar = function() { " +
+        "  var self = this;" +
+        "  return function() {" +
+        "    self.bar(true);" +
+        "  };" +
+        "};",
+        "actual parameter 1 of Foo.prototype.bar does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testIssue765() throws Exception {
+    testTypes(
+        "/** @constructor */" +
+        "var AnotherType = function (parent) {" +
+        "    /** @param {string} stringParameter Description... */" +
+        "    this.doSomething = function (stringParameter) {};" +
+        "};" +
+        "/** @constructor */" +
+        "var YetAnotherType = function () {" +
+        "    this.field = new AnotherType(self);" +
+        "    this.testfun=function(stringdata) {" +
+        "        this.field.doSomething(null);" +
+        "    };" +
+        "};",
+        "actual parameter 1 of AnotherType.doSomething " +
+        "does not match formal parameter\n" +
+        "found   : null\n" +
+        "required: string");
+  }
+
+  public void testIssue783() throws Exception {
+    testTypes(
+        "/** @constructor */" +
+        "var Type = function () {" +
+        "  /** @type {Type} */" +
+        "  this.me_ = this;" +
+        "};" +
+        "Type.prototype.doIt = function() {" +
+        "  var me = this.me_;" +
+        "  for (var i = 0; i < me.unknownProp; i++) {}" +
+        "};",
+        "Property unknownProp never defined on Type");
+  }
+
+  public void testIssue791() throws Exception {
+    testTypes(
+        "/** @param {{func: function()}} obj */" +
+        "function test1(obj) {}" +
+        "var fnStruc1 = {};" +
+        "fnStruc1.func = function() {};" +
+        "test1(fnStruc1);");
+  }
+
+  public void testIssue810() throws Exception {
+    testTypes(
+        "/** @constructor */" +
+        "var Type = function () {" +
+        "};" +
+        "Type.prototype.doIt = function(obj) {" +
+        "  this.prop = obj.unknownProp;" +
+        "};",
+        "Property unknownProp never defined on obj");
+  }
+
   /**
    * Tests that the || operator is type checked correctly, that is of
    * the type of the first argument or of the second argument. See
@@ -4484,7 +6748,8 @@
         "function foo(opt_f) {" +
         "  /** @type {Function} */" +
         "  return opt_f || function () {};" +
-        "}");
+        "}",
+        "Type annotations are not allowed here. Are you missing parentheses?");
   }
 
   /**
@@ -4537,7 +6802,7 @@
   public void testBug909000() throws Exception {
     testTypes("/** @constructor */function A(){}\n" +
         "/** @param {!A} a\n" +
-        "@return boolean*/\n" +
+        "@return {boolean}*/\n" +
         "function y(a) { return a }",
         "inconsistent return type\n" +
         "found   : A\n" +
@@ -4611,7 +6876,7 @@
 
   public void testBug1942972() throws Exception {
     testTypes(
-        "var google = {\n"+
+        "var google = {\n" +
         "  gears: {\n" +
         "    factory: {},\n" +
         "    workerPool: {}\n" +
@@ -4660,7 +6925,7 @@
         "var x = f();" +
         "/** @type {string} */" +
         "x.y = 3;",
-        "assignment to property y of x\n" +
+        "assignment\n" +
         "found   : number\n" +
         "required: string");
   }
@@ -4676,7 +6941,49 @@
         "function foo(x) { return x.index; }");
   }
 
-  public void testScopedConstructors() throws Exception {
+  public void testBug7701884() throws Exception {
+    testTypes(
+        "/**\n" +
+        " * @param {Array.<T>} x\n" +
+        " * @param {function(T)} y\n" +
+        " * @template T\n" +
+        " */\n" +
+        "var forEach = function(x, y) {\n" +
+        "  for (var i = 0; i < x.length; i++) y(x[i]);\n" +
+        "};" +
+        "/** @param {number} x */" +
+        "function f(x) {}" +
+        "/** @param {?} x */" +
+        "function h(x) {" +
+        "  var top = null;" +
+        "  forEach(x, function(z) { top = z; });" +
+        "  if (top) f(top);" +
+        "}");
+  }
+
+  public void testBug8017789() throws Exception {
+    testTypes(
+        "/** @param {(map|function())} isResult */" +
+        "var f = function(isResult) {" +
+        "    while (true)" +
+        "        isResult['t'];" +
+        "};" +
+        "/** @typedef {Object.<string, number>} */" +
+        "var map;");
+  }
+
+  public void testTypedefBeforeUse() throws Exception {
+    testTypes(
+        "/** @typedef {Object.<string, number>} */" +
+        "var map;" +
+        "/** @param {(map|function())} isResult */" +
+        "var f = function(isResult) {" +
+        "    while (true)" +
+        "        isResult['t'];" +
+        "};");
+  }
+
+  public void testScopedConstructors1() throws Exception {
     testTypes(
         "function foo1() { " +
         "  /** @constructor */ function Bar() { " +
@@ -4698,6 +7005,15 @@
         "required: number");
   }
 
+  public void testScopedConstructors2() throws Exception {
+    testTypes(
+        "/** @param {Function} f */" +
+        "function foo1(f) {" +
+        "  /** @param {Function} g */" +
+        "  f.prototype.bar = function(g) {};" +
+        "}");
+  }
+
   public void testQualifiedNameInference1() throws Exception {
     testTypes(
         "/** @constructor */ function Foo() {}" +
@@ -4757,11 +7073,127 @@
         "};");
   }
 
+  public void testQualifiedNameInference5() throws Exception {
+    testTypes(
+        "var ns = {}; " +
+        "(function() { " +
+        "    /** @param {number} x */ ns.foo = function(x) {}; })();" +
+        "(function() { ns.foo(true); })();",
+        "actual parameter 1 of ns.foo does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testQualifiedNameInference6() throws Exception {
+    testTypes(
+        "/** @const */ var ns = {}; " +
+        "/** @param {number} x */ ns.foo = function(x) {};" +
+        "(function() { " +
+        "    ns.foo = function(x) {};" +
+        "    ns.foo(true); " +
+        "})();",
+        "actual parameter 1 of ns.foo does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testQualifiedNameInference7() throws Exception {
+    testTypes(
+        "var ns = {}; " +
+        "(function() { " +
+        "  /** @constructor \n * @param {number} x */ " +
+        "  ns.Foo = function(x) {};" +
+        "  /** @param {ns.Foo} x */ function f(x) {}" +
+        "  f(new ns.Foo(true));" +
+        "})();",
+        "actual parameter 1 of ns.Foo does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testQualifiedNameInference8() throws Exception {
+    testClosureTypesMultipleWarnings(
+        "var ns = {}; " +
+        "(function() { " +
+        "  /** @constructor \n * @param {number} x */ " +
+        "  ns.Foo = function(x) {};" +
+        "})();" +
+        "/** @param {ns.Foo} x */ function f(x) {}" +
+        "f(new ns.Foo(true));",
+        Lists.newArrayList(
+            "actual parameter 1 of ns.Foo does not match formal parameter\n" +
+            "found   : boolean\n" +
+            "required: number"));
+  }
+
+  public void testQualifiedNameInference9() throws Exception {
+    testTypes(
+        "var ns = {}; " +
+        "ns.ns2 = {}; " +
+        "(function() { " +
+        "  /** @constructor \n * @param {number} x */ " +
+        "  ns.ns2.Foo = function(x) {};" +
+        "  /** @param {ns.ns2.Foo} x */ function f(x) {}" +
+        "  f(new ns.ns2.Foo(true));" +
+        "})();",
+        "actual parameter 1 of ns.ns2.Foo does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testQualifiedNameInference10() throws Exception {
+    testTypes(
+        "var ns = {}; " +
+        "ns.ns2 = {}; " +
+        "(function() { " +
+        "  /** @interface */ " +
+        "  ns.ns2.Foo = function() {};" +
+        "  /** @constructor \n * @implements {ns.ns2.Foo} */ " +
+        "  function F() {}" +
+        "  (new F());" +
+        "})();");
+  }
+
+  public void testQualifiedNameInference11() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "function f() {" +
+        "  var x = new Foo();" +
+        "  x.onload = function() {" +
+        "    x.onload = null;" +
+        "  };" +
+        "}");
+  }
+
+  public void testQualifiedNameInference12() throws Exception {
+    // We should be able to tell that the two 'this' properties
+    // are different.
+    testTypes(
+        "/** @param {function(this:Object)} x */ function f(x) {}" +
+        "/** @constructor */ function Foo() {" +
+        "  /** @type {number} */ this.bar = 3;" +
+        "  f(function() { this.bar = true; });" +
+        "}");
+  }
+
+  public void testQualifiedNameInference13() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "function f(z) {" +
+        "  var x = new Foo();" +
+        "  if (z) {" +
+        "    x.onload = function() {};" +
+        "  } else {" +
+        "    x.onload = null;" +
+        "  };" +
+        "}");
+  }
+
   public void testSheqRefinedScope() throws Exception {
     Node n = parseAndTypeCheck(
         "/** @constructor */function A() {}\n" +
         "/** @constructor \n @extends A */ function B() {}\n" +
-        "/** @return number */\n" +
+        "/** @return {number} */\n" +
         "B.prototype.p = function() { return 1; }\n" +
         "/** @param {A} a\n @param {B} b */\n" +
         "function f(a, b) {\n" +
@@ -4872,7 +7304,7 @@
     TypeCheckResult p = parseAndTypeCheckWithScope("var a = new Array();");
     Var a = p.scope.getVar("a");
 
-    assertEquals(ARRAY_TYPE, a.getType());
+    assertTypeEquals(ARRAY_TYPE, a.getType());
   }
 
   public void testNew13() throws Exception {
@@ -4919,24 +7351,35 @@
         "required: string");
   }
 
+  public void testNew17() throws Exception {
+    testTypes("var goog = {}; goog.x = 3; new goog.x",
+              "cannot instantiate non-constructor");
+  }
+
+  public void testNew18() throws Exception {
+    testTypes("var goog = {};" +
+              "/** @constructor */ goog.F = function() {};" +
+              "/** @constructor */ goog.G = goog.F;");
+  }
+
   public void testName1() throws Exception {
-    assertEquals(VOID_TYPE, testNameNode("undefined"));
+    assertTypeEquals(VOID_TYPE, testNameNode("undefined"));
   }
 
   public void testName2() throws Exception {
-    assertEquals(OBJECT_FUNCTION_TYPE, testNameNode("Object"));
+    assertTypeEquals(OBJECT_FUNCTION_TYPE, testNameNode("Object"));
   }
 
   public void testName3() throws Exception {
-    assertEquals(ARRAY_FUNCTION_TYPE, testNameNode("Array"));
+    assertTypeEquals(ARRAY_FUNCTION_TYPE, testNameNode("Array"));
   }
 
   public void testName4() throws Exception {
-    assertEquals(DATE_FUNCTION_TYPE, testNameNode("Date"));
+    assertTypeEquals(DATE_FUNCTION_TYPE, testNameNode("Date"));
   }
 
   public void testName5() throws Exception {
-    assertEquals(REGEXP_FUNCTION_TYPE, testNameNode("RegExp"));
+    assertTypeEquals(REGEXP_FUNCTION_TYPE, testNameNode("RegExp"));
   }
 
   /**
@@ -4945,8 +7388,11 @@
   private JSType testNameNode(String name) {
     Node node = Node.newString(Token.NAME, name);
     Node parent = new Node(Token.SCRIPT, node);
+    parent.setInputId(new InputId("code"));
+
+    Node externs = new Node(Token.SCRIPT);
+    externs.setInputId(new InputId("externs"));
 
-    Node externs = new Node(Token.BLOCK);
     Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);
     externAndJsRoot.setIsSyntheticBlock(true);
 
@@ -5019,7 +7465,7 @@
         "/** @type {some.unknown.type} */var f1;" +
         "var f2 = opt_f || f1;" +
         "f2();",
-        "Parse error. Unknown type some.unknown.type");
+        "Bad type annotation. Unknown type some.unknown.type");
   }
 
   public void testCall4() throws Exception {
@@ -5138,6 +7584,89 @@
         "};");
   }
 
+  public void testFunctionCall9() throws Exception {
+    testTypes(
+        "/** @constructor\n * @template T\n **/ function Foo() {}\n" +
+        "/** @param {T} x */ Foo.prototype.bar = function(x) {}\n" +
+        "var foo = /** @type {Foo.<string>} */ (new Foo());\n" +
+        "foo.bar(3);",
+        "actual parameter 1 of Foo.prototype.bar does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testFunctionBind1() throws Exception {
+    testTypes(
+        "/** @type {function(string, number): boolean} */" +
+        "function f(x, y) { return true; }" +
+        "f.bind(null, 3);",
+        "actual parameter 2 of f.bind does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testFunctionBind2() throws Exception {
+    testTypes(
+        "/** @type {function(number): boolean} */" +
+        "function f(x) { return true; }" +
+        "f(f.bind(null, 3)());",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testFunctionBind3() throws Exception {
+    testTypes(
+        "/** @type {function(number, string): boolean} */" +
+        "function f(x, y) { return true; }" +
+        "f.bind(null, 3)(true);",
+        "actual parameter 1 of function does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: string");
+  }
+
+  public void testFunctionBind4() throws Exception {
+    testTypes(
+        "/** @param {...number} x */" +
+        "function f(x) {}" +
+        "f.bind(null, 3, 3, 3)(true);",
+        "actual parameter 1 of function does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: (number|undefined)");
+  }
+
+  public void testFunctionBind5() throws Exception {
+    testTypes(
+        "/** @param {...number} x */" +
+        "function f(x) {}" +
+        "f.bind(null, true)(3, 3, 3);",
+        "actual parameter 2 of f.bind does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: (number|undefined)");
+  }
+
+  public void testGoogBind1() throws Exception {
+    testClosureTypes(
+        "var goog = {}; goog.bind = function(var_args) {};" +
+        "/** @type {function(number): boolean} */" +
+        "function f(x, y) { return true; }" +
+        "f(goog.bind(f, null, 'x')());",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testGoogBind2() throws Exception {
+    // TODO(nicksantos): We do not currently type-check the arguments
+    // of the goog.bind.
+    testClosureTypes(
+        "var goog = {}; goog.bind = function(var_args) {};" +
+        "/** @type {function(boolean): boolean} */" +
+        "function f(x, y) { return true; }" +
+        "f(goog.bind(f, null, 'x')());",
+        null);
+  }
+
   public void testCast2() throws Exception {
     // can upcast to a base type.
     testTypes("/** @constructor */function base() {}\n" +
@@ -5155,6 +7684,17 @@
         "required: derived");
   }
 
+  public void testCast3a() throws Exception {
+    // cannot downcast
+    testTypes("/** @constructor */function Base() {}\n" +
+        "/** @constructor @extends {Base} */function Derived() {}\n" +
+        "var baseInstance = new Base();" +
+        "/** @type {!Derived} */ var baz = baseInstance;\n",
+        "initializing variable\n" +
+        "found   : Base\n" +
+        "required: Derived");
+  }
+
   public void testCast4() throws Exception {
     // downcast must be explicit
     testTypes("/** @constructor */function base() {}\n" +
@@ -5173,6 +7713,17 @@
         "to  : foo");
   }
 
+  public void testCast5a() throws Exception {
+    // cannot explicitly cast to an unrelated type
+    testTypes("/** @constructor */function foo() {}\n" +
+        "/** @constructor */function bar() {}\n" +
+        "var barInstance = new bar;\n" +
+        "var baz = /** @type {!foo} */(barInstance);\n",
+        "invalid cast - must be a subtype or supertype\n" +
+        "from: bar\n" +
+        "to  : foo");
+  }
+
   public void testCast6() throws Exception {
     // can explicitly cast to a subtype or supertype
     testTypes("/** @constructor */function foo() {}\n" +
@@ -5189,36 +7740,36 @@
 
   public void testCast7() throws Exception {
     testTypes("var x = /** @type {foo} */ (new Object());",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast8() throws Exception {
     testTypes("function f() { return /** @type {foo} */ (new Object()); }",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast9() throws Exception {
     testTypes("var foo = {};" +
         "function f() { return /** @type {foo} */ (new Object()); }",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast10() throws Exception {
     testTypes("var foo = function() {};" +
         "function f() { return /** @type {foo} */ (new Object()); }",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast11() throws Exception {
     testTypes("var goog = {}; goog.foo = {};" +
         "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        "Parse error. Unknown type goog.foo");
+        "Bad type annotation. Unknown type goog.foo");
   }
 
   public void testCast12() throws Exception {
     testTypes("var goog = {}; goog.foo = function() {};" +
         "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        "Parse error. Unknown type goog.foo");
+        "Bad type annotation. Unknown type goog.foo");
   }
 
   public void testCast13() throws Exception {
@@ -5228,7 +7779,7 @@
         "goog.addDependency('zzz.js', ['goog.foo'], []);" +
         "goog.foo = function() {};" +
         "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        "Parse error. Unknown type goog.foo");
+        "Bad type annotation. Unknown type goog.foo");
   }
 
   public void testCast14() throws Exception {
@@ -5240,6 +7791,240 @@
         null);
   }
 
+  public void testCast15() throws Exception {
+    // This fixes a bug where a type cast on an object literal
+    // would cause a run-time cast exception if the node was visited
+    // more than once.
+    //
+    // Some code assumes that an object literal must have a object type,
+    // while because of the cast, it could have any type (including
+    // a union).
+    testTypes(
+        "for (var i = 0; i < 10; i++) {" +
+          "var x = /** @type {Object|number} */ ({foo: 3});" +
+          "/** @param {number} x */ function f(x) {}" +
+          "f(x.foo);" +
+          "f([].foo);" +
+        "}",
+        "Property foo never defined on Array");
+  }
+
+  public void testCast16() throws Exception {
+    // A type cast should not invalidate the checks on the members
+    testTypes(
+        "for (var i = 0; i < 10; i++) {" +
+          "var x = /** @type {Object|number} */ (" +
+          "  {/** @type {string} */ foo: 3});" +
+        "}",
+        "assignment to property foo of {foo: string}\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testCast17a() throws Exception {
+    // Mostly verifying that rhino actually understands these JsDocs.
+    testTypes("/** @constructor */ function Foo() {} \n" +
+        "/** @type {Foo} */ var x = /** @type {Foo} */ (y)");
+
+    testTypes("/** @constructor */ function Foo() {} \n" +
+        "/** @type {Foo} */ var x = (/** @type {Foo} */ y)");
+  }
+
+  public void testCast17b() throws Exception {
+    // Mostly verifying that rhino actually understands these JsDocs.
+    testTypes("/** @constructor */ function Foo() {} \n" +
+        "/** @type {Foo} */ var x = /** @type {Foo} */ ({})");
+  }
+
+  public void testCast19() throws Exception {
+    testTypes(
+        "var x = 'string';\n" +
+        "/** @type {number} */\n" +
+        "var y = /** @type {number} */(x);",
+        "invalid cast - must be a subtype or supertype\n" +
+        "from: string\n" +
+        "to  : number");
+  }
+
+  public void testCast20() throws Exception {
+    testTypes(
+        "/** @enum {boolean|null} */\n" +
+        "var X = {" +
+        "  AA: true," +
+        "  BB: false," +
+        "  CC: null" +
+        "};\n" +
+        "var y = /** @type {X} */(true);");
+  }
+
+  public void testCast21() throws Exception {
+    testTypes(
+        "/** @enum {boolean|null} */\n" +
+        "var X = {" +
+        "  AA: true," +
+        "  BB: false," +
+        "  CC: null" +
+        "};\n" +
+        "var value = true;\n" +
+        "var y = /** @type {X} */(value);");
+  }
+
+  public void testCast22() throws Exception {
+    testTypes(
+        "var x = null;\n" +
+        "var y = /** @type {number} */(x);",
+        "invalid cast - must be a subtype or supertype\n" +
+        "from: null\n" +
+        "to  : number");
+  }
+
+  public void testCast23() throws Exception {
+    testTypes(
+        "var x = null;\n" +
+        "var y = /** @type {Number} */(x);");
+  }
+
+  public void testCast24() throws Exception {
+    testTypes(
+        "var x = undefined;\n" +
+        "var y = /** @type {number} */(x);",
+        "invalid cast - must be a subtype or supertype\n" +
+        "from: undefined\n" +
+        "to  : number");
+  }
+
+  public void testCast25() throws Exception {
+    testTypes(
+        "var x = undefined;\n" +
+        "var y = /** @type {number|undefined} */(x);");
+  }
+
+  public void testCast26() throws Exception {
+    testTypes(
+        "function fn(dir) {\n" +
+        "  var node = dir ? 1 : 2;\n" +
+        "  fn(/** @type {number} */ (node));\n" +
+        "}");
+  }
+
+  public void testCast27() throws Exception {
+    // C doesn't implement I but a subtype might.
+    testTypes(
+        "/** @interface */ function I() {}\n" +
+        "/** @constructor */ function C() {}\n" +
+        "var x = new C();\n" +
+        "var y = /** @type {I} */(x);");
+  }
+
+  public void testCast27a() throws Exception {
+    // C doesn't implement I but a subtype might.
+    testTypes(
+        "/** @interface */ function I() {}\n" +
+        "/** @constructor */ function C() {}\n" +
+        "/** @type {C} */ var x ;\n" +
+        "var y = /** @type {I} */(x);");
+  }
+
+  public void testCast28() throws Exception {
+    // C doesn't implement I but a subtype might.
+    testTypes(
+        "/** @interface */ function I() {}\n" +
+        "/** @constructor */ function C() {}\n" +
+        "/** @type {!I} */ var x;\n" +
+        "var y = /** @type {C} */(x);");
+  }
+
+  public void testCast28a() throws Exception {
+    // C doesn't implement I but a subtype might.
+    testTypes(
+        "/** @interface */ function I() {}\n" +
+        "/** @constructor */ function C() {}\n" +
+        "/** @type {I} */ var x;\n" +
+        "var y = /** @type {C} */(x);");
+  }
+
+  public void testCast29a() throws Exception {
+    // C doesn't implement the record type but a subtype might.
+    testTypes(
+        "/** @constructor */ function C() {}\n" +
+        "var x = new C();\n" +
+        "var y = /** @type {{remoteJids: Array, sessionId: string}} */(x);");
+  }
+
+  public void testCast29b() throws Exception {
+    // C doesn't implement the record type but a subtype might.
+    testTypes(
+        "/** @constructor */ function C() {}\n" +
+        "/** @type {C} */ var x;\n" +
+        "var y = /** @type {{prop1: Array, prop2: string}} */(x);");
+  }
+
+  public void testCast29c() throws Exception {
+    // C doesn't implement the record type but a subtype might.
+    testTypes(
+        "/** @constructor */ function C() {}\n" +
+        "/** @type {{remoteJids: Array, sessionId: string}} */ var x ;\n" +
+        "var y = /** @type {C} */(x);");
+  }
+
+  public void testCast30() throws Exception {
+    // Should be able to cast to a looser return type
+    testTypes(
+        "/** @constructor */ function C() {}\n" +
+        "/** @type {function():string} */ var x ;\n" +
+        "var y = /** @type {function():?} */(x);");
+  }
+
+  public void testCast31() throws Exception {
+    // Should be able to cast to a tighter parameter type
+    testTypes(
+        "/** @constructor */ function C() {}\n" +
+        "/** @type {function(*)} */ var x ;\n" +
+        "var y = /** @type {function(string)} */(x);");
+  }
+
+  public void testCast32() throws Exception {
+    testTypes(
+        "/** @constructor */ function C() {}\n" +
+        "/** @type {Object} */ var x ;\n" +
+        "var y = /** @type {null|{length:number}} */(x);");
+  }
+
+  public void testCast33() throws Exception {
+    // null and void should be assignable to any type that accepts one or the
+    // other or both.
+    testTypes(
+        "/** @constructor */ function C() {}\n" +
+        "/** @type {null|undefined} */ var x ;\n" +
+        "var y = /** @type {string?|undefined} */(x);");
+    testTypes(
+        "/** @constructor */ function C() {}\n" +
+        "/** @type {null|undefined} */ var x ;\n" +
+        "var y = /** @type {string|undefined} */(x);");
+    testTypes(
+        "/** @constructor */ function C() {}\n" +
+        "/** @type {null|undefined} */ var x ;\n" +
+        "var y = /** @type {string?} */(x);");
+    testTypes(
+        "/** @constructor */ function C() {}\n" +
+        "/** @type {null|undefined} */ var x ;\n" +
+        "var y = /** @type {null} */(x);");
+  }
+
+  public void testCast34a() throws Exception {
+    testTypes(
+        "/** @constructor */ function C() {}\n" +
+        "/** @type {Object} */ var x ;\n" +
+        "var y = /** @type {Function} */(x);");
+  }
+
+  public void testCast34b() throws Exception {
+    testTypes(
+        "/** @constructor */ function C() {}\n" +
+        "/** @type {Function} */ var x ;\n" +
+        "var y = /** @type {Object} */(x);");
+  }
+
   public void testNestedCasts() throws Exception {
     testTypes("/** @constructor */var T = function() {};\n" +
         "/** @constructor */var V = function() {};\n" +
@@ -5253,7 +8038,7 @@
         "* @return {boolean|undefined}\n" +
         "*/\n" +
         "function g(b) { return b ? true : undefined; }\n" +
-        "/* @return {T} */\n" +
+        "/** @return {T} */\n" +
         "function h() {\n" +
         "return /** @type {T} */ (f(/** @type {boolean} */ (g(true))));\n" +
         "}");
@@ -5299,7 +8084,7 @@
     testTypes(
         "/** @constructor */ function Foo() {}" +
         "Foo();",
-        "Constructor function (this:Foo): undefined should be called " +
+        "Constructor function (new:Foo): undefined should be called " +
         "with the \"new\" keyword");
   }
 
@@ -5307,6 +8092,22 @@
     testTypes("/**@return {void}*/function foo(){ var a = typeof foo(); }");
   }
 
+  public void testTypeof2() throws Exception {
+    testTypes("function f(){ if (typeof 123 == 'numbr') return 321; }",
+              "unknown type: numbr");
+  }
+
+  public void testTypeof3() throws Exception {
+    testTypes("function f() {" +
+              "return (typeof 123 == 'number' ||" +
+              "typeof 123 == 'string' ||" +
+              "typeof 123 == 'boolean' ||" +
+              "typeof 123 == 'undefined' ||" +
+              "typeof 123 == 'function' ||" +
+              "typeof 123 == 'object' ||" +
+              "typeof 123 == 'unknown'); }");
+  }
+
   public void testConstructorType1() throws Exception {
     testTypes("/**@constructor*/function Foo(){}" +
         "/**@type{!Foo}*/var f = new Date();",
@@ -5368,20 +8169,128 @@
     assertEquals("A", fType.getReferenceName());
   }
 
+  public void testConstructorType8() throws Exception {
+    testTypes(
+        "var ns = {};" +
+        "ns.create = function() { return function() {}; };" +
+        "/** @constructor */ ns.Foo = ns.create();" +
+        "ns.Foo.prototype = {x: 0, y: 0};" +
+        "/**\n" +
+        " * @param {ns.Foo} foo\n" +
+        " * @return {string}\n" +
+        " */\n" +
+        "function f(foo) {" +
+        "  return foo.x;" +
+        "}",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testConstructorType9() throws Exception {
+    testTypes(
+        "var ns = {};" +
+        "ns.create = function() { return function() {}; };" +
+        "ns.extend = function(x) { return x; };" +
+        "/** @constructor */ ns.Foo = ns.create();" +
+        "ns.Foo.prototype = ns.extend({x: 0, y: 0});" +
+        "/**\n" +
+        " * @param {ns.Foo} foo\n" +
+        " * @return {string}\n" +
+        " */\n" +
+        "function f(foo) {" +
+        "  return foo.x;" +
+        "}");
+  }
+
+  public void testConstructorType10() throws Exception {
+    testTypes("/** @constructor */" +
+              "function NonStr() {}" +
+              "/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " * @extends{NonStr}\n" +
+              " */" +
+              "function NonStrKid() {}",
+              "NonStrKid cannot extend this type; " +
+              "structs can only extend structs");
+  }
+
+  public void testConstructorType11() throws Exception {
+    testTypes("/** @constructor */" +
+              "function NonDict() {}" +
+              "/**\n" +
+              " * @constructor\n" +
+              " * @dict\n" +
+              " * @extends{NonDict}\n" +
+              " */" +
+              "function NonDictKid() {}",
+              "NonDictKid cannot extend this type; " +
+              "dicts can only extend dicts");
+  }
+
+  public void testConstructorType12() throws Exception {
+    testTypes("/**\n" +
+              " * @constructor\n" +
+              " * @struct\n" +
+              " */\n" +
+              "function Bar() {}\n" +
+              "Bar.prototype = {};\n",
+              "Bar cannot extend this type; " +
+              "structs can only extend structs");
+  }
+
+  public void testBadStruct() throws Exception {
+    testTypes("/** @struct */function Struct1() {}",
+              "@struct used without @constructor for Struct1");
+  }
+
+  public void testBadDict() throws Exception {
+    testTypes("/** @dict */function Dict1() {}",
+              "@dict used without @constructor for Dict1");
+  }
+
+  public void testAnonymousPrototype1() throws Exception {
+    testTypes(
+        "var ns = {};" +
+        "/** @constructor */ ns.Foo = function() {" +
+        "  this.bar(3, 5);" +
+        "};" +
+        "ns.Foo.prototype = {" +
+        "  bar: function(x) {}" +
+        "};",
+        "Function ns.Foo.prototype.bar: called with 2 argument(s). " +
+        "Function requires at least 1 argument(s) and no more " +
+        "than 1 argument(s).");
+  }
+
+  public void testAnonymousPrototype2() throws Exception {
+    testTypes(
+        "/** @interface */ var Foo = function() {};" +
+        "Foo.prototype = {" +
+        "  foo: function(x) {}" +
+        "};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @implements {Foo}\n" +
+        " */ var Bar = function() {};",
+        "property foo on interface Foo is not implemented by type Bar");
+  }
+
   public void testAnonymousType1() throws Exception {
-    testTypes("function f() {}" +
+    testTypes("function f() { return {}; }" +
         "/** @constructor */\n" +
         "f().bar = function() {};");
   }
 
   public void testAnonymousType2() throws Exception {
-    testTypes("function f() {}" +
+    testTypes("function f() { return {}; }" +
         "/** @interface */\n" +
         "f().bar = function() {};");
   }
 
   public void testAnonymousType3() throws Exception {
-    testTypes("function f() {}" +
+    testTypes("function f() { return {}; }" +
         "/** @enum */\n" +
         "f().bar = {FOO: 1};");
   }
@@ -5445,11 +8354,11 @@
   }
 
   public void testUnknownConstructorInstanceType1() throws Exception {
-    testTypes("/** @return Array */ function g(f) { return new f(); }");
+    testTypes("/** @return {Array} */ function g(f) { return new f(); }");
   }
 
   public void testUnknownConstructorInstanceType2() throws Exception {
-    testTypes("function g(f) { return /** @type Array */ new f(); }");
+    testTypes("function g(f) { return /** @type Array */(new f()); }");
   }
 
   public void testUnknownConstructorInstanceType3() throws Exception {
@@ -5535,7 +8444,7 @@
     // still the same type as the one on the variable
     assertTrue(googGetpropFoo2Type == googScopeType);
 
-    // goog.foo type on the left of the top level GETPROP node
+    // goog.foo type on the left of the top-level GETPROP node
     // (under second ASSIGN)
     JSType googFooGetprop2Type = getpropFoo2.getJSType();
     assertTrue("goog.foo incorrectly annotated in goog.foo.bar selection",
@@ -5545,7 +8454,7 @@
         googFooGetprop2ObjectType.hasProperty("foo"));
     assertTrue("bar property not present on goog.foo type",
         googFooGetprop2ObjectType.hasProperty("bar"));
-    assertEquals("bar property on goog.foo type incorrectly inferred",
+    assertTypeEquals("bar property on goog.foo type incorrectly inferred",
         NUMBER_TYPE, googFooGetprop2ObjectType.getPropertyType("bar"));
   }
 
@@ -5615,9 +8524,9 @@
 
     JSType functionAType = js1Node.getFirstChild().getJSType();
     assertEquals("function (): undefined", functionAType.toString());
-    assertEquals(UNKNOWN_TYPE,
+    assertTypeEquals(UNKNOWN_TYPE,
         U2U_FUNCTION_TYPE.getPropertyType("m1"));
-    assertEquals(UNKNOWN_TYPE,
+    assertTypeEquals(UNKNOWN_TYPE,
         U2U_FUNCTION_TYPE.getPropertyType("m2"));
   }
 
@@ -5672,7 +8581,7 @@
 
   public void testValueTypeBuiltInPrototypePropertyType() throws Exception {
     Node node = parseAndTypeCheck("\"x\".charAt(0)");
-    assertEquals(STRING_TYPE, node.getFirstChild().getFirstChild().getJSType());
+    assertTypeEquals(STRING_TYPE, node.getFirstChild().getFirstChild().getJSType());
   }
 
   public void testDeclareBuiltInConstructor() throws Exception {
@@ -5681,7 +8590,7 @@
     Node node = parseAndTypeCheck(
         "/** @constructor */ var String = function(opt_str) {};\n" +
         "(new String(\"x\")).charAt(0)");
-    assertEquals(STRING_TYPE, node.getLastChild().getFirstChild().getJSType());
+    assertTypeEquals(STRING_TYPE, node.getLastChild().getFirstChild().getJSType());
   }
 
   public void testExtendBuiltInType1() throws Exception {
@@ -5694,7 +8603,7 @@
         "*/\n" +
         "String.prototype.substr = function(start, opt_length) {};\n";
     Node n1 = parseAndTypeCheck(externs + "(new String(\"x\")).substr(0,1);");
-    assertEquals(STRING_TYPE, n1.getLastChild().getFirstChild().getJSType());
+    assertTypeEquals(STRING_TYPE, n1.getLastChild().getFirstChild().getJSType());
   }
 
   public void testExtendBuiltInType2() throws Exception {
@@ -5707,7 +8616,7 @@
         "*/\n" +
         "String.prototype.substr = function(start, opt_length) {};\n";
     Node n2 = parseAndTypeCheck(externs + "\"x\".substr(0,1);");
-    assertEquals(STRING_TYPE, n2.getLastChild().getFirstChild().getJSType());
+    assertTypeEquals(STRING_TYPE, n2.getLastChild().getFirstChild().getJSType());
   }
 
   public void testExtendFunction1() throws Exception {
@@ -5715,7 +8624,7 @@
         "function() { return 1; };\n" +
         "(new Function()).f();");
     JSType type = n.getLastChild().getLastChild().getJSType();
-    assertEquals(NUMBER_TYPE, type);
+    assertTypeEquals(NUMBER_TYPE, type);
   }
 
   public void testExtendFunction2() throws Exception {
@@ -5723,7 +8632,7 @@
         "function() { return 1; };\n" +
         "(function() {}).f();");
     JSType type = n.getLastChild().getLastChild().getJSType();
-    assertEquals(NUMBER_TYPE, type);
+    assertTypeEquals(NUMBER_TYPE, type);
   }
 
   public void testInheritanceCheck1() throws Exception {
@@ -5785,9 +8694,7 @@
         "/** @constructor */goog.Super = function() {};" +
         "goog.Super.prototype.foo = 3;" +
         "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" +
-        "goog.Sub.prototype.foo = 5;",
-        "property foo already defined on superclass goog.Super; " +
-        "use @override to override it");
+        "goog.Sub.prototype.foo = 5;");
   }
 
   public void testInheritanceCheck8() throws Exception {
@@ -5804,14 +8711,15 @@
         "/** @constructor */function Super() {};" +
         "Super.prototype.foo = function() { return 3; };" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
-        "/** @override\n @return number */Sub.prototype.foo =\n" +
+        "/** @override\n @return {number} */Sub.prototype.foo =\n" +
         "function() { return 1; };");
   }
 
   public void testInheritanceCheck9_2() throws Exception {
     testTypes(
         "/** @constructor */function Super() {};" +
-        "/** @return number */Super.prototype.foo = function() { return 1; };" +
+        "/** @return {number} */" +
+        "Super.prototype.foo = function() { return 1; };" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
         "/** @override */Sub.prototype.foo =\n" +
         "function() {};");
@@ -5820,9 +8728,10 @@
   public void testInheritanceCheck9_3() throws Exception {
     testTypes(
         "/** @constructor */function Super() {};" +
-        "/** @return number */Super.prototype.foo = function() { return 1; };" +
+        "/** @return {number} */" +
+        "Super.prototype.foo = function() { return 1; };" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
-        "/** @override\n @return string */Sub.prototype.foo =\n" +
+        "/** @override\n @return {string} */Sub.prototype.foo =\n" +
         "function() { return \"some string\" };",
         "mismatch of the foo property type and the type of the property it " +
         "overrides from superclass Super\n" +
@@ -5836,14 +8745,15 @@
         "Root.prototype.foo = function() { return 3; };" +
         "/** @constructor\n @extends {Root} */function Super() {};" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
-        "/** @override\n @return number */Sub.prototype.foo =\n" +
+        "/** @override\n @return {number} */Sub.prototype.foo =\n" +
         "function() { return 1; };");
   }
 
   public void testInheritanceCheck10_2() throws Exception {
     testTypes(
         "/** @constructor */function Root() {};" +
-        "/** @return number */Root.prototype.foo = function() { return 1; };" +
+        "/** @return {number} */" +
+        "Root.prototype.foo = function() { return 1; };" +
         "/** @constructor\n @extends {Root} */function Super() {};" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
         "/** @override */Sub.prototype.foo =\n" +
@@ -5853,10 +8763,11 @@
   public void testInheritanceCheck10_3() throws Exception {
     testTypes(
         "/** @constructor */function Root() {};" +
-        "/** @return number */Root.prototype.foo = function() { return 1; };" +
+        "/** @return {number} */" +
+        "Root.prototype.foo = function() { return 1; };" +
         "/** @constructor\n @extends {Root} */function Super() {};" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
-        "/** @override\n @return string */Sub.prototype.foo =\n" +
+        "/** @override\n @return {string} */Sub.prototype.foo =\n" +
         "function() { return \"some string\" };",
         "mismatch of the foo property type and the type of the property it " +
         "overrides from superclass Root\n" +
@@ -5883,11 +8794,7 @@
         "/** @constructor */goog.Super = function() {};" +
         "goog.Super.prototype.foo = 3;" +
         "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" +
-        "/** @override */goog.Sub.prototype.foo = \"some string\";",
-        "mismatch of the foo property type and the type of the property it " +
-        "overrides from superclass goog.Super\n" +
-        "original: number\n" +
-        "override: string");
+        "/** @override */goog.Sub.prototype.foo = \"some string\";");
   }
 
   public void testInheritanceCheck13() throws Exception {
@@ -5895,48 +8802,71 @@
         "var goog = {};\n" +
         "/** @constructor\n @extends {goog.Missing} */function Sub() {};" +
         "/** @override */Sub.prototype.foo = function() {};",
-        "Parse error. Unknown type goog.Missing");
+        "Bad type annotation. Unknown type goog.Missing");
   }
 
   public void testInheritanceCheck14() throws Exception {
-    testTypes(
+    testClosureTypes(
         "var goog = {};\n" +
         "/** @constructor\n @extends {goog.Missing} */\n" +
         "goog.Super = function() {};\n" +
         "/** @constructor\n @extends {goog.Super} */function Sub() {};" +
         "/** @override */Sub.prototype.foo = function() {};",
-        "Parse error. Unknown type goog.Missing");
+        "Bad type annotation. Unknown type goog.Missing");
   }
 
-  // TODO(user): We should support this way of declaring properties as it is
-  // widely used.
-  //public void testInheritanceCheck15() throws Exception {
-  //  testTypes(
-  //      "/** @constructor */function Super() {};" +
-  //      "/** @param {number} bar */Super.prototype.foo;" +
-  //      "/** @constructor\n @extends {Super} */function Sub() {};" +
-  //      "/** @override\n  @param {number} bar */Sub.prototype.foo =\n" +
-  //      "function(bar) {};");
-  //}
+  public void testInheritanceCheck15() throws Exception {
+    testTypes(
+        "/** @constructor */function Super() {};" +
+        "/** @param {number} bar */Super.prototype.foo;" +
+        "/** @constructor\n @extends {Super} */function Sub() {};" +
+        "/** @override\n  @param {number} bar */Sub.prototype.foo =\n" +
+        "function(bar) {};");
+  }
 
-//   public void testInterfacePropertyOverride1() throws Exception {
-//     testTypes(
-//         "/** @interface */function Super() {};" +
-//         "/** @desc description */Super.prototype.foo = function() {};" +
-//         "/** @interface\n @extends {Super} */function Sub() {};" +
-//         "/** @desc description */Sub.prototype.foo = function() {};",
-//         "property foo is already defined by the Super extended interface");
-//   }
+  public void testInheritanceCheck16() throws Exception {
+    testTypes(
+        "var goog = {};" +
+        "/** @constructor */goog.Super = function() {};" +
+        "/** @type {number} */ goog.Super.prototype.foo = 3;" +
+        "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" +
+        "/** @type {number} */ goog.Sub.prototype.foo = 5;",
+        "property foo already defined on superclass goog.Super; " +
+        "use @override to override it");
+  }
 
-//   public void testInterfacePropertyOverride2() throws Exception {
-//     testTypes(
-//         "/** @interface */function Root() {};" +
-//         "/** @desc description */Root.prototype.foo = function() {};" +
-//         "/** @interface\n @extends {Root} */function Super() {};" +
-//         "/** @interface\n @extends {Super} */function Sub() {};" +
-//         "/** @desc description */Sub.prototype.foo = function() {};",
-//         "property foo is already defined by the Root extended interface");
-//   }
+  public void testInheritanceCheck17() throws Exception {
+    // Make sure this warning still works, even when there's no
+    // @override tag.
+    reportMissingOverrides = CheckLevel.OFF;
+    testTypes(
+        "var goog = {};" +
+        "/** @constructor */goog.Super = function() {};" +
+        "/** @param {number} x */ goog.Super.prototype.foo = function(x) {};" +
+        "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" +
+        "/** @param {string} x */ goog.Sub.prototype.foo = function(x) {};",
+        "mismatch of the foo property type and the type of the property it " +
+        "overrides from superclass goog.Super\n" +
+        "original: function (this:goog.Super, number): undefined\n" +
+        "override: function (this:goog.Sub, string): undefined");
+  }
+
+  public void testInterfacePropertyOverride1() throws Exception {
+    testTypes(
+        "/** @interface */function Super() {};" +
+        "/** @desc description */Super.prototype.foo = function() {};" +
+        "/** @interface\n @extends {Super} */function Sub() {};" +
+        "/** @desc description */Sub.prototype.foo = function() {};");
+  }
+
+  public void testInterfacePropertyOverride2() throws Exception {
+    testTypes(
+        "/** @interface */function Root() {};" +
+        "/** @desc description */Root.prototype.foo = function() {};" +
+        "/** @interface\n @extends {Root} */function Super() {};" +
+        "/** @interface\n @extends {Super} */function Sub() {};" +
+        "/** @desc description */Sub.prototype.foo = function() {};");
+  }
 
   public void testInterfaceInheritanceCheck1() throws Exception {
     testTypes(
@@ -5980,9 +8910,9 @@
   public void testInterfaceInheritanceCheck5() throws Exception {
     testTypes(
         "/** @interface */function Super() {};" +
-        "/** @return string */Super.prototype.foo = function() {};" +
+        "/** @return {string} */Super.prototype.foo = function() {};" +
         "/** @constructor\n @implements {Super} */function Sub() {};" +
-        "/** @override\n @return number */Sub.prototype.foo =\n" +
+        "/** @override\n @return {number} */Sub.prototype.foo =\n" +
         "function() { return 1; };",
         "mismatch of the foo property type and the type of the property it " +
         "overrides from interface Super\n" +
@@ -5993,10 +8923,10 @@
   public void testInterfaceInheritanceCheck6() throws Exception {
     testTypes(
         "/** @interface */function Root() {};" +
-        "/** @return string */Root.prototype.foo = function() {};" +
+        "/** @return {string} */Root.prototype.foo = function() {};" +
         "/** @interface\n @extends {Root} */function Super() {};" +
         "/** @constructor\n @implements {Super} */function Sub() {};" +
-        "/** @override\n @return number */Sub.prototype.foo =\n" +
+        "/** @override\n @return {number} */Sub.prototype.foo =\n" +
         "function() { return 1; };",
         "mismatch of the foo property type and the type of the property it " +
         "overrides from interface Root\n" +
@@ -6022,11 +8952,114 @@
         "/** @constructor\n @implements {Super} */function Sub() {};" +
         "/** @override */Sub.prototype.foo = function() {};",
         new String[] {
-          "Parse error. Unknown type Super",
+          "Bad type annotation. Unknown type Super",
           "property foo not defined on any superclass of Sub"
         });
   }
 
+  public void testInterfaceInheritanceCheck9() throws Exception {
+    testTypes(
+        "/** @interface */ function I() {}" +
+        "/** @return {number} */ I.prototype.bar = function() {};" +
+        "/** @constructor */ function F() {}" +
+        "/** @return {number} */ F.prototype.bar = function() {return 3; };" +
+        "/** @return {number} */ F.prototype.foo = function() {return 3; };" +
+        "/** @constructor \n * @extends {F} \n * @implements {I} */ " +
+        "function G() {}" +
+        "/** @return {string} */ function f() { return new G().bar(); }",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testInterfaceInheritanceCheck10() throws Exception {
+    testTypes(
+        "/** @interface */ function I() {}" +
+        "/** @return {number} */ I.prototype.bar = function() {};" +
+        "/** @constructor */ function F() {}" +
+        "/** @return {number} */ F.prototype.foo = function() {return 3; };" +
+        "/** @constructor \n * @extends {F} \n * @implements {I} */ " +
+        "function G() {}" +
+        "/** @return {number} \n * @override */ " +
+        "G.prototype.bar = G.prototype.foo;" +
+        "/** @return {string} */ function f() { return new G().bar(); }",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testInterfaceInheritanceCheck12() throws Exception {
+    testTypes(
+        "/** @interface */ function I() {};\n" +
+        "/** @type {string} */ I.prototype.foobar;\n" +
+        "/** \n * @constructor \n * @implements {I} */\n" +
+        "function C() {\n" +
+        "/** \n * @type {number} */ this.foobar = 2;};\n" +
+        "/** @type {I} */ \n var test = new C(); alert(test.foobar);",
+        "mismatch of the foobar property type and the type of the property" +
+        " it overrides from interface I\n" +
+        "original: string\n" +
+        "override: number");
+  }
+
+  public void testInterfaceInheritanceCheck13() throws Exception {
+    testTypes(
+        "function abstractMethod() {};\n" +
+        "/** @interface */var base = function() {};\n" +
+        "/** @extends {base} \n @interface */ var Int = function() {}\n" +
+        "/** @type {{bar : !Function}} */ var x; \n" +
+        "/** @type {!Function} */ base.prototype.bar = abstractMethod; \n" +
+        "/** @type {Int} */ var foo;\n" +
+        "foo.bar();");
+  }
+
+  /**
+   * Verify that templatized interfaces can extend one another and share
+   * template values.
+   */
+  public void testInterfaceInheritanceCheck14() throws Exception {
+    testTypes(
+        "/** @interface\n @template T */function A() {};" +
+        "/** @desc description\n @return {T} */A.prototype.foo = function() {};" +
+        "/** @interface\n @template U\n @extends {A.<U>} */function B() {};" +
+        "/** @desc description\n @return {U} */B.prototype.bar = function() {};" +
+        "/** @constructor\n @implements {B.<string>} */function C() {};" +
+        "/** @return {string}\n @override */C.prototype.foo = function() {};" +
+        "/** @return {string}\n @override */C.prototype.bar = function() {};");
+  }
+
+  /**
+   * Verify that templatized instances can correctly implement templatized
+   * interfaces.
+   */
+  public void testInterfaceInheritanceCheck15() throws Exception {
+    testTypes(
+        "/** @interface\n @template T */function A() {};" +
+        "/** @desc description\n @return {T} */A.prototype.foo = function() {};" +
+        "/** @interface\n @template U\n @extends {A.<U>} */function B() {};" +
+        "/** @desc description\n @return {U} */B.prototype.bar = function() {};" +
+        "/** @constructor\n @template V\n @implements {B.<V>}\n */function C() {};" +
+        "/** @return {V}\n @override */C.prototype.foo = function() {};" +
+        "/** @return {V}\n @override */C.prototype.bar = function() {};");
+  }
+
+  /**
+   * Verify that using @override to declare the signature for an implementing
+   * class works correctly when the interface is generic.
+   */
+  public void testInterfaceInheritanceCheck16() throws Exception {
+    testTypes(
+        "/** @interface\n @template T */function A() {};" +
+        "/** @desc description\n @return {T} */A.prototype.foo = function() {};" +
+        "/** @desc description\n @return {T} */A.prototype.bar = function() {};" +
+        "/** @constructor\n @implements {A.<string>} */function B() {};" +
+        "/** @override */B.prototype.foo = function() { return 'string'};" +
+        "/** @override */B.prototype.bar = function() { return 3 };",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testInterfacePropertyNotImplemented() throws Exception {
     testTypes(
         "/** @interface */function Int() {};" +
@@ -6044,12 +9077,30 @@
         "property foo on interface Int is not implemented by type Foo");
   }
 
+  /**
+   * Verify that templatized interfaces enforce their template type values.
+   */
+  public void testInterfacePropertyNotImplemented3() throws Exception {
+    testTypes(
+        "/** @interface\n @template T */function Int() {};" +
+        "/** @desc description\n @return {T} */Int.prototype.foo = function() {};" +
+        "/** @constructor\n @implements {Int.<string>} */function Foo() {};" +
+        "/** @return {number}\n @override */Foo.prototype.foo = function() {};",
+        "mismatch of the foo property type and the type of the property it " +
+        "overrides from interface Int\n" +
+        "original: function (this:Int): string\n" +
+        "override: function (this:Foo): number");
+  }
+
   public void testStubConstructorImplementingInterface() throws Exception {
     // This does not throw a warning for unimplemented property because Foo is
     // just a stub.
-    testTypes("/** @interface */ function Int() {}\n" +
+    testTypes(
+        // externs
+        "/** @interface */ function Int() {}\n" +
         "/** @desc description */Int.prototype.foo = function() {};" +
-        "/** @constructor \n @implements {Int} */ var Foo;\n");
+        "/** @constructor \n @implements {Int} */ var Foo;\n",
+        "", null, false);
   }
 
   public void testObjectLiteral() throws Exception {
@@ -6065,11 +9116,11 @@
     // value's type
     ObjectType objectType =
         (ObjectType) objectNode.getJSType();
-    assertEquals(NUMBER_TYPE, objectType.getPropertyType("m1"));
-    assertEquals(STRING_TYPE, objectType.getPropertyType("m2"));
+    assertTypeEquals(NUMBER_TYPE, objectType.getPropertyType("m1"));
+    assertTypeEquals(STRING_TYPE, objectType.getPropertyType("m2"));
 
     // variable's type
-    assertEquals(objectType, nameNode.getJSType());
+    assertTypeEquals(objectType, nameNode.getJSType());
   }
 
   public void testObjectLiteralDeclaration1() throws Exception {
@@ -6081,11 +9132,87 @@
         "};");
   }
 
+  public void testObjectLiteralDeclaration2() throws Exception {
+    testTypes(
+        "var x = {" +
+        "  /** @type {boolean} */ abc: true" +
+        "};" +
+        "x.abc = 0;",
+        "assignment to property abc of x\n" +
+        "found   : number\n" +
+        "required: boolean");
+  }
+
+  public void testObjectLiteralDeclaration3() throws Exception {
+    testTypes(
+        "/** @param {{foo: !Function}} x */ function f(x) {}" +
+        "f({foo: function() {}});");
+  }
+
+  public void testObjectLiteralDeclaration4() throws Exception {
+    testClosureTypes(
+        "var x = {" +
+        "  /** @param {boolean} x */ abc: function(x) {}" +
+        "};" +
+        "/**\n" +
+        " * @param {string} x\n" +
+        " * @suppress {duplicate}\n" +
+        " */ x.abc = function(x) {};",
+        "assignment to property abc of x\n" +
+        "found   : function (string): undefined\n" +
+        "required: function (boolean): undefined");
+    // TODO(user): suppress {duplicate} currently also silence the
+    // redefining type error in the TypeValidator. Maybe it needs
+    // a new suppress name instead?
+  }
+
+  public void testObjectLiteralDeclaration5() throws Exception {
+    testTypes(
+        "var x = {" +
+        "  /** @param {boolean} x */ abc: function(x) {}" +
+        "};" +
+        "/**\n" +
+        " * @param {boolean} x\n" +
+        " * @suppress {duplicate}\n" +
+        " */ x.abc = function(x) {};");
+  }
+
+  public void testObjectLiteralDeclaration6() throws Exception {
+    testTypes(
+        "var x = {};" +
+        "/**\n" +
+        " * @param {boolean} x\n" +
+        " * @suppress {duplicate}\n" +
+        " */ x.abc = function(x) {};" +
+        "x = {" +
+        "  /**\n" +
+        "   * @param {boolean} x\n" +
+        "   * @suppress {duplicate}\n" +
+        "   */" +
+        "  abc: function(x) {}" +
+        "};");
+  }
+
+  public void testObjectLiteralDeclaration7() throws Exception {
+    testTypes(
+        "var x = {};" +
+        "/**\n" +
+        " * @type {function(boolean): undefined}\n" +
+        " */ x.abc = function(x) {};" +
+        "x = {" +
+        "  /**\n" +
+        "   * @param {boolean} x\n" +
+        "   * @suppress {duplicate}\n" +
+        "   */" +
+        "  abc: function(x) {}" +
+        "};");
+  }
+
   public void testCallDateConstructorAsFunction() throws Exception {
     // ECMA-262 15.9.2: When Date is called as a function rather than as a
     // constructor, it returns a string.
     Node n = parseAndTypeCheck("Date()");
-    assertEquals(STRING_TYPE, n.getFirstChild().getFirstChild().getJSType());
+    assertTypeEquals(STRING_TYPE, n.getFirstChild().getFirstChild().getJSType());
   }
 
   // According to ECMA-262, Error & Array function calls are equivalent to
@@ -6093,13 +9220,13 @@
 
   public void testCallErrorConstructorAsFunction() throws Exception {
     Node n = parseAndTypeCheck("Error('x')");
-    assertEquals(ERROR_TYPE,
+    assertTypeEquals(ERROR_TYPE,
                  n.getFirstChild().getFirstChild().getJSType());
   }
 
   public void testCallArrayConstructorAsFunction() throws Exception {
     Node n = parseAndTypeCheck("Array()");
-    assertEquals(ARRAY_TYPE,
+    assertTypeEquals(ARRAY_TYPE,
                  n.getFirstChild().getFirstChild().getJSType());
   }
 
@@ -6128,23 +9255,23 @@
   //public void testBadPropertyOnInterface1() throws Exception {
   //  testTypes("/** @interface */ u.T = function() {};\n" +
   //      "/** @return {number} */ u.T.f = function() { return 1;};",
-  //      "cannot reference an interface ouside of its definition");
+  //      "cannot reference an interface outside of its definition");
   //}
   //
   //public void testBadPropertyOnInterface2() throws Exception {
   //  testTypes("/** @interface */ function T() {};\n" +
   //      "/** @return {number} */ T.f = function() { return 1;};",
-  //      "cannot reference an interface ouside of its definition");
+  //      "cannot reference an interface outside of its definition");
   //}
   //
   //public void testBadPropertyOnInterface3() throws Exception {
   //  testTypes("/** @interface */ u.T = function() {}; u.T.x",
-  //      "cannot reference an interface ouside of its definition");
+  //      "cannot reference an interface outside of its definition");
   //}
   //
   //public void testBadPropertyOnInterface4() throws Exception {
   //  testTypes("/** @interface */ function T() {}; T.x;",
-  //      "cannot reference an interface ouside of its definition");
+  //      "cannot reference an interface outside of its definition");
   //}
 
   public void testAnnotatedPropertyOnInterface1() throws Exception {
@@ -6201,11 +9328,54 @@
   //      "interface members can only be plain functions");
   //}
 
-  public void testDataPropertyOnInterface2() throws Exception {
+  public void testDataPropertyOnInterface1() throws Exception {
     testTypes("/** @interface */ function T() {};\n" +
         "/** @type {number} */T.prototype.x;");
   }
 
+  public void testDataPropertyOnInterface2() throws Exception {
+    reportMissingOverrides = CheckLevel.OFF;
+    testTypes("/** @interface */ function T() {};\n" +
+        "/** @type {number} */T.prototype.x;\n" +
+        "/** @constructor \n" +
+        " *  @implements {T} \n" +
+        " */\n" +
+        "function C() {}\n" +
+        "C.prototype.x = 'foo';",
+        "mismatch of the x property type and the type of the property it " +
+        "overrides from interface T\n" +
+        "original: number\n" +
+        "override: string");
+  }
+
+  public void testDataPropertyOnInterface3() throws Exception {
+    testTypes("/** @interface */ function T() {};\n" +
+        "/** @type {number} */T.prototype.x;\n" +
+        "/** @constructor \n" +
+        " *  @implements {T} \n" +
+        " */\n" +
+        "function C() {}\n" +
+        "/** @override */\n" +
+        "C.prototype.x = 'foo';",
+        "mismatch of the x property type and the type of the property it " +
+        "overrides from interface T\n" +
+        "original: number\n" +
+        "override: string");
+  }
+
+  public void testDataPropertyOnInterface4() throws Exception {
+    testTypes("/** @interface */ function T() {};\n" +
+        "/** @type {number} */T.prototype.x;\n" +
+        "/** @constructor \n" +
+        " *  @implements {T} \n" +
+        " */\n" +
+        "function C() { /** @type {string} */ \n this.x = 'foo'; }\n",
+        "mismatch of the x property type and the type of the property it " +
+        "overrides from interface T\n" +
+        "original: number\n" +
+        "override: string");
+  }
+
   public void testWarnDataPropertyOnInterface3() throws Exception {
     testTypes("/** @interface */ u.T = function () {};\n" +
         "/** @type {number} */u.T.prototype.x = 1;",
@@ -6265,11 +9435,15 @@
   }
 
   public void testErrorMismatchingPropertyOnInterface6() throws Exception {
-    testTypes("/** @interface */ function T() {};\n" +
+    testClosureTypesMultipleWarnings(
+        "/** @interface */ function T() {};\n" +
         "/** @return {number} */T.prototype.x = 1",
-        "interface members can only be empty property declarations, "
-        + "empty functions, or goog.abstractMethod"
-        );
+        Lists.newArrayList(
+            "assignment to property x of T.prototype\n" +
+            "found   : number\n" +
+            "required: function (this:T): number",
+            "interface members can only be empty property declarations, " +
+            "empty functions, or goog.abstractMethod"));
   }
 
   public void testInterfaceNonEmptyFunction() throws Exception {
@@ -6292,26 +9466,72 @@
   }
 
   public void testInterfaceInstantiation() throws Exception {
-    testTypes("/** @interface */var f; new f",
+    testTypes("/** @interface */var f = function(){}; new f",
               "cannot instantiate non-constructor");
   }
 
   public void testPrototypeLoop() throws Exception {
-    testTypes(
+    testClosureTypesMultipleWarnings(
         suppressMissingProperty("foo") +
         "/** @constructor \n * @extends {T} */var T = function() {};" +
         "alert((new T).foo);",
-        "Parse error. Cycle detected in inheritance chain of type T");
+        Lists.newArrayList(
+            "Parse error. Cycle detected in inheritance chain of type T",
+            "Could not resolve type in @extends tag of T"));
+  }
+
+  public void testImplementsLoop() throws Exception {
+    testClosureTypesMultipleWarnings(
+        suppressMissingProperty("foo") +
+        "/** @constructor \n * @implements {T} */var T = function() {};" +
+        "alert((new T).foo);",
+        Lists.newArrayList(
+            "Parse error. Cycle detected in inheritance chain of type T"));
+  }
+
+  public void testImplementsExtendsLoop() throws Exception {
+    testClosureTypesMultipleWarnings(
+        suppressMissingProperty("foo") +
+            "/** @constructor \n * @implements {F} */var G = function() {};" +
+            "/** @constructor \n * @extends {G} */var F = function() {};" +
+        "alert((new F).foo);",
+        Lists.newArrayList(
+            "Parse error. Cycle detected in inheritance chain of type F"));
+  }
+
+  public void testInterfaceExtendsLoop() throws Exception {
+    // TODO(user): This should give a cycle in inheritance graph error,
+    // not a cannot resolve error.
+    testClosureTypesMultipleWarnings(
+        suppressMissingProperty("foo") +
+            "/** @interface \n * @extends {F} */var G = function() {};" +
+            "/** @interface \n * @extends {G} */var F = function() {};",
+        Lists.newArrayList(
+            "Could not resolve type in @extends tag of G"));
+  }
+
+  public void testConversionFromInterfaceToRecursiveConstructor()
+      throws Exception {
+    testClosureTypesMultipleWarnings(
+        suppressMissingProperty("foo") +
+            "/** @interface */ var OtherType = function() {}\n" +
+            "/** @implements {MyType} \n * @constructor */\n" +
+            "var MyType = function() {}\n" +
+            "/** @type {MyType} */\n" +
+            "var x = /** @type {!OtherType} */ (new Object());",
+        Lists.newArrayList(
+            "Parse error. Cycle detected in inheritance chain of type MyType",
+            "initializing variable\n" +
+            "found   : OtherType\n" +
+            "required: (MyType|null)"));
   }
 
   public void testDirectPrototypeAssign() throws Exception {
+    // For now, we just ignore @type annotations on the prototype.
     testTypes(
         "/** @constructor */ function Foo() {}" +
         "/** @constructor */ function Bar() {}" +
-        "/** @type {Array} */ Bar.prototype = new Foo()",
-        "assignment to property prototype of Bar\n" +
-        "found   : Foo\n" +
-        "required: (Array|null)");
+        "/** @type {Array} */ Bar.prototype = new Foo()");
   }
 
   // In all testResolutionViaRegistry* tests, since u is unknown, u.T can only
@@ -6386,8 +9606,8 @@
     assertTrue(type instanceof ObjectType);
     ObjectType objectType = (ObjectType) type;
     assertFalse(objectType.hasProperty("x"));
-    assertEquals(
-        Sets.newHashSet(objectType),
+    Asserts.assertTypeCollectionEquals(
+        Lists.newArrayList(objectType),
         registry.getTypesWithProperty("x"));
   }
 
@@ -6395,15 +9615,14 @@
     TypeCheckResult ns =
         parseAndTypeCheckWithScope("/** @type {!Object} */var t; t.x; t;");
     Node n = ns.root;
-    Scope s = ns.scope;
     JSType type = n.getLastChild().getLastChild().getJSType();
     assertFalse(type.isUnknownType());
-    assertEquals(type, OBJECT_TYPE);
+    assertTypeEquals(type, OBJECT_TYPE);
     assertTrue(type instanceof ObjectType);
     ObjectType objectType = (ObjectType) type;
     assertFalse(objectType.hasProperty("x"));
-    assertEquals(
-        Sets.newHashSet(OBJECT_TYPE),
+    Asserts.assertTypeCollectionEquals(
+        Lists.newArrayList(OBJECT_TYPE),
         registry.getTypesWithProperty("x"));
   }
 
@@ -6573,11 +9792,62 @@
         "  function g() { x = 'y'; } g(); " +
         "  return x === 3;" +
         "}",
-        "condition always evaluates to the same value\n" +
+        "condition always evaluates to false\n" +
         "left : (null|string)\n" +
         "right: number");
   }
 
+  public void testTypeInferenceWithNoEntry1() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype.init = function() {" +
+        "  /** @type {?{baz: number}} */ this.bar = {baz: 3};" +
+        "};" +
+        "/**\n" +
+        " * @extends {Foo}\n" +
+        " * @constructor\n" +
+        " */" +
+        "function SubFoo() {}" +
+        "/** Method */" +
+        "SubFoo.prototype.method = function() {" +
+        "  for (var i = 0; i < 10; i++) {" +
+        "    f(this.bar);" +
+        "    f(this.bar.baz);" +
+        "  }" +
+        "};",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : (null|{baz: number})\n" +
+        "required: number");
+  }
+
+  public void testTypeInferenceWithNoEntry2() throws Exception {
+    testClosureTypes(
+        CLOSURE_DEFS +
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @param {!Object} x */ function g(x) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype.init = function() {" +
+        "  /** @type {?{baz: number}} */ this.bar = {baz: 3};" +
+        "};" +
+        "/**\n" +
+        " * @extends {Foo}\n" +
+        " * @constructor\n" +
+        " */" +
+        "function SubFoo() {}" +
+        "/** Method */" +
+        "SubFoo.prototype.method = function() {" +
+        "  for (var i = 0; i < 10; i++) {" +
+        "    f(this.bar);" +
+        "    goog.asserts.assert(this.bar);" +
+        "    g(this.bar);" +
+        "  }" +
+        "};",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : (null|{baz: number})\n" +
+        "required: number");
+  }
+
   public void testForwardPropertyReference() throws Exception {
     testTypes("/** @constructor */ var Foo = function() { this.init(); };" +
         "/** @return {string} */" +
@@ -6596,12 +9866,10 @@
   public void testNoForwardTypeDeclaration() throws Exception {
     testTypes(
         "/** @param {MyType} x */ function f(x) {}",
-        "Parse error. Unknown type MyType");
+        "Bad type annotation. Unknown type MyType");
   }
 
   public void testNoForwardTypeDeclarationAndNoBraces() throws Exception {
-    // To better support third-party code, we do not warn when
-    // there are no braces around an unknown type name.
     testTypes("/** @return The result. */ function f() {}");
   }
 
@@ -6613,14 +9881,17 @@
 
         "goog.addDependency('zzz.js', ['MyType'], []);" +
         "/** @param {MyType} x \n * @return {number} */" +
-        "function f(x) { return x; }", null);
+        "function f(x) { return 3; }", null);
   }
 
   public void testForwardTypeDeclaration2() throws Exception {
-    testClosureTypes(
-        "goog.addDependency('zzz.js', ['MyType'], []);" +
-        "/** @param {MyType} x */ function f(x) { }" +
-        "f(3);", null);
+    String f = "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/** @param {MyType} x */ function f(x) { }";
+    testClosureTypes(f, null);
+    testClosureTypes(f + "f(3);",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: (MyType|null)");
   }
 
   public void testForwardTypeDeclaration3() throws Exception {
@@ -6634,66 +9905,95 @@
         "required: (MyType|null)");
   }
 
-  public void testMalformedOldTypeDef() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "goog.Bar = goog.typedef",
-        "Typedef for goog.Bar does not have any type information");
+  public void testForwardTypeDeclaration4() throws Exception {
+    testClosureTypes(
+        "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/** @param {MyType} x */ function f(x) { return x; }" +
+        "/** @constructor */ var MyType = function() {};" +
+        "f(new MyType());",
+        null);
   }
 
-  public void testMalformedOldTypeDef2() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @typedef {boolean} */ goog.Bar = goog.typedef",
-        "Typedef for goog.Bar does not have any type information");
+  public void testForwardTypeDeclaration5() throws Exception {
+    testClosureTypes(
+        "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {MyType}\n" +
+        " */ var YourType = function() {};" +
+        "/** @override */ YourType.prototype.method = function() {};",
+        "Could not resolve type in @extends tag of YourType");
   }
 
-  public void testDuplicateOldTypeDef() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @constructor */ goog.Bar = function() {};" +
-        "/** @type {number} */ goog.Bar = goog.typedef",
-        "variable goog.Bar redefined with type number, " +
-        "original definition at [testcode]:1 " +
-        "with type function (this:goog.Bar): undefined");
+  public void testForwardTypeDeclaration6() throws Exception {
+    testClosureTypesMultipleWarnings(
+        "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @implements {MyType}\n" +
+        " */ var YourType = function() {};" +
+        "/** @override */ YourType.prototype.method = function() {};",
+        Lists.newArrayList(
+            "Could not resolve type in @implements tag of YourType",
+            "property method not defined on any superclass of YourType"));
   }
 
-  public void testOldTypeDef1() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @type {number} */ goog.Bar = goog.typedef;" +
-        "/** @param {goog.Bar} x */ function f(x) {}" +
-        "f(3);");
+  public void testForwardTypeDeclaration7() throws Exception {
+    testClosureTypes(
+        "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/** @param {MyType=} x */" +
+        "function f(x) { return x == undefined; }", null);
   }
 
-  public void testOldTypeDef2() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @type {number} */ goog.Bar = goog.typedef;" +
-        "/** @param {goog.Bar} x */ function f(x) {}" +
-        "f('3');",
-        "actual parameter 1 of f does not match formal parameter\n" +
-        "found   : string\n" +
-        "required: number");
+  public void testForwardTypeDeclaration8() throws Exception {
+    testClosureTypes(
+        "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/** @param {MyType} x */" +
+        "function f(x) { return x.name == undefined; }", null);
   }
 
-  public void testOldTypeDef3() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @type {number} */ var Bar = goog.typedef;" +
-        "/** @param {Bar} x */ function f(x) {}" +
-        "f('3');",
+  public void testForwardTypeDeclaration9() throws Exception {
+    testClosureTypes(
+        "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/** @param {MyType} x */" +
+        "function f(x) { x.name = 'Bob'; }", null);
+  }
+
+  public void testForwardTypeDeclaration10() throws Exception {
+    String f = "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/** @param {MyType|number} x */ function f(x) { }";
+    testClosureTypes(f, null);
+    testClosureTypes(f + "f(3);", null);
+    testClosureTypes(f + "f('3');",
         "actual parameter 1 of f does not match formal parameter\n" +
         "found   : string\n" +
-        "required: number");
+        "required: (MyType|null|number)");
   }
 
-  public void testCircularOldTypeDef() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @type {number|Array.<goog.Bar>} */ goog.Bar = goog.typedef;" +
-        "/** @param {goog.Bar} x */ function f(x) {}" +
-        "f(3); f([3]); f([[3]]);");
+  public void testForwardTypeDeclaration12() throws Exception {
+    // We assume that {Function} types can produce anything, and don't
+    // want to type-check them.
+    testClosureTypes(
+        "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/**\n" +
+        " * @param {!Function} ctor\n" +
+        " * @return {MyType}\n" +
+        " */\n" +
+        "function f(ctor) { return new ctor(); }", null);
+  }
+
+  public void testForwardTypeDeclaration13() throws Exception {
+    // Some projects use {Function} registries to register constructors
+    // that aren't in their binaries. We want to make sure we can pass these
+    // around, but still do other checks on them.
+    testClosureTypes(
+        "goog.addDependency('zzz.js', ['MyType'], []);" +
+        "/**\n" +
+        " * @param {!Function} ctor\n" +
+        " * @return {MyType}\n" +
+        " */\n" +
+        "function f(ctor) { return (new ctor()).impossibleProp; }",
+        "Property impossibleProp never defined on ?");
   }
 
   public void testDuplicateTypeDef() throws Exception {
@@ -6703,7 +10003,7 @@
         "/** @typedef {number} */ goog.Bar;",
         "variable goog.Bar redefined with type None, " +
         "original definition at [testcode]:1 " +
-        "with type function (this:goog.Bar): undefined");
+        "with type function (new:goog.Bar): undefined");
   }
 
   public void testTypeDef1() throws Exception {
@@ -6736,6 +10036,34 @@
         "required: number");
   }
 
+  public void testTypeDef4() throws Exception {
+    testTypes(
+        "/** @constructor */ function A() {}" +
+        "/** @constructor */ function B() {}" +
+        "/** @typedef {(A|B)} */ var AB;" +
+        "/** @param {AB} x */ function f(x) {}" +
+        "f(new A()); f(new B()); f(1);",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: (A|B|null)");
+  }
+
+  public void testTypeDef5() throws Exception {
+    // Notice that the error message is slightly different than
+    // the one for testTypeDef4, even though they should be the same.
+    // This is an implementation detail necessary for NamedTypes work out
+    // OK, and it should change if NamedTypes ever go away.
+    testTypes(
+        "/** @param {AB} x */ function f(x) {}" +
+        "/** @constructor */ function A() {}" +
+        "/** @constructor */ function B() {}" +
+        "/** @typedef {(A|B)} */ var AB;" +
+        "f(new A()); f(new B()); f(1);",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: (A|B|null)");
+  }
+
   public void testCircularTypeDef() throws Exception {
     testTypes(
         "var goog = {};" +
@@ -6766,6 +10094,16 @@
     assertEquals(100.0, getTypedPercent(js), 0.1);
   }
 
+  public void testGetTypedPercent5() throws Exception {
+    String js = "/** @enum {number} */ keys = {A: 1,B: 2,C: 3};";
+    assertEquals(100.0, getTypedPercent(js), 0.1);
+  }
+
+  public void testGetTypedPercent6() throws Exception {
+    String js = "a = {TRUE: 1, FALSE: 0};";
+    assertEquals(100.0, getTypedPercent(js), 0.1);
+  }
+
   private double getTypedPercent(String js) throws Exception {
     Node n = compiler.parseTestCode(js);
 
@@ -6955,17 +10293,10 @@
   }
 
   public void testMissingProperty20() throws Exception {
-    // NOTE(nicksantos): In the else branch, we know that x.foo is a
-    // CHECKED_UNKNOWN (UNKNOWN restricted to a falsey value). We could
-    // do some more sophisticated analysis here. Obviously, if x.foo is false,
-    // then x.foo cannot possibly be called. For example, you could imagine a
-    // VagueType that was like UnknownType, but had some constraints on it
-    // so that we knew it could never be a function.
-    //
-    // For now, we just punt on this issue.
     testTypes(
         "/** @param {Object} x */" +
-        "function f(x) { if (x.foo) { } else { x.foo(); } }");
+        "function f(x) { if (x.foo) { } else { x.foo(); } }",
+        "Property foo never defined on Object");
   }
 
   public void testMissingProperty21() throws Exception {
@@ -7089,15 +10420,229 @@
         "Foo.prototype.baz = function() { this.b = 3; };");
   }
 
+  public void testMissingProperty35() throws Exception {
+    // Bar has specialProp defined, so Bar|Baz may have specialProp defined.
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @constructor */ function Bar() {}" +
+        "/** @constructor */ function Baz() {}" +
+        "/** @param {Foo|Bar} x */ function f(x) { x.specialProp = 1; }" +
+        "/** @param {Bar|Baz} x */ function g(x) { return x.specialProp; }");
+  }
+
+  public void testMissingProperty36() throws Exception {
+    // Foo has baz defined, and SubFoo has bar defined, so some objects with
+    // bar may have baz.
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype.baz = 0;" +
+        "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" +
+        "SubFoo.prototype.bar = 0;" +
+        "/** @param {{bar: number}} x */ function f(x) { return x.baz; }");
+  }
+
+  public void testMissingProperty37() throws Exception {
+    // This used to emit a missing property warning because we couldn't
+    // determine that the inf(Foo, {isVisible:boolean}) == SubFoo.
+    testTypes(
+        "/** @param {{isVisible: boolean}} x */ function f(x){" +
+        "  x.isVisible = false;" +
+        "}" +
+        "/** @constructor */ function Foo() {}" +
+        "/**\n" +
+        " * @constructor \n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/** @type {boolean} */ SubFoo.prototype.isVisible = true;" +
+        "/**\n" +
+        " * @param {Foo} x\n" +
+        " * @return {boolean}\n" +
+        " */\n" +
+        "function g(x) { return x.isVisible; }");
+  }
+
+  public void testMissingProperty38() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @constructor */ function Bar() {}" +
+        "/** @return {Foo|Bar} */ function f() { return new Foo(); }" +
+        "f().missing;",
+        "Property missing never defined on (Bar|Foo|null)");
+  }
+
+  public void testMissingProperty39() throws Exception {
+    testTypes(
+        "/** @return {string|number} */ function f() { return 3; }" +
+        "f().length;");
+  }
+
+  public void testMissingProperty40() throws Exception {
+    testClosureTypes(
+        "goog.addDependency('zzz.js', ['MissingType'], []);" +
+        "/** @param {(Array|MissingType)} x */" +
+        "function f(x) { x.impossible(); }", null);
+  }
+
+  public void testMissingProperty41() throws Exception {
+    testTypes(
+        "/** @param {(Array|Date)} x */" +
+        "function f(x) { if (x.impossible) x.impossible(); }");
+  }
+
+
+  public void testMissingProperty42() throws Exception {
+    testTypes(
+        "/** @param {Object} x */" +
+        "function f(x) { " +
+        "  if (typeof x.impossible == 'undefined') throw Error();" +
+        "  return x.impossible;" +
+        "}");
+  }
+
+  public void testMissingProperty43() throws Exception {
+    testTypes(
+        "function f(x) { " +
+        " return /** @type {number} */ (x.impossible) && 1;" +
+        "}");
+  }
+
+  public void testReflectObject1() throws Exception {
+    testClosureTypes(
+        "var goog = {}; goog.reflect = {}; " +
+        "goog.reflect.object = function(x, y){};" +
+        "/** @constructor */ function A() {}" +
+        "goog.reflect.object(A, {x: 3});",
+        null);
+  }
+
+  public void testReflectObject2() throws Exception {
+    testClosureTypes(
+        "var goog = {}; goog.reflect = {}; " +
+        "goog.reflect.object = function(x, y){};" +
+        "/** @param {string} x */ function f(x) {}" +
+        "/** @constructor */ function A() {}" +
+        "goog.reflect.object(A, {x: f(1 + 1)});",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testLends1() throws Exception {
+    testTypes(
+        "function extend(x, y) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "extend(Foo, /** @lends */ ({bar: 1}));",
+        "Bad type annotation. missing object name in @lends tag");
+  }
+
+  public void testLends2() throws Exception {
+    testTypes(
+        "function extend(x, y) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "extend(Foo, /** @lends {Foob} */ ({bar: 1}));",
+        "Variable Foob not declared before @lends annotation.");
+  }
+
+  public void testLends3() throws Exception {
+    testTypes(
+        "function extend(x, y) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "extend(Foo, {bar: 1});" +
+        "alert(Foo.bar);",
+        "Property bar never defined on Foo");
+  }
+
+  public void testLends4() throws Exception {
+    testTypes(
+        "function extend(x, y) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "extend(Foo, /** @lends {Foo} */ ({bar: 1}));" +
+        "alert(Foo.bar);");
+  }
+
+  public void testLends5() throws Exception {
+    testTypes(
+        "function extend(x, y) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "extend(Foo, {bar: 1});" +
+        "alert((new Foo()).bar);",
+        "Property bar never defined on Foo");
+  }
+
+  public void testLends6() throws Exception {
+    testTypes(
+        "function extend(x, y) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "extend(Foo, /** @lends {Foo.prototype} */ ({bar: 1}));" +
+        "alert((new Foo()).bar);");
+  }
+
+  public void testLends7() throws Exception {
+    testTypes(
+        "function extend(x, y) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "extend(Foo, /** @lends {Foo.prototype|Foo} */ ({bar: 1}));",
+        "Bad type annotation. expected closing }");
+  }
+
+  public void testLends8() throws Exception {
+    testTypes(
+        "function extend(x, y) {}" +
+        "/** @type {number} */ var Foo = 3;" +
+        "extend(Foo, /** @lends {Foo} */ ({bar: 1}));",
+        "May only lend properties to object types. Foo has type number.");
+  }
+
+  public void testLends9() throws Exception {
+    testClosureTypesMultipleWarnings(
+        "function extend(x, y) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "extend(Foo, /** @lends {!Foo} */ ({bar: 1}));",
+        Lists.newArrayList(
+            "Bad type annotation. expected closing }",
+            "Bad type annotation. missing object name in @lends tag"));
+  }
+
+  public void testLends10() throws Exception {
+    testTypes(
+        "function defineClass(x) { return function() {}; } " +
+        "/** @constructor */" +
+        "var Foo = defineClass(" +
+        "    /** @lends {Foo.prototype} */ ({/** @type {number} */ bar: 1}));" +
+        "/** @return {string} */ function f() { return (new Foo()).bar; }",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testLends11() throws Exception {
+    testTypes(
+        "function defineClass(x, y) { return function() {}; } " +
+        "/** @constructor */" +
+        "var Foo = function() {};" +
+        "/** @return {*} */ Foo.prototype.bar = function() { return 3; };" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "var SubFoo = defineClass(Foo, " +
+        "    /** @lends {SubFoo.prototype} */ ({\n" +
+        "      /** @return {number} */ bar: function() { return 3; }}));" +
+        "/** @return {string} */ function f() { return (new SubFoo()).bar(); }",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testDeclaredNativeTypeEquality() throws Exception {
     Node n = parseAndTypeCheck("/** @constructor */ function Object() {};");
-    assertEquals(registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE),
+    assertTypeEquals(registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE),
                  n.getFirstChild().getJSType());
   }
 
   public void testUndefinedVar() throws Exception {
     Node n = parseAndTypeCheck("var undefined;");
-    assertEquals(registry.getNativeType(JSTypeNative.VOID_TYPE),
+    assertTypeEquals(registry.getNativeType(JSTypeNative.VOID_TYPE),
                  n.getFirstChild().getFirstChild().getJSType());
   }
 
@@ -7110,7 +10655,7 @@
         + "for (; (i + a) < b; ++i) {}}");
 
     // check the type of the add node for i + f
-    assertEquals(registry.getNativeType(JSTypeNative.NUMBER_TYPE),
+    assertTypeEquals(registry.getNativeType(JSTypeNative.NUMBER_TYPE),
         n.getFirstChild().getLastChild().getLastChild().getFirstChild()
         .getNext().getFirstChild().getJSType());
   }
@@ -7131,7 +10676,7 @@
         + "}");
 
     // check the type of afoo when referenced
-    assertEquals(registry.createNullableType(registry.getType("Foo")),
+    assertTypeEquals(registry.createNullableType(registry.getType("Foo")),
         n.getLastChild().getLastChild().getLastChild().getLastChild()
         .getLastChild().getLastChild().getJSType());
   }
@@ -7149,7 +10694,8 @@
   public void testTypeCheckStandaloneAST() throws Exception {
     Node n = compiler.parseTestCode("function Foo() { }");
     typeCheck(n);
-    TypedScopeCreator scopeCreator = new TypedScopeCreator(compiler);
+    MemoizedScopeCreator scopeCreator = new MemoizedScopeCreator(
+        new TypedScopeCreator(compiler));
     Scope topScope = scopeCreator.createScope(n, null);
 
     Node second = compiler.parseTestCode("new Foo");
@@ -7162,7 +10708,7 @@
         compiler,
         new SemanticReverseAbstractInterpreter(
             compiler.getCodingConvention(), registry),
-        registry, topScope, scopeCreator, CheckLevel.WARNING, CheckLevel.OFF)
+        registry, topScope, scopeCreator, CheckLevel.WARNING)
         .process(null, second);
 
     assertEquals(1, compiler.getWarningCount());
@@ -7170,7 +10716,75 @@
         compiler.getWarnings()[0].description);
   }
 
-  public void testBadTemplateType1() throws Exception {
+  public void testUpdateParameterTypeOnClosure() throws Exception {
+    testTypes(
+        "/**\n" +
+        "* @constructor\n" +
+        "* @param {*=} opt_value\n" +
+        "* @return {?}\n" +
+        "*/\n" +
+        "function Object(opt_value) {}\n" +
+        "/**\n" +
+        "* @constructor\n" +
+        "* @param {...*} var_args\n" +
+        "*/\n" +
+        "function Function(var_args) {}\n" +
+        "/**\n" +
+        "* @type {Function}\n" +
+        "*/\n" +
+        // The line below sets JSDocInfo on Object so that the type of the
+        // argument to function f has JSDoc through its prototype chain.
+        "Object.prototype.constructor = function() {};\n",
+        "/**\n" +
+        "* @param {function(): boolean} fn\n" +
+        "*/\n" +
+        "function f(fn) {}\n" +
+        "f(function(g) { });\n",
+        null,
+        false);
+  }
+
+  public void testTemplatedThisType1() throws Exception {
+    testTypes(
+        "/** @constructor */\n" +
+        "function Foo() {}\n" +
+        "/**\n" +
+        " * @this {T}\n" +
+        " * @return {T}\n" +
+        " * @template T\n" +
+        " */\n" +
+        "Foo.prototype.method = function() {};\n" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {}\n" +
+        "var g = new Bar().method();\n" +
+        "/**\n" +
+        " * @param {number} a\n" +
+        " */\n" +
+        "function compute(a) {};\n" +
+        "compute(g);\n",
+
+        "actual parameter 1 of compute does not match formal parameter\n" +
+        "found   : Bar\n" +
+        "required: number");
+  }
+
+  public void testTemplatedThisType2() throws Exception {
+    testTypes(
+        "/**\n" +
+        " * @this {Array.<T>|{length:number}}\n" +
+        " * @return {T}\n" +
+        " * @template T\n" +
+        " */\n" +
+        "Array.prototype.method = function() {};\n" +
+        "(function(){\n" +
+        "  Array.prototype.method.call(arguments);" +
+        "})();");
+  }
+
+  public void testTemplateType1() throws Exception {
     testTypes(
         "/**\n" +
         "* @param {T} x\n" +
@@ -7179,11 +10793,12 @@
         "* @template T\n" +
         "*/\n" +
         "function f(x, y, z) {}\n" +
-        "f(this, this, function() {});",
-        FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format(), true);
+        "f(this, this, function() { this });");
   }
 
-  public void testBadTemplateType2() throws Exception {
+  public void testTemplateType2() throws Exception {
+    // "this" types need to be coerced for ES3 style function or left
+    // allow for ES5-strict methods.
     testTypes(
         "/**\n" +
         "* @param {T} x\n" +
@@ -7191,32 +10806,268 @@
         "* @template T\n" +
         "*/\n" +
         "function f(x, y) {}\n" +
-        "f(0, function() {});",
-        TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format(), true);
+        "f(0, function() {});");
   }
 
-  public void testBadTemplateType3() throws Exception {
+  public void testTemplateType3() throws Exception {
     testTypes(
-        "/**\n" +
-        " * @param {T} x\n" +
+        "/**" +
+        " * @param {T} v\n" +
+        " * @param {function(T)} f\n" +
         " * @template T\n" +
-        "*/\n" +
-        "function f(x) {}\n" +
-        "f(this);",
-        TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format(), true);
+        " */\n" +
+        "function call(v, f) { f.call(null, v); }" +
+        "/** @type {string} */ var s;" +
+        "call(3, function(x) {" +
+        " x = true;" +
+        " s = x;" +
+        "});",
+        "assignment\n" +
+        "found   : boolean\n" +
+        "required: string");
   }
 
-  public void testBadTemplateType4() throws Exception {
+  public void testTemplateType4() throws Exception {
+    testTypes(
+        "/**" +
+        " * @param {...T} p\n" +
+        " * @return {T} \n" +
+        " * @template T\n" +
+        " */\n" +
+        "function fn(p) { return p; }\n" +
+        "/** @type {!Object} */ var x;" +
+        "x = fn(3, null);",
+        "assignment\n" +
+        "found   : (null|number)\n" +
+        "required: Object");
+  }
+
+  public void testTemplateType5() throws Exception {
+    compiler.getOptions().setCodingConvention(new GoogleCodingConvention());
+    testTypes(
+        "var CGI_PARAM_RETRY_COUNT = 'rc';" +
+        "" +
+        "/**" +
+        " * @param {...T} p\n" +
+        " * @return {T} \n" +
+        " * @template T\n" +
+        " */\n" +
+        "function fn(p) { return p; }\n" +
+        "/** @type {!Object} */ var x;" +
+        "" +
+        "/** @return {void} */\n" +
+        "function aScope() {\n" +
+        "  x = fn(CGI_PARAM_RETRY_COUNT, 1);\n" +
+        "}",
+        "assignment\n" +
+        "found   : (number|string)\n" +
+        "required: Object");
+  }
+
+  public void testTemplateType6() throws Exception {
+    testTypes(
+        "/**" +
+        " * @param {Array.<T>} arr \n" +
+        " * @param {?function(T)} f \n" +
+        " * @return {T} \n" +
+        " * @template T\n" +
+        " */\n" +
+        "function fn(arr, f) { return arr[0]; }\n" +
+        "/** @param {Array.<number>} arr */ function g(arr) {" +
+        "  /** @type {!Object} */ var x = fn.call(null, arr, null);" +
+        "}",
+        "initializing variable\n" +
+        "found   : number\n" +
+        "required: Object");
+  }
+
+  public void testTemplateType7() throws Exception {
+    // TODO(johnlenz): As the @this type for Array.prototype.push includes
+    // "{length:number}" (and this includes "Array.<number>") we don't
+    // get a type warning here. Consider special-casing array methods.
+    testTypes(
+        "/** @type {!Array.<string>} */\n" +
+        "var query = [];\n" +
+        "query.push(1);\n");
+  }
+
+  public void testTemplateType8() throws Exception {
+    testTypes(
+        "/** @constructor \n" +
+        " * @template S,T\n" +
+        " */\n" +
+        "function Bar() {}\n" +
+        "/**" +
+        " * @param {Bar.<T>} bar \n" +
+        " * @return {T} \n" +
+        " * @template T\n" +
+        " */\n" +
+        "function fn(bar) {}\n" +
+        "/** @param {Bar.<number>} bar */ function g(bar) {" +
+        "  /** @type {!Object} */ var x = fn(bar);" +
+        "}",
+        "initializing variable\n" +
+        "found   : number\n" +
+        "required: Object");
+  }
+
+  public void testTemplateType9() throws Exception {
+    // verify interface type parameters are recognized.
+    testTypes(
+        "/** @interface \n" +
+        " * @template S,T\n" +
+        " */\n" +
+        "function Bar() {}\n" +
+        "/**" +
+        " * @param {Bar.<T>} bar \n" +
+        " * @return {T} \n" +
+        " * @template T\n" +
+        " */\n" +
+        "function fn(bar) {}\n" +
+        "/** @param {Bar.<number>} bar */ function g(bar) {" +
+        "  /** @type {!Object} */ var x = fn(bar);" +
+        "}",
+        "initializing variable\n" +
+        "found   : number\n" +
+        "required: Object");
+  }
+
+  public void testTemplateType10() throws Exception {
+    // verify a type parameterized with unknown can be assigned to
+    // the same type with any other type parameter.
+    testTypes(
+        "/** @constructor \n" +
+        " * @template T\n" +
+        " */\n" +
+        "function Bar() {}\n" +
+        "\n" +
+        "" +
+        "/** @type {!Bar.<?>} */ var x;" +
+        "/** @type {!Bar.<number>} */ var y;" +
+        "y = x;");
+  }
+
+  public void testTemplateType11() throws Exception {
+    // verify that assignment/subtype relationships work when extending
+    // templatized types.
+    testTypes(
+        "/** @constructor \n" +
+        " * @template T\n" +
+        " */\n" +
+        "function Foo() {}\n" +
+        "" +
+        "/** @constructor \n" +
+        " * @extends {Foo.<string>}\n" +
+        " */\n" +
+        "function A() {}\n" +
+        "" +
+        "/** @constructor \n" +
+        " * @extends {Foo.<number>}\n" +
+        " */\n" +
+        "function B() {}\n" +
+        "" +
+        "/** @type {!Foo.<string>} */ var a = new A();\n" +
+        "/** @type {!Foo.<string>} */ var b = new B();",
+        "initializing variable\n" +
+        "found   : B\n" +
+        "required: Foo.<string>");
+  }
+
+  public void testTemplateType12() throws Exception {
+    // verify that assignment/subtype relationships work when implementing
+    // templatized types.
+    testTypes(
+        "/** @interface \n" +
+        " * @template T\n" +
+        " */\n" +
+        "function Foo() {}\n" +
+        "" +
+        "/** @constructor \n" +
+        " * @implements {Foo.<string>}\n" +
+        " */\n" +
+        "function A() {}\n" +
+        "" +
+        "/** @constructor \n" +
+        " * @implements {Foo.<number>}\n" +
+        " */\n" +
+        "function B() {}\n" +
+        "" +
+        "/** @type {!Foo.<string>} */ var a = new A();\n" +
+        "/** @type {!Foo.<string>} */ var b = new B();",
+        "initializing variable\n" +
+        "found   : B\n" +
+        "required: Foo.<string>");
+  }
+
+  public void testTemplateType13() throws Exception {
+    // verify that assignment/subtype relationships work when extending
+    // templatized types.
+    testTypes(
+        "/** @constructor \n" +
+        " * @template T\n" +
+        " */\n" +
+        "function Foo() {}\n" +
+        "" +
+        "/** @constructor \n" +
+        " * @template T\n" +
+        " * @extends {Foo.<T>}\n" +
+        " */\n" +
+        "function A() {}\n" +
+        "" +
+        "var a1 = new A();\n" +
+        "var a2 = /** @type {!A.<string>} */ (new A());\n" +
+        "var a3 = /** @type {!A.<number>} */ (new A());\n" +
+        "/** @type {!Foo.<string>} */ var f1 = a1;\n" +
+        "/** @type {!Foo.<string>} */ var f2 = a2;\n" +
+        "/** @type {!Foo.<string>} */ var f3 = a3;",
+        "initializing variable\n" +
+        "found   : A.<number>\n" +
+        "required: Foo.<string>");
+  }
+
+  public void testTemplateType14() throws Exception {
+    // verify that assignment/subtype relationships work when implementing
+    // templatized types.
+    testTypes(
+        "/** @interface \n" +
+        " * @template T\n" +
+        " */\n" +
+        "function Foo() {}\n" +
+        "" +
+        "/** @constructor \n" +
+        " * @template T\n" +
+        " * @implements {Foo.<T>}\n" +
+        " */\n" +
+        "function A() {}\n" +
+        "" +
+        "var a1 = new A();\n" +
+        "var a2 = /** @type {!A.<string>} */ (new A());\n" +
+        "var a3 = /** @type {!A.<number>} */ (new A());\n" +
+        "/** @type {!Foo.<string>} */ var f1 = a1;\n" +
+        "/** @type {!Foo.<string>} */ var f2 = a2;\n" +
+        "/** @type {!Foo.<string>} */ var f3 = a3;",
+        "initializing variable\n" +
+        "found   : A.<number>\n" +
+        "required: Foo.<string>");
+  }
+
+  public void disable_testBadTemplateType4() throws Exception {
+    // TODO(johnlenz): Add a check for useless of template types.
+    // Unless there are at least two references to a Template type in
+    // a definition it isn't useful.
     testTypes(
         "/**\n" +
         "* @template T\n" +
         "*/\n" +
         "function f() {}\n" +
         "f();",
-        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);
+        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());
   }
 
-  public void testBadTemplateType5() throws Exception {
+  public void disable_testBadTemplateType5() throws Exception {
+    // TODO(johnlenz): Add a check for useless of template types.
+    // Unless there are at least two references to a Template type in
+    // a definition it isn't useful.
     testTypes(
         "/**\n" +
         "* @template T\n" +
@@ -7224,7 +11075,77 @@
         "*/\n" +
         "function f() {}\n" +
         "f();",
-        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);
+        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());
+  }
+
+  public void disable_testFunctionLiteralUndefinedThisArgument()
+      throws Exception {
+    // TODO(johnlenz): this was a weird error.  We should add a general
+    // restriction on what is accepted for T. Something like:
+    // "@template T of {Object|string}" or some such.
+    testTypes(""
+        + "/**\n"
+        + " * @param {function(this:T, ...)?} fn\n"
+        + " * @param {?T} opt_obj\n"
+        + " * @template T\n"
+        + " */\n"
+        + "function baz(fn, opt_obj) {}\n"
+        + "baz(function() { this; });",
+        "Function literal argument refers to undefined this argument");
+  }
+
+  public void testFunctionLiteralDefinedThisArgument() throws Exception {
+    testTypes(""
+        + "/**\n"
+        + " * @param {function(this:T, ...)?} fn\n"
+        + " * @param {?T} opt_obj\n"
+        + " * @template T\n"
+        + " */\n"
+        + "function baz(fn, opt_obj) {}\n"
+        + "baz(function() { this; }, {});");
+  }
+
+  public void testFunctionLiteralDefinedThisArgument2() throws Exception {
+    testTypes(""
+        + "/** @param {string} x */ function f(x) {}"
+        + "/**\n"
+        + " * @param {?function(this:T, ...)} fn\n"
+        + " * @param {T=} opt_obj\n"
+        + " * @template T\n"
+        + " */\n"
+        + "function baz(fn, opt_obj) {}\n"
+        + "function g() { baz(function() { f(this.length); }, []); }",
+        "actual parameter 1 of f does not match formal parameter\n"
+        + "found   : number\n"
+        + "required: string");
+  }
+
+  public void testFunctionLiteralUnreadNullThisArgument() throws Exception {
+    testTypes(""
+        + "/**\n"
+        + " * @param {function(this:T, ...)?} fn\n"
+        + " * @param {?T} opt_obj\n"
+        + " * @template T\n"
+        + " */\n"
+        + "function baz(fn, opt_obj) {}\n"
+        + "baz(function() {}, null);");
+  }
+
+  public void testUnionTemplateThisType() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** @return {F|Array} */ function g() { return []; }" +
+        "/** @param {F} x */ function h(x) { }" +
+        "/**\n" +
+        "* @param {T} x\n" +
+        "* @param {function(this:T, ...)} y\n" +
+        "* @template T\n" +
+        "*/\n" +
+        "function f(x, y) {}\n" +
+        "f(g(), function() { h(this); });",
+        "actual parameter 1 of h does not match formal parameter\n" +
+        "found   : (Array|F|null)\n" +
+        "required: (F|null)");
   }
 
   public void testActiveXObject() throws Exception {
@@ -7233,17 +11154,720 @@
         "/** @type { {impossibleProperty} } */ var y = new ActiveXObject();");
   }
 
+  public void testRecordType1() throws Exception {
+    testTypes(
+        "/** @param {{prop: number}} x */" +
+        "function f(x) {}" +
+        "f({});",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : {prop: (number|undefined)}\n" +
+        "required: {prop: number}");
+  }
+
+  public void testRecordType2() throws Exception {
+    testTypes(
+        "/** @param {{prop: (number|undefined)}} x */" +
+        "function f(x) {}" +
+        "f({});");
+  }
+
+  public void testRecordType3() throws Exception {
+    testTypes(
+        "/** @param {{prop: number}} x */" +
+        "function f(x) {}" +
+        "f({prop: 'x'});",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : {prop: (number|string)}\n" +
+        "required: {prop: number}");
+  }
+
+  public void testRecordType4() throws Exception {
+    // Notice that we do not do flow-based inference on the object type:
+    // We don't try to prove that x.prop may not be string until x
+    // gets passed to g.
+    testClosureTypesMultipleWarnings(
+        "/** @param {{prop: (number|undefined)}} x */" +
+        "function f(x) {}" +
+        "/** @param {{prop: (string|undefined)}} x */" +
+        "function g(x) {}" +
+        "var x = {}; f(x); g(x);",
+        Lists.newArrayList(
+            "actual parameter 1 of f does not match formal parameter\n" +
+            "found   : {prop: (number|string|undefined)}\n" +
+            "required: {prop: (number|undefined)}",
+            "actual parameter 1 of g does not match formal parameter\n" +
+            "found   : {prop: (number|string|undefined)}\n" +
+            "required: {prop: (string|undefined)}"));
+  }
+
+  public void testRecordType5() throws Exception {
+    testTypes(
+        "/** @param {{prop: (number|undefined)}} x */" +
+        "function f(x) {}" +
+        "/** @param {{otherProp: (string|undefined)}} x */" +
+        "function g(x) {}" +
+        "var x = {}; f(x); g(x);");
+  }
+
+  public void testRecordType6() throws Exception {
+    testTypes(
+        "/** @return {{prop: (number|undefined)}} x */" +
+        "function f() { return {}; }");
+  }
+
+  public void testRecordType7() throws Exception {
+    testTypes(
+        "/** @return {{prop: (number|undefined)}} x */" +
+        "function f() { var x = {}; g(x); return x; }" +
+        "/** @param {number} x */" +
+        "function g(x) {}",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : {prop: (number|undefined)}\n" +
+        "required: number");
+  }
+
+  public void testRecordType8() throws Exception {
+    testTypes(
+        "/** @return {{prop: (number|string)}} x */" +
+        "function f() { var x = {prop: 3}; g(x.prop); return x; }" +
+        "/** @param {string} x */" +
+        "function g(x) {}",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testDuplicateRecordFields1() throws Exception {
+    testTypes("/**"
+         + "* @param {{x:string, x:number}} a"
+         + "*/"
+         + "function f(a) {};",
+         "Parse error. Duplicate record field x");
+  }
+
+  public void testDuplicateRecordFields2() throws Exception {
+    testTypes("/**"
+         + "* @param {{name:string,number:x,number:y}} a"
+         + " */"
+         + "function f(a) {};",
+         new String[] {"Bad type annotation. Unknown type x",
+           "Parse error. Duplicate record field number",
+           "Bad type annotation. Unknown type y"});
+  }
+
+  public void testMultipleExtendsInterface1() throws Exception {
+    testTypes("/** @interface */ function base1() {}\n"
+        + "/** @interface */ function base2() {}\n"
+        + "/** @interface\n"
+        + "* @extends {base1}\n"
+        + "* @extends {base2}\n"
+        + "*/\n"
+        + "function derived() {}");
+  }
+
+  public void testMultipleExtendsInterface2() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @desc description */Int0.prototype.foo = function() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
+        "function Int2() {};" +
+        "/** @constructor\n @implements {Int2} */function Foo() {};",
+        "property foo on interface Int0 is not implemented by type Foo");
+  }
+
+  public void testMultipleExtendsInterface3() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @desc description */Int1.prototype.foo = function() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
+        "function Int2() {};" +
+        "/** @constructor\n @implements {Int2} */function Foo() {};",
+        "property foo on interface Int1 is not implemented by type Foo");
+  }
+
+  public void testMultipleExtendsInterface4() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} \n" +
+        " @extends {number} */" +
+        "function Int2() {};" +
+        "/** @constructor\n @implements {Int2} */function Foo() {};",
+        "Int2 @extends non-object type number");
+  }
+
+  public void testMultipleExtendsInterface5() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @constructor */function Int1() {};" +
+        "/** @desc description @ return {string} x */" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
+        "function Int2() {};",
+        "Int2 cannot extend this type; interfaces can only extend interfaces");
+  }
+
+  public void testMultipleExtendsInterface6() throws Exception {
+    testTypes(
+        "/** @interface */function Super1() {};" +
+        "/** @interface */function Super2() {};" +
+        "/** @param {number} bar */Super2.prototype.foo = function(bar) {};" +
+        "/** @interface\n @extends {Super1}\n " +
+        "@extends {Super2} */function Sub() {};" +
+        "/** @override\n @param {string} bar */Sub.prototype.foo =\n" +
+        "function(bar) {};",
+        "mismatch of the foo property type and the type of the property it " +
+        "overrides from superclass Super2\n" +
+        "original: function (this:Super2, number): undefined\n" +
+        "override: function (this:Sub, string): undefined");
+  }
+
+  public void testMultipleExtendsInterfaceAssignment() throws Exception {
+    testTypes("/** @interface */var I1 = function() {};\n" +
+        "/** @interface */ var I2 = function() {}\n" +
+        "/** @interface\n@extends {I1}\n@extends {I2}*/" +
+        "var I3 = function() {};\n" +
+        "/** @constructor\n@implements {I3}*/var T = function() {};\n" +
+        "var t = new T();\n" +
+         "/** @type {I1} */var i1 = t;\n" +
+         "/** @type {I2} */var i2 = t;\n" +
+         "/** @type {I3} */var i3 = t;\n" +
+         "i1 = i3;\n" +
+         "i2 = i3;\n");
+  }
+
+  public void testMultipleExtendsInterfaceParamPass() throws Exception {
+    testTypes("/** @interface */var I1 = function() {};\n" +
+        "/** @interface */ var I2 = function() {}\n" +
+        "/** @interface\n@extends {I1}\n@extends {I2}*/" +
+        "var I3 = function() {};\n" +
+        "/** @constructor\n@implements {I3}*/var T = function() {};\n" +
+        "var t = new T();\n" +
+        "/** @param x I1 \n@param y I2\n@param z I3*/function foo(x,y,z){};\n" +
+        "foo(t,t,t)\n");
+  }
+
+  public void testBadMultipleExtendsClass() throws Exception {
+    testTypes("/** @constructor */ function base1() {}\n"
+        + "/** @constructor */ function base2() {}\n"
+        + "/** @constructor\n"
+        + "* @extends {base1}\n"
+        + "* @extends {base2}\n"
+        + "*/\n"
+        + "function derived() {}",
+        "Bad type annotation. type annotation incompatible "
+        + "with other annotations");
+  }
+
+  public void testInterfaceExtendsResolution() throws Exception {
+    testTypes("/** @interface \n @extends {A} */ function B() {};\n" +
+        "/** @constructor \n @implements {B} */ function C() {};\n" +
+        "/** @interface */ function A() {};");
+  }
+
+  public void testPropertyCanBeDefinedInObject() throws Exception {
+    testTypes("/** @interface */ function I() {};" +
+        "I.prototype.bar = function() {};" +
+        "/** @type {Object} */ var foo;" +
+        "foo.bar();");
+  }
+
   private void checkObjectType(ObjectType objectType, String propertyName,
         JSType expectedType) {
     assertTrue("Expected " + objectType.getReferenceName() +
         " to have property " +
         propertyName, objectType.hasProperty(propertyName));
-    assertEquals("Expected " + objectType.getReferenceName() +
+    assertTypeEquals("Expected " + objectType.getReferenceName() +
         "'s property " +
         propertyName + " to have type " + expectedType,
         expectedType, objectType.getPropertyType(propertyName));
   }
 
+  public void testExtendedInterfacePropertiesCompatibility1() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
+        "function Int2() {};",
+        "Interface Int2 has a property foo with incompatible types in its " +
+        "super interfaces Int0 and Int1");
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility2() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @interface */function Int2() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @type {Object} */" +
+        "Int2.prototype.foo;" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} \n" +
+        "@extends {Int2}*/" +
+        "function Int3() {};",
+        new String[] {
+            "Interface Int3 has a property foo with incompatible types in " +
+            "its super interfaces Int0 and Int1",
+            "Interface Int3 has a property foo with incompatible types in " +
+            "its super interfaces Int1 and Int2"
+        });
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility3() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};",
+        "Interface Int3 has a property foo with incompatible types in its " +
+        "super interfaces Int0 and Int1");
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility4() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface \n @extends {Int0} */ function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @interface */function Int2() {};" +
+        "/** @interface \n @extends {Int2} */ function Int3() {};" +
+        "/** @type {string} */" +
+        "Int2.prototype.foo;" +
+        "/** @interface \n @extends {Int1} \n @extends {Int3} */" +
+        "function Int4() {};",
+        "Interface Int4 has a property foo with incompatible types in its " +
+        "super interfaces Int0 and Int2");
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility5() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};" +
+        "/** @interface */function Int4() {};" +
+        "/** @type {number} */" +
+        "Int4.prototype.foo;" +
+        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
+        "function Int5() {};",
+        new String[] {
+            "Interface Int3 has a property foo with incompatible types in its" +
+            " super interfaces Int0 and Int1",
+            "Interface Int5 has a property foo with incompatible types in its" +
+            " super interfaces Int1 and Int4"});
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility6() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};" +
+        "/** @interface */function Int4() {};" +
+        "/** @type {string} */" +
+        "Int4.prototype.foo;" +
+        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
+        "function Int5() {};",
+        "Interface Int3 has a property foo with incompatible types in its" +
+        " super interfaces Int0 and Int1");
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility7() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};" +
+        "/** @interface */function Int4() {};" +
+        "/** @type {Object} */" +
+        "Int4.prototype.foo;" +
+        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
+        "function Int5() {};",
+        new String[] {
+            "Interface Int3 has a property foo with incompatible types in its" +
+            " super interfaces Int0 and Int1",
+            "Interface Int5 has a property foo with incompatible types in its" +
+            " super interfaces Int1 and Int4"});
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility8() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.bar;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};" +
+        "/** @interface */function Int4() {};" +
+        "/** @type {Object} */" +
+        "Int4.prototype.foo;" +
+        "/** @type {Null} */" +
+        "Int4.prototype.bar;" +
+        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
+        "function Int5() {};",
+        new String[] {
+            "Interface Int5 has a property bar with incompatible types in its" +
+            " super interfaces Int1 and Int4",
+            "Interface Int5 has a property foo with incompatible types in its" +
+            " super interfaces Int0 and Int4"});
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility9() throws Exception {
+    testTypes(
+        "/** @interface\n * @template T */function Int0() {};" +
+        "/** @interface\n * @template T */function Int1() {};" +
+        "/** @type {T} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {T} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int0.<number>} \n @extends {Int1.<string>} */" +
+        "function Int2() {};",
+        "Interface Int2 has a property foo with incompatible types in its " +
+        "super interfaces Int0.<number> and Int1.<string>");
+  }
+
+  public void testGenerics1() throws Exception {
+    String fnDecl = "/** \n" +
+        " * @param {T} x \n" +
+        " * @param {function(T):T} y \n" +
+        " * @template T\n" +
+        " */ \n" +
+        "function f(x,y) { return y(x); }\n";
+
+    testTypes(
+        fnDecl +
+        "/** @type {string} */" +
+        "var out;" +
+        "/** @type {string} */" +
+        "var result = f('hi', function(x){ out = x; return x; });");
+
+    testTypes(
+        fnDecl +
+        "/** @type {string} */" +
+        "var out;" +
+        "var result = f(0, function(x){ out = x; return x; });",
+        "assignment\n" +
+        "found   : number\n" +
+        "required: string");
+
+    testTypes(
+        fnDecl +
+        "var out;" +
+        "/** @type {string} */" +
+        "var result = f(0, function(x){ out = x; return x; });",
+        "assignment\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testFilter0()
+      throws Exception {
+    testTypes(
+        "/**\n" +
+        " * @param {T} arr\n" +
+        " * @return {T}\n" +
+        " * @template T\n" +
+        " */\n" +
+        "var filter = function(arr){};\n" +
+
+        "/** @type {!Array.<string>} */" +
+        "var arr;\n" +
+        "/** @type {!Array.<string>} */" +
+        "var result = filter(arr);");
+  }
+
+  public void testFilter1()
+      throws Exception {
+    testTypes(
+        "/**\n" +
+        " * @param {!Array.<T>} arr\n" +
+        " * @return {!Array.<T>}\n" +
+        " * @template T\n" +
+        " */\n" +
+        "var filter = function(arr){};\n" +
+
+        "/** @type {!Array.<string>} */" +
+        "var arr;\n" +
+        "/** @type {!Array.<string>} */" +
+        "var result = filter(arr);");
+  }
+
+  public void testFilter2()
+      throws Exception {
+    testTypes(
+        "/**\n" +
+        " * @param {!Array.<T>} arr\n" +
+        " * @return {!Array.<T>}\n" +
+        " * @template T\n" +
+        " */\n" +
+        "var filter = function(arr){};\n" +
+
+        "/** @type {!Array.<string>} */" +
+        "var arr;\n" +
+        "/** @type {!Array.<number>} */" +
+        "var result = filter(arr);",
+        "initializing variable\n" +
+        "found   : Array.<string>\n" +
+        "required: Array.<number>");
+  }
+
+  public void testFilter3()
+      throws Exception {
+    testTypes(
+        "/**\n" +
+        " * @param {Array.<T>} arr\n" +
+        " * @return {Array.<T>}\n" +
+        " * @template T\n" +
+        " */\n" +
+        "var filter = function(arr){};\n" +
+
+        "/** @type {Array.<string>} */" +
+        "var arr;\n" +
+        "/** @type {Array.<number>} */" +
+        "var result = filter(arr);",
+        "initializing variable\n" +
+        "found   : (Array.<string>|null)\n" +
+        "required: (Array.<number>|null)");
+  }
+
+  public void testBackwardsInferenceGoogArrayFilter1()
+      throws Exception {
+    testClosureTypes(
+        CLOSURE_DEFS +
+        "/** @type {Array.<string>} */" +
+        "var arr;\n" +
+        "/** @type {!Array.<number>} */" +
+        "var result = goog.array.filter(" +
+        "   arr," +
+        "   function(item,index,src) {return false;});",
+        "initializing variable\n" +
+        "found   : Array.<string>\n" +
+        "required: Array.<number>");
+  }
+
+  public void testBackwardsInferenceGoogArrayFilter2() throws Exception {
+    testClosureTypes(
+        CLOSURE_DEFS +
+        "/** @type {number} */" +
+        "var out;" +
+        "/** @type {Array.<string>} */" +
+        "var arr;\n" +
+        "var out4 = goog.array.filter(" +
+        "   arr," +
+        "   function(item,index,src) {out = item;});",
+        "assignment\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testBackwardsInferenceGoogArrayFilter3() throws Exception {
+    testClosureTypes(
+        CLOSURE_DEFS +
+        "/** @type {string} */" +
+        "var out;" +
+        "/** @type {Array.<string>} */ var arr;\n" +
+        "var result = goog.array.filter(" +
+        "   arr," +
+        "   function(item,index,src) {out = index;});",
+        "assignment\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testBackwardsInferenceGoogArrayFilter4() throws Exception {
+    testClosureTypes(
+        CLOSURE_DEFS +
+        "/** @type {string} */" +
+        "var out;" +
+        "/** @type {Array.<string>} */ var arr;\n" +
+        "var out4 = goog.array.filter(" +
+        "   arr," +
+        "   function(item,index,srcArr) {out = srcArr;});",
+        "assignment\n" +
+        "found   : (null|{length: number})\n" +
+        "required: string");
+  }
+
+  public void testCatchExpression1() throws Exception {
+    testTypes(
+        "function fn() {" +
+        "  /** @type {number} */" +
+        "  var out = 0;" +
+        "  try {\n" +
+        "    foo();\n" +
+        "  } catch (/** @type {string} */ e) {\n" +
+        "    out = e;" +
+        "  }" +
+        "}\n",
+        "assignment\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testCatchExpression2() throws Exception {
+    testTypes(
+        "function fn() {" +
+        "  /** @type {number} */" +
+        "  var out = 0;" +
+        "  /** @type {string} */" +
+        "  var e;" +
+        "  try {\n" +
+        "    foo();\n" +
+        "  } catch (e) {\n" +
+        "    out = e;" +
+        "  }" +
+        "}\n");
+  }
+
+  public void testTemplatized1() throws Exception {
+    testTypes(
+        "/** @type {!Array.<string>} */" +
+        "var arr1 = [];\n" +
+        "/** @type {!Array.<number>} */" +
+        "var arr2 = [];\n" +
+        "arr1 = arr2;",
+        "assignment\n" +
+        "found   : Array.<number>\n" +
+        "required: Array.<string>");
+  }
+
+  public void testTemplatized2() throws Exception {
+    testTypes(
+        "/** @type {!Array.<string>} */" +
+        "var arr1 = /** @type {!Array.<number>} */([]);\n",
+        "initializing variable\n" +
+        "found   : Array.<number>\n" +
+        "required: Array.<string>");
+  }
+
+  public void testTemplatized3() throws Exception {
+    testTypes(
+        "/** @type {Array.<string>} */" +
+        "var arr1 = /** @type {!Array.<number>} */([]);\n",
+        "initializing variable\n" +
+        "found   : Array.<number>\n" +
+        "required: (Array.<string>|null)");
+  }
+
+  public void testTemplatized4() throws Exception {
+    testTypes(
+        "/** @type {Array.<string>} */" +
+        "var arr1 = [];\n" +
+        "/** @type {Array.<number>} */" +
+        "var arr2 = arr1;\n",
+        "initializing variable\n" +
+        "found   : (Array.<string>|null)\n" +
+        "required: (Array.<number>|null)");
+  }
+
+  public void testTemplatized5() throws Exception {
+    testTypes(
+        "/**\n" +
+        " * @param {Object.<T>} obj\n" +
+        " * @return {boolean|undefined}\n" +
+        " * @template T\n" +
+        " */\n" +
+        "var some = function(obj) {" +
+        "  for (var key in obj) if (obj[key]) return true;" +
+        "};" +
+        "/** @return {!Array} */ function f() { return []; }" +
+        "/** @return {!Array.<string>} */ function g() { return []; }" +
+        "some(f());\n" +
+        "some(g());\n");
+  }
+
+  public void testUnknownTypeReport() throws Exception {
+    compiler.getOptions().setWarningLevel(DiagnosticGroups.REPORT_UNKNOWN_TYPES,
+        CheckLevel.WARNING);
+    testTypes("function id(x) { return x; }",
+        "could not determine the type of this expression");
+  }
+
+  public void testUnknownTypeDisabledByDefault() throws Exception {
+    testTypes("function id(x) { return x; }");
+  }
+
+  public void testTemplatizedTypeSubtypes2() throws Exception {
+    JSType arrayOfNumber = createTemplatizedType(
+        ARRAY_TYPE, NUMBER_TYPE);
+    JSType arrayOfString = createTemplatizedType(
+        ARRAY_TYPE, STRING_TYPE);
+    assertFalse(arrayOfString.isSubtype(createUnionType(arrayOfNumber, NULL_VOID)));
+
+  }
+
+  public void testNonexistentPropertyAccessOnStruct() throws Exception {
+    testTypes(
+        "/**\n" +
+        " * @constructor\n" +
+        " * @struct\n" +
+        " */\n" +
+        "var A = function() {};\n" +
+        "/** @param {A} a */\n" +
+        "function foo(a) {\n" +
+        "  if (a.bar) { a.bar(); }\n" +
+        "}",
+        "Property bar never defined on A");
+  }
+
+  public void testNonexistentPropertyAccessOnStructOrObject() throws Exception {
+    testTypes(
+        "/**\n" +
+        " * @constructor\n" +
+        " * @struct\n" +
+        " */\n" +
+        "var A = function() {};\n" +
+        "/** @param {A|Object} a */\n" +
+        "function foo(a) {\n" +
+        "  if (a.bar) { a.bar(); }\n" +
+        "}");
+  }
+
+  public void testNonexistentPropertyAccessOnExternStruct() throws Exception {
+    testTypes(
+        "/**\n" +
+        " * @constructor\n" +
+        " * @struct\n" +
+        " */\n" +
+        "var A = function() {};",
+        "/** @param {A} a */\n" +
+        "function foo(a) {\n" +
+        "  if (a.bar) { a.bar(); }\n" +
+        "}",
+        "Property bar never defined on A", false);
+  }
+
+
   private void testTypes(String js) throws Exception {
     testTypes(js, (String) null);
   }
@@ -7258,6 +11882,12 @@
 
   private void testClosureTypes(String js, String description)
       throws Exception {
+    testClosureTypesMultipleWarnings(js,
+        description == null ? null : Lists.newArrayList(description));
+  }
+
+  private void testClosureTypesMultipleWarnings(
+      String js, List<String> descriptions) throws Exception {
     Node n = compiler.parseTestCode(js);
     Node externs = new Node(Token.BLOCK);
     Node externAndJsRoot = new Node(Token.BLOCK, externs, n);
@@ -7268,7 +11898,7 @@
         0, compiler.getErrorCount());
 
     // For processing goog.addDependency for forward typedefs.
-    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)
+    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)
         .process(null, n);
 
     CodingConvention convention = compiler.getCodingConvention();
@@ -7281,16 +11911,27 @@
         registry)
         .processForTesting(null, n);
 
-    assertEquals(0, compiler.getErrorCount());
+    assertEquals(
+        "unexpected error(s) : " +
+        Joiner.on(", ").join(compiler.getErrors()),
+        0, compiler.getErrorCount());
 
-    if (description == null) {
+    if (descriptions == null) {
       assertEquals(
           "unexpected warning(s) : " +
           Joiner.on(", ").join(compiler.getWarnings()),
           0, compiler.getWarningCount());
     } else {
-      assertEquals(1, compiler.getWarningCount());
-      assertEquals(description, compiler.getWarnings()[0].description);
+      assertEquals(
+          "unexpected warning(s) : " +
+          Joiner.on(", ").join(compiler.getWarnings()),
+          descriptions.size(), compiler.getWarningCount());
+      Set<String> actualWarningDescriptions = Sets.newHashSet();
+      for (int i = 0; i < descriptions.size(); i++) {
+        actualWarningDescriptions.add(compiler.getWarnings()[i].description);
+      }
+      assertEquals(
+          Sets.newHashSet(descriptions), actualWarningDescriptions);
     }
   }
 
@@ -7301,7 +11942,7 @@
 
   void testTypes(String externs, String js, String description, boolean isError)
       throws Exception {
-    Node n = parseAndTypeCheck(externs, js);
+    parseAndTypeCheck(externs, js);
 
     JSError[] errors = compiler.getErrors();
     if (description != null && isError) {
@@ -7348,12 +11989,13 @@
   private TypeCheckResult parseAndTypeCheckWithScope(
       String externs, String js) {
     compiler.init(
-        Lists.newArrayList(JSSourceFile.fromCode("[externs]", externs)),
-        Lists.newArrayList(JSSourceFile.fromCode("[testcode]", js)),
+        Lists.newArrayList(SourceFile.fromCode("[externs]", externs)),
+        Lists.newArrayList(SourceFile.fromCode("[testcode]", js)),
         compiler.getOptions());
 
-    Node n = compiler.getInput("[testcode]").getAstRoot(compiler);
-    Node externsNode = compiler.getInput("[externs]").getAstRoot(compiler);
+    Node n = compiler.getInput(new InputId("[testcode]")).getAstRoot(compiler);
+    Node externsNode = compiler.getInput(new InputId("[externs]"))
+        .getAstRoot(compiler);
     Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);
     externAndJsRoot.setIsSyntheticBlock(true);
 
@@ -7380,15 +12022,15 @@
         new SemanticReverseAbstractInterpreter(
             compiler.getCodingConvention(), registry),
         registry,
-        reportMissingOverrides,
-        CheckLevel.OFF);
+        reportMissingOverrides);
   }
 
   void testTypes(String js, String[] warnings) throws Exception {
     Node n = compiler.parseTestCode(js);
     assertEquals(0, compiler.getErrorCount());
     Node externsNode = new Node(Token.BLOCK);
-    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);
+    // create a parent node for the extern and source blocks
+    new Node(Token.BLOCK, externsNode, n);
 
     makeTypeCheck().processForTesting(null, n);
     assertEquals(0, compiler.getErrorCount());
