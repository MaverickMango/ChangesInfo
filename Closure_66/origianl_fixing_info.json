{
  "logger": {
    "currentLogLevel": 20,
    "name": "root.bean.benchmarks.Defects4JBug"
  },
  "d4jCmd": "/home/liumengjiao/Desktop/defects4j/framework/bin/defects4j",
  "dataDir": "/home/liumengjiao/Desktop/CI/Benchmark/data/changesInfo/",
  "properties": {
    "trigger.tests": "com.google.javascript.jscomp.TypeCheckTest::testGetTypedPercent5,com.google.javascript.jscomp.TypeCheckTest::testGetTypedPercent6",
    "test.dir": "test",
    "clz.modified": "com.google.javascript.jscomp.TypeCheck",
    "src.dir": "src"
  },
  "timeoutSecond": 100,
  "proj": "Closure",
  "id": "66",
  "workingDir": "../bugs/Closure_66_buggy",
  "buggyCommit": "984bce0d9f36b0a21a0f9b51dc68fca0175aa1c8",
  "inducingCommit": "70f817ae4f80ac11dd2dfe97babf5896c690fb48",
  "originalCommit": "026a1083635e5564b6c18264372ee884f410490f",
  "bug_name": "Closure_66",
  "derive": "defects4j",
  "original_fixing_commit": "59a30b48325cccadabae8687fdf603d72e26c157",
  "buildFiles_changed": false,
  "regression": true,
  "inducing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/NodeUtil.java",
        "src/com/google/javascript/jscomp/NodeUtil.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.NodeUtil:isAssociative:[int type]:boolean",
            "com.google.javascript.jscomp.NodeUtil:checkForStateChangeHelper:[Node n, boolean checkForNewObjects, AbstractCompiler compiler]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isLoopStructure:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:newExpr:[Node child]:Node",
            "com.google.javascript.jscomp.NodeUtil:precedence:[int type]:int",
            "com.google.javascript.jscomp.NodeUtil:setDebugInformation:[Node node, Node basisNode, String originalName]:void",
            "com.google.javascript.jscomp.NodeUtil:isValidDefineValue:[Node val, Set\u003cString\u003e defines]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isSimpleOperatorType:[int type]:boolean",
            "com.google.javascript.jscomp.NodeUtil:mayEffectMutableState:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:removeChild:[Node parent, Node node]:void",
            "com.google.javascript.jscomp.NodeUtil:isUndefined:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:mayBeString:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isAssignmentOp:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:getAddingRoot:[Node n]:Node",
            "com.google.javascript.jscomp.NodeUtil:isStrWhiteSpaceChar:[int c]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isCommutative:[int type]:boolean",
            "com.google.javascript.jscomp.NodeUtil:tryMergeBlock:[Node block]:boolean",
            "com.google.javascript.jscomp.NodeUtil:getStringValue:[Node n]:String",
            "com.google.javascript.jscomp.NodeUtil:isCallOrNew:[Node node]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isEmptyBlock:[Node block]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isLiteralValue:[Node n, boolean includeFunctions]:boolean",
            "com.google.javascript.jscomp.NodeUtil:getLoopCodeBlock:[Node n]:Node",
            "com.google.javascript.jscomp.NodeUtil:getFunctionName:[Node n]:String",
            "com.google.javascript.jscomp.NodeUtil:getNumberValue:[Node n]:Double"
          ],
          "num": 24
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.NodeUtil:getObjectLitKeyTypeFromValueType:[Node key, JSType valueType]:JSType",
            "com.google.javascript.jscomp.NodeUtil:isUndefined:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:functionCallHasSideEffects:[Node callNode]:boolean",
            "com.google.javascript.jscomp.NodeUtil:newHasLocalResult:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:nodeTypeMayHaveSideEffects:[Node n, AbstractCompiler compiler]:boolean",
            "com.google.javascript.jscomp.NodeUtil:newQualifiedNameNode:[CodingConvention convention, String name, int lineno, int charno]:Node",
            "com.google.javascript.jscomp.NodeUtil:getNumberValue:[Node n]:Double",
            "com.google.javascript.jscomp.NodeUtil:functionCallHasSideEffects:[Node callNode, @Nullable AbstractCompiler compiler]:boolean",
            "com.google.javascript.jscomp.NodeUtil:evaluatesToLocalValue:[Node value, Predicate\u003cNode\u003e locals]:boolean",
            "com.google.javascript.jscomp.NodeUtil:getNearestFunctionName:[Node n]:String",
            "com.google.javascript.jscomp.NodeUtil:getFnParameters:[Node fnNode]:Node",
            "com.google.javascript.jscomp.NodeUtil:getArgumentForFunction:[Node function, int index]:Node",
            "com.google.javascript.jscomp.NodeUtil:getObjectLitKeyName:[Node key]:String",
            "com.google.javascript.jscomp.NodeUtil:maybeAddFinally:[Node tryNode]:void",
            "com.google.javascript.jscomp.NodeUtil:isCallOrNew:[Node node]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isGetOrSetKey:[Node node]:boolean",
            "com.google.javascript.jscomp.NodeUtil:getExpressionBooleanValue:[Node n]:TernaryValue",
            "com.google.javascript.jscomp.NodeUtil:isTryCatchNodeContainer:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isWithinLoop:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:newName:[CodingConvention convention, String name, int lineno, int charno]:Node",
            "com.google.javascript.jscomp.NodeUtil:tryMergeBlock:[Node block]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isNumericResult:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isNull:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isSimpleOperator:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:removeChild:[Node parent, Node node]:void",
            "com.google.javascript.jscomp.NodeUtil:isAssociative:[int type]:boolean",
            "com.google.javascript.jscomp.NodeUtil:setDebugInformation:[Node node, Node basisNode, String originalName]:void",
            "com.google.javascript.jscomp.NodeUtil:constructorCallHasSideEffects:[Node callNode]:boolean",
            "com.google.javascript.jscomp.NodeUtil:getFunctionName:[Node n]:String",
            "com.google.javascript.jscomp.NodeUtil:isImmutableValue:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:newName:[CodingConvention convention, String name, Node basisNode, String originalName]:Node",
            "com.google.javascript.jscomp.NodeUtil:newQualifiedNameNode:[CodingConvention convention, String name, Node basisNode, String originalName]:Node",
            "com.google.javascript.jscomp.NodeUtil:trimJsWhiteSpace:[String s]:String",
            "com.google.javascript.jscomp.NodeUtil:isToStringMethodCall:[Node call]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isFunctionObjectCallOrApply:[Node callNode]:boolean",
            "com.google.javascript.jscomp.NodeUtil:newName:[CodingConvention convention, String name, Node basisNode]:Node",
            "com.google.javascript.jscomp.NodeUtil:getNthSibling:[Node first, int index]:Node",
            "com.google.javascript.jscomp.NodeUtil:isValidDefineValue:[Node val, Set\u003cString\u003e defines]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isSimpleFunctionObjectCall:[Node callNode]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isStrWhiteSpaceChar:[int c]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isCommutative:[int type]:boolean",
            "com.google.javascript.jscomp.NodeUtil:evaluatesToLocalValue:[Node value]:boolean",
            "com.google.javascript.jscomp.NodeUtil:constructorCallHasSideEffects:[Node callNode, AbstractCompiler compiler]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isFunction:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:getRootOfQualifiedName:[Node qName]:Node",
            "com.google.javascript.jscomp.NodeUtil:isControlStructure:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isObjectLitKey:[Node node, Node parent]:boolean",
            "com.google.javascript.jscomp.NodeUtil:nodeTypeMayHaveSideEffects:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isBooleanResult:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:checkForStateChangeHelper:[Node n, boolean checkForNewObjects, AbstractCompiler compiler]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isLiteralValue:[Node n, boolean includeFunctions]:boolean",
            "com.google.javascript.jscomp.NodeUtil:callHasLocalResult:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:getStringValue:[Node n]:String",
            "com.google.javascript.jscomp.NodeUtil:mayBeString:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:getArgumentForCallOrNew:[Node call, int index]:Node"
          ],
          "num": 55
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "2",
            "27",
            "43",
            "44",
            "152",
            "178",
            "213",
            "264",
            "274",
            "297",
            "333",
            "449",
            "497",
            "509",
            "510",
            "511",
            "512",
            "513",
            "515",
            "536",
            "537",
            "538",
            "552",
            "563",
            "564",
            "577",
            "578",
            "579",
            "590",
            "621",
            "634",
            "636",
            "795",
            "803",
            "1018",
            "1148",
            "1149",
            "1150",
            "1151",
            "1163",
            "1164",
            "1165",
            "1166",
            "1185",
            "1215",
            "1352",
            "1389",
            "1390",
            "1391",
            "1392",
            "1393",
            "1394",
            "1395",
            "1396",
            "1397",
            "1575",
            "1578",
            "1580",
            "1581",
            "1589",
            "1590",
            "1591",
            "1610",
            "1612",
            "1630",
            "1641",
            "1660",
            "1661",
            "2020",
            "2021",
            "2022",
            "2124"
          ],
          "num": 72
        },
        {
          "qualified_names": [
            "2",
            "28",
            "29",
            "48",
            "49",
            "94",
            "157",
            "158",
            "159",
            "160",
            "161",
            "162",
            "163",
            "164",
            "165",
            "189",
            "190",
            "191",
            "192",
            "193",
            "194",
            "195",
            "196",
            "197",
            "198",
            "199",
            "200",
            "201",
            "202",
            "203",
            "204",
            "205",
            "206",
            "207",
            "208",
            "209",
            "210",
            "211",
            "212",
            "213",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "220",
            "221",
            "222",
            "223",
            "224",
            "225",
            "226",
            "227",
            "228",
            "229",
            "230",
            "231",
            "232",
            "233",
            "234",
            "235",
            "236",
            "237",
            "238",
            "239",
            "240",
            "241",
            "242",
            "243",
            "244",
            "245",
            "246",
            "247",
            "248",
            "249",
            "250",
            "251",
            "252",
            "253",
            "254",
            "255",
            "256",
            "257",
            "258",
            "259",
            "260",
            "261",
            "262",
            "263",
            "264",
            "265",
            "266",
            "267",
            "268",
            "269",
            "270",
            "271",
            "272",
            "273",
            "274",
            "275",
            "276",
            "277",
            "278",
            "279",
            "280",
            "281",
            "282",
            "283",
            "284",
            "285",
            "286",
            "287",
            "288",
            "289",
            "290",
            "291",
            "292",
            "293",
            "294",
            "295",
            "296",
            "297",
            "298",
            "299",
            "300",
            "301",
            "302",
            "303",
            "304",
            "305",
            "306",
            "307",
            "308",
            "309",
            "310",
            "346",
            "347",
            "348",
            "349",
            "350",
            "351",
            "352",
            "353",
            "354",
            "355",
            "356",
            "357",
            "358",
            "359",
            "360",
            "361",
            "362",
            "363",
            "364",
            "365",
            "366",
            "367",
            "368",
            "369",
            "370",
            "371",
            "372",
            "373",
            "374",
            "375",
            "376",
            "377",
            "378",
            "379",
            "380",
            "381",
            "382",
            "443",
            "444",
            "445",
            "446",
            "447",
            "448",
            "449",
            "450",
            "451",
            "452",
            "475",
            "476",
            "481",
            "482",
            "483",
            "484",
            "485",
            "486",
            "487",
            "488",
            "489",
            "490",
            "491",
            "492",
            "493",
            "494",
            "495",
            "496",
            "497",
            "498",
            "499",
            "502",
            "533",
            "534",
            "535",
            "536",
            "653",
            "654",
            "655",
            "656",
            "657",
            "658",
            "659",
            "660",
            "661",
            "662",
            "663",
            "712",
            "713",
            "714",
            "715",
            "716",
            "722",
            "728",
            "729",
            "730",
            "731",
            "732",
            "733",
            "734",
            "735",
            "736",
            "738",
            "739",
            "740",
            "741",
            "742",
            "743",
            "744",
            "745",
            "746",
            "747",
            "748",
            "749",
            "750",
            "751",
            "752",
            "753",
            "774",
            "775",
            "776",
            "777",
            "778",
            "779",
            "780",
            "781",
            "782",
            "797",
            "798",
            "799",
            "800",
            "801",
            "802",
            "803",
            "804",
            "815",
            "828",
            "829",
            "830",
            "831",
            "842",
            "846",
            "847",
            "848",
            "849",
            "850",
            "851",
            "852",
            "853",
            "854",
            "855",
            "856",
            "885",
            "886",
            "887",
            "888",
            "889",
            "890",
            "891",
            "892",
            "893",
            "894",
            "895",
            "896",
            "897",
            "898",
            "899",
            "900",
            "908",
            "909",
            "910",
            "911",
            "922",
            "923",
            "924",
            "925",
            "1078",
            "1079",
            "1080",
            "1081",
            "1082",
            "1083",
            "1084",
            "1085",
            "1086",
            "1087",
            "1088",
            "1089",
            "1090",
            "1091",
            "1092",
            "1093",
            "1094",
            "1095",
            "1096",
            "1097",
            "1098",
            "1099",
            "1100",
            "1101",
            "1102",
            "1103",
            "1104",
            "1105",
            "1106",
            "1107",
            "1108",
            "1109",
            "1110",
            "1111",
            "1112",
            "1113",
            "1114",
            "1115",
            "1116",
            "1117",
            "1118",
            "1119",
            "1120",
            "1121",
            "1122",
            "1123",
            "1124",
            "1125",
            "1126",
            "1127",
            "1128",
            "1129",
            "1130",
            "1131",
            "1132",
            "1133",
            "1134",
            "1135",
            "1136",
            "1137",
            "1138",
            "1139",
            "1140",
            "1141",
            "1142",
            "1143",
            "1144",
            "1145",
            "1146",
            "1147",
            "1148",
            "1149",
            "1150",
            "1151",
            "1152",
            "1153",
            "1154",
            "1155",
            "1156",
            "1157",
            "1158",
            "1159",
            "1160",
            "1161",
            "1162",
            "1163",
            "1164",
            "1165",
            "1166",
            "1167",
            "1170",
            "1179",
            "1180",
            "1181",
            "1182",
            "1183",
            "1184",
            "1185",
            "1186",
            "1187",
            "1188",
            "1189",
            "1190",
            "1191",
            "1192",
            "1193",
            "1194",
            "1195",
            "1196",
            "1197",
            "1198",
            "1414",
            "1415",
            "1416",
            "1417",
            "1418",
            "1419",
            "1420",
            "1421",
            "1422",
            "1423",
            "1424",
            "1425",
            "1426",
            "1427",
            "1428",
            "1429",
            "1430",
            "1558",
            "1559",
            "1560",
            "1561",
            "1562",
            "1563",
            "1564",
            "1567",
            "1568",
            "1569",
            "1570",
            "1571",
            "1572",
            "1573",
            "1574",
            "1575",
            "1576",
            "1577",
            "1578",
            "1579",
            "1580",
            "1581",
            "1582",
            "1583",
            "1584",
            "1585",
            "1586",
            "1587",
            "1588",
            "1589",
            "1590",
            "1591",
            "1622",
            "1623",
            "1624",
            "1625",
            "1626",
            "1627",
            "1628",
            "1629",
            "1630",
            "1631",
            "1632",
            "1663",
            "1664",
            "1665",
            "1666",
            "1667",
            "1668",
            "1669",
            "1670",
            "1808",
            "1809",
            "1810",
            "1811",
            "1812",
            "1813",
            "1814",
            "1815",
            "1816",
            "1817",
            "1818",
            "1819",
            "1856",
            "1857",
            "1858",
            "1859",
            "1860",
            "1861",
            "1862",
            "1863",
            "1864",
            "1865",
            "1866",
            "1867",
            "1868",
            "1869",
            "1870",
            "1871",
            "1872",
            "1873",
            "1874",
            "1875",
            "1876",
            "1877",
            "1878",
            "1879",
            "1880",
            "1881",
            "1882",
            "1883",
            "1884",
            "1885",
            "1886",
            "1887",
            "1888",
            "1889",
            "1890",
            "1891",
            "1892",
            "1893",
            "1894",
            "1895",
            "1896",
            "1897",
            "1898",
            "1899",
            "1900",
            "1901",
            "1902",
            "1903",
            "1904",
            "1905",
            "1906",
            "1907",
            "1908",
            "1909",
            "1910",
            "1913",
            "1914",
            "1915",
            "1916",
            "1917",
            "1918",
            "1919",
            "1920",
            "1921",
            "1922",
            "1923",
            "1924",
            "1925",
            "1926",
            "1927",
            "2103",
            "2104",
            "2107",
            "2109",
            "2110",
            "2118",
            "2119",
            "2120",
            "2121",
            "2122",
            "2141",
            "2142",
            "2144",
            "2150",
            "2151",
            "2152",
            "2153",
            "2154",
            "2155",
            "2156",
            "2157",
            "2158",
            "2159",
            "2160",
            "2161",
            "2162",
            "2163",
            "2177",
            "2178",
            "2179",
            "2180",
            "2181",
            "2182",
            "2183",
            "2184",
            "2185",
            "2196",
            "2197",
            "2199",
            "2200",
            "2201",
            "2219",
            "2220",
            "2221",
            "2222",
            "2581",
            "2582",
            "2583",
            "2686",
            "2687",
            "2688",
            "2689",
            "2690",
            "2691",
            "2692",
            "2693",
            "2694",
            "2695",
            "2696",
            "2697",
            "2698",
            "2699",
            "2700",
            "2701",
            "2702",
            "2703",
            "2704",
            "2705",
            "2706",
            "2707",
            "2708",
            "2709",
            "2710",
            "2711",
            "2712",
            "2713",
            "2714",
            "2715",
            "2716",
            "2717",
            "2718",
            "2719",
            "2720",
            "2721",
            "2722",
            "2723",
            "2724",
            "2725",
            "2726",
            "2727",
            "2728",
            "2729",
            "2730",
            "2731",
            "2732",
            "2733",
            "2734",
            "2735",
            "2736",
            "2737",
            "2738",
            "2739",
            "2740",
            "2741",
            "2742",
            "2743",
            "2744",
            "2745",
            "2746",
            "2747",
            "2748",
            "2749",
            "2750",
            "2751",
            "2752",
            "2753",
            "2754",
            "2755",
            "2756",
            "2757",
            "2758",
            "2759",
            "2760",
            "2761",
            "2762",
            "2763",
            "2764",
            "2765",
            "2766",
            "2767",
            "2768",
            "2769",
            "2770",
            "2771",
            "2772",
            "2773",
            "2774",
            "2775",
            "2776",
            "2777",
            "2778",
            "2779",
            "2780",
            "2781",
            "2782",
            "2783",
            "2784",
            "2785",
            "2786",
            "2787",
            "2788",
            "2789",
            "2790",
            "2791",
            "2792",
            "2793",
            "2794",
            "2795",
            "2796",
            "2797",
            "2798",
            "2799",
            "2800",
            "2801",
            "2802",
            "2803",
            "2804",
            "2805",
            "2806"
          ],
          "num": 740
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 1a7a030..615cec4 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2004 Google Inc.\n+ * Copyright 2004 The Closure Compiler Authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -25,6 +25,8 @@\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.TokenStream;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.TernaryValue;\n \n import java.util.Arrays;\n@@ -40,11 +42,11 @@\n /**\n  * NodeUtil contains utilities that get properties from the Node object.\n  *\n- *\n- *\n  */\n public final class NodeUtil {\n \n+  final static String JSC_PROPERTY_NAME_FN \u003d \"JSCompiler_renameProperty\";\n+\n   // TODO(user): Eliminate this class and make all of the static methods\n   // instance methods of com.google.javascript.rhino.Node.\n \n@@ -149,10 +151,18 @@\n   static String getStringValue(Node n) {\n     // TODO(user): Convert constant array, object, and regex literals as well.\n     switch (n.getType()) {\n-      case Token.NAME:\n       case Token.STRING:\n         return n.getString();\n \n+      case Token.NAME:\n+        String name \u003d n.getString();\n+        if (\"undefined\".equals(name)\n+            || \"Infinity\".equals(name)\n+            || \"NaN\".equals(name)) {\n+          return name;\n+        }\n+        break;\n+\n       case Token.NUMBER:\n         double value \u003d n.getDouble();\n         long longValue \u003d (long) value;\n@@ -176,6 +186,128 @@\n   }\n \n   /**\n+   * Gets the value of a node as a Number, or null if it cannot be converted.\n+   * When it returns a non-null Double, this method effectively emulates the\n+   * \u003ccode\u003eNumber()\u003c/code\u003e JavaScript cast function.\n+   */\n+  static Double getNumberValue(Node n) {\n+    switch (n.getType()) {\n+      case Token.TRUE:\n+        return 1.0;\n+\n+      case Token.FALSE:\n+      case Token.NULL:\n+        return 0.0;\n+\n+      case Token.NUMBER:\n+        return n.getDouble();\n+\n+      case Token.VOID:\n+        if (mayHaveSideEffects(n.getFirstChild())) {\n+          return null;\n+        } else {\n+          return Double.NaN;\n+        }\n+\n+      case Token.NAME:\n+        // Check for known constants\n+        String name \u003d n.getString();\n+        if (name.equals(\"undefined\")) {\n+          return Double.NaN;\n+        }\n+        if (name.equals(\"NaN\")) {\n+          return Double.NaN;\n+        }\n+        if (name.equals(\"Infinity\")) {\n+          return Double.POSITIVE_INFINITY;\n+        }\n+        return null;\n+\n+      case Token.NEG:\n+        if (n.getChildCount() \u003d\u003d 1 \u0026\u0026 n.getFirstChild().getType() \u003d\u003d Token.NAME\n+            \u0026\u0026 n.getFirstChild().getString().equals(\"Infinity\")) {\n+          return Double.NEGATIVE_INFINITY;\n+        }\n+        return null;\n+\n+      case Token.STRING:\n+        String s \u003d trimJsWhiteSpace(n.getString());\n+        // return ScriptRuntime.toNumber(s);\n+        if (s.length() \u003d\u003d 0) {\n+          return 0.0;\n+        }\n+\n+        if (s.length() \u003e 2\n+            \u0026\u0026 s.charAt(0) \u003d\u003d \u00270\u0027\n+            \u0026\u0026 (s.charAt(1) \u003d\u003d \u0027x\u0027 || s.charAt(1) \u003d\u003d \u0027X\u0027)) {\n+          // Attempt to convert hex numbers.\n+          try {\n+            return Double.valueOf(Integer.parseInt(s.substring(2), 16));\n+          } catch (NumberFormatException e) {\n+            return Double.NaN;\n+          }\n+        }\n+\n+        if (s.length() \u003e 3\n+            \u0026\u0026 (s.charAt(0) \u003d\u003d \u0027-\u0027 || s.charAt(0) \u003d\u003d \u0027+\u0027)\n+            \u0026\u0026 s.charAt(1) \u003d\u003d \u00270\u0027\n+            \u0026\u0026 (s.charAt(2) \u003d\u003d \u0027x\u0027 || s.charAt(2) \u003d\u003d \u0027X\u0027)) {\n+          // hex numbers with explicit signs vary between browsers.\n+          return null;\n+        }\n+\n+        // FireFox and IE treat the \"Infinity\" differently. FireFox is case\n+        // insensitive, but IE treats \"infinity\" as NaN.  So leave it alone.\n+        if (s.equals(\"infinity\")\n+            || s.equals(\"-infinity\")\n+            || s.equals(\"+infinity\")) {\n+          return null;\n+        }\n+\n+        try {\n+          return Double.parseDouble(s);\n+        } catch (NumberFormatException e) {\n+          return Double.NaN;\n+        }\n+    }\n+\n+    return null;\n+  }\n+\n+  static String trimJsWhiteSpace(String s) {\n+    int start \u003d 0;\n+    int end \u003d s.length();\n+    while (end \u003e 0 \u0026\u0026 isStrWhiteSpaceChar(s.charAt(end-1))) {\n+      end--;\n+    }\n+    while (start \u003c end \u0026\u0026 isStrWhiteSpaceChar(s.charAt(start))) {\n+      start++;\n+    }\n+    return s.substring(start, end);\n+  }\n+\n+  /**\n+   * Copied from Rhino\u0027s ScriptRuntime\n+   */\n+  static boolean isStrWhiteSpaceChar(int c) {\n+    switch (c) {\n+      case \u0027 \u0027: // \u003cSP\u003e\n+      case \u0027\\n\u0027: // \u003cLF\u003e\n+      case \u0027\\r\u0027: // \u003cCR\u003e\n+      case \u0027\\t\u0027: // \u003cTAB\u003e\n+      case \u0027\\u00A0\u0027: // \u003cNBSP\u003e\n+      case \u0027\\u000C\u0027: // \u003cFF\u003e\n+      case \u0027\\u000B\u0027: // \u003cVT\u003e\n+      case \u0027\\u2028\u0027: // \u003cLS\u003e\n+      case \u0027\\u2029\u0027: // \u003cPS\u003e\n+      case \u0027\\uFEFF\u0027: // \u003cBOM\u003e\n+        return true;\n+      default:\n+        return Character.getType(c) \u003d\u003d Character.SPACE_SEPARATOR;\n+    }\n+  }\n+\n+  /**\n    * Gets the function\u0027s name. This method recognizes five forms:\n    * \u003cul\u003e\n    * \u003cli\u003e{@code function name() ...}\u003c/li\u003e\n@@ -211,6 +343,43 @@\n   }\n \n   /**\n+   * Gets the function\u0027s name. This method recognizes the forms:\n+   * \u003cul\u003e\n+   * \u003cli\u003e{@code \u0026#123;\u0027name\u0027: function() ...\u0026#125;}\u003c/li\u003e\n+   * \u003cli\u003e{@code \u0026#123;name: function() ...\u0026#125;}\u003c/li\u003e\n+   * \u003cli\u003e{@code function name() ...}\u003c/li\u003e\n+   * \u003cli\u003e{@code var name \u003d function() ...}\u003c/li\u003e\n+   * \u003cli\u003e{@code qualified.name \u003d function() ...}\u003c/li\u003e\n+   * \u003cli\u003e{@code var name2 \u003d function name1() ...}\u003c/li\u003e\n+   * \u003cli\u003e{@code qualified.name2 \u003d function name1() ...}\u003c/li\u003e\n+   * \u003c/ul\u003e\n+   *\n+   * @param n a node whose type is {@link Token#FUNCTION}\n+   * @return the function\u0027s name, or {@code null} if it has no name\n+   */\n+  static String getNearestFunctionName(Node n) {\n+    String name \u003d getFunctionName(n);\n+    if (name !\u003d null) {\n+      return name;\n+    }\n+\n+    // Check for the form { \u0027x\u0027 : function() { } }\n+    Node parent \u003d n.getParent();\n+    switch (parent.getType()) {\n+      case Token.SET:\n+      case Token.GET:\n+      case Token.STRING:\n+        // Return the name of the literal\u0027s key.\n+        return parent.getString();\n+      case Token.NUMBER:\n+        return getStringValue(parent);\n+    }\n+\n+    return null;\n+  }\n+\n+\n+  /**\n    * Returns true if this is an immutable value.\n    */\n   static boolean isImmutableValue(Node n) {\n@@ -261,7 +430,6 @@\n   static boolean isLiteralValue(Node n, boolean includeFunctions) {\n     switch (n.getType()) {\n       case Token.ARRAYLIT:\n-      case Token.OBJECTLIT:\n       case Token.REGEXP:\n         // Return true only if all children are const.\n         for (Node child \u003d n.getFirstChild(); child !\u003d null;\n@@ -272,6 +440,16 @@\n         }\n         return true;\n \n+      case Token.OBJECTLIT:\n+        // Return true only if all values are const.\n+        for (Node child \u003d n.getFirstChild(); child !\u003d null;\n+             child \u003d child.getNext()) {\n+          if (!isLiteralValue(child.getFirstChild(), includeFunctions)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+\n       case Token.FUNCTION:\n         return includeFunctions \u0026\u0026 !NodeUtil.isFunctionDeclaration(n);\n \n@@ -294,13 +472,34 @@\n       case Token.FALSE:\n         return true;\n \n-      // Single operators are valid if the child is valid.\n+      // Binary operators are only valid if both children are valid.\n+      case Token.ADD:\n       case Token.BITAND:\n       case Token.BITNOT:\n       case Token.BITOR:\n       case Token.BITXOR:\n+      case Token.DIV:\n+      case Token.EQ:\n+      case Token.GE:\n+      case Token.GT:\n+      case Token.LE:\n+      case Token.LSH:\n+      case Token.LT:\n+      case Token.MOD:\n+      case Token.MUL:\n+      case Token.NE:\n+      case Token.RSH:\n+      case Token.SHEQ:\n+      case Token.SHNE:\n+      case Token.SUB:\n+      case Token.URSH:\n+        return isValidDefineValue(val.getFirstChild(), defines)\n+            \u0026\u0026 isValidDefineValue(val.getLastChild(), defines);\n+\n+      // Uniary operators are valid if the child is valid.\n       case Token.NOT:\n       case Token.NEG:\n+      case Token.POS:\n         return isValidDefineValue(val.getFirstChild(), defines);\n \n       // Names are valid if and only if they are defines themselves.\n@@ -331,6 +530,10 @@\n     return true;\n   }\n \n+  static boolean isSimpleOperator(Node n) {\n+    return isSimpleOperatorType(n.getType());\n+  }\n+\n   /**\n    * A \"simple\" operator is one whose children are expressions,\n    * has no direct side-effects (unlike \u0027+\u003d\u0027), and has no\n@@ -447,6 +650,17 @@\n         return true;\n \n       case Token.OBJECTLIT:\n+        if (checkForNewObjects) {\n+          return true;\n+        }\n+        for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n+          if (checkForStateChangeHelper(\n+                  c.getFirstChild(), checkForNewObjects, compiler)) {\n+            return true;\n+          }\n+        }\n+        return false;\n+\n       case Token.ARRAYLIT:\n       case Token.REGEXP:\n         if (checkForNewObjects) {\n@@ -495,6 +709,11 @@\n         }\n \n         if (isAssignmentOp(n)) {\n+          Node assignTarget \u003d n.getFirstChild();\n+          if (isName(assignTarget)) {\n+            return true;\n+          }\n+\n           // Assignments will have side effects if\n           // a) The RHS has side effects, or\n           // b) The LHS has side effects, or\n@@ -506,13 +725,32 @@\n             return true;\n           }\n \n-          Node current \u003d n.getFirstChild();\n-          for (;\n-               current.getType() \u003d\u003d Token.GETPROP ||\n-               current.getType() \u003d\u003d Token.GETELEM;\n-               current \u003d current.getFirstChild()) { }\n+          if (isGet(assignTarget)) {\n+            // If the object being assigned to is a local object, don\u0027t\n+            // consider this a side-effect as it can\u0027t be referenced\n+            // elsewhere.  Don\u0027t do this recursively as the property might\n+            // be an alias of another object, unlike a literal below.\n+            Node current \u003d assignTarget.getFirstChild();\n+            if (evaluatesToLocalValue(current)) {\n+              return false;\n+            }\n \n-          return !isLiteralValue(current, true);\n+            // A literal value as defined by \"isLiteralValue\" is guaranteed\n+            // not to be an alias, or any components which are aliases of\n+            // other objects.\n+            // If the root object is a literal don\u0027t consider this a\n+            // side-effect.\n+            while (isGet(current)) {\n+              current \u003d current.getFirstChild();\n+            }\n+\n+            return !isLiteralValue(current, true);\n+          } else {\n+            // TODO(johnlenz): remove this code and make this an exception. This\n+            // is here only for legacy reasons, the AST is not valid but\n+            // preserve existing behavior.\n+            return !isLiteralValue(assignTarget, true);\n+          }\n         }\n \n         return true;\n@@ -533,9 +771,15 @@\n    * @param callNode - construtor call node\n    */\n   static boolean constructorCallHasSideEffects(Node callNode) {\n-    Preconditions.checkArgument(\n-        callNode.getType() \u003d\u003d Token.NEW,\n-        \"Expected NEW node, got \" + Token.name(callNode.getType()));\n+    return constructorCallHasSideEffects(callNode, null);\n+  }\n+\n+  static boolean constructorCallHasSideEffects(\n+      Node callNode, AbstractCompiler compiler) {\n+    if (callNode.getType() !\u003d Token.NEW) {\n+      throw new IllegalStateException(\n+          \"Expected NEW node, got \" + Token.name(callNode.getType()));\n+    }\n \n     if (callNode.isNoSideEffectsCall()) {\n       return false;\n@@ -550,6 +794,14 @@\n     return true;\n   }\n \n+  // A list of built-in object creation or primitive type cast functions that\n+  // can also be called as constructors but lack side-effects.\n+  // TODO(johnlenz): consider adding an extern annotation for this.\n+  private static final Set\u003cString\u003e BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS \u003d\n+      ImmutableSet.of(\n+          \"Object\", \"Array\", \"String\", \"Number\", \"Boolean\", \"RegExp\", \"Error\");\n+  private static final Set\u003cString\u003e OBJECT_METHODS_WITHOUT_SIDEEFFECTS \u003d\n+      ImmutableSet.of(\"toString\", \"valueOf\");\n   private static final Set\u003cString\u003e REGEXP_METHODS \u003d\n       ImmutableSet.of(\"test\", \"exec\");\n   private static final Set\u003cString\u003e STRING_REGEXP_METHODS \u003d\n@@ -560,8 +812,7 @@\n    *\n    * @param callNode - function call node\n    */\n-  static boolean functionCallHasSideEffects(\n-      Node callNode) {\n+  static boolean functionCallHasSideEffects(Node callNode) {\n     return functionCallHasSideEffects(callNode, null);\n   }\n \n@@ -574,9 +825,10 @@\n    */\n   static boolean functionCallHasSideEffects(\n       Node callNode, @Nullable AbstractCompiler compiler) {\n-    Preconditions.checkArgument(\n-        callNode.getType() \u003d\u003d Token.CALL,\n-        \"Expected CALL node, got \" + Token.name(callNode.getType()));\n+    if (callNode.getType() !\u003d Token.CALL) {\n+      throw new IllegalStateException(\n+          \"Expected CALL node, got \" + Token.name(callNode.getType()));\n+    }\n \n     if (callNode.isNoSideEffectsCall()) {\n       return false;\n@@ -587,10 +839,21 @@\n     // Built-in functions with no side effects.\n     if (nameNode.getType() \u003d\u003d Token.NAME) {\n       String name \u003d nameNode.getString();\n-      if (name.equals(\"String\")) {\n+      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n         return false;\n       }\n     } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n+      if (callNode.hasOneChild()\n+          \u0026\u0026 OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n+                nameNode.getLastChild().getString())) {\n+        return false;\n+      }\n+\n+      if (callNode.isOnlyModifiesThisCall()\n+          \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n+        return false;\n+      }\n+\n       // Functions in the \"Math\" namespace have no side effects.\n       if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n         String namespaceName \u003d nameNode.getFirstChild().getString();\n@@ -619,6 +882,22 @@\n   }\n \n   /**\n+   * @return Whether the call has a local result.\n+   */\n+  static boolean callHasLocalResult(Node n) {\n+    Preconditions.checkState(n.getType() \u003d\u003d Token.CALL);\n+    return (n.getSideEffectFlags() \u0026 Node.FLAG_LOCAL_RESULTS) \u003e 0;\n+  }\n+\n+  /**\n+   * @return Whether the new has a local result.\n+   */\n+  static boolean newHasLocalResult(Node n) {\n+    Preconditions.checkState(n.getType() \u003d\u003d Token.NEW);\n+    return n.isOnlyModifiesThisCall();\n+  }\n+\n+  /**\n    * Returns true if the current node\u0027s type implies side effects.\n    *\n    * This is a non-recursive version of the may have side effects\n@@ -626,18 +905,24 @@\n    * the reason\u0027s why a subtree has side effects.\n    */\n   static boolean nodeTypeMayHaveSideEffects(Node n) {\n+    return nodeTypeMayHaveSideEffects(n, null);\n+  }\n+\n+  static boolean nodeTypeMayHaveSideEffects(Node n, AbstractCompiler compiler) {\n     if (isAssignmentOp(n)) {\n       return true;\n     }\n \n     switch(n.getType()) {\n-      case Token.CALL:\n       case Token.DELPROP:\n-      case Token.NEW:\n       case Token.DEC:\n       case Token.INC:\n       case Token.THROW:\n         return true;\n+      case Token.CALL:\n+        return NodeUtil.functionCallHasSideEffects(n, compiler);\n+      case Token.NEW:\n+        return NodeUtil.constructorCallHasSideEffects(n, compiler);\n       case Token.NAME:\n         // A variable definition.\n         return n.hasChildren();\n@@ -790,9 +1075,99 @@\n   }\n \n   /**\n+   * Returns true if the result of node evaluation is always a number\n+   */\n+  static boolean isNumericResult(Node n) {\n+    switch (n.getType()) {\n+      // NOTE: ADD is deliberately excluded as it may produce\n+      // a string.\n+      case Token.BITNOT:\n+      case Token.BITOR:\n+      case Token.BITXOR:\n+      case Token.BITAND:\n+      case Token.LSH:\n+      case Token.RSH:\n+      case Token.URSH:\n+      case Token.SUB:\n+      case Token.MUL:\n+      case Token.MOD:\n+      case Token.DIV:\n+      case Token.INC:\n+      case Token.DEC:\n+      case Token.POS:\n+      case Token.NEG:\n+      case Token.NUMBER:\n+        return true;\n+      case Token.NAME:\n+        String name \u003d n.getString();\n+        if (name.equals(\"NaN\")) {\n+          return true;\n+        }\n+        if (name.equals(\"Infinity\")) {\n+          return true;\n+        }\n+        return false;\n+      default:\n+        return false;\n+    }\n+  }\n+\n+  /**\n+   * @return Whether the result of node evaluation is always a boolean\n+   */\n+  static boolean isBooleanResult(Node n) {\n+    // TODO(johnlenz): Add a recursive option to recurse into\n+    // AND, OR, HOOK, COMMA and ASSIGN, like \"getExpressionBooleanValue\".\n+    switch (n.getType()) {\n+      // Primitives\n+      case Token.TRUE:\n+      case Token.FALSE:\n+      // Comparisons\n+      case Token.EQ:\n+      case Token.NE:\n+      case Token.SHEQ:\n+      case Token.SHNE:\n+      case Token.LT:\n+      case Token.GT:\n+      case Token.LE:\n+      case Token.GE:\n+      // Queryies\n+      case Token.IN:\n+      case Token.INSTANCEOF:\n+      // Inversion\n+      case Token.NOT:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+\n+  static boolean isUndefined(Node n) {\n+    switch (n.getType()) {\n+      case Token.VOID:\n+        return true;\n+      case Token.NAME:\n+        return n.getString().equals(\"undefined\");\n+    }\n+    return false;\n+  }\n+\n+  static boolean isNull(Node n) {\n+    return n.getType() \u003d\u003d Token.NULL;\n+  }\n+\n+  /**\n+   * @returns Whether the results is possibly a string.\n+   */\n+  static boolean mayBeString(Node n) {\n+    return !isNumericResult(n) \u0026\u0026 !isBooleanResult(n)\n+        \u0026\u0026 !isUndefined(n) \u0026\u0026 !isNull(n);\n+  }\n+\n+  /**\n    * Returns true if the operator is associative.\n    * e.g. (a * b) * c \u003d a * (b * c)\n-   * Note: \"+\" is not associative because it is also the concatentation\n+   * Note: \"+\" is not associative because it is also the concatenation\n    * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n    */\n   static boolean isAssociative(int type) {\n@@ -801,6 +1176,26 @@\n       case Token.AND:\n       case Token.OR:\n       case Token.BITOR:\n+      case Token.BITXOR:\n+      case Token.BITAND:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+\n+  /**\n+   * Returns true if the operator is commutative.\n+   * e.g. (a * b) * c \u003d c * (b * a)\n+   * Note 1: \"+\" is not commutative because it is also the concatenation\n+   * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n+   * Note 2: only operations on literals and pure functions are commutative.\n+   */\n+  static boolean isCommutative(int type) {\n+    switch (type) {\n+      case Token.MUL:\n+      case Token.BITOR:\n+      case Token.BITXOR:\n       case Token.BITAND:\n         return true;\n       default:\n@@ -1016,6 +1411,23 @@\n   }\n \n   /**\n+   * @return Whether the specified node has a loop parent that\n+   * is within the current scope.\n+   */\n+  static boolean isWithinLoop(Node n) {\n+    for (Node parent : n.getAncestors()) {\n+      if (NodeUtil.isLoopStructure(parent)) {\n+        return true;\n+      }\n+\n+      if (NodeUtil.isFunction(parent)) {\n+        break;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n    * Determines whether the given node is a FOR, DO, WHILE, WITH, or IF node.\n    */\n   static boolean isControlStructure(Node n) {\n@@ -1143,12 +1555,40 @@\n         \u0026\u0026 child \u003d\u003d parent.getLastChild();\n   }\n \n+  /** Whether the node is a CATCH container BLOCK. */\n+  static boolean isTryCatchNodeContainer(Node n) {\n+    Node parent \u003d n.getParent();\n+    return parent.getType() \u003d\u003d Token.TRY\n+        \u0026\u0026 parent.getFirstChild().getNext() \u003d\u003d n;\n+  }\n+\n   /** Safely remove children while maintaining a valid node structure. */\n   static void removeChild(Node parent, Node node) {\n-    // Node parent \u003d node.getParent();\n-    if (isStatementBlock(parent)\n-        || isSwitchCase(node)\n-        || isTryFinallyNode(parent, node)) {\n+    if (isTryFinallyNode(parent, node)) {\n+      if (NodeUtil.hasCatchHandler(getCatchBlock(parent))) {\n+        // A finally can only be removed if there is a catch.\n+        parent.removeChild(node);\n+      } else {\n+        // Otherwise only its children can be removed.\n+        node.detachChildren();\n+      }\n+    } else if (node.getType() \u003d\u003d Token.CATCH) {\n+      // The CATCH can can only be removed if there is a finally clause.\n+      Node tryNode \u003d node.getParent().getParent();\n+      Preconditions.checkState(NodeUtil.hasFinally(tryNode));\n+      node.detachFromParent();\n+    } else if (isTryCatchNodeContainer(node)) {\n+      // The container node itself can\u0027t be removed, but the contained CATCH\n+      // can if there is a \u0027finally\u0027 clause\n+      Node tryNode \u003d node.getParent();\n+      Preconditions.checkState(NodeUtil.hasFinally(tryNode));\n+      node.detachChildren();\n+    } else if (node.getType() \u003d\u003d Token.BLOCK) {\n+      // Simply empty the block.  This maintains source location and\n+      // \"synthetic\"-ness.\n+      node.detachChildren();\n+    } else if (isStatementBlock(parent)\n+        || isSwitchCase(node)) {\n       // A statement in a block can simply be removed.\n       parent.removeChild(node);\n     } else if (parent.getType() \u003d\u003d Token.VAR) {\n@@ -1160,10 +1600,6 @@\n         // This would leave an empty VAR, remove the VAR itself.\n         removeChild(parent.getParent(), parent);\n       }\n-    } else if (node.getType() \u003d\u003d Token.BLOCK) {\n-      // Simply empty the block.  This maintains source location and\n-      // \"synthetic\"-ness.\n-      node.detachChildren();\n     } else if (parent.getType() \u003d\u003d Token.LABEL\n         \u0026\u0026 node \u003d\u003d parent.getLastChild()) {\n       // Remove the node from the parent, so it can be reused.\n@@ -1183,6 +1619,17 @@\n   }\n \n   /**\n+   * Add a finally block if one does not exist.\n+   */\n+  static void maybeAddFinally(Node tryNode) {\n+    Preconditions.checkState(tryNode.getType() \u003d\u003d Token.TRY);\n+    if (!NodeUtil.hasFinally(tryNode)) {\n+      tryNode.addChildrenToBack(new Node(Token.BLOCK)\n+          .copyInformationFrom(tryNode));\n+    }\n+  }\n+\n+  /**\n    * Merge a block with its parent block.\n    * @return Whether the block was removed.\n    */\n@@ -1213,6 +1660,14 @@\n   }\n \n   /**\n+   * @param node A node\n+   * @return Whether the call is a NEW or CALL node.\n+   */\n+  static boolean isCallOrNew(Node node) {\n+    return NodeUtil.isCall(node) || NodeUtil.isNew(node);\n+  }\n+\n+  /**\n    * Is this a FUNCTION node?\n    */\n   static boolean isFunction(Node n) {\n@@ -1350,6 +1805,18 @@\n \n   /**\n    * @return Whether the callNode represents an expression in the form of:\n+   *    x.apply(...)\n+   *    x[\u0027apply\u0027](...)\n+   *  or\n+   *    x.call(...)\n+   *    x[\u0027call\u0027](...)\n+   */\n+  static boolean isFunctionObjectCallOrApply(Node callNode) {\n+    return isFunctionObjectCall(callNode) || isFunctionObjectApply(callNode);\n+  }\n+\n+  /**\n+   * @return Whether the callNode represents an expression in the form of:\n    *    x.call(...)\n    *    x[\u0027call\u0027](...)\n    * where x is a NAME node.\n@@ -1386,17 +1853,78 @@\n    * @param parent The node\u0027s parent\n    */\n   static boolean isObjectLitKey(Node node, Node parent) {\n-    if (node.getType() \u003d\u003d Token.STRING \u0026\u0026 parent.getType() \u003d\u003d Token.OBJECTLIT) {\n-      int index \u003d 0;\n-      for (Node current \u003d parent.getFirstChild();\n-           current !\u003d null;\n-           current \u003d current.getNext()) {\n-        if (current \u003d\u003d node) {\n-          return index % 2 \u003d\u003d 0;\n-        }\n-        index++;\n+    switch (node.getType()) {\n+      case Token.NUMBER:\n+      case Token.STRING:\n+        return parent.getType() \u003d\u003d Token.OBJECTLIT;\n+      case Token.GET:\n+      case Token.SET:\n+        return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Get the name of an object literal key.\n+   *\n+   * @param key A node\n+   */\n+  static String getObjectLitKeyName(Node key) {\n+    switch (key.getType()) {\n+      case Token.NUMBER:\n+        return NodeUtil.getStringValue(key);\n+      case Token.STRING:\n+      case Token.GET:\n+      case Token.SET:\n+        return key.getString();\n+    }\n+    throw new IllegalStateException(\"Unexpected node type: \" + key);\n+  }\n+\n+  /**\n+   * @param key A OBJECTLIT key node.\n+   * @return The type expected when using the key.\n+   */\n+  static JSType getObjectLitKeyTypeFromValueType(Node key, JSType valueType) {\n+    if (valueType !\u003d null) {\n+      switch (key.getType()) {\n+        case Token.GET:\n+          // GET must always return a function type.\n+          if (valueType.isFunctionType()) {\n+            FunctionType fntype \u003d ((FunctionType) valueType);\n+            valueType \u003d fntype.getReturnType();\n+          } else {\n+            return null;\n+          }\n+          break;\n+        case Token.SET:\n+          if (valueType.isFunctionType()) {\n+            // SET must always return a function type.\n+            FunctionType fntype \u003d ((FunctionType) valueType);\n+            Node param \u003d fntype.getParametersNode().getFirstChild();\n+            // SET function must always have one parameter.\n+            valueType \u003d param.getJSType();\n+          } else {\n+            return null;\n+          }\n+          break;\n       }\n     }\n+    return valueType;\n+  }\n+\n+  /**\n+   * Determines whether a node represents an object literal get or set key\n+   * (e.g. key1 in {get key1() {}, set key2(a){}).\n+   *\n+   * @param node A node\n+   */\n+  static boolean isGetOrSetKey(Node node) {\n+    switch (node.getType()) {\n+      case Token.GET:\n+      case Token.SET:\n+        return true;\n+    }\n     return false;\n   }\n \n@@ -1572,13 +2100,14 @@\n    * @param charno The source character offset from start of the line.\n    * @return A NAME or GETPROP node\n    */\n-  public static Node newQualifiedNameNode(String name, int lineno, int charno) {\n+  public static Node newQualifiedNameNode(\n+      CodingConvention convention, String name, int lineno, int charno) {\n     int endPos \u003d name.indexOf(\u0027.\u0027);\n     if (endPos \u003d\u003d -1) {\n-      return Node.newString(Token.NAME, name, lineno, charno);\n+      return newName(convention, name, lineno, charno);\n     }\n-    Node node \u003d Node.newString(Token.NAME, name.substring(0, endPos),\n-                               lineno, charno);\n+    Node node \u003d newName(\n+        convention, name.substring(0, endPos), lineno, charno);\n     int startPos;\n     do {\n       startPos \u003d endPos + 1;\n@@ -1586,9 +2115,11 @@\n       String part \u003d (endPos \u003d\u003d -1\n                      ? name.substring(startPos)\n                      : name.substring(startPos, endPos));\n-      node \u003d new Node(Token.GETPROP, node,\n-                      Node.newString(Token.STRING, part, lineno, charno),\n-                      lineno, charno);\n+      Node propNode \u003d Node.newString(Token.STRING, part, lineno, charno);\n+      if (convention.isConstantKey(part)) {\n+        propNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+      }\n+      node \u003d new Node(Token.GETPROP, node, propNode, lineno, charno);\n     } while (endPos !\u003d -1);\n \n     return node;\n@@ -1607,14 +2138,29 @@\n    *\n    * @return A NAME or GETPROP node\n    */\n-  static Node newQualifiedNameNode(String name, Node basisNode,\n+  static Node newQualifiedNameNode(\n+      CodingConvention convention, String name, Node basisNode,\n       String originalName) {\n-    Node node \u003d newQualifiedNameNode(name, -1, -1);\n+    Node node \u003d newQualifiedNameNode(convention, name, -1, -1);\n     setDebugInformation(node, basisNode, originalName);\n     return node;\n   }\n \n   /**\n+   * Gets the root node of a qualified name. Must be either NAME or THIS.\n+   */\n+  static Node getRootOfQualifiedName(Node qName) {\n+    for (Node current \u003d qName; true;\n+         current \u003d current.getFirstChild()) {\n+      int type \u003d current.getType();\n+      if (type \u003d\u003d Token.NAME || type \u003d\u003d Token.THIS) {\n+        return current;\n+      }\n+      Preconditions.checkState(type \u003d\u003d Token.GETPROP);\n+    }\n+  }\n+\n+  /**\n    * Sets the debug information (source file info and orignal name)\n    * on the given node.\n    *\n@@ -1628,6 +2174,15 @@\n     node.putProp(Node.ORIGINALNAME_PROP, originalName);\n   }\n \n+  private static Node newName(\n+      CodingConvention convention, String name, int lineno, int charno) {\n+    Node nameNode \u003d Node.newString(Token.NAME, name, lineno, charno);\n+    if (convention.isConstant(name)) {\n+      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+    }\n+    return nameNode;\n+  }\n+\n   /**\n    * Creates a new node representing an *existing* name, copying over the source\n    * location information from the basis node.\n@@ -1638,8 +2193,12 @@\n    *\n    * @return The node created.\n    */\n-  static Node newName(String name, Node basisNode) {\n+  static Node newName(\n+      CodingConvention convention, String name, Node basisNode) {\n     Node nameNode \u003d Node.newString(Token.NAME, name);\n+    if (convention.isConstantKey(name)) {\n+      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+    }\n     nameNode.copyInformationFrom(basisNode);\n     return nameNode;\n   }\n@@ -1657,8 +2216,10 @@\n    *\n    * @return The node created.\n    */\n-  static Node newName(String name, Node basisNode, String originalName) {\n-    Node nameNode \u003d newName(name, basisNode);\n+  static Node newName(\n+      CodingConvention convention, String name,\n+      Node basisNode, String originalName) {\n+    Node nameNode \u003d newName(convention, name, basisNode);\n     nameNode.putProp(Node.ORIGINALNAME_PROP, originalName);\n     return nameNode;\n   }\n@@ -2017,9 +2578,9 @@\n     * @return The Node containing the Function parameters.\n     */\n   static Node getFnParameters(Node fnNode) {\n-   // Function NODE: [ FUNCTION -\u003e NAME, LP -\u003e ARG1, ARG2, ... ]\n-   Preconditions.checkArgument(fnNode.getType() \u003d\u003d Token.FUNCTION);\n-   return fnNode.getFirstChild().getNext();\n+    // Function NODE: [ FUNCTION -\u003e NAME, LP -\u003e ARG1, ARG2, ... ]\n+    Preconditions.checkArgument(fnNode.getType() \u003d\u003d Token.FUNCTION);\n+    return fnNode.getFirstChild().getNext();\n   }\n \n   /**\n@@ -2122,4 +2683,125 @@\n     }\n     return call;\n   }\n+\n+  /**\n+   * @return Whether the node is known to be a value that is not referenced\n+   * elsewhere.\n+   */\n+  static boolean evaluatesToLocalValue(Node value) {\n+    return evaluatesToLocalValue(value, Predicates.\u003cNode\u003ealwaysFalse());\n+  }\n+\n+  /**\n+   * @param locals A predicate to apply to unknown local values.\n+   * @return Whether the node is known to be a value that is not a reference\n+   *     outside the expression scope.\n+   */\n+  static boolean evaluatesToLocalValue(Node value, Predicate\u003cNode\u003e locals) {\n+    switch (value.getType()) {\n+      case Token.ASSIGN:\n+        // A result that is aliased by a non-local name, is the effectively the\n+        // same as returning a non-local name, but this doesn\u0027t matter if the\n+        // value is immutable.\n+        return NodeUtil.isImmutableValue(value.getLastChild())\n+            || (locals.apply(value)\n+                \u0026\u0026 evaluatesToLocalValue(value.getLastChild(), locals));\n+      case Token.COMMA:\n+        return evaluatesToLocalValue(value.getLastChild(), locals);\n+      case Token.AND:\n+      case Token.OR:\n+        return evaluatesToLocalValue(value.getFirstChild(), locals)\n+           \u0026\u0026 evaluatesToLocalValue(value.getLastChild(), locals);\n+      case Token.HOOK:\n+        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n+           \u0026\u0026 evaluatesToLocalValue(value.getLastChild(), locals);\n+      case Token.INC:\n+      case Token.DEC:\n+        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n+          return evaluatesToLocalValue(value.getFirstChild(), locals);\n+        } else {\n+          return true;\n+        }\n+      case Token.THIS:\n+        return locals.apply(value);\n+      case Token.NAME:\n+        return isImmutableValue(value) || locals.apply(value);\n+      case Token.GETELEM:\n+      case Token.GETPROP:\n+        // There is no information about the locality of object properties.\n+        return locals.apply(value);\n+      case Token.CALL:\n+        return callHasLocalResult(value)\n+            || isToStringMethodCall(value)\n+            || locals.apply(value);\n+      case Token.NEW:\n+        return newHasLocalResult(value)\n+               || locals.apply(value);\n+      case Token.FUNCTION:\n+      case Token.REGEXP:\n+      case Token.ARRAYLIT:\n+      case Token.OBJECTLIT:\n+        // Literals objects with non-literal children are allowed.\n+        return true;\n+      case Token.IN:\n+        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n+        return true;\n+      default:\n+        // Other op force a local value:\n+        //  x \u003d \u0027\u0027 + g (x is now an local string)\n+        //  x -\u003d g (x is now an local number)\n+        if (isAssignmentOp(value)\n+            || isSimpleOperator(value)\n+            || isImmutableValue(value)) {\n+          return true;\n+        }\n+\n+        throw new IllegalStateException(\n+            \"Unexpected expression node\" + value +\n+            \"\\n parent:\" + value.getParent());\n+    }\n+  }\n+\n+  /**\n+   * Given the first sibling, this returns the nth\n+   * sibling or null if no such sibling exists.\n+   * This is like \"getChildAtIndex\" but returns null for non-existent indexes.\n+   */\n+  private static Node getNthSibling(Node first, int index) {\n+    Node sibling \u003d first;\n+    while (index !\u003d 0 \u0026\u0026 sibling !\u003d null) {\n+      sibling \u003d sibling.getNext();\n+      index--;\n+    }\n+    return sibling;\n+  }\n+\n+  /**\n+   * Given the function, this returns the nth\n+   * argument or null if no such parameter exists.\n+   */\n+  static Node getArgumentForFunction(Node function, int index) {\n+    Preconditions.checkState(isFunction(function));\n+    return getNthSibling(\n+        function.getFirstChild().getNext().getFirstChild(), index);\n+  }\n+\n+  /**\n+   * Given the new or call, this returns the nth\n+   * argument of the call or null if no such argument exists.\n+   */\n+  static Node getArgumentForCallOrNew(Node call, int index) {\n+    Preconditions.checkState(isCallOrNew(call));\n+    return getNthSibling(\n+      call.getFirstChild().getNext(), index);\n+  }\n+\n+  private static boolean isToStringMethodCall(Node call) {\n+    Node getNode \u003d call.getFirstChild();\n+    if (isGet(getNode)) {\n+      Node propNode \u003d getNode.getLastChild();\n+      return isString(propNode) \u0026\u0026 \"toString\".equals(propNode.getString());\n+    }\n+    return false;\n+  }\n }\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [1044,1099]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [1100,1149]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [54167,54575]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [54579,55590]"
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/TypeCheck.java",
        "src/com/google/javascript/jscomp/TypeCheck.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.TypeCheck:hasUnknownOrEmptySupertype:[FunctionType ctor]:boolean",
            "com.google.javascript.jscomp.TypeCheck:visitGetProp:[NodeTraversal t, Node n, Node parent]:void",
            "com.google.javascript.jscomp.TypeCheck:visitAssign:[NodeTraversal t, Node assign]:void",
            "com.google.javascript.jscomp.TypeCheck:checkDeclaredPropertyInheritance:[NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType]:void",
            "com.google.javascript.jscomp.TypeCheck:visit:[NodeTraversal t, Node n, Node parent]:void",
            "com.google.javascript.jscomp.TypeCheck:visitBinaryOperator:[int op, NodeTraversal t, Node n]:void",
            "com.google.javascript.jscomp.TypeCheck:visitCall:[NodeTraversal t, Node n]:void"
          ],
          "num": 7
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.TypeCheck:visitObjLitKey:[NodeTraversal t, Node key, Node objlit]:void",
            "com.google.javascript.jscomp.TypeCheck:visitGetProp:[NodeTraversal t, Node n, Node parent]:void",
            "com.google.javascript.jscomp.TypeCheck:checkEnumInitializer:[NodeTraversal t, Node value, JSType primitiveType]:void",
            "com.google.javascript.jscomp.TypeCheck:checkDeclaredPropertyInheritance:[NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType]:void",
            "com.google.javascript.jscomp.TypeCheck:propertyIsImplicitCast:[ObjectType type, String prop]:boolean",
            "com.google.javascript.jscomp.TypeCheck:visitParameterList:[NodeTraversal t, Node call, FunctionType functionType]:void",
            "com.google.javascript.jscomp.TypeCheck:visit:[NodeTraversal t, Node n, Node parent]:void",
            "com.google.javascript.jscomp.TypeCheck:visitInterfaceGetprop:[NodeTraversal t, Node assign, Node object, String property, Node lvalue, Node rvalue]:void",
            "com.google.javascript.jscomp.TypeCheck:hasUnknownOrEmptySupertype:[FunctionType ctor]:boolean"
          ],
          "num": 9
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "2",
            "51",
            "52",
            "53",
            "252",
            "493",
            "495",
            "496",
            "504",
            "505",
            "506",
            "507",
            "508",
            "509",
            "510",
            "511",
            "643",
            "647",
            "774",
            "927",
            "950",
            "951",
            "952",
            "953",
            "954",
            "955",
            "967",
            "983",
            "984",
            "985",
            "986",
            "1038",
            "1157",
            "1158",
            "1406",
            "1407",
            "1408",
            "1556",
            "1557",
            "1558",
            "1559",
            "1560",
            "1561",
            "1562",
            "1564",
            "1565",
            "1566"
          ],
          "num": 47
        },
        {
          "qualified_names": [
            "2",
            "50",
            "249",
            "250",
            "251",
            "252",
            "253",
            "254",
            "495",
            "496",
            "501",
            "502",
            "503",
            "504",
            "505",
            "506",
            "507",
            "508",
            "509",
            "510",
            "511",
            "512",
            "648",
            "652",
            "780",
            "781",
            "782",
            "783",
            "784",
            "938",
            "939",
            "940",
            "941",
            "942",
            "943",
            "944",
            "945",
            "946",
            "947",
            "948",
            "949",
            "950",
            "951",
            "952",
            "953",
            "954",
            "955",
            "956",
            "957",
            "958",
            "959",
            "960",
            "961",
            "962",
            "963",
            "964",
            "965",
            "966",
            "967",
            "968",
            "969",
            "970",
            "971",
            "972",
            "973",
            "974",
            "975",
            "976",
            "977",
            "978",
            "979",
            "980",
            "981",
            "982",
            "983",
            "984",
            "985",
            "986",
            "987",
            "988",
            "989",
            "990",
            "991",
            "992",
            "993",
            "994",
            "995",
            "1018",
            "1019",
            "1020",
            "1032",
            "1033",
            "1038",
            "1050",
            "1103",
            "1104",
            "1105",
            "1106",
            "1107",
            "1108",
            "1109",
            "1110",
            "1111",
            "1112",
            "1113",
            "1114",
            "1115",
            "1116",
            "1117",
            "1118",
            "1119",
            "1120",
            "1121",
            "1122",
            "1123",
            "1124",
            "1125",
            "1126",
            "1127",
            "1128",
            "1129",
            "1130",
            "1249",
            "1250",
            "1498",
            "1499",
            "1500",
            "1501",
            "1502",
            "1503",
            "1504",
            "1505",
            "1506",
            "1507",
            "1508",
            "1656",
            "1657",
            "1658",
            "1660",
            "1661",
            "1662",
            "1663"
          ],
          "num": 142
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex 8198efc..5760f79 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2006 Google Inc.\n+ * Copyright 2006 The Closure Compiler Authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -48,9 +48,6 @@\n  * \u003cp\u003eChecks the types of JS expressions against any declared type\n  * information.\u003c/p\u003e\n  *\n- *\n- *\n- * @author nicksantos@google.com (Nick Santos)\n  */\n public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n@@ -249,7 +246,12 @@\n       UNKNOWN_EXPR_TYPE,\n       UNRESOLVED_TYPE,\n       WRONG_ARGUMENT_COUNT,\n-      ILLEGAL_IMPLICIT_CAST);\n+      ILLEGAL_IMPLICIT_CAST,\n+      TypedScopeCreator.UNKNOWN_LENDS,\n+      TypedScopeCreator.LENDS_ON_NON_OBJECT,\n+      TypedScopeCreator.CTOR_INITIALIZER,\n+      TypedScopeCreator.IFACE_INITIALIZER,\n+      FunctionTypeBuilder.THIS_TYPE_NON_OBJECT);\n \n   private final AbstractCompiler compiler;\n   private final TypeValidator validator;\n@@ -490,25 +492,28 @@\n         break;\n \n       case Token.NUMBER:\n-        if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n+        // Object literal keys are handled with OBJECTLIT\n+        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n           ensureTyped(t, n, NUMBER_TYPE);\n-        } else {\n-          typeable \u003d false;\n         }\n         break;\n \n+      case Token.STRING:\n+        // Object literal keys are handled with OBJECTLIT\n+        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n+          ensureTyped(t, n, STRING_TYPE);\n+        }\n+        break;\n+\n+      case Token.GET:\n+      case Token.SET:\n+        // Object literal keys are handled with OBJECTLIT\n+        break;\n+\n       case Token.ARRAYLIT:\n         ensureTyped(t, n, ARRAY_TYPE);\n         break;\n \n-      case Token.STRING:\n-        if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n-          ensureTyped(t, n, STRING_TYPE);\n-        } else {\n-          typeable \u003d false;\n-        }\n-        break;\n-\n       case Token.REGEXP:\n         ensureTyped(t, n, REGEXP_TYPE);\n         break;\n@@ -640,11 +645,11 @@\n           // should match a string context.\n           String message \u003d \"left side of comparison\";\n           validator.expectString(t, n, leftType, message);\n-          validator.expectNotVoid(\n+          validator.expectNotNullOrUndefined(\n               t, n, leftType, message, getNativeType(STRING_TYPE));\n           message \u003d \"right side of comparison\";\n           validator.expectString(t, n, rightType, message);\n-          validator.expectNotVoid(\n+          validator.expectNotNullOrUndefined(\n               t, n, rightType, message, getNativeType(STRING_TYPE));\n         }\n         ensureTyped(t, n, BOOLEAN_TYPE);\n@@ -772,6 +777,11 @@\n             ensureTyped(t, n);\n           }\n         }\n+        if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n+          for (Node key : n.children()) {\n+            visitObjLitKey(t, key, n);\n+          }\n+        }\n         break;\n \n       default:\n@@ -925,6 +935,64 @@\n   }\n \n   /**\n+   * Visits an object literal field definition \u003ccode\u003ekey : value\u003c/code\u003e.\n+   *\n+   * If the \u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the\n+   * schema of the object type it is referring to.\n+   *\n+   * @param t the traversal\n+   * @param key the assign node\n+   */\n+  private void visitObjLitKey(NodeTraversal t, Node key, Node objlit) {\n+    // TODO(johnlenz): Validate get and set function declarations are valid\n+    // as is the functions can have \"extraneous\" bits.\n+\n+    // For getter and setter property definitions the\n+    // rvalue type !\u003d the property type.\n+    Node rvalue \u003d key.getFirstChild();\n+    JSType rightType \u003d NodeUtil.getObjectLitKeyTypeFromValueType(\n+        key, getJSType(rvalue));\n+    if (rightType \u003d\u003d null) {\n+      rightType \u003d getNativeType(UNKNOWN_TYPE);\n+    }\n+\n+    Node owner \u003d objlit;\n+\n+    // Validate value is assignable to the key type.\n+\n+    JSType keyType \u003d getJSType(key);\n+    boolean valid \u003d validator.expectCanAssignToPropertyOf(t, key,\n+        rightType, keyType,\n+        owner, NodeUtil.getObjectLitKeyName(key));\n+    if (valid) {\n+      ensureTyped(t, key, rightType);\n+    } else {\n+      ensureTyped(t, key);\n+    }\n+\n+    // Validate that the key type is assignable to the object property type.\n+    // This is necessary as the objlit may have been cast to a non-literal\n+    // object type.\n+    // TODO(johnlenz): consider introducing a CAST node to the AST (or\n+    // perhaps a parentheses node).\n+\n+    JSType objlitType \u003d getJSType(objlit);\n+    ObjectType type \u003d ObjectType.cast(\n+        objlitType.restrictByNotNullOrUndefined());\n+    if (type !\u003d null) {\n+      String property \u003d NodeUtil.getObjectLitKeyName(key);\n+      if (type.hasProperty(property) \u0026\u0026\n+          !type.isPropertyTypeInferred(property) \u0026\u0026\n+          !propertyIsImplicitCast(type, property)) {\n+        validator.expectCanAssignToPropertyOf(\n+            t, key, keyType,\n+            type.getPropertyType(property), owner, property);\n+      }\n+      return;\n+    }\n+  }\n+\n+  /**\n    * Returns true if any type in the chain has an implictCast annotation for\n    * the given property.\n    */\n@@ -947,12 +1015,9 @@\n   private void checkDeclaredPropertyInheritance(\n       NodeTraversal t, Node n, FunctionType ctorType, String propertyName,\n       JSDocInfo info, JSType propertyType) {\n-    // TODO(user): We\u0027re not 100% confident that type-checking works,\n-    // so we return quietly if the unknown type is a superclass of this type.\n-    // Remove this check as we become more confident. We should flag a warning\n-    // when the unknown type is on the inheritance chain, as it is likely\n-    // because of a programmer error.\n-    if (ctorType.hasUnknownSupertype()) {\n+    // If the supertype doesn\u0027t resolve correctly, we\u0027ve warned about this\n+    // already.\n+    if (hasUnknownOrEmptySupertype(ctorType)) {\n       return;\n     }\n \n@@ -964,11 +1029,13 @@\n     boolean foundInterfaceProperty \u003d false;\n     if (ctorType.isConstructor()) {\n       for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n-        if (implementedInterface.isUnknownType()) {\n+        if (implementedInterface.isUnknownType() ||\n+            implementedInterface.isEmptyType()) {\n           continue;\n         }\n         FunctionType interfaceType \u003d\n             implementedInterface.toObjectType().getConstructor();\n+        Preconditions.checkNotNull(interfaceType);\n         boolean interfaceHasProperty \u003d\n             interfaceType.getPrototype().hasProperty(propertyName);\n         foundInterfaceProperty \u003d foundInterfaceProperty || interfaceHasProperty;\n@@ -980,10 +1047,7 @@\n               HIDDEN_INTERFACE_PROPERTY, propertyName,\n               interfaceType.getTopMostDefiningType(propertyName).toString()));\n         }\n-        if (!declaredOverride) {\n-          continue;\n-        }\n-        // @override is present and we have to check that it is ok\n+        // Check that it is ok\n         if (interfaceHasProperty) {\n           JSType interfacePropType \u003d\n               interfaceType.getPrototype().getPropertyType(propertyName);\n@@ -1036,6 +1100,34 @@\n   }\n \n   /**\n+   * Given a constructor or an interface type, find out whether the unknown\n+   * type is a supertype of the current type.\n+   */\n+  private static boolean hasUnknownOrEmptySupertype(FunctionType ctor) {\n+    Preconditions.checkArgument(ctor.isConstructor() || ctor.isInterface());\n+    Preconditions.checkArgument(!ctor.isUnknownType());\n+\n+    // The type system should notice inheritance cycles on its own\n+    // and break the cycle.\n+    while (true) {\n+      ObjectType maybeSuperInstanceType \u003d\n+          ctor.getPrototype().getImplicitPrototype();\n+      if (maybeSuperInstanceType \u003d\u003d null) {\n+        return false;\n+      }\n+      if (maybeSuperInstanceType.isUnknownType() ||\n+          maybeSuperInstanceType.isEmptyType()) {\n+        return true;\n+      }\n+      ctor \u003d maybeSuperInstanceType.getConstructor();\n+      if (ctor \u003d\u003d null) {\n+        return false;\n+      }\n+      Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());\n+    }\n+  }\n+\n+  /**\n    * Visits an ASSIGN node for cases such as\n    * \u003cpre\u003e\n    * interface.property2.property \u003d ...;\n@@ -1154,8 +1246,8 @@\n \n     // TODO(user): remove in favor of flagging every property access on\n     // non-object.\n-    if (!validator.expectNotVoid(t, n, childType,\n-            \"undefined has no properties\", getNativeType(OBJECT_TYPE))) {\n+    if (!validator.expectNotNullOrUndefined(t, n, childType,\n+            childType + \" has no properties\", getNativeType(OBJECT_TYPE))) {\n       ensureTyped(t, n);\n       return;\n     }\n@@ -1403,9 +1495,17 @@\n \n     Iterator\u003cNode\u003e parameters \u003d functionType.getParameters().iterator();\n     int ordinal \u003d 0;\n-    while (arguments.hasNext() \u0026\u0026 parameters.hasNext()) {\n-      Node parameter \u003d parameters.next();\n-      Node argument \u003d arguments.next();\n+    Node parameter \u003d null;\n+    Node argument \u003d null;\n+    while (arguments.hasNext() \u0026\u0026\n+           (parameters.hasNext() ||\n+            parameter !\u003d null \u0026\u0026 parameter.isVarArgs())) {\n+      // If there are no parameters left in the list, then the while loop\n+      // above implies that this must be a var_args function.\n+      if (parameters.hasNext()) {\n+        parameter \u003d parameters.next();\n+      }\n+      argument \u003d arguments.next();\n       ordinal++;\n \n       validator.expectArgumentMatchesParameter(t, argument,\n@@ -1553,17 +1653,14 @@\n   private void checkEnumInitializer(\n       NodeTraversal t, Node value, JSType primitiveType) {\n     if (value.getType() \u003d\u003d Token.OBJECTLIT) {\n-      // re-using value as the value of the object literal and advancing twice\n-      value \u003d value.getFirstChild();\n-      value \u003d (value \u003d\u003d null) ? null : value.getNext();\n-      while (value !\u003d null) {\n-        // the value\u0027s type must be assignable to the enum\u0027s primitive type\n-        validator.expectCanAssignTo(t, value, getJSType(value), primitiveType,\n-            \"element type must match enum\u0027s type\");\n+      for (Node key \u003d value.getFirstChild();\n+           key !\u003d null; key \u003d key.getNext()) {\n+        Node propValue \u003d key.getFirstChild();\n \n-        // advancing twice\n-        value \u003d value.getNext();\n-        value \u003d (value \u003d\u003d null) ? null : value.getNext();\n+        // the value\u0027s type must be assignable to the enum\u0027s primitive type\n+        validator.expectCanAssignTo(\n+            t, propValue, getJSType(propValue), primitiveType,\n+            \"element type must match enum\u0027s type\");\n       }\n     } else if (value.getJSType() instanceof EnumType) {\n       // TODO(user): Remove the instanceof check in favor\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [31138,33112]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [17391,17492]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [17600,17701]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SwitchCase [17724,17739]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SwitchCase [17746,17761]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [18447,18464]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "BreakStatement [19830,19836]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [25403,25420]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "PrefixExpression [17395,17437]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "PrefixExpression [17604,17646]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "EnhancedForStatement [26074,26156]"
        },
        {
          "type": "delete-tree",
          "from": "InfixExpression [17615,17657]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "IfStatement [17611,17757]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [24547,24564]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Block [24366,24587]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [25080,25097]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [25259,25276]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "METHOD_INVOCATION_RECEIVER [17337,17350]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "MethodInvocation [17337,17360]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [17730,17747]",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/TypeInference.java",
        "src/com/google/javascript/jscomp/TypeInference.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.TypeInference:traverseObjectLiteral:[Node n, FlowScope scope]:FlowScope",
            "com.google.javascript.jscomp.TypeInference:branchedFlowThrough:[Node source, FlowScope input]:List\u003cFlowScope\u003e",
            "com.google.javascript.jscomp.TypeInference:updateTypeOfParametersOnClosure:[Node n, FunctionType fnType]:void",
            "com.google.javascript.jscomp.TypeInference:traverse:[Node n, FlowScope scope]:FlowScope",
            "com.google.javascript.jscomp.TypeInference:ensurePropertyDeclaredHelper:[Node getprop, ObjectType objectType]:boolean",
            "com.google.javascript.jscomp.TypeInference:updateTypeOfThisOnClosure:[Node n, FunctionType fnType]:void",
            "com.google.javascript.jscomp.TypeInference:ensurePropertyDefined:[Node getprop, JSType rightType]:void"
          ],
          "num": 7
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.TypeInference:ensurePropertyDefined:[Node getprop, JSType rightType]:void",
            "com.google.javascript.jscomp.TypeInference:traverseObjectLiteral:[Node n, FlowScope scope]:FlowScope",
            "com.google.javascript.jscomp.TypeInference:branchedFlowThrough:[Node source, FlowScope input]:List\u003cFlowScope\u003e",
            "com.google.javascript.jscomp.TypeInference:traverse:[Node n, FlowScope scope]:FlowScope",
            "com.google.javascript.jscomp.TypeInference:ensurePropertyDeclaredHelper:[Node getprop, ObjectType objectType]:boolean",
            "com.google.javascript.jscomp.TypeInference:updateTypeOfThisOnClosure:[Node n, FunctionType fnType]:void",
            "com.google.javascript.jscomp.TypeInference:updateTypeOfParametersOnClosure:[Node n, FunctionType fnType]:void"
          ],
          "num": 7
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "2",
            "26",
            "63",
            "77",
            "212",
            "213",
            "214",
            "215",
            "336",
            "337",
            "338",
            "339",
            "340",
            "341",
            "342",
            "343",
            "348",
            "349",
            "350",
            "351",
            "352",
            "353",
            "354",
            "355",
            "383",
            "399",
            "416",
            "417",
            "575",
            "577",
            "582",
            "624",
            "680",
            "681",
            "682",
            "683",
            "686",
            "688",
            "689",
            "690",
            "692",
            "694",
            "695",
            "696",
            "697",
            "700",
            "703",
            "866",
            "890",
            "891",
            "894",
            "895",
            "896",
            "897",
            "898",
            "899",
            "900",
            "901",
            "905",
            "909",
            "910",
            "911",
            "912",
            "913",
            "914",
            "915",
            "916",
            "917",
            "918",
            "919",
            "920",
            "921",
            "922",
            "923",
            "924",
            "925",
            "926",
            "929",
            "938",
            "939",
            "942",
            "945",
            "946",
            "947",
            "948",
            "949",
            "950"
          ],
          "num": 87
        },
        {
          "qualified_names": [
            "2",
            "25",
            "63",
            "76",
            "77",
            "78",
            "79",
            "80",
            "81",
            "82",
            "83",
            "84",
            "85",
            "216",
            "217",
            "218",
            "219",
            "224",
            "225",
            "226",
            "227",
            "228",
            "229",
            "230",
            "231",
            "232",
            "233",
            "234",
            "235",
            "237",
            "314",
            "377",
            "394",
            "412",
            "576",
            "578",
            "583",
            "625",
            "681",
            "682",
            "683",
            "684",
            "685",
            "686",
            "687",
            "688",
            "689",
            "690",
            "691",
            "694",
            "695",
            "696",
            "697",
            "698",
            "699",
            "700",
            "702",
            "703",
            "705",
            "707",
            "708",
            "709",
            "710",
            "711",
            "712",
            "713",
            "880",
            "904",
            "905",
            "908",
            "909",
            "910",
            "911",
            "915",
            "918",
            "920",
            "921",
            "922",
            "923",
            "924",
            "925",
            "926",
            "927",
            "928",
            "929",
            "930",
            "931",
            "932",
            "933",
            "934",
            "935",
            "936",
            "937",
            "938",
            "939",
            "940",
            "941",
            "944",
            "952",
            "953",
            "954",
            "955",
            "956",
            "957",
            "958",
            "959",
            "960",
            "961",
            "962",
            "963",
            "964",
            "967",
            "968",
            "971",
            "972",
            "974",
            "975",
            "976",
            "977"
          ],
          "num": 119
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 5ab5b09..9f776c6 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2008 Google Inc.\n+ * Copyright 2008 The Closure Compiler Authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,7 +23,6 @@\n import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n@@ -60,7 +59,6 @@\n  * Type inference within a script node or a function body, using the data-flow\n  * analysis framework.\n  *\n- *\n  */\n class TypeInference\n     extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis\u003cNode, FlowScope\u003e {\n@@ -75,6 +73,16 @@\n       \"A function type with the template type as the type of this must be a \" +\n       \"parameter type\");\n \n+  static final DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS \u003d\n+    DiagnosticType.warning(\n+        \"JSC_FUNCTION_LITERAL_UNDEFINED_THIS\",\n+        \"Function literal argument refers to undefined this argument\");\n+\n+  static final DiagnosticType FUNCTION_LITERAL_UNREAD_THIS \u003d\n+    DiagnosticType.warning(\n+        \"JSC_FUNCTION_LITERAL_UNREAD_THIS\",\n+        \"Function literal argument does not refer to bound this argument\");\n+\n   private final AbstractCompiler compiler;\n   private final JSTypeRegistry registry;\n   private final ReverseAbstractInterpreter reverseInterpreter;\n@@ -205,15 +213,28 @@\n           if (NodeUtil.isForIn(source)) {\n             // item is assigned a property name, so its type should be string.\n             Node item \u003d source.getFirstChild();\n+            Node obj \u003d item.getNext();\n+\n+            FlowScope informed \u003d traverse(obj, output.createChildFlowScope());\n+\n             if (item.getType() \u003d\u003d Token.VAR) {\n               item \u003d item.getFirstChild();\n             }\n             if (item.getType() \u003d\u003d Token.NAME) {\n-              FlowScope informed \u003d output.createChildFlowScope();\n-              redeclare(informed, item.getString(),\n-                  getNativeType(STRING_TYPE));\n-              newScope \u003d informed;\n+              JSType iterKeyType \u003d getNativeType(STRING_TYPE);\n+              ObjectType objType \u003d getJSType(obj).dereference();\n+              JSType objIndexType \u003d objType \u003d\u003d null ?\n+                  null : objType.getIndexType();\n+              if (objIndexType !\u003d null \u0026\u0026 !objIndexType.isUnknownType()) {\n+                JSType narrowedKeyType \u003d\n+                    iterKeyType.getGreatestSubtype(objIndexType);\n+                if (!narrowedKeyType.isEmptyType()) {\n+                  iterKeyType \u003d narrowedKeyType;\n+                }\n+              }\n+              redeclare(informed, item.getString(), iterKeyType);\n             }\n+            newScope \u003d informed;\n             break;\n           }\n \n@@ -333,26 +354,10 @@\n         n.setJSType(getNativeType(NUMBER_TYPE));\n         break;\n \n-      case Token.NULL:\n-        n.setJSType(getNativeType(NULL_TYPE));\n-        break;\n-\n-      case Token.VOID:\n-        n.setJSType(getNativeType(VOID_TYPE));\n-        break;\n-\n       case Token.ARRAYLIT:\n         scope \u003d traverseArrayLiteral(n, scope);\n         break;\n \n-      case Token.REF_SPECIAL:\n-        n.setJSType(getNativeType(UNKNOWN_TYPE));\n-        break;\n-\n-      case Token.REGEXP:\n-        n.setJSType(getNativeType(REGEXP_TYPE));\n-        break;\n-\n       case Token.THIS:\n         n.setJSType(scope.getTypeOfThis());\n         break;\n@@ -380,7 +385,6 @@\n       case Token.DEC:\n       case Token.INC:\n       case Token.BITNOT:\n-      case Token.NUMBER:\n         scope \u003d traverseChildren(n, scope);\n         n.setJSType(getNativeType(NUMBER_TYPE));\n         break;\n@@ -396,7 +400,6 @@\n         n.setJSType(getJSType(n.getLastChild()));\n         break;\n \n-      case Token.STRING:\n       case Token.TYPEOF:\n         scope \u003d traverseChildren(n, scope);\n         n.setJSType(getNativeType(STRING_TYPE));\n@@ -413,8 +416,6 @@\n       case Token.SHNE:\n       case Token.INSTANCEOF:\n       case Token.IN:\n-      case Token.TRUE:\n-      case Token.FALSE:\n         scope \u003d traverseChildren(n, scope);\n         n.setJSType(getNativeType(BOOLEAN_TYPE));\n         break;\n@@ -572,14 +573,14 @@\n         if (objectType.hasProperty(propName) ||\n             !objectType.isInstanceType()) {\n           if (\"prototype\".equals(propName)) {\n-            objectType.defineDeclaredProperty(propName, rightType, false);\n+            objectType.defineDeclaredProperty(propName, rightType, false, getprop);\n           } else {\n-            objectType.defineInferredProperty(propName, rightType, false);\n+            objectType.defineInferredProperty(propName, rightType, false, getprop);\n           }\n         } else {\n           if (getprop.getFirstChild().getType() \u003d\u003d Token.THIS \u0026\u0026\n               getJSType(syntacticScope.getRootNode()).isConstructor()) {\n-            objectType.defineInferredProperty(propName, rightType, false);\n+            objectType.defineInferredProperty(propName, rightType, false, getprop);\n           } else {\n             registry.registerPropertyOnType(propName, objectType);\n           }\n@@ -621,7 +622,7 @@\n              (!objectType.isInstanceType() ||\n                  (var.isExtern() \u0026\u0026 !objectType.isNativeObjectType())))) {\n           return objectType.defineDeclaredProperty(\n-              propName, var.getType(), var.isExtern());\n+              propName, var.getType(), var.isExtern(), getprop);\n         }\n       }\n     }\n@@ -677,30 +678,43 @@\n   }\n \n   private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n-    if (n.getJSType() !\u003d null) {\n-      // The node has already been traversed by the data-flow analysis\n-      // framework. Don\u0027t re-generate the anonymous object as it might lead to\n-      // pernicious bugs.\n+    JSType type \u003d n.getJSType();\n+    Preconditions.checkNotNull(type);\n+\n+    // Object literals can be reflected on other types, or changed with\n+    // type casts.\n+    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n+    // Ignore these types of literals.\n+    // TODO(nicksantos): There should be an \"anonymous object\" type that\n+    // we can check for here.\n+    ObjectType objectType \u003d ObjectType.cast(type);\n+    if (objectType \u003d\u003d null) {\n       return scope;\n     }\n-    ObjectType objectType \u003d registry.createAnonymousObjectType();\n+\n+    boolean hasLendsName \u003d n.getJSDocInfo() !\u003d null \u0026\u0026\n+        n.getJSDocInfo().getLendsName() !\u003d null;\n+    if (objectType.hasReferenceName() \u0026\u0026 !hasLendsName) {\n+      return scope;\n+    }\n+\n     for (Node name \u003d n.getFirstChild(); name !\u003d null;\n-         name \u003d name.getNext().getNext()) {\n-      Node value \u003d name.getNext();\n-      scope \u003d traverse(name, scope);\n+         name \u003d name.getNext()) {\n+      Node value \u003d name.getFirstChild();\n       scope \u003d traverse(value, scope);\n-      String memberName \u003d NodeUtil.getStringValue(name);\n+      String memberName \u003d NodeUtil.getObjectLitKeyName(name);\n       if (memberName !\u003d null) {\n-        // TODO(nicksantos): We need to fix the parser so that we can\n-        // attach JSDoc to the individual elements of object literals.\n-        // Right now, this is not possible.\n-        objectType.defineInferredProperty(memberName, getJSType(value), false);\n+        JSType rawValueType \u003d  name.getFirstChild().getJSType();\n+        JSType valueType \u003d NodeUtil.getObjectLitKeyTypeFromValueType(\n+            name, rawValueType);\n+        if (valueType \u003d\u003d null) {\n+          valueType \u003d getNativeType(UNKNOWN_TYPE);\n+        }\n+        objectType.defineInferredProperty(memberName, valueType, false, name);\n       } else {\n         n.setJSType(getNativeType(UNKNOWN_TYPE));\n-        return scope;\n       }\n     }\n-    n.setJSType(objectType);\n     return scope;\n   }\n \n@@ -863,7 +877,7 @@\n         JSType iArgumentType \u003d getJSType(iArgument);\n         if (iArgument.getType() \u003d\u003d Token.FUNCTION \u0026\u0026\n             iArgumentType instanceof FunctionType \u0026\u0026\n-            iArgumentType.getJSDocInfo() \u003d\u003d null) {\n+            iArgument.getJSDocInfo() \u003d\u003d null) {\n           iArgument.setJSType(iParameterFnType);\n         }\n       }\n@@ -887,46 +901,47 @@\n     int childCount \u003d n.getChildCount();\n     // Find the parameter whose type is the template type.\n     for (Node iParameter : fnType.getParameters()) {\n-      JSType iParameterType \u003d getJSType(iParameter);\n-      iParameterType \u003d iParameterType.restrictByNotNullOrUndefined();\n+      JSType iParameterType \u003d\n+          getJSType(iParameter).restrictByNotNullOrUndefined();\n       if (iParameterType.isTemplateType()) {\n         // Find the actual type of this argument.\n-        if (i + 1 \u003e\u003d childCount) {\n-          // TypeCheck#visitParameterList will warn so we bail.\n-          return;\n-        }\n-        Node iArgument \u003d n.getChildAtIndex(i + 1);\n-        JSType iArgumentType \u003d getJSType(iArgument);\n-        if (iArgumentType !\u003d null) {\n-          iArgumentType \u003d iArgumentType.restrictByNotNullOrUndefined();\n+        JSType iArgumentType \u003d null;\n+        if (i + 1 \u003c childCount) {\n+          Node iArgument \u003d n.getChildAtIndex(i + 1);\n+          iArgumentType \u003d getJSType(iArgument).restrictByNotNullOrUndefined();\n           if (!(iArgumentType instanceof ObjectType)) {\n             compiler.report(\n                 JSError.make(NodeUtil.getSourceName(iArgument), iArgument,\n-                             TEMPLATE_TYPE_NOT_OBJECT_TYPE));\n+                    TEMPLATE_TYPE_NOT_OBJECT_TYPE));\n             return;\n           }\n+        }\n \n-          // Find the parameter whose type is function(this: T, ...)\n-          boolean foundTemplateTypeOfThisParameter \u003d false;\n-          int j \u003d 0;\n-          for (Node jParameter : fnType.getParameters()) {\n-            JSType jParameterType \u003d getJSType(jParameter);\n-            if (jParameterType instanceof FunctionType) {\n-              FunctionType jParameterFnType \u003d (FunctionType) jParameterType;\n-              if (jParameterFnType.getTypeOfThis().equals(iParameterType)) {\n-                foundTemplateTypeOfThisParameter \u003d true;\n-                // Find the actual type of this argument.\n-                if (j + 1 \u003e\u003d childCount) {\n-                  // TypeCheck#visitParameterList will warn so we bail.\n-                  return;\n-                }\n-                Node jArgument \u003d n.getChildAtIndex(j + 1);\n-                JSType jArgumentType \u003d getJSType(jArgument);\n-                if (jArgument.getType() \u003d\u003d Token.FUNCTION \u0026\u0026\n-                    jArgumentType instanceof FunctionType) {\n+        // Find the parameter whose type is function(this: T, ...)\n+        boolean foundTemplateTypeOfThisParameter \u003d false;\n+        int j \u003d 0;\n+        for (Node jParameter : fnType.getParameters()) {\n+          JSType jParameterType \u003d\n+              getJSType(jParameter).restrictByNotNullOrUndefined();\n+          if (jParameterType instanceof FunctionType) {\n+            FunctionType jParameterFnType \u003d (FunctionType) jParameterType;\n+            if (jParameterFnType.getTypeOfThis().equals(iParameterType)) {\n+              foundTemplateTypeOfThisParameter \u003d true;\n+              // Find the actual type of the this argument.\n+              if (j + 1 \u003e\u003d childCount) {\n+                // TypeCheck#visitParameterList will warn so we bail.\n+                return;\n+              }\n+              Node jArgument \u003d n.getChildAtIndex(j + 1);\n+              JSType jArgumentType \u003d getJSType(jArgument);\n+              if (jArgument.getType() \u003d\u003d Token.FUNCTION \u0026\u0026\n+                  jArgumentType instanceof FunctionType) {\n+                if (iArgumentType !\u003d null \u0026\u0026\n+                    // null and undefined get filtered out above.\n+                    !iArgumentType.isNoType()) {\n                   // If it\u0027s an function expression, update the type of this\n                   // using the actual type of T.\n-                  FunctionType jArgumentFnType \u003d(FunctionType) jArgumentType;\n+                  FunctionType jArgumentFnType \u003d (FunctionType) jArgumentType;\n                   if (jArgumentFnType.getTypeOfThis().isUnknownType()) {\n                     // The new type will be picked up when we traverse the inner\n                     // function.\n@@ -934,20 +949,32 @@\n                         registry.createFunctionTypeWithNewThisType(\n                             jArgumentFnType, (ObjectType) iArgumentType));\n                   }\n+                  // Warn if the anonymous function literal does not reference this.\n+                  if (!NodeUtil.referencesThis(\n+                          NodeUtil.getFunctionBody(jArgument))) {\n+                    compiler.report(JSError.make(NodeUtil.getSourceName(n), n,\n+                        FUNCTION_LITERAL_UNREAD_THIS));\n+                  }\n+                } else {\n+                  // Warn if the anonymous function literal references this.\n+                  if (NodeUtil.referencesThis(\n+                          NodeUtil.getFunctionBody(jArgument))) {\n+                    compiler.report(JSError.make(NodeUtil.getSourceName(n), n,\n+                        FUNCTION_LITERAL_UNDEFINED_THIS));\n+                  }\n                 }\n-                // TODO(user): Add code to TypeCheck to check that the\n-                // types of the arguments match.\n               }\n+              // TODO(user): Add code to TypeCheck to check that the\n+              // types of the arguments match.\n             }\n-            j++;\n           }\n+          j++;\n+        }\n \n-          if (!foundTemplateTypeOfThisParameter) {\n-            Node source \u003d fnType.getSource();\n-            compiler.report(JSError.make(NodeUtil.getSourceName(source), source,\n-                                         TEMPLATE_TYPE_OF_THIS_EXPECTED));\n-            return;\n-          }\n+        if (!foundTemplateTypeOfThisParameter) {\n+          compiler.report(JSError.make(NodeUtil.getSourceName(n), n,\n+              TEMPLATE_TYPE_OF_THIS_EXPECTED));\n+          return;\n         }\n       }\n       i++;\n",
      "operations": [
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [25113,25169]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [25178,25272]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [25281,25366]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: valueType [25421,25430]"
        },
        {
          "type": "delete-tree",
          "from": "MethodInvocation [25154,25170]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ReturnStatement [25303,25316]",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "src/com/google/javascript/jscomp/TypedScopeCreator.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:maybeDeclareQualifiedName:[NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:processObjectLit:[NodeTraversal t, Node objectLit]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:findOverriddenFunction:[ObjectType ownerType, String propName]:FunctionType",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:processObjectLitProperties:[NodeTraversal t, Node objLit, ObjectType objLitType]:void",
            "com.google.javascript.jscomp.TypedScopeCreator:TypedScopeCreator:[AbstractCompiler compiler, CodingConvention codingConvention]:null",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:applyDelegateRelationship:[DelegateRelationship delegateRelationship]:void",
            "com.google.javascript.jscomp.TypedScopeCreator:TypedScopeCreator:[AbstractCompiler compiler]:null",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:getEnumType:[String name, Node parent, Node value, JSType elementsType]:EnumType",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:getDeclaredGetPropType:[NodeTraversal t, JSDocInfo info, Node n, @Nullable Node rhsValue]:JSType",
            "com.google.javascript.jscomp.TypedScopeCreator:createScope:[Node root, Scope parent]:Scope",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:checkForClassDefiningCalls:[NodeTraversal t, Node n, Node parent]:void",
            "com.google.javascript.jscomp.TypedScopeCreator:declareNativeValueType:[Scope scope, String name, JSTypeNative tId]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:isQnameRootedInGlobalScope:[Node n]:boolean",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:getFunctionType:[String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode]:FunctionType",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:defineSlot:[Node n, Node parent, JSType type, boolean inferred]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:resolveStubDeclarations:[]:void",
            "com.google.javascript.jscomp.TypedScopeCreator:createInitialScope:[Node root]:Scope",
            "com.google.javascript.jscomp.TypedScopeCreator:declareNativeFunctionType:[Scope scope, JSTypeNative tId]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:defineDeclaredFunction:[Node n, Node parent]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:defineNamedTypeAssign:[Node n, Node parent]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:defineName:[Node name, Node var, Node parent, JSDocInfo info]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$DiscoverEnumsAndTypedefs:visit:[NodeTraversal t, Node node, Node parent]:void"
          ],
          "num": 22
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:applyDelegateRelationship:[DelegateRelationship delegateRelationship]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:defineSlot:[Node n, Node parent, JSType type, boolean inferred]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:processObjectLit:[NodeTraversal t, Node objectLit]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$StubDeclaration:StubDeclaration:[Node node, boolean isExtern, String ownerName]:null",
            "com.google.javascript.jscomp.TypedScopeCreator:getNativeType:[JSTypeNative nativeType]:JSType",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:getDeclaredTypeInAnnotation:[String sourceName, Node node, JSDocInfo info]:JSType",
            "com.google.javascript.jscomp.TypedScopeCreator\\$DiscoverEnumsAndTypedefs:identifyNameNode:[Node nameNode, Node valueNode, JSDocInfo info]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$GlobalScopeBuilder:checkForTypedef:[NodeTraversal t, Node candidate, JSDocInfo info]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:resolveStubDeclarations:[]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$GlobalScopeBuilder:maybeDeclareQualifiedName:[NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:getFunctionType:[String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode]:FunctionType",
            "com.google.javascript.jscomp.TypedScopeCreator\\$GlobalScopeBuilder:GlobalScopeBuilder:[Scope scope]:null",
            "com.google.javascript.jscomp.TypedScopeCreator\\$DiscoverEnumsAndTypedefs:visit:[NodeTraversal t, Node node, Node parent]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder\\$CollectProperties:maybeCollectMember:[NodeTraversal t, Node member, Node nodeWithJsDocInfo, @Nullable Node value]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:defineName:[Node name, Node var, Node parent, JSDocInfo info]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:processObjectLitProperties:[NodeTraversal t, Node objLit, ObjectType objLitType]:void",
            "com.google.javascript.jscomp.TypedScopeCreator:getPrototypePropertyOwner:[Node n]:Node",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:getDeclaredGetPropType:[NodeTraversal t, JSDocInfo info, Node n, @Nullable Node rhsValue]:JSType",
            "com.google.javascript.jscomp.TypedScopeCreator\\$DiscoverEnumsAndTypedefs:DiscoverEnumsAndTypedefs:[JSTypeRegistry registry]:null",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder\\$CollectProperties:visit:[NodeTraversal t, Node n, Node parent]:void",
            "com.google.javascript.jscomp.TypedScopeCreator:createInitialScope:[Node root]:Scope",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:getEnumType:[String name, Node parent, Node value, JSType elementsType]:EnumType",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:visit:[NodeTraversal t, Node n, Node parent]:void",
            "com.google.javascript.jscomp.TypedScopeCreator:createScope:[Node root, Scope parent]:Scope",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:attachLiteralTypes:[NodeTraversal t, Node n]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:isQnameRootedInGlobalScope:[Node n]:boolean",
            "com.google.javascript.jscomp.TypedScopeCreator\\$GlobalScopeBuilder:visit:[NodeTraversal t, Node n, Node parent]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$LocalScopeBuilder:visit:[NodeTraversal t, Node n, Node parent]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$GlobalScopeBuilder:checkForOldStyleTypedef:[NodeTraversal t, Node candidate]:void",
            "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:maybeDeclareQualifiedName:[NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue]:void"
          ],
          "num": 30
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "2",
            "30",
            "52",
            "87",
            "109",
            "161",
            "163",
            "164",
            "165",
            "166",
            "167",
            "168",
            "169",
            "170",
            "171",
            "172",
            "173",
            "174",
            "175",
            "176",
            "177",
            "178",
            "179",
            "180",
            "181",
            "182",
            "185",
            "186",
            "187",
            "199",
            "222",
            "248",
            "251",
            "259",
            "260",
            "261",
            "263",
            "264",
            "267",
            "268",
            "272",
            "273",
            "274",
            "275",
            "283",
            "299",
            "311",
            "356",
            "372",
            "373",
            "539",
            "568",
            "569",
            "573",
            "695",
            "696",
            "702",
            "705",
            "774",
            "775",
            "783",
            "788",
            "792",
            "794",
            "796",
            "800",
            "801",
            "802",
            "804",
            "806",
            "807",
            "811",
            "816",
            "817",
            "818",
            "819",
            "820",
            "821",
            "822",
            "825",
            "827",
            "828",
            "829",
            "830",
            "831",
            "832",
            "833",
            "834",
            "835",
            "836",
            "837",
            "838",
            "839",
            "843",
            "844",
            "846",
            "847",
            "848",
            "850",
            "851",
            "852",
            "853",
            "854",
            "855",
            "856",
            "857",
            "858",
            "859",
            "860",
            "861",
            "862",
            "863",
            "864",
            "865",
            "866",
            "867",
            "868",
            "869",
            "870",
            "871",
            "872",
            "873",
            "874",
            "875",
            "876",
            "877",
            "878",
            "879",
            "880",
            "881",
            "882",
            "883",
            "884",
            "885",
            "886",
            "887",
            "888",
            "889",
            "890",
            "891",
            "892",
            "893",
            "894",
            "895",
            "896",
            "897",
            "898",
            "899",
            "900",
            "901",
            "902",
            "903",
            "904",
            "905",
            "906",
            "907",
            "1000",
            "1019",
            "1020",
            "1021",
            "1022",
            "1023",
            "1024",
            "1025",
            "1026",
            "1027",
            "1028",
            "1029",
            "1030",
            "1031",
            "1032",
            "1033",
            "1034",
            "1035",
            "1036",
            "1037",
            "1038",
            "1039",
            "1040",
            "1041",
            "1042",
            "1043",
            "1044",
            "1045",
            "1046",
            "1047",
            "1048",
            "1049",
            "1050",
            "1051",
            "1052",
            "1053",
            "1054",
            "1055",
            "1056",
            "1057",
            "1058",
            "1059",
            "1060",
            "1061",
            "1062",
            "1063",
            "1064",
            "1065",
            "1066",
            "1067",
            "1068",
            "1069",
            "1070",
            "1071",
            "1072",
            "1073",
            "1074",
            "1075",
            "1076",
            "1077",
            "1078",
            "1079",
            "1080",
            "1081",
            "1082",
            "1083",
            "1084",
            "1085",
            "1086",
            "1087",
            "1088",
            "1098",
            "1118",
            "1123",
            "1144",
            "1145",
            "1146",
            "1147",
            "1148",
            "1149",
            "1150",
            "1151",
            "1152",
            "1153",
            "1154",
            "1155",
            "1156",
            "1157",
            "1158",
            "1159",
            "1184",
            "1190",
            "1216",
            "1217",
            "1218",
            "1219",
            "1220",
            "1221",
            "1222",
            "1223",
            "1224",
            "1225",
            "1226",
            "1227",
            "1228",
            "1229",
            "1230",
            "1231",
            "1232",
            "1233",
            "1234",
            "1235",
            "1236",
            "1237",
            "1238",
            "1242",
            "1266",
            "1275",
            "1276",
            "1277",
            "1278",
            "1279",
            "1280",
            "1281",
            "1282",
            "1283",
            "1284",
            "1285",
            "1286",
            "1287",
            "1288",
            "1289",
            "1294",
            "1302",
            "1303",
            "1305",
            "1308",
            "1315",
            "1328",
            "1335",
            "1376",
            "1377",
            "1378",
            "1379",
            "1380",
            "1381",
            "1382",
            "1383",
            "1384",
            "1385",
            "1386",
            "1387",
            "1388",
            "1389",
            "1390",
            "1391",
            "1392"
          ],
          "num": 313
        },
        {
          "qualified_names": [
            "2",
            "31",
            "33",
            "39",
            "41",
            "56",
            "91",
            "92",
            "93",
            "94",
            "106",
            "107",
            "108",
            "109",
            "110",
            "111",
            "112",
            "113",
            "114",
            "115",
            "121",
            "122",
            "123",
            "124",
            "125",
            "126",
            "127",
            "128",
            "129",
            "130",
            "136",
            "184",
            "189",
            "190",
            "194",
            "195",
            "196",
            "197",
            "198",
            "199",
            "200",
            "201",
            "202",
            "203",
            "204",
            "205",
            "206",
            "207",
            "208",
            "209",
            "210",
            "211",
            "212",
            "213",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "231",
            "232",
            "255",
            "281",
            "282",
            "285",
            "294",
            "295",
            "296",
            "297",
            "298",
            "301",
            "302",
            "303",
            "304",
            "305",
            "306",
            "307",
            "308",
            "309",
            "310",
            "313",
            "315",
            "316",
            "317",
            "318",
            "319",
            "320",
            "321",
            "322",
            "323",
            "324",
            "325",
            "326",
            "327",
            "328",
            "336",
            "353",
            "354",
            "355",
            "356",
            "369",
            "370",
            "371",
            "372",
            "373",
            "374",
            "375",
            "376",
            "377",
            "378",
            "379",
            "380",
            "381",
            "382",
            "427",
            "428",
            "429",
            "430",
            "431",
            "432",
            "433",
            "434",
            "435",
            "436",
            "437",
            "438",
            "439",
            "440",
            "441",
            "442",
            "443",
            "444",
            "445",
            "446",
            "447",
            "448",
            "449",
            "450",
            "451",
            "452",
            "453",
            "454",
            "455",
            "456",
            "457",
            "458",
            "459",
            "460",
            "461",
            "462",
            "463",
            "464",
            "465",
            "466",
            "467",
            "468",
            "469",
            "470",
            "471",
            "472",
            "473",
            "474",
            "475",
            "476",
            "477",
            "478",
            "479",
            "480",
            "481",
            "482",
            "483",
            "484",
            "485",
            "486",
            "487",
            "488",
            "489",
            "490",
            "491",
            "492",
            "493",
            "494",
            "495",
            "496",
            "497",
            "498",
            "499",
            "500",
            "501",
            "502",
            "503",
            "504",
            "505",
            "506",
            "507",
            "508",
            "509",
            "510",
            "511",
            "512",
            "513",
            "514",
            "515",
            "516",
            "517",
            "518",
            "519",
            "520",
            "521",
            "522",
            "523",
            "524",
            "525",
            "526",
            "527",
            "528",
            "529",
            "530",
            "531",
            "532",
            "533",
            "534",
            "535",
            "536",
            "537",
            "538",
            "539",
            "540",
            "541",
            "542",
            "543",
            "544",
            "545",
            "546",
            "547",
            "548",
            "549",
            "550",
            "551",
            "552",
            "553",
            "554",
            "555",
            "556",
            "557",
            "558",
            "559",
            "560",
            "561",
            "562",
            "563",
            "564",
            "565",
            "566",
            "567",
            "568",
            "569",
            "570",
            "571",
            "572",
            "573",
            "574",
            "575",
            "576",
            "577",
            "578",
            "579",
            "580",
            "581",
            "582",
            "583",
            "584",
            "585",
            "601",
            "602",
            "603",
            "604",
            "770",
            "799",
            "800",
            "803",
            "804",
            "805",
            "927",
            "928",
            "929",
            "930",
            "931",
            "937",
            "1007",
            "1008",
            "1009",
            "1010",
            "1011",
            "1012",
            "1013",
            "1014",
            "1015",
            "1016",
            "1017",
            "1018",
            "1019",
            "1020",
            "1021",
            "1023",
            "1024",
            "1032",
            "1033",
            "1034",
            "1042",
            "1044",
            "1046",
            "1050",
            "1051",
            "1052",
            "1053",
            "1055",
            "1056",
            "1057",
            "1059",
            "1060",
            "1064",
            "1065",
            "1066",
            "1067",
            "1068",
            "1069",
            "1070",
            "1071",
            "1072",
            "1073",
            "1074",
            "1075",
            "1076",
            "1077",
            "1078",
            "1079",
            "1080",
            "1081",
            "1082",
            "1083",
            "1090",
            "1092",
            "1093",
            "1094",
            "1095",
            "1096",
            "1097",
            "1098",
            "1099",
            "1100",
            "1104",
            "1106",
            "1107",
            "1108",
            "1109",
            "1110",
            "1112",
            "1113",
            "1114",
            "1115",
            "1116",
            "1117",
            "1118",
            "1119",
            "1120",
            "1121",
            "1122",
            "1215",
            "1243",
            "1263",
            "1264",
            "1265",
            "1270",
            "1291",
            "1292",
            "1293",
            "1318",
            "1324",
            "1331",
            "1332",
            "1333",
            "1334",
            "1335",
            "1336",
            "1337",
            "1338",
            "1339",
            "1340",
            "1341",
            "1342",
            "1343",
            "1344",
            "1345",
            "1368",
            "1392",
            "1405",
            "1413",
            "1414",
            "1415",
            "1417",
            "1418",
            "1421",
            "1428",
            "1441",
            "1448",
            "1449",
            "1453",
            "1454",
            "1455",
            "1456",
            "1457",
            "1458",
            "1459",
            "1460",
            "1461",
            "1462",
            "1463",
            "1464",
            "1465",
            "1466",
            "1467",
            "1468",
            "1469",
            "1470",
            "1471",
            "1472",
            "1473",
            "1474",
            "1475",
            "1476",
            "1477",
            "1478",
            "1479",
            "1480",
            "1481",
            "1482",
            "1483",
            "1484",
            "1485",
            "1486",
            "1487",
            "1488",
            "1489",
            "1490",
            "1491",
            "1492",
            "1493",
            "1494",
            "1495",
            "1496",
            "1497",
            "1498",
            "1499",
            "1500",
            "1501",
            "1502",
            "1503",
            "1504",
            "1505",
            "1506",
            "1507",
            "1508",
            "1509",
            "1510",
            "1511",
            "1512",
            "1513",
            "1514",
            "1515",
            "1516",
            "1517",
            "1518",
            "1519",
            "1520",
            "1521",
            "1522",
            "1523",
            "1524",
            "1525",
            "1526",
            "1527",
            "1528",
            "1529",
            "1530",
            "1531",
            "1532",
            "1533",
            "1534",
            "1535",
            "1536",
            "1537",
            "1538",
            "1539",
            "1540",
            "1541",
            "1542",
            "1543",
            "1544",
            "1545",
            "1546",
            "1547",
            "1548",
            "1549",
            "1550",
            "1551",
            "1552",
            "1553",
            "1554",
            "1555",
            "1556",
            "1557",
            "1558",
            "1559",
            "1560",
            "1561",
            "1562",
            "1563",
            "1564",
            "1565",
            "1566",
            "1567",
            "1568",
            "1569",
            "1570",
            "1571",
            "1572",
            "1573",
            "1574",
            "1575",
            "1576",
            "1577",
            "1578",
            "1579",
            "1580",
            "1581",
            "1582",
            "1583",
            "1584",
            "1622"
          ],
          "num": 541
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex f70e733..a2dc149 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2004 Google Inc.\n+ * Copyright 2004 The Closure Compiler Authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -28,13 +28,17 @@\n import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.RANGE_ERROR_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_FUNCTION_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_OBJECT_FUNCTION_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;\n@@ -49,7 +53,7 @@\n import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast;\n import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n import com.google.javascript.jscomp.CodingConvention.SubclassType;\n-import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n@@ -84,7 +88,10 @@\n   /**\n    * A suffix for naming delegate proxies differently from their base.\n    */\n-  static final String DELEGATE_PROXY_SUFFIX \u003d \"(Proxy)\";\n+  static final String DELEGATE_PROXY_SUFFIX \u003d\n+      ObjectType.createDelegateSuffix(\"Proxy\");\n+\n+  private static final String LEGACY_TYPEDEF \u003d \"goog.typedef\";\n \n   static final DiagnosticType MALFORMED_TYPEDEF \u003d\n       DiagnosticType.warning(\n@@ -96,17 +103,37 @@\n           \"JSC_ENUM_INITIALIZER_NOT_ENUM\",\n           \"enum initializer must be an object literal or an enum\");\n \n+  static final DiagnosticType CTOR_INITIALIZER \u003d\n+      DiagnosticType.warning(\n+          \"JSC_CTOR_INITIALIZER_NOT_CTOR\",\n+          \"Constructor {0} must be initialized at declaration\");\n+\n+  static final DiagnosticType IFACE_INITIALIZER \u003d\n+      DiagnosticType.warning(\n+          \"JSC_IFACE_INITIALIZER_NOT_IFACE\",\n+          \"Interface {0} must be initialized at declaration\");\n+\n   static final DiagnosticType CONSTRUCTOR_EXPECTED \u003d\n       DiagnosticType.warning(\n           \"JSC_REFLECT_CONSTRUCTOR_EXPECTED\",\n           \"Constructor expected as first argument\");\n \n+  static final DiagnosticType UNKNOWN_LENDS \u003d\n+      DiagnosticType.warning(\n+          \"JSC_UNKNOWN_LENDS\",\n+          \"Variable {0} not declared before @lends annotation.\");\n+\n+  static final DiagnosticType LENDS_ON_NON_OBJECT \u003d\n+      DiagnosticType.warning(\n+          \"JSC_LENDS_ON_NON_OBJECT\",\n+          \"May only lend properties to object types. {0} has type {1}.\");\n+\n   private final AbstractCompiler compiler;\n   private final ErrorReporter typeParsingErrorReporter;\n   private final TypeValidator validator;\n   private final CodingConvention codingConvention;\n   private final JSTypeRegistry typeRegistry;\n-  private List\u003cObjectType\u003e delegateProxyPrototypes \u003d Lists.newArrayList();\n+  private final List\u003cObjectType\u003e delegateProxyPrototypes \u003d Lists.newArrayList();\n \n   /**\n    * Defer attachment of types to nodes until all type names\n@@ -154,37 +181,42 @@\n     // inner scopes, because only global scopes can contain named classes that\n     // show up in the type registry.\n     Scope newScope \u003d null;\n+    AbstractScopeBuilder scopeBuilder \u003d null;\n     if (parent \u003d\u003d null) {\n       // Find all the classes in the global scope.\n       newScope \u003d createInitialScope(root);\n \n-      GlobalScopeBuilder scopeBuilder \u003d new GlobalScopeBuilder(newScope);\n+      GlobalScopeBuilder globalScopeBuilder \u003d new GlobalScopeBuilder(newScope);\n+      scopeBuilder \u003d globalScopeBuilder;\n       NodeTraversal.traverse(compiler, root, scopeBuilder);\n-      scopeBuilder.resolveStubDeclarations();\n-      scopeBuilder.resolveTypes();\n-\n-      // Gather the properties in each function that we found in the\n-      // global scope, if that function has a @this type that we can\n-      // build properties on.\n-      for (Node functionNode : scopeBuilder.nonExternFunctions) {\n-        JSType type \u003d functionNode.getJSType();\n-        if (type !\u003d null \u0026\u0026 type instanceof FunctionType) {\n-          FunctionType fnType \u003d (FunctionType) type;\n-          ObjectType fnThisType \u003d fnType.getTypeOfThis();\n-          if (!fnThisType.isUnknownType()) {\n-            NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n-                scopeBuilder.new CollectProperties(fnThisType));\n-          }\n-        }\n-      }\n-\n-      codingConvention.defineDelegateProxyPrototypeProperties(\n-          typeRegistry, newScope, delegateProxyPrototypes);\n     } else {\n       newScope \u003d new Scope(parent, root);\n-      LocalScopeBuilder scopeBuilder \u003d new LocalScopeBuilder(newScope);\n-      scopeBuilder.build();\n-      scopeBuilder.resolveTypes();\n+      LocalScopeBuilder localScopeBuilder \u003d new LocalScopeBuilder(newScope);\n+      scopeBuilder \u003d localScopeBuilder;\n+      localScopeBuilder.build();\n+    }\n+\n+    scopeBuilder.resolveStubDeclarations();\n+    scopeBuilder.resolveTypes();\n+\n+    // Gather the properties in each function that we found in the\n+    // global scope, if that function has a @this type that we can\n+    // build properties on.\n+    for (Node functionNode : scopeBuilder.nonExternFunctions) {\n+      JSType type \u003d functionNode.getJSType();\n+      if (type !\u003d null \u0026\u0026 type instanceof FunctionType) {\n+        FunctionType fnType \u003d (FunctionType) type;\n+        ObjectType fnThisType \u003d fnType.getTypeOfThis();\n+        if (!fnThisType.isUnknownType()) {\n+          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n+              scopeBuilder.new CollectProperties(fnThisType));\n+        }\n+      }\n+    }\n+\n+    if (parent \u003d\u003d null) {\n+      codingConvention.defineDelegateProxyPrototypeProperties(\n+          typeRegistry, newScope, delegateProxyPrototypes);\n     }\n     return newScope;\n   }\n@@ -196,7 +228,8 @@\n   @VisibleForTesting\n   Scope createInitialScope(Node root) {\n \n-    NodeTraversal.traverse(compiler, root, new DiscoverEnums(typeRegistry));\n+    NodeTraversal.traverse(\n+        compiler, root, new DiscoverEnumsAndTypedefs(typeRegistry));\n \n     Scope s \u003d new Scope(root, compiler);\n     declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);\n@@ -219,7 +252,7 @@\n     // The typedef construct needs the any type, so that it can be assigned\n     // to anything. This is kind of a hack, and an artifact of the typedef\n     // syntax we\u0027ve chosen.\n-    declareNativeValueType(s, \"goog.typedef\", NO_TYPE);\n+    declareNativeValueType(s, LEGACY_TYPEDEF, NO_TYPE);\n \n     // ActiveXObject is unqiuely special, because it can be used to construct\n     // any type (the type that it creates is related to the arguments you\n@@ -245,10 +278,11 @@\n     scope.declare(name, null, t, null, false);\n   }\n \n-  private static class DiscoverEnums extends AbstractShallowCallback {\n+  private static class DiscoverEnumsAndTypedefs\n+      extends AbstractShallowStatementCallback {\n     private final JSTypeRegistry registry;\n \n-    DiscoverEnums(JSTypeRegistry registry) {\n+    DiscoverEnumsAndTypedefs(JSTypeRegistry registry) {\n       this.registry \u003d registry;\n     }\n \n@@ -256,23 +290,42 @@\n     public void visit(NodeTraversal t, Node node, Node parent) {\n       Node nameNode \u003d null;\n       switch (node.getType()) {\n-        case Token.NAME:\n-          nameNode \u003d node;\n-          break;\n         case Token.VAR:\n-          if (node.hasOneChild()) {\n-            nameNode \u003d node.getFirstChild();\n+          for (Node child \u003d node.getFirstChild();\n+               child !\u003d null; child \u003d child.getNext()) {\n+            identifyNameNode(\n+                child, child.getFirstChild(),\n+                NodeUtil.getInfoForNameNode(child));\n           }\n           break;\n-        case Token.ASSIGN:\n-          nameNode \u003d node.getFirstChild();\n+        case Token.EXPR_RESULT:\n+          Node firstChild \u003d node.getFirstChild();\n+          if (firstChild.getType() \u003d\u003d Token.ASSIGN) {\n+            identifyNameNode(\n+                firstChild.getFirstChild(), firstChild.getLastChild(),\n+                firstChild.getJSDocInfo());\n+          } else {\n+            identifyNameNode(\n+                firstChild, null, firstChild.getJSDocInfo());\n+          }\n           break;\n       }\n+    }\n \n-      if (nameNode !\u003d null) {\n-        JSDocInfo info \u003d node.getJSDocInfo();\n-        if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-          registry.identifyEnumName(nameNode.getQualifiedName());\n+    private void identifyNameNode(\n+        Node nameNode, Node valueNode, JSDocInfo info) {\n+      if (nameNode.isQualifiedName()) {\n+        if (info !\u003d null) {\n+          if (info.hasEnumParameterType()) {\n+            registry.identifyNonNullableName(nameNode.getQualifiedName());\n+          } else if (info.hasTypedefType()) {\n+            registry.identifyNonNullableName(nameNode.getQualifiedName());\n+          }\n+        }\n+\n+        if (valueNode !\u003d null \u0026\u0026\n+            LEGACY_TYPEDEF.equals(valueNode.getQualifiedName())) {\n+          registry.identifyNonNullableName(nameNode.getQualifiedName());\n         }\n       }\n     }\n@@ -280,7 +333,7 @@\n \n   /**\n    * Given a node, determines whether that node names a prototype\n-   * property, and if so, returns the qualfied name node representing\n+   * property, and if so, returns the qualified name node representing\n    * the owner of that property. Otherwise, returns null.\n    */\n   private static Node getPrototypePropertyOwner(Node n) {\n@@ -297,6 +350,10 @@\n     return null;\n   }\n \n+  private JSType getNativeType(JSTypeNative nativeType) {\n+    return typeRegistry.getNativeType(nativeType);\n+  }\n+\n   private abstract class AbstractScopeBuilder\n       implements NodeTraversal.Callback {\n \n@@ -309,6 +366,20 @@\n         Lists.newArrayList();\n \n     /**\n+     * Functions that we found in the global scope and not in externs.\n+     */\n+    private final List\u003cNode\u003e nonExternFunctions \u003d Lists.newArrayList();\n+\n+    /**\n+     * Type-less stubs.\n+     *\n+     * If at the end of traversal, we still don\u0027t have types for these\n+     * stubs, then we should declare UNKNOWN types.\n+     */\n+    private final List\u003cStubDeclaration\u003e stubDeclarations \u003d\n+        Lists.newArrayList();\n+\n+    /**\n      * The current source file that we\u0027re in.\n      */\n     private String sourceName \u003d null;\n@@ -353,7 +424,165 @@\n     }\n \n     @Override\n-    public abstract void visit(NodeTraversal t, Node n, Node parent);\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      attachLiteralTypes(t, n);\n+\n+      switch (n.getType()) {\n+        case Token.CALL:\n+          checkForClassDefiningCalls(t, n, parent);\n+          break;\n+\n+        case Token.FUNCTION:\n+          if (t.getInput() \u003d\u003d null || !t.getInput().isExtern()) {\n+            nonExternFunctions.add(n);\n+          }\n+\n+          // VARs and ASSIGNs are handled in different branches of this\n+          // switch statement.\n+          if (parent.getType() !\u003d Token.ASSIGN \u0026\u0026\n+              parent.getType() !\u003d Token.NAME) {\n+            defineDeclaredFunction(n, parent);\n+          }\n+\n+          break;\n+\n+        case Token.ASSIGN:\n+          // Handle constructor and enum definitions.\n+          defineNamedTypeAssign(n, parent);\n+\n+          // Handle initialization of properties.\n+          Node firstChild \u003d n.getFirstChild();\n+          if (firstChild.getType() \u003d\u003d Token.GETPROP \u0026\u0026\n+              firstChild.isQualifiedName()) {\n+            maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n+                firstChild, n, firstChild.getNext());\n+          }\n+          break;\n+\n+        case Token.CATCH:\n+          defineCatch(n, parent);\n+          break;\n+\n+        case Token.VAR:\n+          defineVar(n, parent);\n+          break;\n+\n+        case Token.GETPROP:\n+          // Handle stubbed properties.\n+          if (parent.getType() \u003d\u003d Token.EXPR_RESULT \u0026\u0026\n+              n.isQualifiedName()) {\n+            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n+          }\n+          break;\n+      }\n+    }\n+\n+    private void attachLiteralTypes(NodeTraversal t, Node n) {\n+      switch (n.getType()) {\n+        case Token.NULL:\n+          n.setJSType(getNativeType(NULL_TYPE));\n+          break;\n+\n+        case Token.VOID:\n+          n.setJSType(getNativeType(VOID_TYPE));\n+          break;\n+\n+        case Token.STRING:\n+          // Defer keys to the Token.OBJECTLIT case\n+          if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n+            n.setJSType(getNativeType(STRING_TYPE));\n+          }\n+          break;\n+\n+        case Token.NUMBER:\n+          // Defer keys to the Token.OBJECTLIT case\n+          if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n+            n.setJSType(getNativeType(NUMBER_TYPE));\n+          }\n+          break;\n+\n+        case Token.TRUE:\n+        case Token.FALSE:\n+          n.setJSType(getNativeType(BOOLEAN_TYPE));\n+          break;\n+\n+        case Token.REGEXP:\n+          n.setJSType(getNativeType(REGEXP_TYPE));\n+          break;\n+\n+        case Token.REF_SPECIAL:\n+          n.setJSType(getNativeType(UNKNOWN_TYPE));\n+          break;\n+\n+        case Token.OBJECTLIT:\n+          processObjectLit(t, n);\n+          break;\n+\n+          // NOTE(nicksantos): If we ever support Array tuples,\n+          // we will need to put ARRAYLIT here as well.\n+      }\n+    }\n+\n+    private void processObjectLit(NodeTraversal t, Node objectLit) {\n+      JSDocInfo info \u003d objectLit.getJSDocInfo();\n+      if (info !\u003d null \u0026\u0026\n+          info.getLendsName() !\u003d null) {\n+        String lendsName \u003d info.getLendsName();\n+        Var lendsVar \u003d scope.getVar(lendsName);\n+        if (lendsVar \u003d\u003d null) {\n+          compiler.report(\n+              JSError.make(sourceName, objectLit, UNKNOWN_LENDS, lendsName));\n+        } else {\n+          JSType type \u003d lendsVar.getType();\n+          if (type \u003d\u003d null) {\n+            type \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n+          }\n+          if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n+            compiler.report(\n+                JSError.make(sourceName, objectLit, LENDS_ON_NON_OBJECT,\n+                    lendsName, type.toString()));\n+          } else {\n+            objectLit.setJSType(type);\n+          }\n+        }\n+      }\n+\n+      if (objectLit.getJSType() \u003d\u003d null) {\n+        objectLit.setJSType(typeRegistry.createAnonymousObjectType());\n+      }\n+\n+      processObjectLitProperties(\n+          t, objectLit, ObjectType.cast(objectLit.getJSType()));\n+    }\n+\n+    /**\n+     * Process an object literal and all the types on it.\n+     * @param objLit The OBJECTLIT node.\n+     * @param objLitType The type of the OBJECTLIT node. This might be a named\n+     *     type, because of the lends annotation.\n+     */\n+    void processObjectLitProperties(\n+        NodeTraversal t, Node objLit, ObjectType objLitType) {\n+      for (Node name \u003d objLit.getFirstChild(); name !\u003d null;\n+           name \u003d name.getNext()) {\n+        Node value \u003d name.getFirstChild();\n+        String memberName \u003d NodeUtil.getObjectLitKeyName(name);\n+        JSType valueType \u003d getDeclaredTypeInAnnotation(\n+            t, name, name.getJSDocInfo());\n+        JSType keyType \u003d NodeUtil.getObjectLitKeyTypeFromValueType(\n+            name, valueType);\n+        if (keyType !\u003d null) {\n+          name.setJSType(keyType);\n+          // TODO(nicksantos): Even if the type of the object literal is null,\n+          // we may want to declare its properties in the current scope.\n+          if (objLitType !\u003d null) {\n+            boolean isExtern \u003d t.getInput() !\u003d null \u0026\u0026 t.getInput().isExtern();\n+            objLitType.defineDeclaredProperty(\n+                memberName, keyType, isExtern, name);\n+          }\n+        }\n+      }\n+    }\n \n     /**\n      * Returns the type specified in a JSDoc annotation near a GETPROP or NAME.\n@@ -369,8 +598,10 @@\n     JSType getDeclaredTypeInAnnotation(String sourceName,\n         Node node, JSDocInfo info) {\n       JSType jsType \u003d null;\n-      Node objNode \u003d node.getType() \u003d\u003d Token.GETPROP ?\n-          node.getFirstChild() : null;\n+      Node objNode \u003d\n+          node.getType() \u003d\u003d Token.GETPROP ? node.getFirstChild() :\n+          NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() :\n+          null;\n       if (info !\u003d null) {\n         if (info.hasType()) {\n           jsType \u003d info.getType().evaluate(scope, typeRegistry);\n@@ -536,7 +767,7 @@\n           CompilerInput input \u003d compiler.getInput(sourceName);\n           Preconditions.checkNotNull(input, sourceName);\n           type \u003d input.isExtern() ?\n-              typeRegistry.getNativeType(UNKNOWN_TYPE) : null;\n+              getNativeType(UNKNOWN_TYPE) : null;\n         } else if (info.hasEnumParameterType()) {\n           type \u003d getEnumType(name.getString(), var, value,\n               info.getEnumParameterType().evaluate(scope, typeRegistry));\n@@ -565,12 +796,13 @@\n         Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n       FunctionType functionType \u003d null;\n \n-      // Handle function aliases.\n-      if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName()) {\n+      // Global function aliases should be registered with the type registry.\n+      if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n         Var var \u003d scope.getVar(rValue.getQualifiedName());\n         if (var !\u003d null \u0026\u0026 var.getType() instanceof FunctionType) {\n           functionType \u003d (FunctionType) var.getType();\n-          if (functionType !\u003d null \u0026\u0026 functionType.isConstructor()) {\n+          if (functionType !\u003d null \u0026\u0026\n+              (functionType.isConstructor() || functionType.isInterface())) {\n             typeRegistry.declareType(name, functionType.getInstanceType());\n           }\n         }\n@@ -692,17 +924,19 @@\n           Node key \u003d value.getFirstChild();\n           while (key !\u003d null) {\n             String keyName \u003d NodeUtil.getStringValue(key);\n-\n-            if (enumType.hasOwnProperty(keyName)) {\n+            if (keyName \u003d\u003d null) {\n+              // GET and SET don\u0027t have a String value;\n+              compiler.report(\n+                  JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n+            } else if (enumType.hasOwnProperty(keyName)) {\n               compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n             } else if (!codingConvention.isValidEnumKey(keyName)) {\n               compiler.report(\n                   JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n             } else {\n-              enumType.defineElement(keyName);\n+              enumType.defineElement(keyName, key);\n             }\n             key \u003d key.getNext();\n-            key \u003d (key \u003d\u003d null) ? null : key.getNext();\n           }\n         } else if (value.isQualifiedName()) {\n           Var var \u003d scope.getVar(value.getQualifiedName());\n@@ -770,9 +1004,24 @@\n       String variableName \u003d n.getQualifiedName();\n       Preconditions.checkArgument(!variableName.isEmpty());\n \n+      // If n is a property, then we should really declare it in the\n+      // scope where the root object appears. This helps out people\n+      // who declare \"global\" names in an anonymous namespace.\n+      Scope scopeToDeclareIn \u003d scope;\n+      if (n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 !scope.isGlobal() \u0026\u0026\n+          isQnameRootedInGlobalScope(n)) {\n+        Scope globalScope \u003d scope.getGlobalScope();\n+\n+        // don\u0027t try to declare in the global scope if there\u0027s\n+        // already a symbol there with this name.\n+        if (!globalScope.isDeclared(variableName, false)) {\n+          scopeToDeclareIn \u003d scope.getGlobalScope();\n+        }\n+      }\n+\n       // declared in closest scope?\n-      if (scope.isDeclared(variableName, false)) {\n-        Var oldVar \u003d scope.getVar(variableName);\n+      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n+        Var oldVar \u003d scopeToDeclareIn.getVar(variableName);\n         validator.expectUndeclaredVariable(\n             sourceName, n, parent, oldVar, variableName, type);\n       } else {\n@@ -780,131 +1029,97 @@\n           setDeferredType(n, type);\n         }\n         CompilerInput input \u003d compiler.getInput(sourceName);\n-        scope.declare(variableName, n, type, input, inferred);\n+        boolean isExtern \u003d input.isExtern();\n+        Var newVar \u003d\n+            scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n \n         if (shouldDeclareOnGlobalThis) {\n           ObjectType globalThis \u003d\n               typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n-          boolean isExtern \u003d input.isExtern();\n           if (inferred) {\n             globalThis.defineInferredProperty(variableName,\n                 type \u003d\u003d null ?\n-                    typeRegistry.getNativeType(JSTypeNative.NO_TYPE) :\n+                    getNativeType(JSTypeNative.NO_TYPE) :\n                     type,\n-                isExtern);\n+                isExtern, n);\n           } else {\n-            globalThis.defineDeclaredProperty(variableName, type, isExtern);\n+            globalThis.defineDeclaredProperty(variableName, type, isExtern, n);\n           }\n         }\n \n-        // If we\u0027re in the global scope, also declare var.prototype\n-        // in the scope chain.\n-        if (scope.isGlobal() \u0026\u0026 type instanceof FunctionType) {\n+        // We need to do some additional work for constructors and interfaces.\n+        if (type instanceof FunctionType \u0026\u0026\n+            // We don\u0027t want to look at empty function types.\n+            !type.isEmptyType()) {\n           FunctionType fnType \u003d (FunctionType) type;\n-          if (fnType.isConstructor() || fnType.isInterface()) {\n+          if ((fnType.isConstructor() || fnType.isInterface()) \u0026\u0026\n+              !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n+            // Declare var.prototype in the scope chain.\n             FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n-            scope.declare(variableName + \".prototype\", n,\n-                fnType.getPrototype(), compiler.getInput(sourceName),\n+            scopeToDeclareIn.declare(variableName + \".prototype\", n,\n+                fnType.getPrototype(), input,\n                 /* declared iff there\u0027s an explicit supertype */\n                 superClassCtor \u003d\u003d null ||\n                 superClassCtor.getInstanceType().equals(\n-                    typeRegistry.getNativeType(OBJECT_TYPE)));\n+                    getNativeType(OBJECT_TYPE)));\n+\n+            // Make sure the variable is initialized to something if\n+            // it constructs itself.\n+            if (newVar.getInitialValue() \u003d\u003d null \u0026\u0026\n+                !isExtern \u0026\u0026\n+                // We want to make sure that when we declare a new instance\n+                // type (with @constructor) that there\u0027s actually a ctor for it.\n+                // This doesn\u0027t apply to structural constructors\n+                // (like function(new:Array). Checking the constructed\n+                // type against the variable name is a sufficient check for\n+                // this.\n+                variableName.equals(\n+                    fnType.getInstanceType().getReferenceName())) {\n+              compiler.report(\n+                  JSError.make(sourceName, n,\n+                      fnType.isConstructor() ?\n+                          CTOR_INITIALIZER : IFACE_INITIALIZER,\n+                      variableName));\n+            }\n           }\n         }\n       }\n     }\n-  }\n-\n-  /**\n-   * A shallow traversal of the global scope to build up all classes,\n-   * functions, and methods.\n-   */\n-  private final class GlobalScopeBuilder extends AbstractScopeBuilder {\n \n     /**\n-     * Functions that we found in the global scope and not in externs.\n+     * Check if the given node is a property of a name in the global scope.\n      */\n-    private final List\u003cNode\u003e nonExternFunctions \u003d Lists.newArrayList();\n-\n-    /**\n-     * Type-less stubs in the global scope.\n-     *\n-     * If at the end of traversal, we still don\u0027t have types for these\n-     * stubs, then we should declare UNKNOWN types.\n-     */\n-    private final List\u003cStubDeclaration\u003e stubDeclarations \u003d\n-        Lists.newArrayList();\n-\n-    private GlobalScopeBuilder(Scope scope) {\n-      super(scope);\n+    private boolean isQnameRootedInGlobalScope(Node n) {\n+      Node root \u003d NodeUtil.getRootOfQualifiedName(n);\n+      if (root.getType() \u003d\u003d Token.NAME) {\n+        Var var \u003d scope.getVar(root.getString());\n+        if (var !\u003d null) {\n+          return var.isGlobal();\n+        }\n+      }\n+      return false;\n     }\n \n     /**\n-     * Visit a node in the global scope, and add anything it declares to the\n-     * global symbol table.\n+     * Look for a type declaration on a GETPROP node.\n      *\n-     * @param t The current traversal.\n-     * @param n The node being visited.\n-     * @param parent The parent of n\n+     * @param info The doc info for this property.\n+     * @param n A top-level GETPROP node (it should not be contained inside\n+     *     another GETPROP).\n+     * @param rhsValue The node that {@code n} is being initialized to,\n+     *     or {@code null} if this is a stub declaration.\n      */\n-    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n-      switch (n.getType()) {\n-        case Token.CALL:\n-          checkForClassDefiningCalls(t, n, parent);\n-          break;\n-\n-        case Token.FUNCTION:\n-          if (!t.getInput().isExtern()) {\n-            nonExternFunctions.add(n);\n-          }\n-\n-          // VARs and ASSIGNs are handled separately.\n-          if (parent.getType() \u003d\u003d Token.ASSIGN ||\n-              parent.getType() \u003d\u003d Token.NAME) {\n-            return;\n-          }\n-\n-          defineDeclaredFunction(n, parent);\n-          break;\n-\n-        case Token.ASSIGN:\n-          // Handle constructor and enum definitions.\n-          defineNamedTypeAssign(n, parent);\n-\n-          // Handle typedefs.\n-          checkForOldStyleTypedef(t, n);\n-\n-          // Handle initialization of properties.\n-          Node firstChild \u003d n.getFirstChild();\n-          if (firstChild.getType() \u003d\u003d Token.GETPROP \u0026\u0026\n-              firstChild.isQualifiedName()) {\n-            maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n-                firstChild, n, firstChild.getNext());\n-          }\n-          break;\n-\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-\n-        case Token.VAR:\n-          defineVar(n, parent);\n-\n-          // Handle typedefs.\n-          if (n.hasOneChild()) {\n-            checkForOldStyleTypedef(t, n);\n-            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());\n-          }\n-          break;\n-\n-        case Token.GETPROP:\n-          // Handle stubbed properties.\n-          if (parent.getType() \u003d\u003d Token.EXPR_RESULT \u0026\u0026\n-              n.isQualifiedName()) {\n-            checkForTypedef(t, n, n.getJSDocInfo());\n-            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n-          }\n-          break;\n+    private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,\n+        Node n, @Nullable Node rhsValue) {\n+      if (info !\u003d null \u0026\u0026 info.hasType()) {\n+        return getDeclaredTypeInAnnotation(t, n, info);\n+      } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n+        return n.getJSType();\n+      } else if (rhsValue !\u003d null \u0026\u0026\n+          rhsValue.getType() \u003d\u003d Token.FUNCTION) {\n+        return rhsValue.getJSType();\n+      } else {\n+        return getDeclaredTypeInAnnotation(t, n, info);\n       }\n     }\n \n@@ -997,7 +1212,7 @@\n           FunctionParamBuilder functionParamBuilder \u003d\n               new FunctionParamBuilder(typeRegistry);\n           functionParamBuilder.addRequiredParams(\n-              typeRegistry.getNativeType(U2U_CONSTRUCTOR_TYPE));\n+              getNativeType(U2U_CONSTRUCTOR_TYPE));\n           FunctionType findDelegate \u003d typeRegistry.createFunctionType(\n               typeRegistry.createDefaultObjectUnion(delegateBaseObject),\n               functionParamBuilder.build());\n@@ -1016,76 +1231,6 @@\n     }\n \n     /**\n-     * Handle typedefs.\n-     * @param t The current traversal.\n-     * @param candidate A qualified name node.\n-     * @param info JSDoc comments.\n-     */\n-    private void checkForTypedef(\n-        NodeTraversal t, Node candidate, JSDocInfo info) {\n-      if (info \u003d\u003d null || !info.hasTypedefType()) {\n-        return;\n-      }\n-\n-      String typedef \u003d candidate.getQualifiedName();\n-      if (typedef \u003d\u003d null) {\n-        return;\n-      }\n-\n-      // TODO(nicksantos|user): This is a terrible, terrible hack\n-      // to bail out on recusive typedefs. We\u0027ll eventually need\n-      // to handle these properly.\n-      typeRegistry.forwardDeclareType(typedef);\n-\n-      JSType realType \u003d info.getTypedefType().evaluate(scope, typeRegistry);\n-      if (realType \u003d\u003d null) {\n-        compiler.report(\n-            JSError.make(\n-                t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n-      }\n-\n-      typeRegistry.declareType(typedef, realType);\n-      if (candidate.getType() \u003d\u003d Token.GETPROP) {\n-        defineSlot(candidate, candidate.getParent(),\n-            typeRegistry.getNativeType(NO_TYPE), false);\n-      }\n-    }\n-\n-    /**\n-     * Handle typedefs.\n-     * @param t The current traversal.\n-     * @param candidate An ASSIGN or VAR node.\n-     */\n-    // TODO(nicksantos): Kill this.\n-    private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) {\n-      // old-style typedefs\n-      String typedef \u003d codingConvention.identifyTypeDefAssign(candidate);\n-      if (typedef !\u003d null) {\n-        // TODO(nicksantos|user): This is a terrible, terrible hack\n-        // to bail out on recusive typedefs. We\u0027ll eventually need\n-        // to handle these properly.\n-        typeRegistry.forwardDeclareType(typedef);\n-\n-        JSDocInfo info \u003d candidate.getJSDocInfo();\n-        JSType realType \u003d null;\n-        if (info !\u003d null \u0026\u0026 info.getType() !\u003d null) {\n-          realType \u003d info.getType().evaluate(scope, typeRegistry);\n-        }\n-\n-        if (realType \u003d\u003d null) {\n-          compiler.report(\n-              JSError.make(\n-                  t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n-        }\n-\n-        typeRegistry.declareType(typedef, realType);\n-\n-        // Duplicate typedefs get handled when we try to register\n-        // this typedef in the scope.\n-      }\n-    }\n-\n-    /**\n      * Declare the symbol for a qualified name in the global scope.\n      *\n      * @param info The doc info for this property.\n@@ -1095,7 +1240,7 @@\n      * @param rhsValue The node that {@code n} is being initialized to,\n      *     or {@code null} if this is a stub declaration.\n      */\n-    private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n+    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n         Node n, Node parent, Node rhsValue) {\n       Node ownerNode \u003d n.getFirstChild();\n       String ownerName \u003d ownerNode.getQualifiedName();\n@@ -1115,12 +1260,14 @@\n             // Just ignore assigns to declared prototypes.\n             return;\n           }\n-          scope.undeclare(qVar);\n+          if (qVar.getScope() \u003d\u003d scope) {\n+            scope.undeclare(qVar);\n+          }\n         }\n       }\n \n       // Precedence of type information on GETPROPs:\n-      // 1) @type annotation / @enum annotation\n+      // 1) @type annnotation / @enum annotation\n       // 2) ASSIGN to FUNCTION literal\n       // 3) @param/@return annotation (with no function literal)\n       // 4) ASSIGN to anything else\n@@ -1141,22 +1288,9 @@\n       if (valueType \u003d\u003d null) {\n         if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n           stubDeclarations.add(new StubDeclaration(\n-              n, t.getInput().isExtern(), ownerName));\n-        } else if (rhsValue !\u003d null \u0026\u0026\n-                   rhsValue.getType() \u003d\u003d Token.TRUE) {\n-          // We declare these for delegate proxy method properties.\n-          ObjectType ownerType \u003d getObjectSlot(ownerName);\n-          if (ownerType instanceof FunctionType) {\n-            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n-            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n-            JSType delegateType \u003d delegateName \u003d\u003d null ?\n-                null : typeRegistry.getType(delegateName);\n-            if (delegateType !\u003d null \u0026\u0026\n-                ownerTypeOfThis.isSubtype(delegateType)) {\n-              defineSlot(n, parent, typeRegistry.getNativeType(BOOLEAN_TYPE),\n-                         true);\n-            }\n-          }\n+              n,\n+              t.getInput() !\u003d null \u0026\u0026 t.getInput().isExtern(),\n+              ownerName));\n         }\n \n         return;\n@@ -1181,19 +1315,34 @@\n         if (ownerType !\u003d null) {\n           // Only declare this as an official property if it has not been\n           // declared yet.\n-          boolean isExtern \u003d t.getInput().isExtern();\n+          boolean isExtern \u003d t.getInput() !\u003d null \u0026\u0026 t.getInput().isExtern();\n           if ((!ownerType.hasOwnProperty(propName) ||\n                ownerType.isPropertyTypeInferred(propName)) \u0026\u0026\n               ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) ||\n                !ownerType.isInstanceType())) {\n             // If the property is undeclared or inferred, declare it now.\n-            ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n+            ownerType.defineDeclaredProperty(propName, valueType, isExtern, n);\n           }\n         }\n \n         // If the property is already declared, the error will be\n         // caught when we try to declare it in the current scope.\n         defineSlot(n, parent, valueType, inferred);\n+      } else if (rhsValue !\u003d null \u0026\u0026\n+          rhsValue.getType() \u003d\u003d Token.TRUE) {\n+        // We declare these for delegate proxy method properties.\n+        ObjectType ownerType \u003d getObjectSlot(ownerName);\n+        if (ownerType instanceof FunctionType) {\n+          JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n+          String delegateName \u003d codingConvention.getDelegateSuperclassName();\n+          JSType delegateType \u003d delegateName \u003d\u003d null ?\n+              null : typeRegistry.getType(delegateName);\n+          if (delegateType !\u003d null \u0026\u0026\n+              ownerTypeOfThis.isSubtype(delegateType)) {\n+            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE),\n+                true);\n+          }\n+        }\n       }\n     }\n \n@@ -1213,33 +1362,10 @@\n     }\n \n     /**\n-     * Look for a type declaration on a GETPROP node.\n-     *\n-     * @param info The doc info for this property.\n-     * @param n A top-level GETPROP node (it should not be contained inside\n-     *     another GETPROP).\n-     * @param rhsValue The node that {@code n} is being initialized to,\n-     *     or {@code null} if this is a stub declaration.\n-     */\n-    private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,\n-        Node n, Node rhsValue) {\n-      if (info !\u003d null \u0026\u0026 info.hasType()) {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n-      } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-        return n.getJSType();\n-      } else if (rhsValue !\u003d null \u0026\u0026\n-          rhsValue.getType() \u003d\u003d Token.FUNCTION) {\n-        return rhsValue.getJSType();\n-      } else {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n-      }\n-    }\n-\n-    /**\n      * Resolve any stub delcarations to unknown types if we could not\n      * find types for them during traversal.\n      */\n-    private void resolveStubDeclarations() {\n+    void resolveStubDeclarations() {\n       for (StubDeclaration stub : stubDeclarations) {\n         Node n \u003d stub.node;\n         Node parent \u003d n.getParent();\n@@ -1263,7 +1389,7 @@\n           // If this is a stub for a prototype, just declare it\n           // as an unknown type. These are seen often in externs.\n           ownerType.defineInferredProperty(\n-              propName, unknownType, isExtern);\n+              propName, unknownType, isExtern, n);\n         } else {\n           typeRegistry.registerPropertyOnType(\n               propName, ownerType \u003d\u003d null ? unknownType : ownerType);\n@@ -1272,26 +1398,11 @@\n     }\n \n     /**\n-     * A stub declaration without any type information.\n-     */\n-    private final class StubDeclaration {\n-      private final Node node;\n-      private final boolean isExtern;\n-      private final String ownerName;\n-\n-      private StubDeclaration(Node node, boolean isExtern, String ownerName) {\n-        this.node \u003d node;\n-        this.isExtern \u003d isExtern;\n-        this.ownerName \u003d ownerName;\n-      }\n-    }\n-\n-    /**\n      * Collects all declared properties in a function, and\n      * resolves them relative to the global scope.\n      */\n     private final class CollectProperties\n-        extends AbstractShallowCallback {\n+        extends AbstractShallowStatementCallback {\n       private final ObjectType thisType;\n \n       CollectProperties(ObjectType thisType) {\n@@ -1299,20 +1410,22 @@\n       }\n \n       public void visit(NodeTraversal t, Node n, Node parent) {\n-        if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n-          switch (n.getType()) {\n+        if (n.getType() \u003d\u003d Token.EXPR_RESULT) {\n+          Node child \u003d n.getFirstChild();\n+          switch (child.getType()) {\n             case Token.ASSIGN:\n-              maybeCollectMember(t, n.getFirstChild(), n);\n+              maybeCollectMember(t, child.getFirstChild(), child,\n+                  child.getLastChild());\n               break;\n             case Token.GETPROP:\n-              maybeCollectMember(t, n, n);\n+              maybeCollectMember(t, child, child, null);\n               break;\n           }\n         }\n       }\n \n       private void maybeCollectMember(NodeTraversal t,\n-          Node member, Node nodeWithJsDocInfo) {\n+          Node member, Node nodeWithJsDocInfo, @Nullable Node value) {\n         JSDocInfo info \u003d nodeWithJsDocInfo.getJSDocInfo();\n \n         // Do nothing if there is no JSDoc type info, or\n@@ -1325,17 +1438,150 @@\n         }\n \n         member.getFirstChild().setJSType(thisType);\n-        JSType jsType \u003d getDeclaredTypeInAnnotation(t, member, info);\n+        JSType jsType \u003d getDeclaredGetPropType(t, info, member, value);\n         Node name \u003d member.getLastChild();\n         if (jsType !\u003d null \u0026\u0026\n             (name.getType() \u003d\u003d Token.NAME || name.getType() \u003d\u003d Token.STRING)) {\n           thisType.defineDeclaredProperty(\n               name.getString(),\n               jsType,\n-              false /* functions with implementations are not in externs */);\n+              false /* functions with implementations are not in externs */,\n+              member);\n         }\n       }\n     } // end CollectProperties\n+  }\n+\n+  /**\n+   * A stub declaration without any type information.\n+   */\n+  private static final class StubDeclaration {\n+    private final Node node;\n+    private final boolean isExtern;\n+    private final String ownerName;\n+\n+    private StubDeclaration(Node node, boolean isExtern, String ownerName) {\n+      this.node \u003d node;\n+      this.isExtern \u003d isExtern;\n+      this.ownerName \u003d ownerName;\n+    }\n+  }\n+\n+  /**\n+   * A shallow traversal of the global scope to build up all classes,\n+   * functions, and methods.\n+   */\n+  private final class GlobalScopeBuilder extends AbstractScopeBuilder {\n+\n+    private GlobalScopeBuilder(Scope scope) {\n+      super(scope);\n+    }\n+\n+    /**\n+     * Visit a node in the global scope, and add anything it declares to the\n+     * global symbol table.\n+     *\n+     * @param t The current traversal.\n+     * @param n The node being visited.\n+     * @param parent The parent of n\n+     */\n+    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n+      super.visit(t, n, parent);\n+\n+      switch (n.getType()) {\n+\n+        case Token.ASSIGN:\n+          // Handle typedefs.\n+          checkForOldStyleTypedef(t, n);\n+          break;\n+\n+        case Token.VAR:\n+          // Handle typedefs.\n+          if (n.hasOneChild()) {\n+            checkForOldStyleTypedef(t, n);\n+            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());\n+          }\n+          break;\n+      }\n+    }\n+\n+    @Override\n+    void maybeDeclareQualifiedName(\n+        NodeTraversal t, JSDocInfo info,\n+        Node n, Node parent, Node rhsValue) {\n+      checkForTypedef(t, n, info);\n+      super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n+    }\n+\n+    /**\n+     * Handle typedefs.\n+     * @param t The current traversal.\n+     * @param candidate A qualified name node.\n+     * @param info JSDoc comments.\n+     */\n+    private void checkForTypedef(\n+        NodeTraversal t, Node candidate, JSDocInfo info) {\n+      if (info \u003d\u003d null || !info.hasTypedefType()) {\n+        return;\n+      }\n+\n+      String typedef \u003d candidate.getQualifiedName();\n+      if (typedef \u003d\u003d null) {\n+        return;\n+      }\n+\n+      // TODO(nicksantos|user): This is a terrible, terrible hack\n+      // to bail out on recusive typedefs. We\u0027ll eventually need\n+      // to handle these properly.\n+      typeRegistry.declareType(typedef, getNativeType(UNKNOWN_TYPE));\n+\n+      JSType realType \u003d info.getTypedefType().evaluate(scope, typeRegistry);\n+      if (realType \u003d\u003d null) {\n+        compiler.report(\n+            JSError.make(\n+                t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n+      }\n+\n+      typeRegistry.overwriteDeclaredType(typedef, realType);\n+      if (candidate.getType() \u003d\u003d Token.GETPROP) {\n+        defineSlot(candidate, candidate.getParent(),\n+            getNativeType(NO_TYPE), false);\n+      }\n+    }\n+\n+    /**\n+     * Handle typedefs.\n+     * @param t The current traversal.\n+     * @param candidate An ASSIGN or VAR node.\n+     */\n+    // TODO(nicksantos): Kill this.\n+    private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) {\n+      // old-style typedefs\n+      String typedef \u003d codingConvention.identifyTypeDefAssign(candidate);\n+      if (typedef !\u003d null) {\n+        // TODO(nicksantos|user): This is a terrible, terrible hack\n+        // to bail out on recusive typedefs. We\u0027ll eventually need\n+        // to handle these properly.\n+        typeRegistry.declareType(typedef, getNativeType(UNKNOWN_TYPE));\n+\n+        JSDocInfo info \u003d candidate.getJSDocInfo();\n+        JSType realType \u003d null;\n+        if (info !\u003d null \u0026\u0026 info.getType() !\u003d null) {\n+          realType \u003d info.getType().evaluate(scope, typeRegistry);\n+        }\n+\n+        if (realType \u003d\u003d null) {\n+          compiler.report(\n+              JSError.make(\n+                  t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n+        }\n+\n+        typeRegistry.overwriteDeclaredType(typedef, realType);\n+\n+        // Duplicate typedefs get handled when we try to register\n+        // this typedef in the scope.\n+      }\n+    }\n   } // end GlobalScopeBuilder\n \n   /**\n@@ -1373,23 +1619,7 @@\n         return;\n       }\n \n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          // VARs and ASSIGNs are handled separately.\n-          if (parent.getType() \u003d\u003d Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+      super.visit(t, n, parent);\n     }\n \n     /** Handle bleeding functions and function parameters. */\n",
      "operations": [
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [18369,18483]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [18591,18705]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "PrefixExpression [18373,18415]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [18417,18483]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "PrefixExpression [18595,18637]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [18639,18705]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [21041,21130]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [21172,21196]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [34244,34835]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [34248,34263]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Block [34265,34445]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "ReturnStatement [20662,20669]",
          "to": ""
        }
      ]
    }
  ],
  "inducing_type": {
    "add_classes": {
      "qualified_names": [
        "src/com/google/javascript/jscomp/InlineSimpleMethods.java",
        "src/com/google/javascript/jscomp/OptimizeCalls.java",
        "src/com/google/javascript/jscomp/OptimizeReturns.java",
        "src/com/google/javascript/jscomp/ProcessTweaks.java",
        "src/com/google/javascript/jscomp/SimpleFunctionAliasAnalysis.java",
        "src/com/google/javascript/jscomp/SourceMap2.java",
        "src/com/google/javascript/jscomp/SourceMapLegacy.java",
        "src/com/google/javascript/jscomp/SpecializationAwareCompilerPass.java",
        "src/com/google/javascript/jscomp/SpecializeModule.java",
        "src/com/google/javascript/jscomp/UnfoldCompoundAssignments.java",
        "src/com/google/javascript/jscomp/deps/JsFunctionParser.java",
        "src/com/google/javascript/jscomp/jsonml/ErrorLevel.java",
        "src/com/google/javascript/jscomp/jsonml/JsonML.java",
        "src/com/google/javascript/jscomp/jsonml/JsonMLAst.java",
        "src/com/google/javascript/jscomp/jsonml/JsonMLError.java",
        "src/com/google/javascript/jscomp/jsonml/JsonMLException.java",
        "src/com/google/javascript/jscomp/jsonml/JsonMLUtil.java",
        "src/com/google/javascript/jscomp/jsonml/NodeUtil.java",
        "src/com/google/javascript/jscomp/jsonml/Reader.java",
        "src/com/google/javascript/jscomp/jsonml/SecureCompiler.java",
        "src/com/google/javascript/jscomp/jsonml/TagAttr.java",
        "src/com/google/javascript/jscomp/jsonml/TagType.java",
        "src/com/google/javascript/jscomp/jsonml/Validator.java",
        "src/com/google/javascript/jscomp/jsonml/Writer.java",
        "src/com/google/javascript/rhino/jstype/NoResolvedType.java"
      ],
      "num": 25
    },
    "delete_classes": {
      "qualified_names": [
        "gen/com/google/javascript/jscomp/FunctionInformationMapOrBuilder.java",
        "gen/com/google/javascript/jscomp/InstrumentationOrBuilder.java",
        "src/com/google/javascript/jscomp/InlineGetters.java",
        "src/com/google/javascript/jscomp/RemoveConstantExpressions.java",
        "src/com/google/javascript/jscomp/RemoveConstantExpressionsParallel.java"
      ],
      "num": 5
    },
    "add_functions": {
      "qualified_names": [
        "com.google.javascript.jscomp.NodeUtil:isNull:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:getRootOfQualifiedName:[Node qName]:Node",
        "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:visit:[NodeTraversal t, Node n, Node parent]:void",
        "com.google.javascript.jscomp.NodeUtil:evaluatesToLocalValue:[Node value, Predicate\u003cNode\u003e locals]:boolean",
        "com.google.javascript.jscomp.TypeCheck:visitObjLitKey:[NodeTraversal t, Node key, Node objlit]:void",
        "com.google.javascript.jscomp.NodeUtil:constructorCallHasSideEffects:[Node callNode]:boolean",
        "com.google.javascript.jscomp.NodeUtil:getFnParameters:[Node fnNode]:Node",
        "com.google.javascript.jscomp.NodeUtil:newQualifiedNameNode:[CodingConvention convention, String name, int lineno, int charno]:Node",
        "com.google.javascript.jscomp.NodeUtil:getArgumentForFunction:[Node function, int index]:Node",
        "com.google.javascript.jscomp.TypeCheck:propertyIsImplicitCast:[ObjectType type, String prop]:boolean",
        "com.google.javascript.jscomp.NodeUtil:newName:[CodingConvention convention, String name, int lineno, int charno]:Node",
        "com.google.javascript.jscomp.TypedScopeCreator\\$GlobalScopeBuilder:visit:[NodeTraversal t, Node n, Node parent]:void",
        "com.google.javascript.jscomp.NodeUtil:newQualifiedNameNode:[CodingConvention convention, String name, Node basisNode, String originalName]:Node",
        "com.google.javascript.jscomp.TypedScopeCreator\\$GlobalScopeBuilder:checkForOldStyleTypedef:[NodeTraversal t, Node candidate]:void",
        "com.google.javascript.jscomp.NodeUtil:isSimpleOperator:[Node n]:boolean",
        "com.google.javascript.jscomp.TypeCheck:checkEnumInitializer:[NodeTraversal t, Node value, JSType primitiveType]:void",
        "com.google.javascript.jscomp.NodeUtil:isSimpleFunctionObjectCall:[Node callNode]:boolean",
        "com.google.javascript.jscomp.TypedScopeCreator\\$DiscoverEnumsAndTypedefs:DiscoverEnumsAndTypedefs:[JSTypeRegistry registry]:null",
        "com.google.javascript.jscomp.NodeUtil:getObjectLitKeyName:[Node key]:String",
        "com.google.javascript.jscomp.NodeUtil:newName:[CodingConvention convention, String name, Node basisNode]:Node",
        "com.google.javascript.jscomp.NodeUtil:getNthSibling:[Node first, int index]:Node",
        "com.google.javascript.jscomp.NodeUtil:getObjectLitKeyTypeFromValueType:[Node key, JSType valueType]:JSType",
        "com.google.javascript.jscomp.TypeCheck:visitParameterList:[NodeTraversal t, Node call, FunctionType functionType]:void",
        "com.google.javascript.jscomp.NodeUtil:newHasLocalResult:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:nodeTypeMayHaveSideEffects:[Node n, AbstractCompiler compiler]:boolean",
        "com.google.javascript.jscomp.NodeUtil:functionCallHasSideEffects:[Node callNode, @Nullable AbstractCompiler compiler]:boolean",
        "com.google.javascript.jscomp.NodeUtil:isWithinLoop:[Node n]:boolean",
        "com.google.javascript.jscomp.TypedScopeCreator\\$StubDeclaration:StubDeclaration:[Node node, boolean isExtern, String ownerName]:null",
        "com.google.javascript.jscomp.TypedScopeCreator\\$GlobalScopeBuilder:checkForTypedef:[NodeTraversal t, Node candidate, JSDocInfo info]:void",
        "com.google.javascript.jscomp.TypeCheck:visitInterfaceGetprop:[NodeTraversal t, Node assign, Node object, String property, Node lvalue, Node rvalue]:void",
        "com.google.javascript.jscomp.TypedScopeCreator:getPrototypePropertyOwner:[Node n]:Node",
        "com.google.javascript.jscomp.NodeUtil:isGetOrSetKey:[Node node]:boolean",
        "com.google.javascript.jscomp.NodeUtil:trimJsWhiteSpace:[String s]:String",
        "com.google.javascript.jscomp.NodeUtil:isTryCatchNodeContainer:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:isNumericResult:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:getExpressionBooleanValue:[Node n]:TernaryValue",
        "com.google.javascript.jscomp.TypedScopeCreator\\$GlobalScopeBuilder:GlobalScopeBuilder:[Scope scope]:null",
        "com.google.javascript.jscomp.NodeUtil:nodeTypeMayHaveSideEffects:[Node n]:boolean",
        "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder\\$CollectProperties:maybeCollectMember:[NodeTraversal t, Node member, Node nodeWithJsDocInfo, @Nullable Node value]:void",
        "com.google.javascript.jscomp.NodeUtil:constructorCallHasSideEffects:[Node callNode, AbstractCompiler compiler]:boolean",
        "com.google.javascript.jscomp.NodeUtil:isFunctionObjectCallOrApply:[Node callNode]:boolean",
        "com.google.javascript.jscomp.NodeUtil:isObjectLitKey:[Node node, Node parent]:boolean",
        "com.google.javascript.jscomp.NodeUtil:newName:[CodingConvention convention, String name, Node basisNode, String originalName]:Node",
        "com.google.javascript.jscomp.NodeUtil:isFunction:[Node n]:boolean",
        "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:getDeclaredTypeInAnnotation:[String sourceName, Node node, JSDocInfo info]:JSType",
        "com.google.javascript.jscomp.NodeUtil:isControlStructure:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:isBooleanResult:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:getArgumentForCallOrNew:[Node call, int index]:Node",
        "com.google.javascript.jscomp.NodeUtil:isImmutableValue:[Node n]:boolean",
        "com.google.javascript.jscomp.TypedScopeCreator\\$DiscoverEnumsAndTypedefs:identifyNameNode:[Node nameNode, Node valueNode, JSDocInfo info]:void",
        "com.google.javascript.jscomp.NodeUtil:getNearestFunctionName:[Node n]:String",
        "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:attachLiteralTypes:[NodeTraversal t, Node n]:void",
        "com.google.javascript.jscomp.TypedScopeCreator\\$LocalScopeBuilder:visit:[NodeTraversal t, Node n, Node parent]:void",
        "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder\\$CollectProperties:visit:[NodeTraversal t, Node n, Node parent]:void",
        "com.google.javascript.jscomp.NodeUtil:functionCallHasSideEffects:[Node callNode]:boolean",
        "com.google.javascript.jscomp.NodeUtil:evaluatesToLocalValue:[Node value]:boolean",
        "com.google.javascript.jscomp.TypedScopeCreator:getNativeType:[JSTypeNative nativeType]:JSType",
        "com.google.javascript.jscomp.NodeUtil:isToStringMethodCall:[Node call]:boolean",
        "com.google.javascript.jscomp.NodeUtil:maybeAddFinally:[Node tryNode]:void",
        "com.google.javascript.jscomp.NodeUtil:callHasLocalResult:[Node n]:boolean",
        "com.google.javascript.jscomp.TypedScopeCreator\\$GlobalScopeBuilder:maybeDeclareQualifiedName:[NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue]:void"
      ],
      "num": 61
    },
    "delete_functions": {
      "qualified_names": [
        "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:defineDeclaredFunction:[Node n, Node parent]:void",
        "com.google.javascript.jscomp.NodeUtil:getLoopCodeBlock:[Node n]:Node",
        "com.google.javascript.jscomp.TypeCheck:visitAssign:[NodeTraversal t, Node assign]:void",
        "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:defineNamedTypeAssign:[Node n, Node parent]:void",
        "com.google.javascript.jscomp.TypedScopeCreator:TypedScopeCreator:[AbstractCompiler compiler]:null",
        "com.google.javascript.jscomp.NodeUtil:getAddingRoot:[Node n]:Node",
        "com.google.javascript.jscomp.NodeUtil:isSimpleOperatorType:[int type]:boolean",
        "com.google.javascript.jscomp.NodeUtil:newExpr:[Node child]:Node",
        "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:checkForClassDefiningCalls:[NodeTraversal t, Node n, Node parent]:void",
        "com.google.javascript.jscomp.TypeCheck:visitBinaryOperator:[int op, NodeTraversal t, Node n]:void",
        "com.google.javascript.jscomp.TypedScopeCreator\\$AbstractScopeBuilder:findOverriddenFunction:[ObjectType ownerType, String propName]:FunctionType",
        "com.google.javascript.jscomp.TypedScopeCreator:declareNativeFunctionType:[Scope scope, JSTypeNative tId]:void",
        "com.google.javascript.jscomp.NodeUtil:isLoopStructure:[Node n]:boolean",
        "com.google.javascript.jscomp.TypedScopeCreator:declareNativeValueType:[Scope scope, String name, JSTypeNative tId]:void",
        "com.google.javascript.jscomp.NodeUtil:mayEffectMutableState:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeUtil:isAssignmentOp:[Node n]:boolean",
        "com.google.javascript.jscomp.TypedScopeCreator:TypedScopeCreator:[AbstractCompiler compiler, CodingConvention codingConvention]:null",
        "com.google.javascript.jscomp.TypeCheck:visitCall:[NodeTraversal t, Node n]:void",
        "com.google.javascript.jscomp.NodeUtil:precedence:[int type]:int",
        "com.google.javascript.jscomp.NodeUtil:isEmptyBlock:[Node block]:boolean"
      ],
      "num": 20
    }
  },
  "trigger_tests": [
    {
      "test_class": "com.google.javascript.jscomp.TypeCheckTest",
      "test_function": "testGetTypedPercent5",
      "assertion_line": "7784",
      "exception": "junit.framework.AssertionFailedError",
      "message": "expected:\u003c100.0\u003e but was:\u003c62.5\u003e"
    },
    {
      "test_class": "com.google.javascript.jscomp.TypeCheckTest",
      "test_function": "testGetTypedPercent6",
      "assertion_line": "7789",
      "exception": "junit.framework.AssertionFailedError",
      "message": "expected:\u003c100.0\u003e but was:\u003c66.66666666666667\u003e"
    }
  ],
  "fixing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/TypeCheck.java",
        "src/com/google/javascript/jscomp/TypeCheck.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.TypeCheck:visit:[NodeTraversal t, Node n, Node parent]:void"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.TypeCheck:visit:[NodeTraversal t, Node n, Node parent]:void"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "515"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "516",
            "517",
            "518"
          ],
          "num": 3
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex 5edb4f0..d3def01 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -513,6 +513,9 @@\n         // Object literal keys are handled with OBJECTLIT\n         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n           ensureTyped(t, n, STRING_TYPE);\n+        } else {\n+          // Object literal keys are not typeable\n+          typeable \u003d false;\n         }\n         break;\n \n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "Block [18099,18188]"
        }
      ]
    }
  ],
  "fixing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [],
      "num": 0
    },
    "add_functions": {
      "qualified_names": [],
      "num": 0
    },
    "delete_functions": {
      "qualified_names": [],
      "num": 0
    }
  },
  "patch_changed_mths": {
    "qualified_names": [
      "com.google.javascript.jscomp.TypeCheck:visit(Lcom/google/javascript/jscomp/NodeTraversal;Lcom/google/javascript/rhino/Node;Lcom/google/javascript/rhino/Node;)V:regression"
    ],
    "num": 1
  }
}