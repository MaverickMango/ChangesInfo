{
  "logger": {
    "currentLogLevel": 20,
    "name": "root.bean.benchmarks.Defects4JBug"
  },
  "d4jCmd": "/home/liumengjiao/Desktop/defects4j/framework/bin/defects4j",
  "dataDir": "data/changesInfo/",
  "timeoutSecond": 300,
  "proj": "Closure",
  "id": "30",
  "workingDir": "../bugs/Closure_30_buggy",
  "inducingCommit": "74a817bbf5256d671036356c58096f612535e4a2",
  "originalCommit": "7e0d71b3d68ad4788a094d8618e2b0aa474cf3db",
  "bug_name": "Closure_30",
  "derive": "defects4j",
  "original_fixing_commit": "38e2b8f247423734adec3dbd76fa22da1a3561a8",
  "buildFiles_changed": false,
  "inducing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/AbstractCompiler.java",
        "src/com/google/javascript/jscomp/AbstractCompiler.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "report",
            "getParserConfig",
            "prepareAst",
            "isTypeCheckingEnabled"
          ],
          "num": 4
        },
        {
          "qualified_names": [
            "areNodesEqualForInlining",
            "setUnnormalized",
            "hasRegExpGlobalReferences",
            "prepareAst",
            "isTypeCheckingEnabled",
            "getParserConfig",
            "setHasRegExpGlobalReferences",
            "report",
            "setNormalized"
          ],
          "num": 9
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "24",
            "31",
            "74",
            "186",
            "187",
            "188",
            "189",
            "190",
            "191",
            "194",
            "204"
          ],
          "num": 11
        },
        {
          "qualified_names": [
            "21",
            "31",
            "34",
            "35",
            "36",
            "77",
            "184",
            "185",
            "186",
            "187",
            "188",
            "194",
            "195",
            "198",
            "209",
            "210",
            "211",
            "212",
            "213",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "220",
            "221",
            "222",
            "223",
            "224",
            "225",
            "226",
            "227",
            "228",
            "229",
            "230",
            "231",
            "232",
            "233",
            "234",
            "235",
            "236",
            "237",
            "238",
            "239"
          ],
          "num": 45
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/AbstractCompiler.java b/src/com/google/javascript/jscomp/AbstractCompiler.java\nindex 44846ec..2971dbc 100644\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n@@ -18,19 +18,22 @@\n \n import com.google.common.base.Supplier;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n+import com.google.javascript.jscomp.parsing.Config;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n-\n /**\n  * An abstract compiler, to help remove the circular dependency of\n  * passes on JSCompiler.\n  *\n  * This is an abstract class, so that we can make the methods package-private.\n  *\n-*\n+ * @author nicksantos@google.com (Nick Santos)\n  */\n public abstract class AbstractCompiler implements SourceExcerptProvider {\n+  static final DiagnosticType READ_ERROR \u003d DiagnosticType.error(\n+      \"JSC_READ_ERROR\", \"Cannot read: {0}\");\n+\n   // TODO(nicksantos): Decide if all of these are really necessary.\n   // Many of them are just accessors that should be passed to the\n   // CompilerPass\u0027s constructor.\n@@ -71,7 +74,7 @@\n   /**\n    * Report an error or warning.\n    */\n-  abstract void report(JSError error);\n+  public abstract void report(JSError error);\n \n   /**\n    * Report an internal error.\n@@ -178,20 +181,21 @@\n   abstract boolean isIdeMode();\n \n   /**\n+   * Returns the parser configuration.\n+   */\n+  abstract Config getParserConfig();\n+\n+  /**\n    * Returns true if type checking is enabled.\n    */\n   abstract boolean isTypeCheckingEnabled();\n \n   /**\n-   * Normalizes the types of AST nodes in the given tree.\n-   */\n-  abstract void normalizeNodeTypes(Node root);\n-\n-  /**\n-   * Annotates any nodes to which the coding convention applies so that passes\n+   * Normalizes the types of AST nodes in the given tree, and\n+   * annotates any nodes to which the coding convention applies so that passes\n    * can read the annotations instead of using the coding convention.\n    */\n-  abstract void annotateCodingConvention(Node root);\n+  abstract void prepareAst(Node root);\n \n   /**\n    * Acquires the symbol table.\n@@ -202,4 +206,35 @@\n    * Gets the error manager.\n    */\n   abstract public ErrorManager getErrorManager();\n+\n+  /**\n+   * Set if the normalization pass has been done.\n+   * Note: non-private to enable test cases that require the Normalize pass.\n+   */\n+  abstract void setNormalized();\n+\n+  /**\n+   * Set once unnormalizing passes have been start.\n+   * Note: non-private to enable test cases that require the Normalize pass.\n+   */\n+  abstract void setUnnormalized();\n+\n+  /**\n+   * Are the nodes equal for the purpose of inlining?\n+   * If type aware optimizations are on, type equality is checked.\n+   */\n+  abstract boolean areNodesEqualForInlining(Node n1, Node n2);\n+\n+  /**\n+   * Set if RegExp global properties are used.\n+   * @param references Whether there are references to the RegExp global object\n+   *     properties.\n+   */\n+  abstract void setHasRegExpGlobalReferences(boolean references);\n+  \n+  /**\n+   * @return Whether the AST constains references to the RegExp global object\n+   *     properties.\n+   */\n+  abstract boolean hasRegExpGlobalReferences();\n }\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [6207,6430]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [6436,6592]"
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/Compiler.java",
        "src/com/google/javascript/jscomp/Compiler.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "endPass",
            "prepareAst",
            "getColumnIndex",
            "startPass",
            "getLength",
            "setState",
            "getUniqueNameIdSupplier",
            "setCssRenamingMap",
            "getPropertyMap",
            "externExports",
            "toSourceArray",
            "processDefines",
            "hasErrors",
            "runCustomPasses",
            "removeTryCatchFinally",
            "init",
            "getSourceLine",
            "removeChangeHandler",
            "checkFirstModule",
            "init",
            "maybeSanityCheck",
            "recordFunctionInformation",
            "isTypeCheckingEnabled",
            "getRoot",
            "optimize",
            "normalize",
            "getAllInputsFromModules",
            "getTypeRegistry",
            "setPassConfig",
            "addChangeHandler",
            "throwInternalError",
            "getErrorCount",
            "Compiler",
            "getVariableMap",
            "parseSyntheticCode",
            "fillEmptyModules",
            "reportCodeChange",
            "Compiler",
            "Compiler",
            "setLoggingLevel",
            "process",
            "runSanityCheck",
            "reset",
            "getNodeForCodeInsertion",
            "setErrorManager",
            "areNodesEqualForInlining",
            "computeCFG",
            "newExternInput",
            "initInputsByNameMap",
            "isInliningForbidden",
            "precheck",
            "getCodingConvention",
            "report",
            "getFunctionalInformationMap",
            "compile",
            "check",
            "getOptions",
            "isIdeMode",
            "getLineIndex",
            "getWarningCount",
            "IntermediateState",
            "acquireSymbolTable",
            "getState",
            "getPassConfig",
            "createPassConfigInternal",
            "hasHaltingErrors",
            "compileInternal",
            "endsWith",
            "setUnnormalized",
            "createMessageFormatter",
            "rebuildInputsFromModules",
            "getReverseAbstractInterpreter",
            "getAstDotGraph",
            "append",
            "getSourceRegion",
            "initModules",
            "getSourceFileByName",
            "isNormalized",
            "runInCompilerThread",
            "toString",
            "getSourceMap",
            "toSource",
            "getCssRenamingMap",
            "addToDebugLog",
            "getErrorManager",
            "setNormalized",
            "makeCompilerInput",
            "parseTestCode",
            "toSource",
            "parseInputs"
          ],
          "num": 90
        },
        {
          "qualified_names": [
            "getModuleGraph",
            "toSource",
            "getOptions",
            "rebuildInputsFromModules",
            "setNormalized",
            "getParserConfig",
            "normalize",
            "getSourceFileByName",
            "check",
            "setLoggingLevel",
            "externExports",
            "newTracer",
            "getCssRenamingMap",
            "maybeSanityCheck",
            "Compiler",
            "initBasedOnOptions",
            "parseInputs",
            "parseTestCode",
            "parseSyntheticCode",
            "parse",
            "getFunctionalInformationMap",
            "runInCompilerThread",
            "initModules",
            "getState",
            "setState",
            "createMessageFormatter",
            "getAllInputsFromModules",
            "compile",
            "isInliningForbidden",
            "toSourceArray",
            "createPassConfigInternal",
            "removeTryCatchFinally",
            "compileModules",
            "addToDebugLog",
            "getReverseAbstractInterpreter",
            "getPropertyMap",
            "init",
            "getSourceMap",
            "stopTracer",
            "report",
            "Compiler",
            "checkFirstModule",
            "stripCode",
            "processDefines",
            "getNodeForCodeInsertion",
            "getInput",
            "setCssRenamingMap",
            "getResult",
            "compile",
            "runCustomPasses",
            "getVariableMap",
            "isIdeMode",
            "initCompilerOptionsIfTesting",
            "getCodingConvention",
            "compileInternal",
            "setUnnormalized",
            "areNodesEqualForInlining",
            "getErrorManager",
            "setHasRegExpGlobalReferences",
            "initOptions",
            "init",
            "initInputsByNameMap",
            "parseSyntheticCode",
            "toSource",
            "prepareAst",
            "compile",
            "recordFunctionInformation",
            "makeCompilerInput",
            "optimize",
            "fillEmptyModules",
            "addIncrementalSourceAst",
            "newExternInput",
            "runSanityCheck",
            "init",
            "hasRegExpGlobalReferences",
            "computeCFG",
            "isTypeCheckingEnabled",
            "endPass"
          ],
          "num": 78
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "22",
            "25",
            "26",
            "34",
            "38",
            "66",
            "67",
            "68",
            "69",
            "70",
            "71",
            "72",
            "77",
            "80",
            "83",
            "86",
            "99",
            "100",
            "101",
            "102",
            "103",
            "104",
            "105",
            "106",
            "107",
            "108",
            "111",
            "114",
            "131",
            "132",
            "133",
            "135",
            "138",
            "141",
            "159",
            "160",
            "167",
            "168",
            "169",
            "170",
            "171",
            "172",
            "182",
            "189",
            "190",
            "191",
            "199",
            "200",
            "201",
            "212",
            "213",
            "214",
            "215",
            "244",
            "245",
            "253",
            "254",
            "255",
            "256",
            "257",
            "268",
            "275",
            "276",
            "280",
            "288",
            "289",
            "290",
            "295",
            "296",
            "297",
            "298",
            "299",
            "316",
            "317",
            "319",
            "321",
            "324",
            "336",
            "344",
            "345",
            "346",
            "347",
            "363",
            "366",
            "380",
            "381",
            "383",
            "384",
            "389",
            "391",
            "392",
            "420",
            "447",
            "485",
            "538",
            "539",
            "543",
            "549",
            "554",
            "559",
            "580",
            "616",
            "625",
            "626",
            "627",
            "630",
            "634",
            "635",
            "636",
            "637",
            "638",
            "639",
            "650",
            "651",
            "652",
            "653",
            "654",
            "658",
            "664",
            "681",
            "682",
            "683",
            "691",
            "704",
            "713",
            "714",
            "715",
            "716",
            "717",
            "718",
            "719",
            "720",
            "721",
            "722",
            "723",
            "724",
            "725",
            "726",
            "727",
            "728",
            "729",
            "730",
            "731",
            "732",
            "733",
            "734",
            "735",
            "736",
            "737",
            "738",
            "739",
            "740",
            "744",
            "747",
            "779",
            "788",
            "796",
            "805",
            "806",
            "807",
            "808",
            "867",
            "875",
            "884",
            "894",
            "899",
            "904",
            "915",
            "920",
            "947",
            "973",
            "988",
            "990",
            "1000",
            "1008",
            "1020",
            "1026",
            "1027",
            "1048",
            "1057",
            "1069",
            "1070",
            "1072",
            "1118",
            "1122",
            "1203",
            "1207",
            "1208",
            "1220",
            "1221",
            "1243",
            "1244",
            "1245",
            "1310",
            "1318",
            "1319",
            "1320",
            "1321",
            "1322",
            "1323",
            "1324",
            "1325",
            "1326",
            "1327",
            "1328",
            "1329",
            "1330",
            "1331",
            "1332",
            "1333",
            "1334",
            "1335",
            "1336",
            "1337",
            "1338",
            "1339",
            "1340",
            "1341",
            "1342",
            "1343",
            "1344",
            "1345",
            "1346",
            "1347",
            "1348",
            "1349",
            "1350",
            "1351",
            "1352",
            "1353",
            "1354",
            "1355",
            "1356",
            "1357",
            "1358",
            "1359",
            "1360",
            "1361",
            "1362",
            "1363",
            "1364",
            "1365",
            "1366",
            "1367",
            "1368",
            "1369",
            "1370",
            "1371",
            "1372",
            "1373",
            "1374",
            "1375",
            "1376",
            "1377",
            "1378",
            "1379",
            "1380",
            "1381",
            "1382",
            "1383",
            "1384",
            "1385",
            "1386",
            "1387",
            "1388",
            "1389",
            "1390",
            "1391",
            "1392",
            "1393",
            "1394",
            "1395",
            "1396",
            "1397",
            "1398",
            "1399",
            "1400",
            "1401",
            "1402",
            "1403",
            "1404",
            "1405",
            "1406",
            "1407",
            "1408",
            "1409",
            "1410",
            "1411",
            "1412",
            "1413",
            "1414",
            "1415",
            "1416",
            "1417",
            "1418",
            "1419",
            "1420",
            "1421",
            "1422",
            "1423",
            "1424",
            "1425",
            "1426",
            "1427",
            "1428",
            "1429",
            "1430",
            "1431",
            "1432",
            "1433",
            "1434",
            "1435",
            "1436",
            "1437",
            "1438",
            "1439",
            "1440",
            "1441",
            "1442",
            "1443",
            "1444",
            "1445",
            "1446",
            "1447",
            "1448",
            "1449",
            "1450",
            "1451",
            "1452",
            "1453",
            "1454",
            "1455",
            "1456",
            "1457",
            "1458",
            "1459",
            "1460",
            "1461",
            "1462",
            "1463",
            "1464",
            "1465",
            "1466",
            "1467",
            "1468",
            "1469",
            "1470",
            "1475",
            "1480",
            "1481",
            "1482",
            "1483",
            "1484",
            "1485",
            "1486",
            "1487",
            "1488",
            "1489",
            "1490",
            "1501",
            "1505",
            "1506",
            "1507",
            "1508",
            "1509",
            "1510",
            "1511",
            "1512",
            "1513",
            "1514",
            "1515",
            "1516",
            "1517",
            "1518",
            "1519",
            "1520",
            "1521",
            "1522",
            "1523",
            "1524",
            "1525",
            "1526",
            "1527",
            "1528",
            "1529",
            "1530",
            "1531",
            "1532",
            "1533",
            "1534",
            "1535",
            "1536",
            "1537",
            "1538",
            "1539",
            "1540",
            "1541",
            "1542",
            "1543",
            "1544",
            "1545",
            "1546",
            "1547",
            "1548",
            "1549",
            "1550",
            "1551",
            "1552",
            "1553",
            "1554",
            "1555",
            "1556",
            "1557",
            "1558",
            "1559",
            "1560",
            "1561",
            "1562",
            "1563",
            "1564",
            "1566",
            "1567",
            "1573",
            "1581",
            "1582",
            "1583",
            "1584",
            "1585",
            "1586",
            "1587",
            "1588",
            "1589",
            "1590",
            "1591",
            "1592",
            "1593",
            "1594",
            "1595",
            "1596",
            "1597",
            "1598",
            "1599",
            "1600",
            "1601",
            "1602",
            "1603",
            "1604",
            "1605",
            "1606",
            "1607",
            "1608",
            "1609",
            "1610",
            "1611",
            "1612",
            "1613",
            "1614",
            "1615",
            "1616",
            "1617",
            "1618",
            "1620",
            "1627",
            "1628",
            "1629",
            "1630",
            "1631",
            "1632",
            "1633",
            "1634",
            "1636",
            "1637",
            "1638",
            "1639",
            "1640",
            "1641",
            "1642",
            "1643",
            "1645",
            "1646",
            "1647",
            "1648",
            "1649",
            "1650",
            "1651",
            "1652",
            "1653",
            "1654",
            "1655",
            "1656",
            "1657",
            "1658",
            "1659",
            "1660",
            "1661",
            "1662",
            "1663",
            "1664",
            "1665",
            "1666",
            "1667",
            "1668",
            "1669",
            "1670",
            "1671",
            "1672",
            "1673",
            "1674",
            "1675",
            "1676",
            "1677",
            "1678",
            "1679",
            "1680",
            "1681",
            "1682",
            "1683",
            "1684",
            "1685",
            "1686",
            "1687",
            "1688",
            "1689",
            "1690",
            "1691",
            "1692",
            "1693",
            "1694",
            "1695",
            "1696",
            "1697",
            "1698",
            "1699",
            "1700",
            "1701",
            "1702",
            "1703",
            "1704",
            "1705",
            "1706",
            "1707",
            "1708",
            "1709",
            "1710",
            "1711",
            "1712",
            "1713",
            "1714",
            "1715",
            "1716",
            "1717",
            "1718",
            "1719",
            "1720",
            "1721",
            "1722",
            "1723",
            "1724",
            "1725",
            "1726",
            "1727",
            "1728",
            "1729",
            "1730",
            "1731",
            "1732",
            "1733",
            "1734",
            "1738",
            "1741",
            "1743",
            "1776",
            "1777",
            "1778",
            "1779",
            "1780",
            "1781",
            "1786",
            "1791",
            "1800",
            "1802",
            "1867",
            "1868",
            "1869",
            "1873",
            "1874",
            "1908",
            "1912",
            "1913",
            "1914",
            "1915",
            "1916",
            "1919",
            "1920",
            "1921",
            "1922",
            "1923",
            "1929",
            "1933",
            "1937",
            "1941",
            "1945",
            "1952",
            "1967",
            "1987",
            "1988",
            "1989",
            "1990",
            "2005",
            "2006",
            "2007",
            "2008",
            "2023",
            "2024",
            "2025",
            "2026"
          ],
          "num": 616
        },
        {
          "qualified_names": [
            "22",
            "28",
            "29",
            "64",
            "69",
            "72",
            "75",
            "78",
            "91",
            "94",
            "97",
            "114",
            "115",
            "116",
            "117",
            "118",
            "119",
            "121",
            "124",
            "127",
            "130",
            "161",
            "164",
            "165",
            "170",
            "171",
            "178",
            "179",
            "180",
            "219",
            "220",
            "221",
            "222",
            "223",
            "224",
            "225",
            "226",
            "227",
            "228",
            "229",
            "230",
            "231",
            "232",
            "233",
            "234",
            "235",
            "236",
            "237",
            "238",
            "239",
            "247",
            "248",
            "249",
            "250",
            "251",
            "252",
            "253",
            "254",
            "255",
            "256",
            "257",
            "258",
            "259",
            "260",
            "261",
            "262",
            "273",
            "274",
            "278",
            "279",
            "280",
            "281",
            "282",
            "283",
            "284",
            "285",
            "286",
            "287",
            "288",
            "289",
            "292",
            "294",
            "295",
            "299",
            "307",
            "308",
            "313",
            "314",
            "315",
            "316",
            "317",
            "318",
            "319",
            "320",
            "321",
            "322",
            "323",
            "324",
            "325",
            "326",
            "327",
            "344",
            "345",
            "347",
            "349",
            "352",
            "353",
            "354",
            "355",
            "356",
            "357",
            "358",
            "359",
            "360",
            "361",
            "362",
            "363",
            "364",
            "376",
            "384",
            "385",
            "386",
            "387",
            "403",
            "406",
            "420",
            "421",
            "423",
            "424",
            "429",
            "431",
            "432",
            "460",
            "461",
            "462",
            "463",
            "464",
            "465",
            "466",
            "467",
            "468",
            "469",
            "492",
            "493",
            "494",
            "495",
            "496",
            "497",
            "498",
            "499",
            "500",
            "501",
            "506",
            "544",
            "597",
            "598",
            "599",
            "603",
            "609",
            "614",
            "619",
            "622",
            "623",
            "624",
            "625",
            "644",
            "680",
            "689",
            "690",
            "691",
            "694",
            "698",
            "699",
            "700",
            "701",
            "702",
            "703",
            "717",
            "723",
            "740",
            "741",
            "742",
            "746",
            "747",
            "748",
            "749",
            "754",
            "767",
            "779",
            "782",
            "814",
            "823",
            "831",
            "840",
            "841",
            "842",
            "843",
            "844",
            "904",
            "913",
            "923",
            "924",
            "925",
            "926",
            "927",
            "928",
            "929",
            "930",
            "931",
            "932",
            "933",
            "934",
            "944",
            "949",
            "954",
            "965",
            "970",
            "997",
            "1023",
            "1038",
            "1040",
            "1050",
            "1058",
            "1070",
            "1076",
            "1077",
            "1099",
            "1108",
            "1112",
            "1113",
            "1114",
            "1115",
            "1116",
            "1117",
            "1118",
            "1119",
            "1122",
            "1127",
            "1130",
            "1131",
            "1133",
            "1179",
            "1183",
            "1264",
            "1268",
            "1269",
            "1270",
            "1271",
            "1272",
            "1273",
            "1274",
            "1275",
            "1276",
            "1277",
            "1278",
            "1279",
            "1291",
            "1292",
            "1313",
            "1314",
            "1316",
            "1317",
            "1318",
            "1319",
            "1384",
            "1396",
            "1401",
            "1412",
            "1417",
            "1418",
            "1424",
            "1433",
            "1441",
            "1442",
            "1443",
            "1445",
            "1449",
            "1452",
            "1453",
            "1455",
            "1488",
            "1489",
            "1490",
            "1495",
            "1496",
            "1497",
            "1498",
            "1499",
            "1500",
            "1501",
            "1502",
            "1503",
            "1504",
            "1509",
            "1518",
            "1520",
            "1585",
            "1586",
            "1587",
            "1591",
            "1592",
            "1626",
            "1632",
            "1633",
            "1634",
            "1635",
            "1641",
            "1645",
            "1649",
            "1653",
            "1657",
            "1664",
            "1680",
            "1681",
            "1682",
            "1702",
            "1703",
            "1704",
            "1719",
            "1720",
            "1721",
            "1736",
            "1737",
            "1738",
            "1744",
            "1745",
            "1746",
            "1747",
            "1748",
            "1749",
            "1750",
            "1751",
            "1752",
            "1753"
          ],
          "num": 334
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 803266c..0104062 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -19,23 +19,21 @@\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Supplier;\n-import com.google.common.base.Tracer;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n-import com.google.common.flags.Flag;\n-import com.google.common.flags.FlagSpec;\n import com.google.javascript.jscomp.CompilerOptions.DevMode;\n import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n+import com.google.javascript.jscomp.parsing.Config;\n+import com.google.javascript.jscomp.parsing.ParserRunner;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n-import java.io.FileReader;\n import java.io.IOException;\n import java.io.PrintStream;\n import java.io.Serializable;\n-import java.text.ParseException;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n@@ -63,27 +61,21 @@\n *\n  */\n public class Compiler extends AbstractCompiler {\n-  @FlagSpec(help \u003d \"As part of the aliasing pass, outputs all strings and \" +\n-                   \"the number of times they were used in the application to \" +\n-                   \"the server log.\")\n-  public static final Flag\u003cBoolean\u003e FLAG_output_js_string_usage \u003d\n-      Flag.value(false);\n-\n-  CompilerOptions options_ \u003d createDefaultOptions();\n+  CompilerOptions options \u003d null;\n \n   private PassConfig passes \u003d null;\n \n   // The externs inputs\n-  private CompilerInput[] externs_;\n+  private List\u003cCompilerInput\u003e externs;\n \n   // The JS source modules\n-  private JSModule[] modules_;\n+  private List\u003cJSModule\u003e modules;\n \n   // The graph of the JS source modules\n-  private JSModuleGraph moduleGraph_;\n+  private JSModuleGraph moduleGraph;\n \n   // The JS source inputs\n-  private CompilerInput[] inputs_;\n+  private List\u003cCompilerInput\u003e inputs;\n \n   // error manager to which error management is delegated\n   private ErrorManager errorManager;\n@@ -96,22 +88,13 @@\n   Node jsRoot;\n   Node externAndJsRoot;\n \n-  private Map\u003cString, CompilerInput\u003e inputsByName_;\n-\n-  /** Fully qualified function names and globally unique ids */\n-  private FunctionNames functionNames_;\n-\n-  /** The variable renaming map */\n-  private VariableMap variableMap_;\n-\n-  /** The property renaming map */\n-  private VariableMap propertyMap_;\n+  private Map\u003cString, CompilerInput\u003e inputsByName;\n \n   /** The source code map */\n-  private SourceMap sourceMap_;\n+  private SourceMap sourceMap;\n \n   /** The externs created from the exports.  */\n-  private String externExports_ \u003d null;\n+  private String externExports \u003d null;\n \n   /**\n    * Ids for function inlining so that each declared name remains\n@@ -128,19 +111,23 @@\n   /** Whether to use threads. */\n   private boolean useThreads \u003d true;\n \n-  /** The naming map for anonymous functions */\n-  private VariableMap anonFunctionNameMap_;\n-\n+  /** \n+   * Whether to assume there are references to the RegExp Global object\n+   * properties.\n+   */\n+  private boolean hasRegExpGlobalReferences \u003d true;\n+  \n   /** The function information map */\n-  private FunctionInformationMap functionInformationMap_;\n+  private FunctionInformationMap functionInformationMap;\n \n   /** Debugging information */\n-  private final StringBuilder debugLog_ \u003d new StringBuilder();\n+  private final StringBuilder debugLog \u003d new StringBuilder();\n \n   /** Detects Google-specific coding conventions. */\n-  private CodingConvention codingConvention \u003d new GoogleCodingConvention();\n+  CodingConvention defaultCodingConvention \u003d new GoogleCodingConvention();\n \n   private JSTypeRegistry typeRegistry;\n+  private Config parserConfig \u003d null;\n \n   private ReverseAbstractInterpreter abstractInterpreter;\n   private final TypeValidator typeValidator;\n@@ -156,20 +143,12 @@\n       RhinoErrorReporter.forNewRhino(this);\n \n   /** Error strings used for reporting JSErrors */\n-  public static final DiagnosticType READ_ERROR \u003d DiagnosticType.error(\n-      \"JSC_READ_ERROR\", \"Cannot read: {0}\");\n   public static final DiagnosticType OPTIMIZE_LOOP_ERROR \u003d DiagnosticType.error(\n       \"JSC_OPTIMIZE_LOOP_ERROR\",\n       \"Exceeded max number of optimization iterations: {0}\");\n   public static final DiagnosticType MOTION_ITERATIONS_ERROR \u003d\n       DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n           \"Exceeded max number of code motion iterations: {0}\");\n-  private static final DiagnosticType INPUT_MAP_PROP_PARSE \u003d\n-      DiagnosticType.error(\"JSC_INPUT_MAP_PROP_PARSE\",\n-          \"Input property map parse error: {0}\");\n-  private static final DiagnosticType INPUT_VAR_PROP_PARSE \u003d\n-      DiagnosticType.error(\"JSC_INPUT_MAP_VAR_PARSE\",\n-          \"Input variable map parse error: {0}\");\n \n   private static final long COMPILER_STACK_SIZE \u003d 1048576L;\n \n@@ -179,16 +158,16 @@\n    * setting configuration for this logger affects all loggers\n    *  in other classes within the compiler.\n    */\n-  private static final Logger logger_ \u003d\n+  private static final Logger logger \u003d\n       Logger.getLogger(\"com.google.javascript.jscomp\");\n \n+  private final PrintStream outStream;\n+\n   /**\n    * Creates a Compiler that reports errors and warnings to its logger.\n    */\n   public Compiler() {\n-    addChangeHandler(recentChange);\n-    this.typeValidator \u003d new TypeValidator(this);\n-    setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger_));\n+    this((PrintStream) null);\n   }\n \n   /**\n@@ -196,9 +175,9 @@\n    * stream.\n    */\n   public Compiler(PrintStream stream) {\n-    this();\n-    setErrorManager(\n-        new PrintStreamErrorManager(createMessageFormatter(), stream));\n+    addChangeHandler(recentChange);\n+    this.typeValidator \u003d new TypeValidator(this);\n+    outStream \u003d stream;\n   }\n \n   /**\n@@ -209,10 +188,6 @@\n     setErrorManager(errorManager);\n   }\n \n-  CompilerOptions createDefaultOptions() {\n-    return new CompilerOptions();\n-  }\n-\n   /**\n    * Acquires the symbol table.\n    */\n@@ -241,8 +216,27 @@\n    * {@link CompilerOptions}.\n    */\n   private MessageFormatter createMessageFormatter() {\n-    boolean colorize \u003d options_.shouldColorizeErrorOutput();\n-    return options_.errorFormat.toFormatter(this, colorize);\n+    boolean colorize \u003d options.shouldColorizeErrorOutput();\n+    return options.errorFormat.toFormatter(this, colorize);\n+  }\n+\n+  /**\n+   * Initialize the compiler options. Only necessary if you\u0027re not doing\n+   * a normal compile() job.\n+   */\n+  public void initOptions(CompilerOptions options) {\n+    this.options \u003d options;\n+    if (errorManager \u003d\u003d null) {\n+      if (outStream \u003d\u003d null) {\n+        setErrorManager(\n+            new LoggerErrorManager(createMessageFormatter(), logger));\n+      } else {\n+        PrintStreamErrorManager printer \u003d\n+            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n+        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n+        setErrorManager(printer);\n+      }\n+    }\n   }\n \n   /**\n@@ -250,11 +244,22 @@\n    */\n   public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n       CompilerOptions options) {\n-    externs_ \u003d makeCompilerInput(externs, true);\n-    modules_ \u003d null;\n-    moduleGraph_ \u003d null;\n-    inputs_ \u003d makeCompilerInput(inputs, false);\n-    options_ \u003d options;\n+    init(Lists.\u003cJSSourceFile\u003enewArrayList(externs),\n+        Lists.\u003cJSSourceFile\u003enewArrayList(inputs), options);\n+  }\n+\n+  /**\n+   * Initializes the instance state needed for a compile job.\n+   */\n+  public void init(List\u003cJSSourceFile\u003e externs, List\u003cJSSourceFile\u003e inputs,\n+      CompilerOptions options) {\n+    initOptions(options);\n+    \n+    this.externs \u003d makeCompilerInput(externs, true);\n+    this.modules \u003d null;\n+    this.moduleGraph \u003d null;\n+    this.inputs \u003d makeCompilerInput(inputs, false);\n+    initBasedOnOptions();\n \n     initInputsByNameMap();\n   }\n@@ -265,19 +270,33 @@\n               + \"Modules must be listed in dependency order.\");\n \n   /**\n-   * Initializes the instance state needed for a compile job.\n+   * Initializes the instance state needed for a compile job if the sources\n+   * are in modules.\n    */\n   public void init(JSSourceFile[] externs, JSModule[] modules,\n       CompilerOptions options) {\n+    initModules(Lists.\u003cJSSourceFile\u003enewArrayList(externs),\n+         Lists.\u003cJSModule\u003enewArrayList(modules), options);\n+  }\n+  \n+  /**\n+   * Initializes the instance state needed for a compile job if the sources\n+   * are in modules.\n+   */\n+  public void initModules(\n+      List\u003cJSSourceFile\u003e externs, List\u003cJSModule\u003e modules,\n+      CompilerOptions options) {\n+    initOptions(options);\n \n     checkFirstModule(modules);\n+    fillEmptyModules(modules);\n \n-    externs_ \u003d makeCompilerInput(externs, true);\n-    modules_ \u003d modules;\n+    this.externs \u003d makeCompilerInput(externs, true);\n+    this.modules \u003d modules;\n     // Generate the module graph, and report any errors in the module\n     // specification as errors.\n     try {\n-      moduleGraph_ \u003d new JSModuleGraph(modules);\n+      this.moduleGraph \u003d new JSModuleGraph(modules);\n     } catch (JSModuleGraph.ModuleDependenceException e) {\n       // problems with the module format.  Report as an error.  The\n       // message gives all details.\n@@ -285,18 +304,27 @@\n           e.getModule().getName(), e.getDependentModule().getName()));\n       return;\n     }\n-    inputs_ \u003d getAllInputsFromModules();\n-    options_ \u003d options;\n-\n+    this.inputs \u003d getAllInputsFromModules();\n+    initBasedOnOptions();\n \n     initInputsByNameMap();\n   }\n \n-  private CompilerInput[] makeCompilerInput(\n-      JSSourceFile[] files, boolean isExtern) {\n-    CompilerInput [] inputs \u003d new CompilerInput[files.length];\n-    for (int i \u003d 0; i \u003c files.length; ++i) {\n-      inputs[i] \u003d new CompilerInput(files[i], isExtern);\n+  /**\n+   * Do any initialization that is dependent on the compiler options.\n+   */\n+  private void initBasedOnOptions() {\n+    // Create the source map if necessary.\n+    if (options.sourceMapOutputPath !\u003d null) {\n+      sourceMap \u003d new SourceMap();\n+    }\n+  }\n+\n+  private List\u003cCompilerInput\u003e makeCompilerInput(\n+      List\u003cJSSourceFile\u003e files, boolean isExtern) {\n+    List\u003cCompilerInput\u003e inputs \u003d Lists.newArrayList();\n+    for (JSSourceFile file : files) {\n+      inputs.add(new CompilerInput(file, isExtern));\n     }\n     return inputs;\n   }\n@@ -313,15 +341,27 @@\n    * Verifies that at least one module has been provided and that the first one\n    * has at least one source code input.\n    */\n-  private void checkFirstModule(JSModule[] modules) {\n-    if (modules.length \u003d\u003d 0) {\n+  private void checkFirstModule(List\u003cJSModule\u003e modules) {\n+    if (modules.isEmpty()) {\n       report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n-    } else if (modules[0].getInputs().isEmpty()) {\n+    } else if (modules.get(0).getInputs().isEmpty()) {\n       report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n-          modules[0].getName()));\n+          modules.get(0).getName()));\n     }\n   }\n-\n+  \n+  /**\n+   * Fill any empty modules with a place holder file. It makes any cross module\n+   * motion easier.\n+   */\n+  private void fillEmptyModules(List\u003cJSModule\u003e modules) {\n+    for (JSModule module : modules) {\n+      if (module.getInputs().isEmpty()) {\n+        module.add(JSSourceFile.fromCode(\"[\" + module.getName() + \"]\", \"\"));\n+      }\n+    }\n+  }\n+  \n   static final DiagnosticType DUPLICATE_INPUT_IN_MODULES \u003d\n       DiagnosticType.error(\"JSC_DUPLICATE_INPUT_IN_MODULES_ERROR\",\n           \"Two modules cannot contain the same input, but module {0} and {1} \"\n@@ -333,7 +373,7 @@\n    * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.\n    */\n   public void rebuildInputsFromModules() {\n-    inputs_ \u003d getAllInputsFromModules();\n+    inputs \u003d getAllInputsFromModules();\n     initInputsByNameMap();\n   }\n \n@@ -341,10 +381,10 @@\n    * Builds a single list of all module inputs. Verifies that it contains no\n    * duplicates.\n    */\n-  private CompilerInput[] getAllInputsFromModules() {\n-    List\u003cCompilerInput\u003e inputs \u003d new ArrayList\u003cCompilerInput\u003e();\n-    Map\u003cString, JSModule\u003e inputMap \u003d new HashMap\u003cString, JSModule\u003e();\n-    for (JSModule module : modules_) {\n+  private List\u003cCompilerInput\u003e getAllInputsFromModules() {\n+    List\u003cCompilerInput\u003e inputs \u003d Lists.newArrayList();\n+    Map\u003cString, JSModule\u003e inputMap \u003d Maps.newHashMap();\n+    for (JSModule module : modules) {\n       for (CompilerInput input : module.getInputs()) {\n         String inputName \u003d input.getName();\n         JSModule firstModule \u003d inputMap.get(inputName);\n@@ -360,10 +400,10 @@\n     if (hasErrors()) {\n \n       // There\u0027s no reason to bother parsing the code.\n-      return new CompilerInput[0];\n+      return ImmutableList.of();\n     }\n \n-    return inputs.toArray(new CompilerInput[inputs.size()]);\n+    return inputs;\n   }\n \n   static final DiagnosticType DUPLICATE_INPUT \u003d\n@@ -377,19 +417,19 @@\n    * duplicate inputs.\n    */\n   void initInputsByNameMap() {\n-    inputsByName_ \u003d new HashMap\u003cString, CompilerInput\u003e();\n-    for (CompilerInput input : externs_) {\n+    inputsByName \u003d new HashMap\u003cString, CompilerInput\u003e();\n+    for (CompilerInput input : externs) {\n       String name \u003d input.getName();\n-      if (!inputsByName_.containsKey(name)) {\n-        inputsByName_.put(name, input);\n+      if (!inputsByName.containsKey(name)) {\n+        inputsByName.put(name, input);\n       } else {\n         report(JSError.make(DUPLICATE_EXTERN_INPUT, name));\n       }\n     }\n-    for (CompilerInput input : inputs_) {\n+    for (CompilerInput input : inputs) {\n       String name \u003d input.getName();\n-      if (!inputsByName_.containsKey(name)) {\n-        inputsByName_.put(name, input);\n+      if (!inputsByName.containsKey(name)) {\n+        inputsByName.put(name, input);\n       } else {\n         report(JSError.make(DUPLICATE_INPUT, name));\n       }\n@@ -417,7 +457,16 @@\n   public Result compile(JSSourceFile[] externs,\n                         JSSourceFile[] inputs,\n                         CompilerOptions options) {\n-\n+    return compile(Lists.\u003cJSSourceFile\u003enewArrayList(externs),\n+        Lists.\u003cJSSourceFile\u003enewArrayList(inputs),\n+        options);\n+  }\n+  \n+  /**\n+   * Compiles a list of inputs.\n+   */\n+  public Result compile(List\u003cJSSourceFile\u003e externs,\n+      List\u003cJSSourceFile\u003e inputs, CompilerOptions options) {\n     // The compile method should only be called once.\n     Preconditions.checkState(jsRoot \u003d\u003d null);\n \n@@ -440,11 +489,21 @@\n   public Result compile(JSSourceFile[] externs,\n                         JSModule[] modules,\n                         CompilerOptions options) {\n+    return compileModules(Lists.\u003cJSSourceFile\u003enewArrayList(externs),\n+        Lists.\u003cJSModule\u003enewArrayList(modules),\n+        options);\n+  }\n+\n+  /**\n+   * Compiles a list of modules.\n+   */\n+  public Result compileModules(List\u003cJSSourceFile\u003e externs,\n+      List\u003cJSModule\u003e modules, CompilerOptions options) {\n     // The compile method should only be called once.\n     Preconditions.checkState(jsRoot \u003d\u003d null);\n \n     try {\n-      init(externs, modules, options);\n+      initModules(externs, modules, options);\n       if (hasErrors()) {\n         return getResult();\n       }\n@@ -482,7 +541,7 @@\n     // increase the stack size for *every* thread (which is what -Xss does).\n     // Might want to add thread pool support for clients that compile a lot.\n \n-    final boolean dumpTraceReport \u003d options_.tracer.isOn();\n+    final boolean dumpTraceReport \u003d options.tracer.isOn();\n     final Object[] result \u003d new Object[1];\n     final Throwable[] exception \u003d new Throwable[1];\n     Runnable runnable \u003d new Runnable() {\n@@ -535,30 +594,35 @@\n       return;\n     }\n \n-    if (options_.nameAnonymousFunctionsOnly) {\n-      nameAnonymousFunctions(options_.anonymousFunctionNaming);\n+    if (options.nameAnonymousFunctionsOnly) {\n+      // TODO(nicksantos): Move this into an instrument() phase maybe?\n+      check();\n       return;\n     }\n \n-    if (!options_.skipAllPasses) {\n+    if (!options.skipAllPasses) {\n       check();\n       if (hasErrors()) {\n         return;\n       }\n \n-      if (options_.externExportsPath !\u003d null) {\n+      if (options.externExportsPath !\u003d null) {\n         externExports();\n       }\n \n       // IDE-mode is defined to stop here, before the heavy rewriting begins.\n-      if (!options_.ideMode) {\n+      if (!options.ideMode) {\n         optimize();\n       }\n     }\n \n-    if (options_.recordFunctionInformation) {\n+    if (options.recordFunctionInformation) {\n       recordFunctionInformation();\n     }\n+\n+    if (options.devMode \u003d\u003d DevMode.START_AND_END) {\n+      runSanityCheck();\n+    }\n   }\n \n   public void parse() {\n@@ -577,7 +641,7 @@\n    * overriding this.\n    */\n   PassConfig createPassConfigInternal() {\n-    return new DefaultPassConfig(options_);\n+    return new DefaultPassConfig(options);\n   }\n \n   /**\n@@ -613,7 +677,7 @@\n     runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n \n     PhaseOptimizer phaseOptimizer \u003d new PhaseOptimizer(this, tracker);\n-    if (options_.devMode \u003d\u003d DevMode.EVERY_PASS) {\n+    if (options.devMode \u003d\u003d DevMode.EVERY_PASS) {\n       phaseOptimizer.setSanityCheck(sanityCheck);\n     }\n     phaseOptimizer.consume(getPassConfig().getChecks());\n@@ -622,21 +686,21 @@\n       return;\n     }\n \n-    if (options_.instrumentationTemplate !\u003d null ||\n-        options_.recordFunctionInformation) {\n-      computeFunctionNames();\n+    // TODO(nicksantos): clean this up. The flow here is too hard to follow.\n+    if (options.nameAnonymousFunctionsOnly) {\n+      return;\n     }\n \n-    if (options_.removeTryCatchFinally) {\n+    if (options.removeTryCatchFinally) {\n       removeTryCatchFinally();\n     }\n \n-    if (!options_.stripTypes.isEmpty() ||\n-        !options_.stripNameSuffixes.isEmpty() ||\n-        !options_.stripTypePrefixes.isEmpty() ||\n-        !options_.stripNamePrefixes.isEmpty()) {\n-      stripCode(options_.stripTypes, options_.stripNameSuffixes,\n-          options_.stripTypePrefixes, options_.stripNamePrefixes);\n+    if (!options.stripTypes.isEmpty() ||\n+        !options.stripNameSuffixes.isEmpty() ||\n+        !options.stripTypePrefixes.isEmpty() ||\n+        !options.stripNamePrefixes.isEmpty()) {\n+      stripCode(options.stripTypes, options.stripNameSuffixes,\n+          options.stripTypePrefixes, options.stripNamePrefixes);\n     }\n \n     runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n@@ -647,21 +711,16 @@\n     // 2) ReplaceMessages, stripCode, and potentially custom passes rely on\n     // unmodified local names.\n     normalize();\n-\n-    // Create the source map if necessary.\n-    if (options_.sourceMapOutputPath !\u003d null) {\n-      this.sourceMap_ \u003d new SourceMap();\n-    }\n   }\n \n   private void externExports() {\n-    logger_.info(\"Creating extern file for exports\");\n+    logger.info(\"Creating extern file for exports\");\n     startPass(\"externExports\");\n \n     ExternExportsPass pass \u003d new ExternExportsPass(this);\n     process(pass);\n \n-    externExports_ \u003d pass.getGeneratedExterns();\n+    externExports \u003d pass.getGeneratedExterns();\n \n     endPass();\n   }\n@@ -678,17 +737,21 @@\n     }\n   };\n \n-  private void maybeSanityCheck(String passName) {\n-    if (options_.devMode \u003d\u003d DevMode.EVERY_PASS) {\n-      sanityCheck.create(this).process(null, jsRoot);\n+  private void maybeSanityCheck() {\n+    if (options.devMode \u003d\u003d DevMode.EVERY_PASS) {\n+      runSanityCheck();\n     }\n   }\n \n+  private void runSanityCheck() {\n+    sanityCheck.create(this).process(externsRoot, jsRoot);\n+  }\n+\n   /**\n    * Removes try/catch/finally statements for easier debugging.\n    */\n   void removeTryCatchFinally() {\n-    logger_.info(\"Remove try/catch/finally\");\n+    logger.info(\"Remove try/catch/finally\");\n     startPass(\"removeTryCatchFinally\");\n     RemoveTryCatch r \u003d new RemoveTryCatch(this);\n     process(r);\n@@ -701,7 +764,7 @@\n    */\n   void stripCode(Set\u003cString\u003e stripTypes, Set\u003cString\u003e stripNameSuffixes,\n       Set\u003cString\u003e stripTypePrefixes, Set\u003cString\u003e stripNamePrefixes) {\n-    logger_.info(\"Strip code\");\n+    logger.info(\"Strip code\");\n     startPass(\"stripCode\");\n     StripCode r \u003d new StripCode(this, stripTypes, stripNameSuffixes,\n         stripTypePrefixes, stripNamePrefixes);\n@@ -710,41 +773,13 @@\n   }\n \n   /**\n-   * Alias string literals with global variables, to avoid creating lots of\n-   * transient objects.\n-   */\n-  private void aliasStrings(Set\u003cString\u003e aliasableStrings,\n-                            boolean aliasAllStrings,\n-                            String aliasStringsBlacklist,\n-                            boolean outputStringUsage) {\n-    logger_.info(\"Aliasing strings\");\n-    startPass(\"aliasStrings\");\n-    AliasStrings aliasStrings \u003d new AliasStrings(\n-        this,\n-        getModuleGraph(),\n-        aliasAllStrings ? null : aliasableStrings,\n-        aliasStringsBlacklist,\n-        outputStringUsage);\n-    process(aliasStrings);\n-    endPass();\n-  }\n-\n-  private void aliasKeywords() {\n-    logger_.info(\"Aliasing true/false/null\");\n-    startPass(\"aliasKeywords\");\n-    AliasKeywords aliasKeywords \u003d new AliasKeywords(this);\n-    process(aliasKeywords);\n-    endPass();\n-  }\n-\n-  /**\n    * Runs custom passes that are designated to run at a particular time.\n    */\n   private void runCustomPasses(CustomPassExecutionTime executionTime) {\n-    if (options_.customPasses !\u003d null) {\n+    if (options.customPasses !\u003d null) {\n       Tracer t \u003d newTracer(\"runCustomPasses\");\n       try {\n-        for (CompilerPass p : options_.customPasses.get(executionTime)) {\n+        for (CompilerPass p : options.customPasses.get(executionTime)) {\n           process(p);\n         }\n       } finally {\n@@ -776,7 +811,7 @@\n     currentPassName \u003d null;\n     currentTracer \u003d null;\n \n-    maybeSanityCheck(passToCheck);\n+    maybeSanityCheck();\n   }\n \n   /**\n@@ -785,7 +820,7 @@\n   Tracer newTracer(String passName) {\n     String comment \u003d passName\n         + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n-    if (options_.tracer.isOn()) {\n+    if (options.tracer.isOn()) {\n       tracker.recordPassStart(passName);\n     }\n     return new Tracer(\"Compiler\", comment);\n@@ -793,7 +828,7 @@\n \n   void stopTracer(Tracer t, String passName) {\n     long result \u003d t.stop();\n-    if (options_.tracer.isOn()) {\n+    if (options.tracer.isOn()) {\n       tracker.recordPassStop(passName, result);\n     }\n   }\n@@ -802,10 +837,11 @@\n    * Returns the result of the compilation.\n    */\n   public Result getResult() {\n-    return new Result(getErrors(), getWarnings(), debugLog_.toString(),\n-                      variableMap_, propertyMap_, anonFunctionNameMap_,\n-                      functionInformationMap_, sourceMap_, externExports_,\n-                      getPassConfig().getCssNames());\n+    PassConfig.State state \u003d getPassConfig().getIntermediateState();\n+    return new Result(getErrors(), getWarnings(), debugLog.toString(),\n+        state.variableMap, state.propertyMap,\n+        state.anonymousFunctionNameMap, functionInformationMap,\n+        sourceMap, externExports, state.cssNames);\n   }\n \n   /**\n@@ -865,6 +901,7 @@\n    * Set if the normalization pass has been done.\n    * Note: non-private to enable test cases that require the Normalize pass.\n    */\n+  @Override\n   void setNormalized() {\n     normalized \u003d true;\n   }\n@@ -873,6 +910,7 @@\n    * Set once unnormalizing passes have been start.\n    * Note: non-private to enable test cases that require the Normalize pass.\n    */\n+  @Override\n   void setUnnormalized() {\n     normalized \u003d false;\n   }\n@@ -882,6 +920,18 @@\n     return normalized;\n   }\n \n+  @Override\n+  boolean areNodesEqualForInlining(Node n1, Node n2) {\n+    if (options.ambiguateProperties ||\n+        options.disambiguateProperties) {\n+      // The type based optimizations require that type information is preserved\n+      // during other optimizations.\n+      return n1.checkTreeTypeAwareEqualsSilent(n2);\n+    } else {\n+      return n1.checkTreeEqualsSilent(n2);\n+    }\n+  }\n+\n   //------------------------------------------------------------------------\n   // Inputs\n   //------------------------------------------------------------------------\n@@ -891,17 +941,17 @@\n \n   @Override\n   public CompilerInput getInput(String name) {\n-    return inputsByName_.get(name);\n+    return inputsByName.get(name);\n   }\n \n   @Override\n   public CompilerInput newExternInput(String name) {\n-    if (inputsByName_.containsKey(name)) {\n+    if (inputsByName.containsKey(name)) {\n       throw new IllegalArgumentException(\"Conflicting externs name: \" + name);\n     }\n     SourceAst ast \u003d new SyntheticAst(name);\n     CompilerInput input \u003d new CompilerInput(ast, name, true);\n-    inputsByName_.put(name, input);\n+    inputsByName.put(name, input);\n     externsRoot.addChildToFront(ast.getAstRoot(this));\n     return input;\n   }\n@@ -912,12 +962,12 @@\n     Preconditions.checkState(\n         getInput(sourceName) \u003d\u003d null,\n         \"Duplicate input of name \" + sourceName);\n-    inputsByName_.put(sourceName, new CompilerInput(ast));\n+    inputsByName.put(sourceName, new CompilerInput(ast));\n   }\n \n   @Override\n   JSModuleGraph getModuleGraph() {\n-    return moduleGraph_;\n+    return moduleGraph;\n   }\n \n   @Override\n@@ -944,7 +994,7 @@\n       ChainableReverseAbstractInterpreter interpreter \u003d\n           new SemanticReverseAbstractInterpreter(\n               getCodingConvention(), getTypeRegistry());\n-      if (options_.closurePass) {\n+      if (options.closurePass) {\n         interpreter \u003d new ClosureReverseAbstractInterpreter(\n             getCodingConvention(), getTypeRegistry())\n             .append(interpreter).getFirst();\n@@ -970,7 +1020,7 @@\n    *     and the main root\n    */\n   Node parseInputs() {\n-    boolean devMode \u003d options_.devMode !\u003d DevMode.OFF;\n+    boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n \n     // If old roots exist (we are parsing a second time), detach each of the\n     // individual file parse trees.\n@@ -985,9 +1035,9 @@\n     jsRoot \u003d new Node(Token.BLOCK);\n     jsRoot.setIsSyntheticBlock(true);\n \n-    if (options_.tracer.isOn()) {\n+    if (options.tracer.isOn()) {\n       tracker \u003d new PerformanceTracker(jsRoot,\n-          options_.tracer \u003d\u003d TracerMode.ALL);\n+          options.tracer \u003d\u003d TracerMode.ALL);\n       addChangeHandler(tracker.getCodeChangeHandler());\n     }\n \n@@ -997,7 +1047,7 @@\n       // Parse externs sources.\n       externsRoot \u003d new Node(Token.BLOCK);\n       externsRoot.setIsSyntheticBlock(true);\n-      for (CompilerInput input : externs_) {\n+      for (CompilerInput input : externs) {\n         Node n \u003d input.getAstRoot(this);\n         if (hasErrors()) {\n           return null;\n@@ -1005,7 +1055,7 @@\n         externsRoot.addChildToBack(n);\n       }\n \n-      for (CompilerInput input : inputs_) {\n+      for (CompilerInput input : inputs) {\n         Node n \u003d input.getAstRoot(this);\n         if (hasErrors()) {\n           return null;\n@@ -1017,14 +1067,14 @@\n         }\n \n         if (devMode) {\n-          sanityCheck.create(this).process(null, n);\n+          runSanityCheck();\n           if (hasErrors()) {\n             return null;\n           }\n         }\n \n-        if (options_.sourceMapOutputPath !\u003d null ||\n-            options_.nameReferenceReportPath !\u003d null) {\n+        if (options.sourceMapOutputPath !\u003d null ||\n+            options.nameReferenceReportPath !\u003d null) {\n \n           // Annotate the nodes in the tree with information from the\n           // input file. This information is used to construct the SourceMap.\n@@ -1046,6 +1096,7 @@\n   }\n \n   public Node parse(JSSourceFile file) {\n+    initCompilerOptionsIfTesting();\n     addToDebugLog(\"Parsing: \" + file.getName());\n     return new JsAst(file).getAstRoot(this);\n   }\n@@ -1054,22 +1105,32 @@\n   Node parseSyntheticCode(String js) {\n     CompilerInput input \u003d new CompilerInput(\n         JSSourceFile.fromCode(\" [synthetic] \", js));\n-    inputsByName_.put(input.getName(), input);\n+    inputsByName.put(input.getName(), input);\n     return input.getAstRoot(this);\n   }\n \n+  void initCompilerOptionsIfTesting() {\n+    if (options \u003d\u003d null) {\n+      // initialization for tests that don\u0027t initialize the compiler\n+      // by the normal mechanisms.\n+      initOptions(new CompilerOptions());\n+    }\n+  }\n+\n   @Override\n   Node parseSyntheticCode(String fileName, String js) {\n+    initCompilerOptionsIfTesting();\n     return parse(JSSourceFile.fromCode(fileName, js));\n   }\n \n   Node parseTestCode(String js) {\n+    initCompilerOptionsIfTesting();\n     CompilerInput input \u003d new CompilerInput(\n         JSSourceFile.fromCode(\" [testcode] \", js));\n-    if (inputsByName_ \u003d\u003d null) {\n-      inputsByName_ \u003d Maps.newHashMap();\n+    if (inputsByName \u003d\u003d null) {\n+      inputsByName \u003d Maps.newHashMap();\n     }\n-    inputsByName_.put(input.getName(), input);\n+    inputsByName.put(input.getName(), input);\n     return input.getAstRoot(this);\n   }\n \n@@ -1115,11 +1176,11 @@\n       public String[] call() throws Exception {\n         Tracer tracer \u003d newTracer(\"toSourceArray\");\n         try {\n-          int numInputs \u003d inputs_.length;\n+          int numInputs \u003d inputs.size();\n           String[] sources \u003d new String[numInputs];\n           CodeBuilder cb \u003d new CodeBuilder();\n           for (int i \u003d 0; i \u003c numInputs; i++) {\n-            Node scriptNode \u003d inputs_[i].getAstRoot(Compiler.this);\n+            Node scriptNode \u003d inputs.get(i).getAstRoot(Compiler.this);\n             cb.reset();\n             toSource(cb, i, scriptNode);\n             sources[i] \u003d cb.toString();\n@@ -1200,12 +1261,22 @@\n                        final Node root) {\n     runInCompilerThread(new Callable\u003cVoid\u003e() {\n       public Void call() throws Exception {\n-        if (options_.printInputDelimiter) {\n+        if (options.printInputDelimiter) {\n           if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n             cb.append(\"\\n\");  // Make sure that the label starts on a new line\n           }\n-          cb.append(\"// Input \")\n-            .append(String.valueOf(inputSeqNum))\n+          Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n+          \n+          String delimiter \u003d options.inputDelimiter;\n+          \n+          String sourceName \u003d (String)root.getProp(Node.SOURCENAME_PROP);\n+          Preconditions.checkState(sourceName !\u003d null);\n+          Preconditions.checkState(!sourceName.isEmpty());\n+          \n+          delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName)\n+            .replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+\n+          cb.append(delimiter)\n             .append(\"\\n\");\n         }\n         if (root.getJSDocInfo() !\u003d null \u0026\u0026\n@@ -1217,8 +1288,8 @@\n \n         // If there is a valid source map, then indicate to it that the current\n         // root node\u0027s mappings are offset by the given string builder buffer.\n-        if (options_.sourceMapOutputPath !\u003d null) {\n-          sourceMap_.setStartingPosition(\n+        if (options.sourceMapOutputPath !\u003d null) {\n+          sourceMap.setStartingPosition(\n               cb.getLineIndex(), cb.getColumnIndex());\n         }\n \n@@ -1239,10 +1310,13 @@\n    */\n   @Override\n   String toSource(Node n) {\n+    initCompilerOptionsIfTesting();\n+    \n     CodePrinter.Builder builder \u003d new CodePrinter.Builder(n);\n-    builder.setPrettyPrint(options_.prettyPrint);\n-    builder.setLineBreak(options_.lineBreak);\n-    builder.setSourceMap(sourceMap_);\n+    builder.setPrettyPrint(options.prettyPrint);\n+    builder.setLineBreak(options.lineBreak);\n+    builder.setSourceMap(sourceMap);\n+    builder.setOutputCharset(options.outputCharset);\n     return builder.build();\n   }\n \n@@ -1307,7 +1381,7 @@\n \n   public void optimize() {\n     PhaseOptimizer phaseOptimizer \u003d new PhaseOptimizer(this, tracker);\n-    if (options_.devMode \u003d\u003d DevMode.EVERY_PASS) {\n+    if (options.devMode \u003d\u003d DevMode.EVERY_PASS) {\n       phaseOptimizer.setSanityCheck(sanityCheck);\n     }\n     phaseOptimizer.consume(getPassConfig().getOptimizations());\n@@ -1315,179 +1389,16 @@\n     if (hasErrors()) {\n       return;\n     }\n-\n-    if (options_.flowSensitiveInlineVariables) {\n-      flowSensitiveInlineVariables();\n-    }\n-\n-    if (options_.collapseAnonymousFunctions) {\n-      collapseAnonymousFunctions();\n-    }\n-\n-    // Move functions before extracting prototype member declarations.\n-    if (options_.moveFunctionDeclarations) {\n-      moveFunctionDeclarations();\n-    }\n-\n-    if (options_.anonymousFunctionNaming \u003d\u003d\n-        AnonymousFunctionNamingPolicy.MAPPED) {\n-      nameAnonymousFunctions(AnonymousFunctionNamingPolicy.MAPPED);\n-    }\n-\n-    // The mapped name anonymous function pass makes use of information that\n-    // the extract prototype member declarations pass removes so the former\n-    // happens before the latter.\n-    //\n-    // Extracting prototype properties screws up the heuristic renaming\n-    // policies, so never run it when those policies are requested.\n-    if (options_.extractPrototypeMemberDeclarations \u0026\u0026\n-        (options_.propertyRenaming !\u003d PropertyRenamingPolicy.HEURISTIC \u0026\u0026\n-         options_.propertyRenaming !\u003d\n-            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC)) {\n-      extractPrototypeMemberDeclarations();\n-    }\n-\n-    if (options_.coalesceVariableNames) {\n-      coalesceVariableNames();\n-    }\n-\n-    VariableMap prevPropertyMap \u003d null;\n-    if (options_.inputPropertyMapSerialized !\u003d null) {\n-      try {\n-        prevPropertyMap \u003d\n-            VariableMap.fromBytes(options_.inputPropertyMapSerialized);\n-      } catch (ParseException e) {\n-        report(JSError.make(INPUT_MAP_PROP_PARSE, e.getMessage()));\n-      }\n-    }\n-\n-    if (options_.ambiguateProperties \u0026\u0026 (options_.propertyRenaming\n-        \u003d\u003d PropertyRenamingPolicy.ALL_UNQUOTED)) {\n-      ambiguateProperties(options_.anonymousFunctionNaming\n-          .getReservedCharacters());\n-    }\n-\n-    switch (options_.propertyRenaming) {\n-      case HEURISTIC:\n-        renamePrototypes(false,\n-            options_.anonymousFunctionNaming,\n-            prevPropertyMap);\n-        break;\n-      case AGGRESSIVE_HEURISTIC:\n-        renamePrototypes(true,\n-            options_.anonymousFunctionNaming,\n-            prevPropertyMap);\n-        break;\n-      case ALL_UNQUOTED:\n-        renameProperties(options_.generatePseudoNames,\n-            options_.anonymousFunctionNaming,\n-            prevPropertyMap);\n-        break;\n-    }\n-\n-    // This comes after property renaming because quoted property names must\n-    // not be renamed.\n-    if (options_.convertToDottedProperties) {\n-      convertToDottedProperties();\n-    }\n-\n-    // Property renaming must happen before this pass runs since this\n-    // pass may convert dotted properties into quoted properties.  It\n-    // is beneficial to run before alias strings, alias keywords and\n-    // variable renaming.\n-    if (options_.rewriteFunctionExpressions) {\n-      rewriteFunctionExpressions();\n-    }\n-\n-    // This comes after converting quoted property accesses to dotted property\n-    // accesses in order to avoid aliasing property names.\n-    if (!options_.aliasableStrings.isEmpty() || options_.aliasAllStrings) {\n-      aliasStrings(options_.aliasableStrings,\n-                   options_.aliasAllStrings,\n-                   options_.aliasStringsBlacklist,\n-                   FLAG_output_js_string_usage.get());\n-    }\n-\n-    if (options_.aliasExternals) {\n-      aliasExternals();\n-    }\n-\n-    if (options_.aliasKeywords) {\n-      aliasKeywords();\n-    }\n-\n-    if (options_.collapseVariableDeclarations) {\n-      collapseVariableDeclarations();\n-    }\n-\n-    denormalize();\n-\n-    if (options_.instrumentationTemplate !\u003d null) {\n-      instrumentFunctions();\n-    }\n-\n-    if (options_.variableRenaming !\u003d VariableRenamingPolicy.ALL) {\n-      // If we\u0027re leaving some (or all) variables with their old names,\n-      // then we need to undo any of the markers we added for distinguishing\n-      // local variables (\"$$1\") or constants (\"$$constant\").\n-      invertContextualRenaming();\n-    }\n-\n-    if (options_.variableRenaming !\u003d VariableRenamingPolicy.OFF) {\n-      VariableMap prevVariableMap \u003d null;\n-      if (options_.inputVariableMapSerialized !\u003d null) {\n-        try {\n-          prevVariableMap \u003d\n-              VariableMap.fromBytes(options_.inputVariableMapSerialized);\n-        } catch (ParseException e) {\n-          report(JSError.make(INPUT_VAR_PROP_PARSE, e.getMessage()));\n-        }\n-      }\n-\n-      renameVars(options_.renamePrefix,\n-          options_.variableRenaming \u003d\u003d VariableRenamingPolicy.LOCAL,\n-          options_.anonymousFunctionNaming,\n-          prevVariableMap);\n-    }\n-\n-    // This pass should run after names stop changing.\n-    if (options_.processObjectPropertyString) {\n-      objectPropertyStringPostprocess();\n-    }\n-\n-    if (options_.labelRenaming) {\n-      renameLabels();\n-    }\n-\n-    if (options_.anonymousFunctionNaming \u003d\u003d\n-        AnonymousFunctionNamingPolicy.UNMAPPED) {\n-      nameAnonymousFunctions(AnonymousFunctionNamingPolicy.UNMAPPED);\n-    }\n-\n-    // Safety check\n-    if (options_.checkSymbols) {\n-      sanityCheckVars();\n-    }\n   }\n \n   @Override\n   void setCssRenamingMap(CssRenamingMap map) {\n-    options_.cssRenamingMap \u003d map;\n+    options.cssRenamingMap \u003d map;\n   }\n \n   @Override\n   CssRenamingMap getCssRenamingMap() {\n-    return options_.cssRenamingMap;\n-  }\n-\n-\n-  /** Checks that all variables are defined. */\n-  void sanityCheckVars() {\n-    logger_.info(\"Checking for undefined vars\");\n-    startPass(\"sanityCheckVars\");\n-    VarCheck v \u003d new VarCheck(this, false);\n-    process(v);\n-    endPass();\n+    return options.cssRenamingMap;\n   }\n \n   /**\n@@ -1498,79 +1409,19 @@\n    * specifically for that target.\n    */\n   public void processDefines() {\n-    (new DefaultPassConfig(options_)).processDefines.create(this)\n+    (new DefaultPassConfig(options)).processDefines.create(this)\n         .process(externsRoot, jsRoot);\n   }\n \n-  void computeFunctionNames() {\n-    logger_.info(\"Computing fully-qualified function names and ids\");\n-    startPass(\"computeFunctionNames\");\n-    functionNames_ \u003d new FunctionNames(this);\n-    process(functionNames_);\n-    endPass();\n-  }\n-\n-  void flowSensitiveInlineVariables() {\n-    logger_.info(\"Flow Sensitive Inline Variables\");\n-    startPass(\"flowSensitiveInlineVariables\");\n-    process(new FlowSensitiveInlineVariables(this));\n-    endPass();\n-  }\n-\n-  void coalesceVariableNames() {\n-    logger_.info(\"Coalesce Variable Names\");\n-    startPass(\"coalesceVariableNames\");\n-    process(new CoalesceVariableNames(this));\n-    endPass();\n-  }\n-\n-  void collapseVariableDeclarations() {\n-    logger_.info(\"Collapsing variable declarations\");\n-    startPass(\"collapseVariableDeclarations\");\n-    process(new CollapseVariableDeclarations(this));\n-    setUnnormalized();\n-    endPass();\n-  }\n-\n-  void extractPrototypeMemberDeclarations() {\n-    logger_.info(\"Extracting Common Prototype Member Declarations\");\n-    startPass(\"extractPrototypeMemberDeclarations\");\n-    process(new ExtractPrototypeMemberDeclarations(this));\n-    endPass();\n-  }\n-\n-  void rewriteFunctionExpressions() {\n-    logger_.info(\"Rewrite function expressions\");\n-    startPass(\"rewriteFunctionExpressions\");\n-    process(new FunctionRewriter(this));\n-    endPass();\n-  }\n-\n-  void collapseAnonymousFunctions() {\n-    logger_.info(\"Collapsing anonymous functions\");\n-    startPass(\"collapseAnonymousFunctions\");\n-    process(new CollapseAnonymousFunctions(this));\n-    endPass();\n-  }\n-\n-\n-\n-  void moveFunctionDeclarations() {\n-    logger_.info(\"Move function declarations\");\n-    startPass(\"moveFunctionDeclarations\");\n-    process(new MoveFunctionDeclarations(this));\n-    endPass();\n-  }\n-\n   boolean isInliningForbidden() {\n-    return options_.propertyRenaming \u003d\u003d PropertyRenamingPolicy.HEURISTIC ||\n-        options_.propertyRenaming \u003d\u003d\n+    return options.propertyRenaming \u003d\u003d PropertyRenamingPolicy.HEURISTIC ||\n+        options.propertyRenaming \u003d\u003d\n             PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n   }\n \n   /** Control Flow Analysis. */\n   ControlFlowGraph\u003cNode\u003e computeCFG() {\n-    logger_.info(\"Computing Control Flow Graph\");\n+    logger.info(\"Computing Control Flow Graph\");\n     Tracer tracer \u003d newTracer(\"computeCFG\");\n     ControlFlowAnalysis cfa \u003d new ControlFlowAnalysis(this, true);\n     process(cfa);\n@@ -1578,169 +1429,30 @@\n     return cfa.getCfg();\n   }\n \n-  void nameAnonymousFunctions(AnonymousFunctionNamingPolicy policy) {\n-    logger_.info(\"Naming anonymous functions\");\n-    startPass(\"nameAnonymousFunctions\");\n-    if (policy \u003d\u003d AnonymousFunctionNamingPolicy.UNMAPPED) {\n-      process(new NameAnonymousFunctions(this));\n-    } else if (policy \u003d\u003d AnonymousFunctionNamingPolicy.MAPPED) {\n-      NameAnonymousFunctionsMapped naf \u003d new NameAnonymousFunctionsMapped(this);\n-      process(naf);\n-      anonFunctionNameMap_ \u003d naf.getFunctionMap();\n-    }\n-    endPass();\n-  }\n-\n-  void aliasExternals() {\n-    logger_.info(\"Creating alias functions for externals\");\n-    startPass(\"aliasExternals\");\n-    AliasExternals ae \u003d new AliasExternals(this,\n-                                           getModuleGraph(),\n-                                           options_.unaliasableGlobals,\n-                                           options_.aliasableGlobals);\n-    process(ae);\n-    endPass();\n-  }\n-\n-  void objectPropertyStringPostprocess() {\n-    logger_.info(\"goog.testing.ObjectPropertyString postprocess\");\n-    startPass(\"ObjectPropertyStringPostprocess\");\n-    process(new ObjectPropertyStringPostprocess(this));\n-    endPass();\n-  }\n-\n-  void ambiguateProperties(char[] reservedCharacters) {\n-    logger_.info(\"Ambiguating properties\");\n-    startPass(\"ambiguateProperties\");\n-    process(new AmbiguateProperties(this, reservedCharacters));\n-    endPass();\n-  }\n-\n   public void normalize() {\n-    logger_.info(\"Normalizing\");\n+    logger.info(\"Normalizing\");\n     startPass(\"normalize\");\n     process(new Normalize(this, false));\n     setNormalized();\n     endPass();\n   }\n \n-  private void denormalize() {\n-    logger_.info(\"Denormalizing\");\n-    startPass(\"denormalize\");\n-    process(new Denormalize(this));\n-    setUnnormalized();\n-    endPass();\n-  }\n-\n   @Override\n-  void normalizeNodeTypes(Node root) {\n-    Tracer tracer \u003d newTracer(\"normalizeNodeTypes\");\n-\n-    // TODO(johnlenz): Move the Node type normalizer into the general\n-    // Normalization pass once we force everybody to turn it on. It\u0027s\n-    // confusing to have a mandatory normalization pass and an optional\n-    // one.\n-    CompilerPass pass \u003d new NodeTypeNormalizer();\n+  void prepareAst(Node root) {\n+    Tracer tracer \u003d newTracer(\"prepareAst\");\n+    CompilerPass pass \u003d new PrepareAst(this);\n     pass.process(null, root);\n-\n-    stopTracer(tracer, \"normalizeNodeTypes\");\n-  }\n-\n-  @Override\n-  void annotateCodingConvention(Node root) {\n-    Tracer tracer \u003d newTracer(\"annotateCodingConvention\");\n-    CompilerPass pass \u003d new CodingConventionAnnotator(this);\n-    pass.process(null, root);\n-    stopTracer(tracer, \"annotateCodingConvention\");\n-  }\n-\n-  void renameVars(String renamePrefix, boolean renameLocalVarsOnly,\n-      AnonymousFunctionNamingPolicy anonFunctionNamePolicy,\n-      VariableMap prevVariableMap) {\n-    logger_.info(\"Renaming vars\");\n-    startPass(\"renameVars\");\n-    RenameVars rn \u003d new RenameVars(\n-        this, renamePrefix, renameLocalVarsOnly, prevVariableMap,\n-        anonFunctionNamePolicy.getReservedCharacters(),\n-        getPassConfig().getExportedNames());\n-    process(rn);\n-    variableMap_ \u003d rn.getVariableMap();\n-    endPass();\n-  }\n-\n-  void renameProperties(boolean generatePseudoNames,\n-      AnonymousFunctionNamingPolicy anonFunctionNamePolicy,\n-      VariableMap prevPropertyMap) {\n-    logger_.info(\"Renaming properties\");\n-    startPass(\"renameProperties\");\n-    RenameProperties rp \u003d new RenameProperties(\n-        this, generatePseudoNames, prevPropertyMap,\n-        anonFunctionNamePolicy.getReservedCharacters());\n-    process(rp);\n-    propertyMap_ \u003d rp.getPropertyMap();\n-    endPass();\n-  }\n-\n-  void invertContextualRenaming() {\n-    logger_.info(\"Denormalizing local names\");\n-    startPass(\"invertNames\");\n-    process(MakeDeclaredNamesUnique.getContextualRenameInverter(this));\n-    endPass();\n-  }\n-\n-  void renamePrototypes(boolean aggressive,\n-      AnonymousFunctionNamingPolicy anonFunctionNamePolicy,\n-      VariableMap prevPropertyMap) {\n-    logger_.info(\"Renaming prototypes\");\n-    startPass(\"renamePrototypes\");\n-    RenamePrototypes rp \u003d new RenamePrototypes(this, aggressive,\n-        anonFunctionNamePolicy.getReservedCharacters(),\n-        prevPropertyMap);\n-    process(rp);\n-    propertyMap_ \u003d rp.getPropertyMap();\n-    endPass();\n-  }\n-\n-  void renameLabels() {\n-    logger_.info(\"Renaming labels\");\n-    startPass(\"renameLabels\");\n-    RenameLabels rn \u003d new RenameLabels(this);\n-    process(rn);\n-    endPass();\n-  }\n-\n-  void convertToDottedProperties() {\n-    logger_.info(\"Converting quoted property accesses to dot syntax\");\n-    startPass(\"convertToDottedProperties\");\n-    process(new ConvertToDottedProperties(this));\n-    endPass();\n-  }\n-\n-  void instrumentFunctions() {\n-    logger_.info(\"Instrumenting functions\");\n-    startPass(\"instrumentFunctions\");\n-    try {\n-      FileReader templateFile \u003d\n-          new FileReader(options_.instrumentationTemplate);\n-\n-      process(new InstrumentFunctions(this,\n-                                      functionNames_,\n-                                      options_.instrumentationTemplate,\n-                                      options_.appNameStr,\n-                                      templateFile));\n-    } catch (IOException e) {\n-      report(JSError.make(READ_ERROR, options_.instrumentationTemplate));\n-    }\n-    endPass();\n+    stopTracer(tracer, \"prepareAst\");\n   }\n \n   void recordFunctionInformation() {\n-    logger_.info(\"Recording function information\");\n+    logger.info(\"Recording function information\");\n     startPass(\"recordFunctionInformation\");\n     RecordFunctionInformation recordFunctionInfoPass \u003d\n-        new RecordFunctionInformation(this, functionNames_);\n+        new RecordFunctionInformation(\n+            this, getPassConfig().getIntermediateState().functionNames);\n     process(recordFunctionInfoPass);\n-    functionInformationMap_ \u003d recordFunctionInfoPass.getMap();\n+    functionInformationMap \u003d recordFunctionInfoPass.getMap();\n     endPass();\n   }\n \n@@ -1773,22 +1485,28 @@\n \n   @Override\n   public CodingConvention getCodingConvention() {\n-    return codingConvention;\n-  }\n-\n-  public void setCodingConvention(CodingConvention convention) {\n-    Preconditions.checkState(convention !\u003d null);\n-    codingConvention \u003d convention;\n+    CodingConvention convention \u003d options.getCodingConvention();\n+    convention \u003d convention !\u003d null ? convention : defaultCodingConvention;\n+    return convention;\n   }\n \n   @Override\n   public boolean isIdeMode() {\n-    return options_.ideMode;\n+    return options.ideMode;\n+  }\n+\n+  @Override\n+  Config getParserConfig() {\n+    if (parserConfig \u003d\u003d null) {\n+      parserConfig \u003d ParserRunner.createConfig(\n+          getTypeRegistry(), isIdeMode());\n+    }\n+    return parserConfig;\n   }\n \n   @Override\n   public boolean isTypeCheckingEnabled() {\n-    return options_.checkTypes;\n+    return options.checkTypes;\n   }\n \n \n@@ -1797,9 +1515,9 @@\n   //------------------------------------------------------------------------\n \n   @Override\n-  void report(JSError error) {\n+  public void report(JSError error) {\n     CheckLevel level \u003d error.level;\n-    WarningsGuard guard \u003d options_.getWarningsGuard();\n+    WarningsGuard guard \u003d options.getWarningsGuard();\n     if (guard !\u003d null) {\n       CheckLevel newLevel \u003d guard.level(error);\n       if (newLevel !\u003d null) {\n@@ -1864,14 +1582,14 @@\n   /** Called from the compiler passes, adds debug info */\n   @Override\n   void addToDebugLog(String str) {\n-    debugLog_.append(str);\n-    debugLog_.append(\u0027\\n\u0027);\n-    logger_.fine(str);\n+    debugLog.append(str);\n+    debugLog.append(\u0027\\n\u0027);\n+    logger.fine(str);\n   }\n \n   private SourceFile getSourceFileByName(String sourceName) {\n-    if (inputsByName_.containsKey(sourceName)) {\n-      return inputsByName_.get(sourceName).getSourceFile();\n+    if (inputsByName.containsKey(sourceName)) {\n+      return inputsByName.get(sourceName).getSourceFile();\n     }\n     return null;\n   }\n@@ -1905,51 +1623,45 @@\n   @Override\n   Node getNodeForCodeInsertion(JSModule module) {\n     if (module \u003d\u003d null) {\n-      if (inputs_.length \u003d\u003d 0) {\n+      if (inputs.isEmpty()) {\n         throw new IllegalStateException(\"No inputs\");\n       }\n \n-      return inputs_[0].getAstRoot(this);\n-    }\n-\n-    List\u003cCompilerInput\u003e inputs \u003d module.getInputs();\n-    if (inputs.size() \u003e 0) {\n       return inputs.get(0).getAstRoot(this);\n     }\n-    for (JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) {\n-      inputs \u003d m.getInputs();\n-      if (inputs.size() \u003e 0) {\n-        return inputs.get(0).getAstRoot(this);\n-      }\n+\n+    List\u003cCompilerInput\u003e moduleInputs \u003d module.getInputs();\n+    if (moduleInputs.size() \u003e 0) {\n+      return moduleInputs.get(0).getAstRoot(this);\n     }\n     throw new IllegalStateException(\"Root module has no inputs\");\n   }\n \n   public SourceMap getSourceMap() {\n-    return sourceMap_;\n+    return sourceMap;\n   }\n \n   VariableMap getVariableMap() {\n-    return variableMap_;\n+    return getPassConfig().getIntermediateState().variableMap;\n   }\n \n   VariableMap getPropertyMap() {\n-    return propertyMap_;\n+    return getPassConfig().getIntermediateState().propertyMap;\n   }\n \n   CompilerOptions getOptions() {\n-    return options_;\n+    return options;\n   }\n \n   FunctionInformationMap getFunctionalInformationMap() {\n-    return functionInformationMap_;\n+    return functionInformationMap;\n   }\n \n   /**\n    * Sets the logging level for the com.google.javascript.jscomp package.\n    */\n   public static void setLoggingLevel(Level level) {\n-    logger_.setLevel(level);\n+    logger.setLevel(level);\n   }\n \n   /** Gets the DOT graph of the AST generated at the end of compilation. */\n@@ -1965,6 +1677,9 @@\n \n   @Override\n   public ErrorManager getErrorManager() {\n+    if (options \u003d\u003d null) {\n+      initOptions(new CompilerOptions());\n+    }\n     return errorManager;\n   }\n \n@@ -1984,10 +1699,9 @@\n \n     Node externsRoot;\n     private Node jsRoot;\n-    private CompilerInput[] externs;\n-    private CompilerInput[] inputs;\n-    private JSModule[] modules;\n-    private FunctionNames functionNames;\n+    private List\u003cCompilerInput\u003e externs;\n+    private List\u003cCompilerInput\u003e inputs;\n+    private List\u003cJSModule\u003e modules;\n     private PassConfig.State passConfigState;\n     private JSTypeRegistry typeRegistry;\n     private boolean normalized;\n@@ -2002,10 +1716,9 @@\n     IntermediateState state \u003d new IntermediateState();\n     state.externsRoot \u003d externsRoot;\n     state.jsRoot \u003d jsRoot;\n-    state.externs \u003d externs_;\n-    state.inputs \u003d inputs_;\n-    state.modules \u003d modules_;\n-    state.functionNames \u003d functionNames_;\n+    state.externs \u003d externs;\n+    state.inputs \u003d inputs;\n+    state.modules \u003d modules;\n     state.passConfigState \u003d getPassConfig().getIntermediateState();\n     state.typeRegistry \u003d typeRegistry;\n     state.normalized \u003d normalized;\n@@ -2020,13 +1733,22 @@\n   public void setState(IntermediateState state) {\n     externsRoot \u003d state.externsRoot;\n     jsRoot \u003d state.jsRoot;\n-    externs_ \u003d state.externs;\n-    inputs_ \u003d state.inputs;\n-    modules_ \u003d state.modules;\n-    functionNames_ \u003d state.functionNames;\n+    externs \u003d state.externs;\n+    inputs \u003d state.inputs;\n+    modules \u003d state.modules;\n     passes \u003d createPassConfigInternal();\n     getPassConfig().setIntermediateState(state.passConfigState);\n     typeRegistry \u003d state.typeRegistry;\n     normalized \u003d state.normalized;\n   }\n+\n+  @Override\n+  boolean hasRegExpGlobalReferences() {\n+    return hasRegExpGlobalReferences;\n+  }\n+\n+  @Override\n+  void setHasRegExpGlobalReferences(boolean references) {\n+    hasRegExpGlobalReferences \u003d references;\n+  }\n }\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "FieldDeclaration [3388,3539]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [50460,50551]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [50555,50670]"
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "src/com/google/javascript/jscomp/DefaultPassConfig.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "getCodeRemovingPasses",
            "getIntermediateState",
            "getMainOptimizationLoop",
            "getChecks",
            "getOptimizations"
          ],
          "num": 5
        },
        {
          "qualified_names": [
            "getCodeRemovingPasses",
            "getIntermediateState",
            "getChecks",
            "runPropertyRenaming",
            "getOptimizations",
            "runVariableRenaming",
            "getMainOptimizationLoop",
            "setIntermediateState"
          ],
          "num": 8
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "25",
            "39",
            "66",
            "78",
            "131",
            "132",
            "148",
            "149",
            "154",
            "155",
            "156",
            "157",
            "158",
            "159",
            "160",
            "161",
            "189",
            "200",
            "217",
            "224",
            "226",
            "261",
            "262",
            "263",
            "264",
            "265",
            "266",
            "267",
            "268",
            "278",
            "309",
            "320",
            "322",
            "337",
            "338",
            "340",
            "474",
            "475",
            "476",
            "477",
            "478",
            "479",
            "480",
            "481",
            "482",
            "483",
            "489",
            "520",
            "522",
            "524",
            "526",
            "563",
            "593",
            "594",
            "595",
            "596",
            "597",
            "598",
            "599",
            "600",
            "601",
            "602",
            "603",
            "604",
            "605",
            "606",
            "607",
            "608",
            "609",
            "610",
            "788",
            "846",
            "847",
            "848",
            "849",
            "850",
            "851",
            "852",
            "853",
            "854",
            "855",
            "856",
            "857",
            "858",
            "859",
            "860",
            "861",
            "862",
            "863",
            "864",
            "865",
            "866",
            "867",
            "868",
            "869",
            "958",
            "968",
            "1075",
            "1076",
            "1077",
            "1087",
            "1110",
            "1186",
            "1187",
            "1188",
            "1189",
            "1190",
            "1191",
            "1192",
            "1193",
            "1194",
            "1195",
            "1196",
            "1197",
            "1198",
            "1199",
            "1200",
            "1201"
          ],
          "num": 118
        },
        {
          "qualified_names": [
            "24",
            "31",
            "33",
            "35",
            "38",
            "43",
            "71",
            "72",
            "73",
            "74",
            "75",
            "76",
            "77",
            "78",
            "91",
            "92",
            "93",
            "94",
            "95",
            "96",
            "97",
            "98",
            "99",
            "100",
            "101",
            "102",
            "103",
            "104",
            "105",
            "106",
            "107",
            "108",
            "109",
            "110",
            "111",
            "112",
            "113",
            "114",
            "115",
            "116",
            "117",
            "118",
            "124",
            "125",
            "126",
            "127",
            "128",
            "129",
            "130",
            "131",
            "132",
            "133",
            "134",
            "135",
            "136",
            "137",
            "138",
            "139",
            "140",
            "141",
            "142",
            "143",
            "144",
            "145",
            "146",
            "150",
            "151",
            "152",
            "153",
            "154",
            "155",
            "156",
            "157",
            "158",
            "159",
            "160",
            "205",
            "206",
            "207",
            "208",
            "209",
            "210",
            "211",
            "212",
            "213",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "220",
            "236",
            "237",
            "238",
            "239",
            "240",
            "241",
            "242",
            "275",
            "276",
            "277",
            "278",
            "279",
            "280",
            "292",
            "293",
            "294",
            "295",
            "296",
            "297",
            "314",
            "318",
            "362",
            "363",
            "364",
            "365",
            "366",
            "367",
            "368",
            "372",
            "376",
            "377",
            "378",
            "379",
            "380",
            "381",
            "382",
            "383",
            "384",
            "385",
            "386",
            "387",
            "388",
            "389",
            "390",
            "391",
            "392",
            "393",
            "394",
            "395",
            "396",
            "425",
            "426",
            "427",
            "428",
            "429",
            "430",
            "431",
            "432",
            "433",
            "434",
            "435",
            "436",
            "437",
            "438",
            "439",
            "440",
            "441",
            "442",
            "443",
            "444",
            "445",
            "446",
            "447",
            "448",
            "449",
            "450",
            "451",
            "452",
            "453",
            "454",
            "455",
            "456",
            "457",
            "458",
            "459",
            "460",
            "461",
            "462",
            "463",
            "464",
            "465",
            "466",
            "467",
            "468",
            "469",
            "470",
            "471",
            "472",
            "473",
            "474",
            "475",
            "476",
            "477",
            "478",
            "479",
            "480",
            "481",
            "482",
            "483",
            "484",
            "485",
            "486",
            "487",
            "488",
            "489",
            "490",
            "491",
            "492",
            "493",
            "494",
            "495",
            "496",
            "497",
            "498",
            "499",
            "500",
            "501",
            "502",
            "503",
            "504",
            "505",
            "506",
            "507",
            "508",
            "509",
            "510",
            "511",
            "512",
            "513",
            "514",
            "515",
            "516",
            "517",
            "518",
            "519",
            "520",
            "521",
            "522",
            "523",
            "524",
            "525",
            "526",
            "527",
            "528",
            "529",
            "530",
            "531",
            "532",
            "533",
            "534",
            "535",
            "536",
            "537",
            "538",
            "539",
            "540",
            "541",
            "542",
            "543",
            "544",
            "545",
            "546",
            "547",
            "548",
            "549",
            "550",
            "551",
            "561",
            "562",
            "564",
            "571",
            "579",
            "581",
            "709",
            "710",
            "711",
            "712",
            "713",
            "714",
            "715",
            "716",
            "717",
            "718",
            "719",
            "720",
            "721",
            "722",
            "723",
            "724",
            "725",
            "726",
            "727",
            "728",
            "729",
            "736",
            "737",
            "738",
            "739",
            "745",
            "776",
            "778",
            "780",
            "782",
            "820",
            "821",
            "822",
            "823",
            "824",
            "825",
            "826",
            "827",
            "828",
            "829",
            "830",
            "831",
            "832",
            "833",
            "834",
            "835",
            "836",
            "837",
            "1045",
            "1046",
            "1047",
            "1048",
            "1049",
            "1050",
            "1051",
            "1052",
            "1053",
            "1054",
            "1055",
            "1056",
            "1057",
            "1058",
            "1059",
            "1060",
            "1061",
            "1062",
            "1063",
            "1064",
            "1065",
            "1066",
            "1067",
            "1068",
            "1069",
            "1070",
            "1071",
            "1072",
            "1218",
            "1219",
            "1220",
            "1221",
            "1222",
            "1223",
            "1224",
            "1225",
            "1226",
            "1227",
            "1237",
            "1238",
            "1345",
            "1346",
            "1347",
            "1348",
            "1349",
            "1350",
            "1351",
            "1360",
            "1361",
            "1363",
            "1364",
            "1365",
            "1388",
            "1395",
            "1396",
            "1397",
            "1398",
            "1399",
            "1400",
            "1401",
            "1402",
            "1403",
            "1404",
            "1405",
            "1406",
            "1407",
            "1408",
            "1409",
            "1410",
            "1411",
            "1412",
            "1413",
            "1414",
            "1415",
            "1416",
            "1417",
            "1418",
            "1419",
            "1420",
            "1421",
            "1422",
            "1423",
            "1424",
            "1425",
            "1426",
            "1427",
            "1428",
            "1429",
            "1430",
            "1431",
            "1432",
            "1433",
            "1434",
            "1435",
            "1436",
            "1437",
            "1438",
            "1439",
            "1440",
            "1441",
            "1442",
            "1443",
            "1444",
            "1445",
            "1446",
            "1447",
            "1448",
            "1449",
            "1450",
            "1451",
            "1452",
            "1453",
            "1454",
            "1455",
            "1456",
            "1457",
            "1458",
            "1459",
            "1460",
            "1461",
            "1462",
            "1463",
            "1464",
            "1465",
            "1466",
            "1467",
            "1468",
            "1469",
            "1470",
            "1471",
            "1472",
            "1473",
            "1474",
            "1475",
            "1476",
            "1477",
            "1478",
            "1479",
            "1480",
            "1481",
            "1482",
            "1483",
            "1484",
            "1485",
            "1486",
            "1487",
            "1488",
            "1489",
            "1490",
            "1491",
            "1492",
            "1493",
            "1494",
            "1495",
            "1496",
            "1497",
            "1498",
            "1499",
            "1500",
            "1501",
            "1502",
            "1503",
            "1504",
            "1505",
            "1506",
            "1507",
            "1508",
            "1509",
            "1510",
            "1511",
            "1512",
            "1513",
            "1514",
            "1515",
            "1516",
            "1517",
            "1518",
            "1519",
            "1520",
            "1521",
            "1522",
            "1523",
            "1524",
            "1525",
            "1526",
            "1527",
            "1528",
            "1529",
            "1530",
            "1531",
            "1532",
            "1533",
            "1534",
            "1535",
            "1536",
            "1537",
            "1538",
            "1539",
            "1540",
            "1541",
            "1542",
            "1543",
            "1544",
            "1545",
            "1546",
            "1547",
            "1548",
            "1549",
            "1550",
            "1551",
            "1552",
            "1553",
            "1554",
            "1555",
            "1556",
            "1557",
            "1558",
            "1559",
            "1560",
            "1561",
            "1562",
            "1563",
            "1564",
            "1565",
            "1566",
            "1567",
            "1568",
            "1569",
            "1570",
            "1571",
            "1572",
            "1573",
            "1574",
            "1575",
            "1576",
            "1577",
            "1578",
            "1579",
            "1580",
            "1581",
            "1582",
            "1583",
            "1584",
            "1585",
            "1586",
            "1587",
            "1588",
            "1589",
            "1590",
            "1591",
            "1592",
            "1593",
            "1594",
            "1595",
            "1596",
            "1597",
            "1598",
            "1599",
            "1600",
            "1601",
            "1602",
            "1603",
            "1604",
            "1605",
            "1606",
            "1607",
            "1608",
            "1609",
            "1610",
            "1611",
            "1612",
            "1613",
            "1614",
            "1615",
            "1616",
            "1617",
            "1618",
            "1619",
            "1620",
            "1621",
            "1622",
            "1623",
            "1624",
            "1625",
            "1626",
            "1627",
            "1628",
            "1629",
            "1630",
            "1631",
            "1632",
            "1633",
            "1634",
            "1635",
            "1636",
            "1637",
            "1638",
            "1639",
            "1640",
            "1641",
            "1642",
            "1643",
            "1644",
            "1645",
            "1646",
            "1647",
            "1648",
            "1649",
            "1650",
            "1651",
            "1652",
            "1653",
            "1654",
            "1655",
            "1656",
            "1657",
            "1658",
            "1659",
            "1660",
            "1661",
            "1662",
            "1663",
            "1664",
            "1665",
            "1666",
            "1667",
            "1668",
            "1669",
            "1670",
            "1671",
            "1672",
            "1673",
            "1674",
            "1675",
            "1676",
            "1677",
            "1678",
            "1679",
            "1680",
            "1681",
            "1682",
            "1683",
            "1684",
            "1685",
            "1686",
            "1687",
            "1688",
            "1689",
            "1690",
            "1691",
            "1692",
            "1693",
            "1694",
            "1695",
            "1696",
            "1697",
            "1698",
            "1699",
            "1700",
            "1701",
            "1702",
            "1703",
            "1704",
            "1705",
            "1706",
            "1707",
            "1708",
            "1709",
            "1710",
            "1711",
            "1712",
            "1713",
            "1714",
            "1715",
            "1716",
            "1717",
            "1718",
            "1719",
            "1720",
            "1721",
            "1722",
            "1723",
            "1724",
            "1725",
            "1726",
            "1727",
            "1728",
            "1729",
            "1730"
          ],
          "num": 712
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/DefaultPassConfig.java b/src/com/google/javascript/jscomp/DefaultPassConfig.java\nindex ed9dc98..d60ba48 100644\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n@@ -21,22 +21,26 @@\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n import com.google.common.io.Files;\n-import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import java.io.File;\n+import java.io.FileReader;\n import java.io.IOException;\n+import java.text.ParseException;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n \n /**\n  * Pass factories and meta-data for native JSCompiler passes.\n  *\n-*\n+ * @author nicksantos@google.com (Nick Santos)\n  */\n // TODO(nicksantos): This needs state for a variety of reasons. Some of it\n // is to satisfy the existing API. Some of it is because passes really do\n@@ -64,6 +68,14 @@\n       DiagnosticType.error(\"JSC_REPORT_PATH_IO_ERROR\",\n           \"Error writing compiler report to {0}\");\n \n+  private static final DiagnosticType INPUT_MAP_PROP_PARSE \u003d\n+      DiagnosticType.error(\"JSC_INPUT_MAP_PROP_PARSE\",\n+          \"Input property map parse error: {0}\");\n+\n+  private static final DiagnosticType INPUT_MAP_VAR_PARSE \u003d\n+      DiagnosticType.error(\"JSC_INPUT_MAP_VAR_PARSE\",\n+          \"Input variable map parse error: {0}\");\n+\n   /**\n    * A global namespace to share across checking passes.\n    * TODO(nicksantos): This is a hack until I can get the namespace into\n@@ -76,14 +88,76 @@\n    */\n   private TightenTypes tightenTypes \u003d null;\n \n+  /** Names exported by goog.exportSymbol. */\n+  private Set\u003cString\u003e exportedNames \u003d null;\n+\n+  /**\n+   * Ids for cross-module method stubbing, so that each method has\n+   * a unique id.\n+   */\n+  private CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator \u003d\n+      new CrossModuleMethodMotion.IdGenerator();\n+\n+  /**\n+   * Keys are arguments passed to getCssName() found during compilation; values\n+   * are the number of times the key appeared as an argument to getCssName().\n+   */\n+  private Map\u003cString, Integer\u003e cssNames \u003d null;\n+\n+  /** The variable renaming map */\n+  private VariableMap variableMap \u003d null;\n+\n+  /** The property renaming map */\n+  private VariableMap propertyMap \u003d null;\n+\n+  /** The naming map for anonymous functions */\n+  private VariableMap anonymousFunctionNameMap \u003d null;\n+\n+  /** Fully qualified function names and globally unique ids */\n+  private FunctionNames functionNames \u003d null;\n+\n   public DefaultPassConfig(CompilerOptions options) {\n     super(options);\n   }\n \n   @Override\n+  State getIntermediateState() {\n+    return new State(\n+        cssNames \u003d\u003d null ? null : Maps.newHashMap(cssNames),\n+        exportedNames \u003d\u003d null ? null :\n+            Collections.unmodifiableSet(exportedNames),\n+        crossModuleIdGenerator, variableMap, propertyMap,\n+        anonymousFunctionNameMap, functionNames);\n+  }\n+\n+  @Override\n+  void setIntermediateState(State state) {\n+    this.cssNames \u003d state.cssNames \u003d\u003d null ? null :\n+        Maps.newHashMap(state.cssNames);\n+    this.exportedNames \u003d state.exportedNames \u003d\u003d null ? null :\n+        Sets.newHashSet(state.exportedNames);\n+    this.crossModuleIdGenerator \u003d state.crossModuleIdGenerator;\n+    this.variableMap \u003d state.variableMap;\n+    this.propertyMap \u003d state.propertyMap;\n+    this.anonymousFunctionNameMap \u003d state.anonymousFunctionNameMap;\n+    this.functionNames \u003d state.functionNames;\n+  }\n+\n+  @Override\n   protected List\u003cPassFactory\u003e getChecks() {\n     List\u003cPassFactory\u003e checks \u003d Lists.newArrayList();\n \n+    if (options.nameAnonymousFunctionsOnly) {\n+      if (options.anonymousFunctionNaming \u003d\u003d\n+          AnonymousFunctionNamingPolicy.MAPPED) {\n+        checks.add(nameMappedAnonymousFunctions);\n+      } else if (options.anonymousFunctionNaming \u003d\u003d\n+          AnonymousFunctionNamingPolicy.UNMAPPED) {\n+        checks.add(nameUnmappedAnonymousFunctions);\n+      }\n+      return checks;\n+    }\n+\n     if (options.checkSuspiciousCode) {\n       checks.add(suspiciousCode);\n     }\n@@ -128,8 +202,22 @@\n       checks.add(createSyntheticBlocks);\n     }\n \n-    if (options.checkSymbols) {\n-      checks.add(checkVars);\n+    // All passes must run the variable check. This synthesizes\n+    // variables later so that the compiler doesn\u0027t crash. It also\n+    // checks the externs file for validity. If you don\u0027t want to warn\n+    // about missing variable declarations, we shut that specific\n+    // error off.\n+    WarningsGuard warningsGuard \u003d options.getWarningsGuard();\n+    if (!options.checkSymbols \u0026\u0026\n+        (warningsGuard \u003d\u003d null || !warningsGuard.disables(\n+            DiagnosticGroups.CHECK_VARIABLES))) {\n+      options.setWarningLevel(DiagnosticGroups.CHECK_VARIABLES,\n+          CheckLevel.OFF);\n+    }\n+\n+    checks.add(checkVars);\n+    if (options.computeFunctionSideEffects) {\n+      checks.add(checkRegExp);\n     }\n \n     if (options.checkShadowVars.isOn()) {\n@@ -145,20 +233,17 @@\n       checks.add(objectPropertyStringPreprocess);\n     }\n \n-    // Type-checking already does more accurate method arity checking, so don\u0027t\n-    // do legacy method arity checking unless checkTypes is OFF.\n+    // DiagnosticGroups override the plain checkTypes option.\n+    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n+      options.checkTypes \u003d true;\n+    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n+      options.checkTypes \u003d false;\n+    }\n+\n     if (options.checkTypes) {\n       checks.add(resolveTypes.makeOneTimePass());\n       checks.add(inferTypes.makeOneTimePass());\n       checks.add(checkTypes.makeOneTimePass());\n-    } else {\n-      if (options.checkFunctions.isOn()) {\n-        checks.add(checkFunctions);\n-      }\n-\n-      if (options.checkMethods.isOn()) {\n-        checks.add(checkMethods);\n-      }\n     }\n \n     if (options.checkUnreachableCode.isOn() ||\n@@ -187,6 +272,12 @@\n \n     // Defines in code always need to be processed.\n     checks.add(processDefines);\n+\n+    if (options.instrumentationTemplate !\u003d null ||\n+        options.recordFunctionInformation) {\n+      checks.add(computeFunctionNames);\n+    }\n+\n     assertAllOneTimePasses(checks);\n     return checks;\n   }\n@@ -198,6 +289,12 @@\n     // TODO(nicksantos): The order of these passes makes no sense, and needs\n     // to be re-arranged.\n \n+    if (options.runtimeTypeCheck) {\n+      passes.add(runtimeTypeCheck);\n+    }\n+\n+    passes.add(createEmptyPass(\"beforeStandardOptimizations\"));\n+\n     if (!options.idGenerators.isEmpty()) {\n       passes.add(replaceIdGenerators);\n     }\n@@ -214,16 +311,14 @@\n \n     // Abstract method removal works best on minimally modified code, and also\n     // only needs to run once.\n-    if (options.closurePass) {\n+    if (options.closurePass \u0026\u0026 options.removeAbstractMethods) {\n       passes.add(removeAbstractMethods);\n     }\n \n     // Collapsing properties can undo constant inlining, so we do this before\n     // the main optimization loop.\n     if (options.collapseProperties) {\n-      passes.add(undoConstantRenaming);\n       passes.add(collapseProperties);\n-      passes.add(renameConstants.makeOneTimePass());\n     }\n \n     // Tighten types based on actual usage.\n@@ -258,27 +353,47 @@\n       passes.add(chainCalls);\n     }\n \n-    // Method devirtualization benefits from property disambiguiation so\n-    // it should run after that pass but before passes that do\n-    // optimizations based on global names (like smart name removal and cross\n-    // module code motion)\n-    if (options.devirtualizePrototypeMethods) {\n-      passes.add(devirtualizePrototypeMethods);\n-    }\n-\n     // Constant checking must be done after property collapsing because\n     // property collapsing can introduce new constants (e.g. enum values).\n     if (options.inlineConstantVars) {\n       passes.add(checkConsts);\n     }\n \n+    // The Caja library adds properties to Object.prototype, which breaks\n+    // most for-in loops.  This adds a check to each loop that skips\n+    // any property matching /___$/.\n+    if (options.ignoreCajaProperties) {\n+      passes.add(ignoreCajaProperties);\n+    }\n+\n     assertAllOneTimePasses(passes);\n \n     if (options.smartNameRemoval || options.reportPath !\u003d null) {\n-      passes.addAll(getCodeRemovingPasses(true));\n+      passes.addAll(getCodeRemovingPasses());\n       passes.add(smartNamePass);\n     }\n \n+    // TODO(user): This forces a first crack at crossModuleCodeMotion\n+    // before devirtualization. Once certain functions are devirtualized,\n+    // it confuses crossModuleCodeMotion ability to recognized that\n+    // it is recursive.\n+\n+    // TODO(user): This is meant for a temporary quick win.\n+    // In the future, we might want to improve our analysis in\n+    // CrossModuleCodeMotion so we don\u0027t need to do this.\n+    if (options.crossModuleCodeMotion) {\n+      passes.add(crossModuleCodeMotion);\n+    }\n+\n+    // Method devirtualization benefits from property disambiguiation so\n+    // it should run after that pass but before passes that do\n+    // optimizations based on global names (like cross module code motion\n+    // and inline functions).  Smart Name Removal does better if run before\n+    // this pass.\n+    if (options.devirtualizePrototypeMethods) {\n+      passes.add(devirtualizePrototypeMethods);\n+    }\n+\n     if (options.customPasses !\u003d null) {\n       passes.add(getCustomPasses(\n           CustomPassExecutionTime.BEFORE_OPTIMIZATION_LOOP));\n@@ -307,6 +422,133 @@\n           CustomPassExecutionTime.AFTER_OPTIMIZATION_LOOP));\n     }\n \n+    if (options.flowSensitiveInlineVariables) {\n+      passes.add(flowSensitiveInlineVariables);\n+\n+      // After inlining some of the variable uses, some variables are unused.\n+      // Re-run remove unused vars to clean it up.\n+      if (options.removeUnusedVars) {\n+        passes.add(removeUnusedVars);\n+      }\n+    }\n+\n+    if (options.collapseAnonymousFunctions) {\n+      passes.add(collapseAnonymousFunctions);\n+    }\n+\n+    // Move functions before extracting prototype member declarations.\n+    if (options.moveFunctionDeclarations) {\n+      passes.add(moveFunctionDeclarations);\n+    }\n+\n+    if (options.anonymousFunctionNaming \u003d\u003d\n+        AnonymousFunctionNamingPolicy.MAPPED) {\n+      passes.add(nameMappedAnonymousFunctions);\n+    }\n+\n+    // The mapped name anonymous function pass makes use of information that\n+    // the extract prototype member declarations pass removes so the former\n+    // happens before the latter.\n+    //\n+    // Extracting prototype properties screws up the heuristic renaming\n+    // policies, so never run it when those policies are requested.\n+    if (options.extractPrototypeMemberDeclarations \u0026\u0026\n+        (options.propertyRenaming !\u003d PropertyRenamingPolicy.HEURISTIC \u0026\u0026\n+         options.propertyRenaming !\u003d\n+            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC)) {\n+      passes.add(extractPrototypeMemberDeclarations);\n+    }\n+\n+    if (options.coalesceVariableNames) {\n+      passes.add(coalesceVariableNames);\n+    }\n+\n+    if (options.ambiguateProperties \u0026\u0026\n+        (options.propertyRenaming \u003d\u003d PropertyRenamingPolicy.ALL_UNQUOTED)) {\n+      passes.add(ambiguateProperties);\n+    }\n+\n+    if (options.propertyRenaming !\u003d PropertyRenamingPolicy.OFF) {\n+      passes.add(renameProperties);\n+    }\n+\n+    // Reserve global names added to the \"windows\" object.\n+    if (options.reserveRawExports) {\n+      passes.add(gatherRawExports);\n+    }\n+\n+    // This comes after property renaming because quoted property names must\n+    // not be renamed.\n+    if (options.convertToDottedProperties) {\n+      passes.add(convertToDottedProperties);\n+    }\n+\n+    // Property renaming must happen before this pass runs since this\n+    // pass may convert dotted properties into quoted properties.  It\n+    // is beneficial to run before alias strings, alias keywords and\n+    // variable renaming.\n+    if (options.rewriteFunctionExpressions) {\n+      passes.add(rewriteFunctionExpressions);\n+    }\n+\n+    // This comes after converting quoted property accesses to dotted property\n+    // accesses in order to avoid aliasing property names.\n+    if (!options.aliasableStrings.isEmpty() || options.aliasAllStrings) {\n+      passes.add(aliasStrings);\n+    }\n+\n+    if (options.aliasExternals) {\n+      passes.add(aliasExternals);\n+    }\n+\n+    if (options.aliasKeywords) {\n+      passes.add(aliasKeywords);\n+    }\n+\n+    if (options.collapseVariableDeclarations) {\n+      passes.add(collapseVariableDeclarations);\n+    }\n+\n+    passes.add(denormalize);\n+\n+    if (options.instrumentationTemplate !\u003d null) {\n+      passes.add(instrumentFunctions);\n+    }\n+\n+    if (options.variableRenaming !\u003d VariableRenamingPolicy.ALL) {\n+      // If we\u0027re leaving some (or all) variables with their old names,\n+      // then we need to undo any of the markers we added for distinguishing\n+      // local variables (\"$$1\").\n+      passes.add(invertContextualRenaming);\n+    }\n+\n+    if (options.variableRenaming !\u003d VariableRenamingPolicy.OFF) {\n+      passes.add(renameVars);\n+    }\n+\n+    if (options.groupVariableDeclarations) {\n+      passes.add(groupVariableDeclarations);\n+    }\n+\n+    // This pass should run after names stop changing.\n+    if (options.processObjectPropertyString) {\n+      passes.add(objectPropertyStringPostprocess);\n+    }\n+\n+    if (options.labelRenaming) {\n+      passes.add(renameLabels);\n+    }\n+\n+    if (options.anonymousFunctionNaming \u003d\u003d\n+        AnonymousFunctionNamingPolicy.UNMAPPED) {\n+      passes.add(nameUnmappedAnonymousFunctions);\n+    }\n+\n+    // Safety check\n+    if (options.checkSymbols) {\n+      passes.add(sanityCheckVars);\n+    }\n+\n     return passes;\n   }\n \n@@ -317,9 +559,9 @@\n       passes.add(inlineGetters);\n     }\n \n-    passes.addAll(getCodeRemovingPasses(false));\n+    passes.addAll(getCodeRemovingPasses());\n \n-    if (options.inlineFunctions) {\n+    if (options.inlineFunctions || options.inlineLocalFunctions) {\n       passes.add(inlineFunctions);\n     }\n \n@@ -334,10 +576,9 @@\n   }\n \n   /** Creates several passes aimed at removing code. */\n-  private List\u003cPassFactory\u003e getCodeRemovingPasses(\n-      boolean beforeSmartNameRemoval) {\n+  private List\u003cPassFactory\u003e getCodeRemovingPasses() {\n     List\u003cPassFactory\u003e passes \u003d Lists.newArrayList();\n-    if (options.inlineVariables \u0026\u0026 !beforeSmartNameRemoval) {\n+    if (options.inlineVariables || options.inlineLocalVariables) {\n       passes.add(inlineVariables);\n     } else if (options.inlineConstantVars) {\n       passes.add(inlineConstants);\n@@ -465,28 +706,43 @@\n     }\n   };\n \n+  /** Raw exports processing pass. */\n+  final PassFactory gatherRawExports \u003d\n+      new PassFactory(\"gatherRawExports\", false) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      final GatherRawExports pass \u003d new GatherRawExports(\n+          compiler);\n+\n+      return new CompilerPass() {\n+        @Override\n+        public void process(Node externs, Node root) {\n+          pass.process(externs, root);\n+          if (exportedNames \u003d\u003d null) {\n+            exportedNames \u003d Sets.newHashSet();\n+          }\n+          exportedNames.addAll(pass.getExportedVariableNames());\n+        }\n+      };\n+    }\n+  };\n+\n   /** Closure pre-processing pass. */\n   @SuppressWarnings(\"deprecation\")\n   final PassFactory closurePrimitives \u003d\n       new PassFactory(\"processProvidesAndRequires\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      final ProcessClosurePrimitives pass \u003d\n-          options.brokenClosureRequiresLevel !\u003d null ?\n-          new ProcessClosurePrimitives(\n-              compiler,\n-              options.brokenClosureRequiresLevel,\n-              options.rewriteNewDateGoogNow) :\n-          new ProcessClosurePrimitives(\n-              compiler,\n-              options.allowBrokenClosureRequires,\n-              options.rewriteNewDateGoogNow);\n+      final ProcessClosurePrimitives pass \u003d new ProcessClosurePrimitives(\n+          compiler,\n+          options.brokenClosureRequiresLevel,\n+          options.rewriteNewDateGoogNow);\n \n       return new CompilerPass() {\n         @Override\n         public void process(Node externs, Node root) {\n           pass.process(externs, root);\n-          setExportedNames(pass.getExportedVariableNames());\n+          exportedNames \u003d pass.getExportedVariableNames();\n         }\n       };\n     }\n@@ -517,13 +773,13 @@\n       return new CompilerPass() {\n         @Override\n         public void process(Node externs, Node jsRoot) {\n-          Map\u003cString, Integer\u003e cssNames \u003d null;\n+          Map\u003cString, Integer\u003e newCssNames \u003d null;\n           if (options.gatherCssNames) {\n-            cssNames \u003d Maps.newHashMap();\n+            newCssNames \u003d Maps.newHashMap();\n           }\n-          (new ReplaceCssNames(compiler, cssNames)).process(\n+          (new ReplaceCssNames(compiler, newCssNames)).process(\n               externs, jsRoot);\n-          setCssNames(cssNames);\n+          cssNames \u003d newCssNames;\n         }\n       };\n     }\n@@ -561,6 +817,24 @@\n     }\n   };\n \n+  /** Checks for RegExp references. */\n+  private final PassFactory checkRegExp \u003d\n+      new PassFactory(\"checkRegExp\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      final CheckRegExp pass \u003d new CheckRegExp(compiler);\n+\n+      return new CompilerPass() {\n+        @Override\n+        public void process(Node externs, Node root) {\n+          pass.process(externs, root);\n+          compiler.setHasRegExpGlobalReferences(\n+              pass.isGlobalRegExpPropertiesUsed());\n+        }\n+      };\n+    }\n+  };\n+\n   /** Checks that no vars are illegally shadowed. */\n   private final PassFactory checkShadowVars \u003d\n       new PassFactory(\"variableShadowDeclarationCheck\", true) {\n@@ -590,24 +864,6 @@\n     }\n   };\n \n-  /** Checks number of args passed to functions. */\n-  private final PassFactory checkFunctions \u003d\n-      new PassFactory(\"checkFunctions\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new FunctionCheck(compiler, options.checkFunctions);\n-    }\n-  };\n-\n-  /** Checks number of args passed to methods. */\n-  private final PassFactory checkMethods \u003d\n-      new PassFactory(\"checkMethods\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new MethodCheck(compiler, options.checkMethods);\n-    }\n-  };\n-\n   /** Creates a typed scope and adds types to the type registry. */\n   final PassFactory resolveTypes \u003d\n       new PassFactory(\"resolveTypes\", false) {\n@@ -786,6 +1042,34 @@\n     }\n   };\n \n+  /** Computes the names of functions for later analysis. */\n+  private final PassFactory computeFunctionNames \u003d\n+      new PassFactory(\"computeFunctionNames\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return ((functionNames \u003d new FunctionNames(compiler)));\n+    }\n+  };\n+\n+  /** Skips Caja-private properties in for-in loops */\n+  private final PassFactory ignoreCajaProperties \u003d\n+      new PassFactory(\"ignoreCajaProperties\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new IgnoreCajaProperties(compiler);\n+    }\n+  };\n+\n+  /** Inserts runtime type assertions for debugging. */\n+  private final PassFactory runtimeTypeCheck \u003d\n+      new PassFactory(\"runtimeTypeCheck\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new RuntimeTypeCheck(compiler,\n+          options.runtimeTypeCheckLogFunction);\n+    }\n+  };\n+\n   /** Generates unique ids. */\n   private final PassFactory replaceIdGenerators \u003d\n       new PassFactory(\"replaceIdGenerators\", true) {\n@@ -843,30 +1127,6 @@\n   };\n \n   /**\n-   * Undo the renaming to $$CONSTANT that we\u0027re doing to preserve\n-   * annotations.\n-   */\n-  private final PassFactory undoConstantRenaming \u003d\n-      new PassFactory(\"undoConstantNames\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new MakeDeclaredNamesUnique.UndoConstantRenaming(compiler);\n-    }\n-  };\n-\n-  /**\n-   * Add $$CONSTANT to names of constant variables, to preserve the\n-   * {@code @const} annotation.\n-   */\n-  private final PassFactory renameConstants \u003d\n-      new PassFactory(\"renameConstants\", false) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new Normalize(compiler, false).new RenameConstants();\n-    }\n-  };\n-\n-  /**\n    * Try to infer the actual types, which may be narrower\n    * than the declared types.\n    */\n@@ -955,7 +1215,16 @@\n         // schemes need to die.\n         return new ErrorPass(compiler, CANNOT_USE_PROTOTYPE_AND_VAR);\n       } else {\n-        return new InlineVariables(compiler, false, true);\n+        InlineVariables.Mode mode;\n+        if (options.inlineVariables) {\n+          mode \u003d InlineVariables.Mode.ALL;\n+        } else if (options.inlineLocalVariables) {\n+          mode \u003d InlineVariables.Mode.LOCALS_ONLY;\n+        } else {\n+          throw new IllegalStateException(\"No variable inlining option set.\");\n+        }\n+\n+        return new InlineVariables(compiler, mode, true);\n       }\n     }\n   };\n@@ -965,7 +1234,8 @@\n       new PassFactory(\"inlineConstants\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new InlineVariables(compiler, true, true);\n+      return new InlineVariables(\n+          compiler, InlineVariables.Mode.CONSTANTS_ONLY, true);\n     }\n   };\n \n@@ -1072,9 +1342,13 @@\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       boolean enableBlockInlining \u003d !isInliningForbidden();\n       return new InlineFunctions(\n-          compiler, compiler.getUniqueNameIdSupplier(),\n-          enableBlockInlining, options.decomposeExpressions,\n-          options.inlineAnonymousFunctionExpressions);\n+          compiler,\n+          compiler.getUniqueNameIdSupplier(),\n+          options.inlineFunctions,\n+          options.inlineLocalFunctions,\n+          options.inlineAnonymousFunctionExpressions,\n+          enableBlockInlining,\n+          options.decomposeExpressions);\n     }\n   };\n \n@@ -1083,8 +1357,12 @@\n       new PassFactory(\"removeUnusedVars\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      boolean preserveAnonymousFunctionNames \u003d\n+        options.anonymousFunctionNaming !\u003d AnonymousFunctionNamingPolicy.OFF;\n       return new RemoveUnusedVars(\n-          compiler, options.removeUnusedVarsInGlobalScope);\n+          compiler,\n+          options.removeUnusedVarsInGlobalScope,\n+          preserveAnonymousFunctionNames);\n     }\n   };\n \n@@ -1107,13 +1385,349 @@\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return new CrossModuleMethodMotion(\n-          compiler, getCrossModuleIdGenerator(),\n+          compiler, crossModuleIdGenerator,\n           // Only move properties in externs if we\u0027re not treating\n           // them as exports.\n           options.removeUnusedPrototypePropertiesInExterns);\n     }\n   };\n \n+  /** A data-flow based variable inliner. */\n+  private final PassFactory flowSensitiveInlineVariables \u003d\n+      new PassFactory(\"flowSensitiveInlineVariables\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new FlowSensitiveInlineVariables(compiler);\n+    }\n+  };\n+\n+  /** Uses register-allocation algorithms to use fewer variables. */\n+  private final PassFactory coalesceVariableNames \u003d\n+      new PassFactory(\"coalesceVariableNames\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new CoalesceVariableNames(compiler, options.generatePseudoNames);\n+    }\n+  };\n+\n+  /**\n+   * Some simple, local collapses (e.g., {@code var x; var y;} becomes\n+   * {@code var x,y;}.\n+   */\n+  private final PassFactory collapseVariableDeclarations \u003d\n+      new PassFactory(\"collapseVariableDeclarations\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      compiler.setUnnormalized();\n+      return new CollapseVariableDeclarations(compiler);\n+    }\n+  };\n+\n+  /**\n+   * Simple global collapses of variable declarations.\n+   */\n+  private final PassFactory groupVariableDeclarations \u003d\n+      new PassFactory(\"groupVariableDeclarations\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      compiler.setNormalized();\n+      return new GroupVariableDeclarations(compiler);\n+    }\n+  };\n+\n+  /**\n+   * Extracts common sub-expressions.\n+   */\n+  private final PassFactory extractPrototypeMemberDeclarations \u003d\n+      new PassFactory(\"extractPrototypeMemberDeclarations\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new ExtractPrototypeMemberDeclarations(compiler);\n+    }\n+  };\n+\n+  /** Rewrites common function definitions to be more compact. */\n+  private final PassFactory rewriteFunctionExpressions \u003d\n+      new PassFactory(\"rewriteFunctionExpressions\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new FunctionRewriter(compiler);\n+    }\n+  };\n+\n+  /** Collapses functions to not use the VAR keyword. */\n+  private final PassFactory collapseAnonymousFunctions \u003d\n+      new PassFactory(\"collapseAnonymousFunctions\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new CollapseAnonymousFunctions(compiler);\n+    }\n+  };\n+\n+  /** Moves function declarations to the top, to simulate actual hoisting. */\n+  private final PassFactory moveFunctionDeclarations \u003d\n+      new PassFactory(\"moveFunctionDeclarations\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new MoveFunctionDeclarations(compiler);\n+    }\n+  };\n+\n+  private final PassFactory nameUnmappedAnonymousFunctions \u003d\n+      new PassFactory(\"nameAnonymousFunctions\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new NameAnonymousFunctions(compiler);\n+    }\n+  };\n+\n+  private final PassFactory nameMappedAnonymousFunctions \u003d\n+      new PassFactory(\"nameAnonymousFunctions\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      return new CompilerPass() {\n+        @Override public void process(Node externs, Node root) {\n+          NameAnonymousFunctionsMapped naf \u003d\n+              new NameAnonymousFunctionsMapped(compiler);\n+          naf.process(externs, root);\n+          anonymousFunctionNameMap \u003d naf.getFunctionMap();\n+        }\n+      };\n+    }\n+  };\n+\n+  /** Alias external symbols. */\n+  private final PassFactory aliasExternals \u003d\n+      new PassFactory(\"aliasExternals\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new AliasExternals(compiler, compiler.getModuleGraph(),\n+          options.unaliasableGlobals, options.aliasableGlobals);\n+    }\n+  };\n+\n+  /**\n+   * Alias string literals with global variables, to avoid creating lots of\n+   * transient objects.\n+   */\n+  private final PassFactory aliasStrings \u003d\n+      new PassFactory(\"aliasStrings\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new AliasStrings(\n+          compiler,\n+          compiler.getModuleGraph(),\n+          options.aliasAllStrings ? null : options.aliasableStrings,\n+          options.aliasStringsBlacklist,\n+          options.outputJsStringUsage);\n+    }\n+  };\n+\n+  /** Aliases common keywords (true, false) */\n+  private final PassFactory aliasKeywords \u003d\n+      new PassFactory(\"aliasKeywords\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new AliasKeywords(compiler);\n+    }\n+  };\n+\n+  /** Handling for the ObjectPropertyString primitive. */\n+  private final PassFactory objectPropertyStringPostprocess \u003d\n+      new PassFactory(\"ObjectPropertyStringPostprocess\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new ObjectPropertyStringPostprocess(compiler);\n+    }\n+  };\n+\n+  /**\n+   * Renames properties so that the two properties that never appear on\n+   * the same object get the same name.\n+   */\n+  private final PassFactory ambiguateProperties \u003d\n+      new PassFactory(\"ambiguateProperties\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new AmbiguateProperties(\n+          compiler, options.anonymousFunctionNaming.getReservedCharacters());\n+    }\n+  };\n+\n+  /** Denormalize the AST for code generation. */\n+  private final PassFactory denormalize \u003d\n+      new PassFactory(\"denormalize\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      compiler.setUnnormalized();\n+      return new Denormalize(compiler);\n+    }\n+  };\n+\n+  /** Inverting name normalization. */\n+  private final PassFactory invertContextualRenaming \u003d\n+      new PassFactory(\"invertNames\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return MakeDeclaredNamesUnique.getContextualRenameInverter(compiler);\n+    }\n+  };\n+\n+  /**\n+   * Renames properties.\n+   */\n+  private final PassFactory renameProperties \u003d\n+      new PassFactory(\"renameProperties\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      VariableMap map \u003d null;\n+      if (options.inputPropertyMapSerialized !\u003d null) {\n+        try {\n+          map \u003d VariableMap.fromBytes(options.inputPropertyMapSerialized);\n+        } catch (ParseException e) {\n+          return new ErrorPass(compiler,\n+              JSError.make(INPUT_MAP_PROP_PARSE, e.getMessage()));\n+        }\n+      }\n+\n+      final VariableMap prevPropertyMap \u003d map;\n+      return new CompilerPass() {\n+        @Override public void process(Node externs, Node root) {\n+          propertyMap \u003d runPropertyRenaming(\n+              compiler, prevPropertyMap, externs, root);\n+        }\n+      };\n+    }\n+  };\n+\n+  private VariableMap runPropertyRenaming(\n+      AbstractCompiler compiler, VariableMap prevPropertyMap,\n+      Node externs, Node root) {\n+    char[] reservedChars \u003d\n+        options.anonymousFunctionNaming.getReservedCharacters();\n+    switch (options.propertyRenaming) {\n+      case HEURISTIC:\n+        RenamePrototypes rproto \u003d new RenamePrototypes(compiler, false,\n+            reservedChars, prevPropertyMap);\n+        rproto.process(externs, root);\n+        return rproto.getPropertyMap();\n+\n+      case AGGRESSIVE_HEURISTIC:\n+        RenamePrototypes rproto2 \u003d new RenamePrototypes(compiler, true,\n+            reservedChars, prevPropertyMap);\n+        rproto2.process(externs, root);\n+        return rproto2.getPropertyMap();\n+\n+      case ALL_UNQUOTED:\n+        RenameProperties rprop \u003d new RenameProperties(\n+            compiler, options.generatePseudoNames, prevPropertyMap,\n+            reservedChars);\n+        rprop.process(externs, root);\n+        return rprop.getPropertyMap();\n+\n+      default:\n+        throw new IllegalStateException(\n+            \"Unrecognized property renaming policy\");\n+    }\n+  }\n+\n+  /** Renames variables. */\n+  private final PassFactory renameVars \u003d\n+      new PassFactory(\"renameVars\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      VariableMap map \u003d null;\n+      if (options.inputVariableMapSerialized !\u003d null) {\n+        try {\n+          map \u003d VariableMap.fromBytes(options.inputVariableMapSerialized);\n+        } catch (ParseException e) {\n+          return new ErrorPass(compiler,\n+              JSError.make(INPUT_MAP_VAR_PARSE, e.getMessage()));\n+        }\n+      }\n+\n+      final VariableMap prevVariableMap \u003d map;\n+      return new CompilerPass() {\n+        @Override public void process(Node externs, Node root) {\n+          variableMap \u003d runVariableRenaming(\n+              compiler, prevVariableMap, externs, root);\n+        }\n+      };\n+    }\n+  };\n+\n+  private VariableMap runVariableRenaming(\n+      AbstractCompiler compiler, VariableMap prevVariableMap,\n+      Node externs, Node root) {\n+    char[] reservedChars \u003d\n+        options.anonymousFunctionNaming.getReservedCharacters();\n+    boolean preserveAnonymousFunctionNames \u003d\n+        options.anonymousFunctionNaming !\u003d AnonymousFunctionNamingPolicy.OFF;\n+    RenameVars rn \u003d new RenameVars(\n+        compiler,\n+        options.renamePrefix,\n+        options.variableRenaming \u003d\u003d VariableRenamingPolicy.LOCAL,\n+        preserveAnonymousFunctionNames,\n+        options.generatePseudoNames,\n+        prevVariableMap,\n+        reservedChars,\n+        exportedNames);\n+    rn.process(externs, root);\n+    return rn.getVariableMap();\n+  }\n+\n+  /** Renames labels */\n+  private final PassFactory renameLabels \u003d\n+      new PassFactory(\"renameLabels\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new RenameLabels(compiler);\n+    }\n+  };\n+\n+  /** Convert bracket access to dot access */\n+  private final PassFactory convertToDottedProperties \u003d\n+      new PassFactory(\"convertToDottedProperties\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new ConvertToDottedProperties(compiler);\n+    }\n+  };\n+\n+  /** Checks that all variables are defined. */\n+  private final PassFactory sanityCheckVars \u003d\n+      new PassFactory(\"sanityCheckVars\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new VarCheck(compiler, true);\n+    }\n+  };\n+\n+  /** Adds instrumentations according to an instrumentation template. */\n+  private final PassFactory instrumentFunctions \u003d\n+      new PassFactory(\"instrumentFunctions\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      return new CompilerPass() {\n+        @Override public void process(Node externs, Node root) {\n+          try {\n+            FileReader templateFile \u003d\n+                new FileReader(options.instrumentationTemplate);\n+            (new InstrumentFunctions(\n+                compiler, functionNames,\n+                options.instrumentationTemplate,\n+                options.appNameStr,\n+                templateFile)).process(externs, root);\n+          } catch (IOException e) {\n+            compiler.report(\n+                JSError.make(AbstractCompiler.READ_ERROR,\n+                    options.instrumentationTemplate));\n+          }\n+        }\n+      };\n+    }\n+  };\n+\n   /**\n    * Create a no-op pass that can only run once. Used to break up loops.\n    */\n@@ -1183,22 +1797,6 @@\n     return additionalReplacements;\n   }\n \n-  /** A compiler pass that just reports an error. */\n-  private static class ErrorPass implements CompilerPass {\n-    private final AbstractCompiler compiler;\n-    private final DiagnosticType error;\n-\n-    private ErrorPass(AbstractCompiler compiler, DiagnosticType error) {\n-      this.compiler \u003d compiler;\n-      this.error \u003d error;\n-    }\n-\n-    @Override\n-    public void process(Node externs, Node root) {\n-      compiler.report(JSError.make(error));\n-    }\n-  }\n-\n   /** A compiler pass that marks pure functions. */\n   private static class PureFunctionMarker implements CompilerPass {\n     private final AbstractCompiler compiler;\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "FieldDeclaration [26919,27469]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [7364,7442]"
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/DiagnosticGroups.java",
        "src/com/google/javascript/jscomp/DiagnosticGroups.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [],
          "num": 0
        },
        {
          "qualified_names": [
            "DiagnosticGroups",
            "setWarningLevels",
            "forName"
          ],
          "num": 3
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "25",
            "29",
            "41",
            "96"
          ],
          "num": 4
        },
        {
          "qualified_names": [
            "19",
            "22",
            "27",
            "31",
            "43",
            "47",
            "48",
            "49",
            "50",
            "51",
            "52",
            "53",
            "54",
            "107",
            "108",
            "109",
            "110",
            "111",
            "112",
            "113",
            "114",
            "115",
            "116",
            "117",
            "118",
            "119",
            "120",
            "121",
            "122",
            "123",
            "124",
            "125",
            "126",
            "127",
            "128",
            "129",
            "130",
            "131",
            "132",
            "133",
            "134"
          ],
          "num": 41
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/DiagnosticGroups.java b/src/com/google/javascript/jscomp/DiagnosticGroups.java\nindex 3a9f756..c29b417 100644\n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n@@ -16,17 +16,19 @@\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.collect.Maps;\n \n+import java.util.List;\n import java.util.Map;\n \n /**\n  * Named groups of DiagnosticTypes exposed by Compiler.\n-*\n+ * @author nicksantos@google.com (Nick Santos)\n  */\n public class DiagnosticGroups {\n \n-  private DiagnosticGroups() {} // all static\n+  public DiagnosticGroups() {}\n \n   private final static Map\u003cString, DiagnosticGroup\u003e groupsByName \u003d\n       Maps.newHashMap();\n@@ -38,10 +40,18 @@\n   }\n \n   /** Find the diagnostic group registered under the given name. */\n-  static DiagnosticGroup forName(String name) {\n+  protected DiagnosticGroup forName(String name) {\n     return groupsByName.get(name);\n   }\n \n+  // A bit a hack to display the available groups on the command-line.\n+  // New groups should be added to this list if they are public and should\n+  // be listed on the command-line as an available option.\n+  static final String DIAGNOSTIC_GROUP_NAMES \u003d \"accessControls, checkRegExp,\" +\n+      \"checkTypes, checkVars, deprecated, fileoverviewTags, invalidCasts, \" +\n+      \"missingProperties, nonStandardJsDocs, strictModuleDepCheck, \" +\n+      \"undefinedVars, unknownDefines, visibility\";\n+\n   public static DiagnosticGroup DEPRECATED \u003d DiagnosticGroups\n       .registerGroup(\"deprecated\",\n           new DiagnosticGroup(\n@@ -94,4 +104,32 @@\n       DiagnosticGroups.registerGroup(\"undefinedVars\",\n           new DiagnosticGroup(VarCheck.UNDEFINED_VAR_ERROR));\n \n+  public static DiagnosticGroup CHECK_REGEXP \u003d\n+    DiagnosticGroups.registerGroup(\"checkRegExp\",\n+        new DiagnosticGroup(\n+            CheckRegExp.REGEXP_REFERENCE));\n+\n+  public static DiagnosticGroup CHECK_TYPES \u003d\n+      DiagnosticGroups.registerGroup(\"checkTypes\",\n+          new DiagnosticGroup(\n+              TypeValidator.ALL_DIAGNOSTICS,\n+              TypeCheck.ALL_DIAGNOSTICS));\n+\n+  public static DiagnosticGroup CHECK_VARIABLES \u003d\n+    DiagnosticGroups.registerGroup(\"checkVars\",\n+        new DiagnosticGroup(\n+            VarCheck.UNDEFINED_VAR_ERROR,\n+            SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR));\n+\n+  /**\n+   * Adds warning levels by name.\n+   */\n+  void setWarningLevels(CompilerOptions options,\n+      List\u003cString\u003e diagnosticGroups, CheckLevel level) {\n+    for (String name : diagnosticGroups) {\n+      DiagnosticGroup group \u003d forName(name);\n+      Preconditions.checkNotNull(group, \"No warning class for name: \" + name);\n+      options.setWarningLevel(group, level);\n+    }\n+  }\n }\n",
      "operations": [
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "FieldDeclaration [4173,4340]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java",
        "src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "canInline"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "checkRightOf",
            "canInline",
            "checkLeftOf"
          ],
          "num": 3
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "20",
            "28",
            "79",
            "238",
            "251",
            "280",
            "365"
          ],
          "num": 7
        },
        {
          "qualified_names": [
            "21",
            "30",
            "82",
            "83",
            "84",
            "85",
            "86",
            "87",
            "88",
            "89",
            "90",
            "91",
            "92",
            "93",
            "94",
            "95",
            "96",
            "97",
            "98",
            "99",
            "100",
            "101",
            "102",
            "103",
            "104",
            "105",
            "106",
            "107",
            "108",
            "109",
            "110",
            "111",
            "264",
            "265",
            "266",
            "267",
            "268",
            "269",
            "270",
            "271",
            "272",
            "273",
            "274",
            "275",
            "276",
            "277",
            "278",
            "279",
            "280",
            "281",
            "282",
            "283",
            "284",
            "285",
            "286",
            "287",
            "288",
            "289",
            "290",
            "291",
            "292",
            "293",
            "294",
            "301",
            "314",
            "343",
            "429",
            "430",
            "431",
            "432",
            "433",
            "434",
            "435",
            "436",
            "437",
            "438",
            "439",
            "440",
            "441",
            "442",
            "443",
            "444",
            "445",
            "446",
            "447",
            "448",
            "449",
            "450",
            "451",
            "452",
            "453",
            "454",
            "455",
            "456",
            "457",
            "458",
            "459",
            "460",
            "461",
            "462",
            "463",
            "464",
            "465",
            "466",
            "467",
            "468",
            "469"
          ],
          "num": 107
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nindex 7b8a3e3..8ec85c1 100644\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -18,6 +18,7 @@\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n+import com.google.common.base.Predicates;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n@@ -26,6 +27,7 @@\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n@@ -77,6 +79,36 @@\n   private MustBeReachingVariableDef reachingDef;\n   private MaybeReachingVariableUse reachingUses;\n \n+  private static final Predicate\u003cNode\u003e SIDE_EFFECT_PREDICATE \u003d\n+    new Predicate\u003cNode\u003e() {\n+      @Override\n+      public boolean apply(Node n) {\n+        // When the node is null it means, we reached the implicit return\n+        // where the function returns (possibly without an return statement)\n+        if (n \u003d\u003d null) {\n+          return false;\n+        }\n+\n+        // TODO(user): We only care about calls to functions that\n+        // passes one of the dependent variable to a non-sideeffect free\n+        // function.\n+        if (NodeUtil.isCall(n) \u0026\u0026 NodeUtil.functionCallHasSideEffects(n)) {\n+          return true;\n+        }\n+\n+        if (NodeUtil.isNew(n) \u0026\u0026 NodeUtil.constructorCallHasSideEffects(n)) {\n+          return true;\n+        }\n+\n+        for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n+          if (!ControlFlowGraph.isEnteringNewCfgNode(c) \u0026\u0026 apply(c)) {\n+            return true;\n+          }\n+        }\n+        return false;\n+      }\n+  };\n+\n   public FlowSensitiveInlineVariables(AbstractCompiler compiler) {\n     this.compiler \u003d compiler;\n   }\n@@ -229,13 +261,44 @@\n         return false;\n       }\n \n+\n+      // The right of the definition has side effect:\n+      // Example, for x:\n+      // x \u003d readProp(b), modifyProp(b); print(x);\n+      if (checkRightOf(def, defCfgNode, SIDE_EFFECT_PREDICATE)) {\n+        return false;\n+      }\n+\n+      // Similar check as the above but this time, all the sub-expressions\n+      // left of the use of the variable.\n+      // x \u003d readProp(b); modifyProp(b), print(x);\n+      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n+        return false;\n+      }\n+\n+      // Similar side effect check as above but this time the side effect is\n+      // else where along the path.\n+      // x \u003d readProp(b); while(modifyProp(b)) {}; print(x);\n+      CheckPathsBetweenNodes\u003cNode, ControlFlowGraph.Branch\u003e\n+        pathCheck \u003d new CheckPathsBetweenNodes\u003cNode, ControlFlowGraph.Branch\u003e(\n+               cfg,\n+               cfg.getDirectedGraphNode(defCfgNode),\n+               cfg.getDirectedGraphNode(useCfgNode),\n+               SIDE_EFFECT_PREDICATE,\n+               Predicates.\n+                   \u003cDiGraphEdge\u003cNode, ControlFlowGraph.Branch\u003e\u003ealwaysTrue(),\n+               false);\n+      if (pathCheck.somePathsSatisfyPredicate()) {\n+        return false;\n+      }\n+\n       // TODO(user): Side-effect is ok sometimes. As long as there are no\n       // side-effect function down all paths to the use. Once we have all the\n       // side-effect analysis tool.\n       if (NodeUtil.mayHaveSideEffects(def.getLastChild())) {\n         return false;\n       }\n-      \n+\n       // TODO(user): We could inline all the uses if the expression is short.\n \n       // Finally we have to make sure that there are no more than one use\n@@ -248,7 +311,7 @@\n       // We give up inling stuff with R-Value that has GETPROP, GETELEM,\n       // or anything that creates a new object.\n       // Example:\n-      // var x \u003d a.b.c; j.c \u003d 1; print(x); \n+      // var x \u003d a.b.c; j.c \u003d 1; print(x);\n       // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n       // TODO(user): We could get more accuracy by looking more in-detail\n       // what j is and what x is trying to into to.\n@@ -277,7 +340,7 @@\n           })) {\n         return false;\n       }\n-      \n+\n       Collection\u003cNode\u003e uses \u003d reachingUses.getUses(varName, defCfgNode);\n \n       if (uses.size() !\u003d 1) {\n@@ -363,4 +426,45 @@\n       NodeTraversal.traverse(compiler, n, gatherCb);\n     }\n   }\n+\n+  /**\n+   * Given an expression by its root and sub-expression n, return true if there\n+   * the predicate is true for some expression on the right of n.\n+   *\n+   * Example:\n+   *\n+   * NotChecked(), NotChecked(), n, Checked(), Checked();\n+   */\n+  private static boolean checkRightOf(\n+      Node n, Node expressionRoot, Predicate\u003cNode\u003e predicate) {\n+    for (Node p \u003d n; p !\u003d expressionRoot; p \u003d p.getParent()) {\n+      for (Node cur \u003d p.getNext(); cur !\u003d null; cur \u003d cur.getNext()) {\n+        if (predicate.apply(cur)) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Given an expression by its root and sub-expression n, return true if there\n+   * the predicate is true for some expression on the left of n.\n+   *\n+   * Example:\n+   *\n+   * Checked(), Checked(), n, NotChecked(), NotChecked();\n+   */\n+  private static boolean checkLeftOf(\n+      Node n, Node expressionRoot, Predicate\u003cNode\u003e predicate) {\n+    for (Node p \u003d n.getParent(); p !\u003d expressionRoot; p \u003d p.getParent()) {\n+      for (Node cur \u003d p.getParent().getFirstChild(); cur !\u003d p;\n+          cur \u003d cur.getNext()) {\n+        if (predicate.apply(cur)) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n }\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [721,762]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [1304,1366]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "FieldDeclaration [3151,4109]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [14551,15130]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [15134,15748]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [9193,9282]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [9458,9546]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [9728,10151]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [10158,10232]"
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/TypedCodeGenerator.java",
        "src/com/google/javascript/jscomp/TypedCodeGenerator.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "add",
            "getFunctionAnnotation"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "TypedCodeGenerator",
            "getFunctionAnnotation",
            "add"
          ],
          "num": 3
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "24",
            "32",
            "33",
            "37",
            "38",
            "86",
            "87",
            "89",
            "90",
            "91",
            "92",
            "93",
            "95",
            "96",
            "97",
            "98",
            "124"
          ],
          "num": 17
        },
        {
          "qualified_names": [
            "25",
            "26",
            "34",
            "35",
            "38",
            "40",
            "41",
            "42",
            "43",
            "91",
            "92",
            "93",
            "95",
            "96",
            "97",
            "98",
            "99",
            "100",
            "101",
            "102",
            "103",
            "104",
            "132",
            "133",
            "134",
            "135",
            "136"
          ],
          "num": 27
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/TypedCodeGenerator.java b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\nindex 6f2c3b5..167f75f 100644\n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n@@ -22,6 +22,8 @@\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n \n+import java.nio.charset.Charset;\n+\n \n /**\n  * A code generator that outputs type annotations for functions and\n@@ -29,13 +31,16 @@\n *\n  */\n class TypedCodeGenerator extends CodeGenerator {\n-  TypedCodeGenerator(CodeConsumer consumer) {\n-    super(consumer);\n+  TypedCodeGenerator(CodeConsumer consumer, Charset outputCharset) {\n+    super(consumer, outputCharset, true);\n   }\n \n+  @Override\n   void add(Node n, Context context) {\n-    if (n.getParent().getType() \u003d\u003d Token.BLOCK\n-        || n.getParent().getType() \u003d\u003d Token.SCRIPT) {\n+    Node parent \u003d n.getParent();\n+    if (parent !\u003d null \n+        \u0026\u0026 (parent.getType() \u003d\u003d Token.BLOCK\n+            || parent.getType() \u003d\u003d Token.SCRIPT)) {\n       if (n.getType() \u003d\u003d Token.FUNCTION) {\n         add(getFunctionAnnotation(n));\n       } else if (n.getType() \u003d\u003d Token.EXPR_RESULT\n@@ -83,19 +88,21 @@\n     //   LP\n     //     NAME param1\n     //     NAME param2\n-    Node paramNode \u003d funType.getSource().getFirstChild().getNext()\n-        .getFirstChild();\n+    Node fnNode \u003d funType.getSource();\n+    if (fnNode !\u003d null) {\n+      Node paramNode \u003d NodeUtil.getFnParameters(fnNode).getFirstChild();\n \n-    // Param types\n-    for (Node n : funType.getParameters()) {\n-      // Skip any parameters for which we do not have a name.\n-      if (paramNode \u003d\u003d null) {\n-        break;\n+      // Param types\n+      for (Node n : funType.getParameters()) {\n+        // Bail out if the paramNode is not there.\n+        if (paramNode \u003d\u003d null) {\n+          break;\n+        }\n+        sb.append(\" * @param {\" + n.getJSType() + \"} \");\n+        sb.append(paramNode.getString());\n+        sb.append(\"\\n\");\n+        paramNode \u003d paramNode.getNext();\n       }\n-      sb.append(\" * @param {\" + n.getJSType() + \"} \");\n-      sb.append(paramNode.getString());\n-      sb.append(\"\\n\");\n-      paramNode \u003d paramNode.getNext();\n     }\n \n     // Return type\n@@ -122,6 +129,11 @@\n         sb.append(\" * @interface\\n\");\n       }\n     }\n+\n+    if (fnNode !\u003d null \u0026\u0026 fnNode.getBooleanProp(Node.IS_DISPATCHER)) {\n+      sb.append(\" * @javadispatch\\n\");\n+    }\n+\n     sb.append(\" */\\n\");\n     return sb.toString();\n   }\n",
      "operations": [
        {
          "type": "insert-node",
          "from": "",
          "to": "InfixExpression [1265,1373]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [1265,1279]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "INFIX_EXPRESSION_OPERATOR: \u0026\u0026 [1289,1291]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "ParenthesizedExpression [1292,1373]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        }
      ]
    }
  ],
  "inducing_type": {
    "add_classes": {
      "qualified_names": [
        "gen/com/google/javascript/jscomp/FunctionInfo.java",
        "gen/com/google/javascript/jscomp/FunctionInformationMap.java",
        "gen/com/google/javascript/jscomp/Instrumentation.java",
        "gen/com/google/javascript/jscomp/InstrumentationTemplate.java",
        "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "src/com/google/javascript/jscomp/CheckRegExp.java",
        "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "src/com/google/javascript/jscomp/ErrorPass.java",
        "src/com/google/javascript/jscomp/GatherRawExports.java",
        "src/com/google/javascript/jscomp/GroupVariableDeclarations.java",
        "src/com/google/javascript/jscomp/IgnoreCajaProperties.java",
        "src/com/google/javascript/jscomp/PrepareAst.java",
        "src/com/google/javascript/jscomp/RuntimeTypeCheck.java",
        "src/com/google/javascript/jscomp/Strings.java",
        "src/com/google/javascript/jscomp/Tracer.java",
        "src/com/google/javascript/jscomp/WarningLevel.java",
        "src/com/google/javascript/jscomp/ant/AntErrorManager.java",
        "src/com/google/javascript/jscomp/ant/CompileTask.java",
        "src/com/google/javascript/jscomp/deps/DependencyInfo.java",
        "src/com/google/javascript/jscomp/deps/DepsFileParser.java",
        "src/com/google/javascript/jscomp/deps/JsFileLineParser.java",
        "src/com/google/javascript/jscomp/deps/JsFileParser.java",
        "src/com/google/javascript/jscomp/deps/SimpleDependencyInfo.java",
        "src/com/google/javascript/jscomp/parsing/Annotation.java"
      ],
      "num": 24
    },
    "delete_classes": {
      "qualified_names": [
        "src/com/google/javascript/jscomp/AbstractCompilerRunner.java",
        "src/com/google/javascript/jscomp/CodingConventionAnnotator.java",
        "src/com/google/javascript/jscomp/CompilerRunner.java",
        "src/com/google/javascript/jscomp/FunctionCheck.java",
        "src/com/google/javascript/jscomp/MethodCheck.java",
        "src/com/google/javascript/jscomp/NodeTypeNormalizer.java"
      ],
      "num": 6
    },
    "add_functions": {
      "qualified_names": [
        "initCompilerOptionsIfTesting",
        "initBasedOnOptions",
        "newTracer",
        "checkLeftOf",
        "forName",
        "hasRegExpGlobalReferences",
        "stripCode",
        "TypedCodeGenerator",
        "getModuleGraph",
        "runPropertyRenaming",
        "stopTracer",
        "compileModules",
        "parse",
        "getInput",
        "setHasRegExpGlobalReferences",
        "setWarningLevels",
        "getResult",
        "runVariableRenaming",
        "setIntermediateState",
        "checkRightOf",
        "initOptions",
        "addIncrementalSourceAst",
        "DiagnosticGroups"
      ],
      "num": 23
    },
    "delete_functions": {
      "qualified_names": [
        "startPass",
        "getAstDotGraph",
        "precheck",
        "acquireSymbolTable",
        "setErrorManager",
        "reportCodeChange",
        "getSourceLine",
        "setPassConfig",
        "throwInternalError",
        "getRoot",
        "isNormalized",
        "getPassConfig",
        "process",
        "hasErrors",
        "removeChangeHandler",
        "getUniqueNameIdSupplier",
        "getErrorCount",
        "getTypeRegistry",
        "getLineIndex",
        "getSourceRegion",
        "hasHaltingErrors",
        "IntermediateState",
        "getWarningCount",
        "addChangeHandler",
        "endsWith",
        "reset",
        "getLength",
        "getColumnIndex",
        "toString",
        "append"
      ],
      "num": 30
    }
  },
  "trigger_tests": [
    {
      "test_class": "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest",
      "test_function": "testInlineArguments",
      "exception": "junit.framework.AssertionFailedError",
      "message": ""
    },
    {
      "test_class": "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest",
      "test_function": "testIssue698",
      "exception": "junit.framework.AssertionFailedError",
      "message": ""
    }
  ],
  "fixing_changes": [],
  "fixing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [],
      "num": 0
    },
    "add_functions": {
      "qualified_names": [],
      "num": 0
    },
    "delete_functions": {
      "qualified_names": [],
      "num": 0
    }
  }
}