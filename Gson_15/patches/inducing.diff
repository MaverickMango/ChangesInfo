diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java
new file mode 100644
index 0000000..0f626b3
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java
@@ -0,0 +1,1125 @@
+/*
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.stream;
+
+import java.io.Closeable;
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.Reader;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Reads a JSON (<a href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>)
+ * encoded value as a stream of tokens. This stream includes both literal
+ * values (strings, numbers, booleans, and nulls) as well as the begin and
+ * end delimiters of objects and arrays. The tokens are traversed in
+ * depth-first order, the same order that they appear in the JSON document.
+ * Within JSON objects, name/value pairs are represented by a single token.
+ *
+ * <h3>Parsing JSON</h3>
+ * To create a recursive descent parser your own JSON streams, first create an
+ * entry point method that creates a {@code JsonReader}.
+ *
+ * <p>Next, create handler methods for each structure in your JSON text. You'll
+ * need a method for each object type and for each array type.
+ * <ul>
+ *   <li>Within <strong>array handling</strong> methods, first call {@link
+ *       #beginArray} to consume the array's opening bracket. Then create a
+ *       while loop that accumulates values, terminating when {@link #hasNext}
+ *       is false. Finally, read the array's closing bracket by calling {@link
+ *       #endArray}.
+ *   <li>Within <strong>object handling</strong> methods, first call {@link
+ *       #beginObject} to consume the object's opening brace. Then create a
+ *       while loop that assigns values to local variables based on their name.
+ *       This loop should terminate when {@link #hasNext} is false. Finally,
+ *       read the object's closing brace by calling {@link #endObject}.
+ * </ul>
+ * <p>When a nested object or array is encountered, delegate to the
+ * corresponding handler method.
+ *
+ * <p>When an unknown name is encountered, strict parsers should fail with an
+ * exception. Lenient parsers should call {@link #skipValue()} to recursively
+ * skip the value's nested tokens, which may otherwise conflict.
+ *
+ * <p>If a value may be null, you should first check using {@link #peek()}.
+ * Null literals can be consumed using either {@link #nextNull()} or {@link
+ * #skipValue()}.
+ *
+ * <h3>Example</h3>
+ * Suppose we'd like to parse a stream of messages such as the following: <pre> {@code
+ * [
+ *   {
+ *     "id": 912345678901,
+ *     "text": "How do I read a JSON stream in Java?",
+ *     "geo": null,
+ *     "user": {
+ *       "name": "json_newb",
+ *       "followers_count": 41
+ *      }
+ *   },
+ *   {
+ *     "id": 912345678902,
+ *     "text": "@json_newb just use JsonReader!",
+ *     "geo": [50.454722, -104.606667],
+ *     "user": {
+ *       "name": "jesse",
+ *       "followers_count": 2
+ *     }
+ *   }
+ * ]}</pre>
+ * This code implements the parser for the above structure: <pre>   {@code
+ *
+ *   public List<Message> readJsonStream(InputStream in) throws IOException {
+ *     JsonReader reader = new JsonReader(new InputStreamReader(in, "UTF-8"));
+ *     return readMessagesArray(reader);
+ *   }
+ *
+ *   public List<Message> readMessagesArray(JsonReader reader) throws IOException {
+ *     List<Message> messages = new ArrayList<Message>();
+ *
+ *     reader.beginArray();
+ *     while (reader.hasNext()) {
+ *       messages.add(readMessage(reader));
+ *     }
+ *     reader.endArray();
+ *     return messages;
+ *   }
+ *
+ *   public Message readMessage(JsonReader reader) throws IOException {
+ *     long id = -1;
+ *     String text = null;
+ *     User user = null;
+ *     List<Double> geo = null;
+ *
+ *     reader.beginObject();
+ *     while (reader.hasNext()) {
+ *       String name = reader.nextName();
+ *       if (name.equals("id")) {
+ *         id = reader.nextLong();
+ *       } else if (name.equals("text")) {
+ *         text = reader.nextString();
+ *       } else if (name.equals("geo") && reader.peek() != JsonToken.NULL) {
+ *         geo = readDoublesArray(reader);
+ *       } else if (name.equals("user")) {
+ *         user = readUser(reader);
+ *       } else {
+ *         reader.skipValue();
+ *       }
+ *     }
+ *     reader.endObject();
+ *     return new Message(id, text, user, geo);
+ *   }
+ *
+ *   public List<Double> readDoublesArray(JsonReader reader) throws IOException {
+ *     List<Double> doubles = new ArrayList<Double>();
+ *
+ *     reader.beginArray();
+ *     while (reader.hasNext()) {
+ *       doubles.add(reader.nextDouble());
+ *     }
+ *     reader.endArray();
+ *     return doubles;
+ *   }
+ *
+ *   public User readUser(JsonReader reader) throws IOException {
+ *     String username = null;
+ *     int followersCount = -1;
+ *
+ *     reader.beginObject();
+ *     while (reader.hasNext()) {
+ *       String name = reader.nextName();
+ *       if (name.equals("name")) {
+ *         username = reader.nextString();
+ *       } else if (name.equals("followers_count")) {
+ *         followersCount = reader.nextInt();
+ *       } else {
+ *         reader.skipValue();
+ *       }
+ *     }
+ *     reader.endObject();
+ *     return new User(username, followersCount);
+ *   }}</pre>
+ *
+ * <h3>Number Handling</h3>
+ * This reader permits numeric values to be read as strings and string values to
+ * be read as numbers. For example, both elements of the JSON array {@code
+ * [1, "1"]} may be read using either {@link #nextInt} or {@link #nextString}.
+ * This behavior is intended to prevent lossy numeric conversions: double is
+ * JavaScript's only numeric type and very large values like {@code
+ * 9007199254740993} cannot be represented exactly on that platform. To minimize
+ * precision loss, extremely large values should be written and read as strings
+ * in JSON.
+ *
+ * <a name="nonexecuteprefix"/><h3>Non-Execute Prefix</h3>
+ * Web servers that serve private data using JSON may be vulnerable to <a
+ * href="http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery">Cross-site
+ * request forgery</a> attacks. In such an attack, a malicious site gains access
+ * to a private JSON file by executing it with an HTML {@code <script>} tag.
+ *
+ * <p>Prefixing JSON files with <code>")]}'\n"</code> makes them non-executable
+ * by {@code <script>} tags, disarming the attack. Since the prefix is malformed
+ * JSON, strict parsing fails when it is encountered. This class permits the
+ * non-execute prefix when {@link #setLenient(boolean) lenient parsing} is
+ * enabled.
+ *
+ * <p>Each {@code JsonReader} may be used to read a single JSON stream. Instances
+ * of this class are not thread safe.
+ * 
+ * @author Jesse Wilson
+ */
+public final class JsonReader implements Closeable {
+
+  /** The only non-execute prefix this parser permits */
+  private static final char[] NON_EXECUTE_PREFIX = ")]}'\n".toCharArray();
+
+  /** The input JSON. */
+  private final Reader in;
+
+  /** True to accept non-spec compliant JSON */
+  private boolean lenient = false;
+
+  /**
+   * Use a manual buffer to easily read and unread upcoming characters, and
+   * also so we can create strings without an intermediate StringBuilder.
+   */
+  private final char[] buffer = new char[1024];
+  private int pos = 0;
+  private int limit = 0;
+
+  private final List<JsonScope> stack = new ArrayList<JsonScope>();
+  {
+    push(JsonScope.EMPTY_DOCUMENT);
+  }
+
+  /**
+   * True if we've already read the next token. If we have, the string value
+   * for that token will be assigned to {@code value} if such a string value
+   * exists. And the token type will be assigned to {@code token} if the token
+   * type is known. The token type may be null for literals, since we derive
+   * that lazily.
+   */
+  private boolean hasToken;
+
+  /**
+   * The type of the next token to be returned by {@link #peek} and {@link
+   * #advance}, or {@code null} if it is unknown and must first be derived
+   * from {@code value}. This value is undefined if {@code hasToken} is false.
+   */
+  private JsonToken token;
+
+  /** The text of the next name. */
+  private String name;
+
+  /** The text of the next literal value. */
+  private String value;
+
+  /** True if we're currently handling a skipValue() call. */
+  private boolean skipping = false;
+
+  /**
+   * Creates a new instance that reads a JSON-encoded stream from {@code in}.
+   */
+  public JsonReader(Reader in) {
+    if (in == null) {
+      throw new NullPointerException("in == null");
+    }
+    this.in = in;
+  }
+
+  /**
+   * Configure this parser to be  be liberal in what it accepts. By default,
+   * this parser is strict and only accepts JSON as specified by <a
+   * href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>. Setting the
+   * parser to lenient causes it to ignore the following syntax errors:
+   *
+   * <ul>
+   *   <li>Streams that start with the <a href="#nonexecuteprefix">non-execute
+   *       prefix</a>, <code>")]}'\n"</code>.
+   *   <li>Streams that include multiple top-level values. With strict parsing,
+   *       each stream must contain exactly one top-level value.
+   *   <li>Top-level values of any type. With strict parsing, the top-level
+   *       value must be an object or an array.
+   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link
+   *       Double#isInfinite() infinities}.
+   *   <li>End of line comments starting with {@code //} or {@code #} and
+   *       ending with a newline character.
+   *   <li>C-style comments starting with {@code /*} and ending with
+   *       {@code *}{@code /}. Such comments may not be nested.
+   *   <li>Names that are unquoted or {@code 'single quoted'}.
+   *   <li>Strings that are unquoted or {@code 'single quoted'}.
+   *   <li>Array elements separated by {@code ;} instead of {@code ,}.
+   *   <li>Unnecessary array separators. These are interpreted as if null
+   *       was the omitted value.
+   *   <li>Names and values separated by {@code =} or {@code =>} instead of
+   *       {@code :}.
+   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.
+   * </ul>
+   */
+  public void setLenient(boolean lenient) {
+    this.lenient = lenient;
+  }
+
+  /**
+   * Returns true if this parser is liberal in what it accepts.
+   */
+  public boolean isLenient() {
+    return lenient;
+  }
+
+  /**
+   * Consumes the next token from the JSON stream and asserts that it is the
+   * beginning of a new array.
+   */
+  public void beginArray() throws IOException {
+    expect(JsonToken.BEGIN_ARRAY);
+  }
+
+  /**
+   * Consumes the next token from the JSON stream and asserts that it is the
+   * end of the current array.
+   */
+  public void endArray() throws IOException {
+    expect(JsonToken.END_ARRAY);
+  }
+
+  /**
+   * Consumes the next token from the JSON stream and asserts that it is the
+   * beginning of a new object.
+   */
+  public void beginObject() throws IOException {
+    expect(JsonToken.BEGIN_OBJECT);
+  }
+
+  /**
+   * Consumes the next token from the JSON stream and asserts that it is the
+   * end of the current array.
+   */
+  public void endObject() throws IOException {
+    expect(JsonToken.END_OBJECT);
+  }
+
+  /**
+   * Consumes {@code expected}.
+   */
+  private void expect(JsonToken expected) throws IOException {
+    quickPeek();
+    if (token != expected) {
+      throw new IllegalStateException("Expected " + expected + " but was " + peek());
+    }
+    advance();
+  }
+
+  /**
+   * Returns true if the current array or object has another element.
+   */
+  public boolean hasNext() throws IOException {
+    quickPeek();
+    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;
+  }
+
+  /**
+   * Returns the type of the next token without consuming it.
+   */
+  public JsonToken peek() throws IOException {
+    quickPeek();
+
+    if (token == null) {
+      decodeLiteral();
+    }
+
+    return token;
+  }
+
+  /**
+   * Ensures that a token is ready. After this call either {@code token} or
+   * {@code value} will be non-null. To ensure {@code token} has a definitive
+   * value, use {@link #peek()}
+   */
+  private JsonToken quickPeek() throws IOException {
+    if (hasToken) {
+      return token;
+    }
+
+    switch (peekStack()) {
+    case EMPTY_DOCUMENT:
+      if (lenient) {
+        consumeNonExecutePrefix();
+      }
+      replaceTop(JsonScope.NONEMPTY_DOCUMENT);
+      JsonToken firstToken = nextValue();
+      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {
+        syntaxError("Expected JSON document to start with '[' or '{'");
+      }
+      return firstToken;
+    case EMPTY_ARRAY:
+      return nextInArray(true);
+    case NONEMPTY_ARRAY:
+      return nextInArray(false);
+    case EMPTY_OBJECT:
+      return nextInObject(true);
+    case DANGLING_NAME:
+      return objectValue();
+    case NONEMPTY_OBJECT:
+      return nextInObject(false);
+    case NONEMPTY_DOCUMENT:
+      try {
+        JsonToken token = nextValue();
+        if (lenient) {
+          return token;
+        } else {
+          throw syntaxError("Expected EOF");
+        }
+      } catch (EOFException e) {
+        hasToken = true; // TODO: avoid throwing here?
+        return token = JsonToken.END_DOCUMENT;
+      }
+    case CLOSED:
+      throw new IllegalStateException("JsonReader is closed");
+    default:
+      throw new AssertionError();
+    }
+  }
+
+  /**
+   * Consumes the non-execute prefix if it exists.
+   */
+  private void consumeNonExecutePrefix() throws IOException {
+    // fast forward through the leading whitespace
+    nextNonWhitespace();
+    pos--;
+    
+    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {
+      return;
+    }
+    
+    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {
+      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {
+        return; // not a security token!
+      }
+    }
+    
+    // we consumed a security token!
+    pos += NON_EXECUTE_PREFIX.length;
+  }
+
+  /**
+   * Advances the cursor in the JSON stream to the next token.
+   */
+  private JsonToken advance() throws IOException {
+    quickPeek();
+
+    JsonToken result = token;
+    hasToken = false;
+    token = null;
+    value = null;
+    name = null;
+    return result;
+  }
+
+  /**
+   * Returns the next token, a {@link JsonToken#NAME property name}, and
+   * consumes it.
+   *
+   * @throws IOException if the next token in the stream is not a property
+   *     name.
+   */
+  public String nextName() throws IOException {
+    quickPeek();
+    if (token != JsonToken.NAME) {
+      throw new IllegalStateException("Expected a name but was " + peek());
+    }
+    String result = name;
+    advance();
+    return result;
+  }
+
+  /**
+   * Returns the {@link JsonToken#STRING string} value of the next token,
+   * consuming it. If the next token is a number, this method will return its
+   * string form.
+   *
+   * @throws IllegalStateException if the next token is not a string or if
+   *     this reader is closed.
+   */
+  public String nextString() throws IOException {
+    peek();
+    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {
+      throw new IllegalStateException("Expected a string but was " + peek());
+    }
+
+    String result = value;
+    advance();
+    return result;
+  }
+
+  /**
+   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,
+   * consuming it.
+   *
+   * @throws IllegalStateException if the next token is not a boolean or if
+   *     this reader is closed.
+   */
+  public boolean nextBoolean() throws IOException {
+    quickPeek();
+    if (value == null || token == JsonToken.STRING) {
+      throw new IllegalStateException("Expected a boolean but was " + peek());
+    }
+
+    boolean result;
+    if (value.equalsIgnoreCase("true")) {
+      result = true;
+    } else if (value.equalsIgnoreCase("false")) {
+      result = false;
+    } else {
+      throw new IllegalStateException("Not a boolean: " + value);
+    }
+
+    advance();
+    return result;
+  }
+
+  /**
+   * Consumes the next token from the JSON stream and asserts that it is a
+   * literal null.
+   *
+   * @throws IllegalStateException if the next token is not null or if this
+   *     reader is closed.
+   */
+  public void nextNull() throws IOException {
+    quickPeek();
+    if (value == null || token == JsonToken.STRING) {
+      throw new IllegalStateException("Expected null but was " + peek());
+    }
+
+    if (!value.equalsIgnoreCase("null")) {
+      throw new IllegalStateException("Not a null: " + value);
+    }
+
+    advance();
+  }
+
+  /**
+   * Returns the {@link JsonToken#NUMBER double} value of the next token,
+   * consuming it. If the next token is a string, this method will attempt to
+   * parse it as a double.
+   *
+   * @throws IllegalStateException if the next token is not a literal value.
+   * @throws NumberFormatException if the next literal value cannot be parsed
+   *     as a double, or is non-finite.
+   */
+  public double nextDouble() throws IOException {
+    quickPeek();
+    if (value == null) {
+      throw new IllegalStateException("Expected a double but was " + peek());
+    }
+
+    double result = Double.parseDouble(value);
+
+    if ((result >= 1.0d && value.startsWith("0"))) {
+      throw new NumberFormatException("JSON forbids octal prefixes: " + value);
+    }
+
+    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
+      throw new NumberFormatException("JSON forbids NaN and infinities: " + value);
+    }
+
+    advance();
+    return result;
+  }
+
+  /**
+   * Returns the {@link JsonToken#NUMBER long} value of the next token,
+   * consuming it. If the next token is a string, this method will attempt to
+   * parse it as a long. If the next token's numeric value cannot be exactly
+   * represented by a Java {@code long}, this method throws.
+   *
+   * @throws IllegalStateException if the next token is not a literal value.
+   * @throws NumberFormatException if the next literal value cannot be parsed
+   *     as a number, or exactly represented as a long.
+   */
+  public long nextLong() throws IOException {
+    quickPeek();
+    if (value == null) {
+      throw new IllegalStateException("Expected a long but was " + peek());
+    }
+
+    long result;
+    try {
+      result = Long.parseLong(value);
+    } catch (NumberFormatException ignored) {
+      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException
+      result = (long) asDouble;
+      if ((double) result != asDouble) {
+        throw new NumberFormatException(value);
+      }
+    }
+
+    if (result >= 1L && value.startsWith("0")) {
+      throw new NumberFormatException("JSON forbids octal prefixes: " + value);
+    }
+
+    advance();
+    return result;
+  }
+
+  /**
+   * Returns the {@link JsonToken#NUMBER int} value of the next token,
+   * consuming it. If the next token is a string, this method will attempt to
+   * parse it as an int. If the next token's numeric value cannot be exactly
+   * represented by a Java {@code int}, this method throws.
+   *
+   * @throws IllegalStateException if the next token is not a literal value.
+   * @throws NumberFormatException if the next literal value cannot be parsed
+   *     as a number, or exactly represented as an int.
+   */
+  public int nextInt() throws IOException {
+    quickPeek();
+    if (value == null) {
+      throw new IllegalStateException("Expected an int but was " + peek());
+    }
+
+    int result;
+    try {
+      result = Integer.parseInt(value);
+    } catch (NumberFormatException ignored) {
+      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException
+      result = (int) asDouble;
+      if ((double) result != asDouble) {
+        throw new NumberFormatException(value);
+      }
+    }
+
+    if (result >= 1L && value.startsWith("0")) {
+      throw new NumberFormatException("JSON forbids octal prefixes: " + value);
+    }
+
+    advance();
+    return result;
+  }
+
+  /**
+   * Closes this JSON reader and the underlying {@link Reader}.
+   */
+  public void close() throws IOException {
+    hasToken = false;
+    value = null;
+    token = null;
+    stack.clear();
+    stack.add(JsonScope.CLOSED);
+    in.close();
+  }
+
+  /**
+   * Skips the next value recursively. If it is an object or array, all nested
+   * elements are skipped. This method is intended for use when the JSON token
+   * stream contains unrecognized or unhandled values.
+   */
+  public void skipValue() throws IOException {
+    skipping = true;
+    try {
+      int count = 0;
+      do {
+        JsonToken token = advance();
+        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {
+          count++;
+        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {
+          count--;
+        }
+      } while (count != 0);
+    } finally {
+      skipping = false;
+    }
+  }
+
+  private JsonScope peekStack() {
+    return stack.get(stack.size() - 1);
+  }
+
+  private JsonScope pop() {
+    return stack.remove(stack.size() - 1);
+  }
+
+  private void push(JsonScope newTop) {
+    stack.add(newTop);
+  }
+
+  /**
+   * Replace the value on the top of the stack with the given value.
+   */
+  private void replaceTop(JsonScope newTop) {
+    stack.set(stack.size() - 1, newTop);
+  }
+
+  private JsonToken nextInArray(boolean firstElement) throws IOException {
+    if (firstElement) {
+      replaceTop(JsonScope.NONEMPTY_ARRAY);
+    } else {
+      /* Look for a comma before each element after the first element. */
+      switch (nextNonWhitespace()) {
+      case ']':
+        pop();
+        hasToken = true;
+        return token = JsonToken.END_ARRAY;
+      case ';':
+        checkLenient(); // fall-through
+      case ',':
+        break;
+      default:
+        throw syntaxError("Unterminated array");
+      }
+    }
+
+    switch (nextNonWhitespace()) {
+    case ']':
+      if (firstElement) {
+        pop();
+        hasToken = true;
+        return token = JsonToken.END_ARRAY;
+      }
+      // fall-through to handle ",]"
+    case ';':
+    case ',':
+      /* In lenient mode, a 0-length literal means 'null' */
+      checkLenient();
+      pos--;
+      hasToken = true;
+      value = "null";
+      return token = JsonToken.NULL;
+    default:
+      pos--;
+      return nextValue();
+    }
+  }
+
+  private JsonToken nextInObject(boolean firstElement) throws IOException {
+    /*
+     * Read delimiters. Either a comma/semicolon separating this and the
+     * previous name-value pair, or a close brace to denote the end of the
+     * object.
+     */
+    if (firstElement) {
+      /* Peek to see if this is the empty object. */
+      switch (nextNonWhitespace()) {
+      case '}':
+        pop();
+        hasToken = true;
+        return token = JsonToken.END_OBJECT;
+      default:
+        pos--;
+      }
+    } else {
+      switch (nextNonWhitespace()) {
+      case '}':
+        pop();
+        hasToken = true;
+        return token = JsonToken.END_OBJECT;
+      case ';':
+      case ',':
+        break;
+      default:
+        throw syntaxError("Unterminated object");
+      }
+    }
+
+    /* Read the name. */
+    int quote = nextNonWhitespace();
+    switch (quote) {
+    case '\'':
+      checkLenient(); // fall-through
+    case '"':
+      name = nextString((char) quote);
+      break;
+    default:
+      checkLenient();
+      pos--;
+      name = nextLiteral();
+      if (name.isEmpty()) {
+        throw syntaxError("Expected name");
+      }
+    }
+
+    replaceTop(JsonScope.DANGLING_NAME);
+    hasToken = true;
+    return token = JsonToken.NAME;
+  }
+
+  private JsonToken objectValue() throws IOException {
+    /*
+     * Read the name/value separator. Usually a colon ':'. In lenient mode
+     * we also accept an equals sign '=', or an arrow "=>".
+     */
+    switch (nextNonWhitespace()) {
+    case ':':
+      break;
+    case '=':
+      checkLenient();
+      if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
+        pos++;
+      }
+      break;
+    default:
+      throw syntaxError("Expected ':'");
+    }
+
+    replaceTop(JsonScope.NONEMPTY_OBJECT);
+    return nextValue();
+  }
+
+  private JsonToken nextValue() throws IOException {
+    int c = nextNonWhitespace();
+    switch (c) {
+    case '{':
+      push(JsonScope.EMPTY_OBJECT);
+      hasToken = true;
+      return token = JsonToken.BEGIN_OBJECT;
+
+    case '[':
+      push(JsonScope.EMPTY_ARRAY);
+      hasToken = true;
+      return token = JsonToken.BEGIN_ARRAY;
+
+    case '\'':
+      checkLenient(); // fall-through
+    case '"':
+      value = nextString((char) c);
+      hasToken = true;
+      return token = JsonToken.STRING;
+
+    default:
+      pos--;
+      return readLiteral();
+    }
+  }
+
+  /**
+   * Returns true once {@code limit - pos >= minimum}. If the data is
+   * exhausted before that many characters are available, this returns
+   * false.
+   */
+  private boolean fillBuffer(int minimum) throws IOException {
+    if (limit != pos) {
+      limit -= pos;
+      System.arraycopy(buffer, pos, buffer, 0, limit);
+    } else {
+      limit = 0;
+    }
+
+    pos = 0;
+    int total;
+    while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {
+      limit += total;
+      if (limit >= minimum) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private int nextNonWhitespace() throws IOException {
+    while (pos < limit || fillBuffer(1)) {
+      int c = buffer[pos++];
+      switch (c) {
+      case '\t':
+      case ' ':
+      case '\n':
+      case '\r':
+        continue;
+
+      case '/':
+        if (pos == limit && !fillBuffer(1)) {
+          return c;
+        }
+
+        checkLenient();
+        char peek = buffer[pos];
+        switch (peek) {
+        case '*':
+          // skip a /* c-style comment */
+          pos++;
+          if (!skipTo("*/")) {
+            throw syntaxError("Unterminated comment");
+          }
+          pos += 2;
+          continue;
+
+        case '/':
+          // skip a // end-of-line comment
+          pos++;
+          skipToEndOfLine();
+          continue;
+
+        default:
+          return c;
+        }
+
+      case '#':
+        /*
+         * Skip a # hash end-of-line comment. The JSON RFC doesn't
+         * specify this behaviour, but it's required to parse
+         * existing documents. See http://b/2571423.
+         */
+        checkLenient();
+        skipToEndOfLine();
+        continue;
+
+      default:
+        return c;
+      }
+    }
+    throw new EOFException("End of input");
+  }
+
+  private void checkLenient() throws IOException {
+    if (!lenient) {
+      throw syntaxError("Use JsonReader.setLenient(true) to accept malformed JSON");
+    }
+  }
+
+  /**
+   * Advances the position until after the next newline character. If the line
+   * is terminated by "\r\n", the '\n' must be consumed as whitespace by the
+   * caller.
+   */
+  private void skipToEndOfLine() throws IOException {
+    while (pos < limit || fillBuffer(1)) {
+      char c = buffer[pos++];
+      if (c == '\r' || c == '\n') {
+        break;
+      }
+    }
+  }
+
+  private boolean skipTo(String toFind) throws IOException {
+    outer:
+    for (; pos + toFind.length() < limit || fillBuffer(toFind.length()); pos++) {
+      for (int c = 0; c < toFind.length(); c++) {
+        if (buffer[pos + c] != toFind.charAt(c)) {
+          continue outer;
+        }
+      }
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * Returns the string up to but not including {@code quote}, unescaping any
+   * character escape sequences encountered along the way. The opening quote
+   * should have already been read. This consumes the closing quote, but does
+   * not include it in the returned string.
+   *
+   * @param quote either ' or ".
+   * @throws NumberFormatException if any unicode escape sequences are
+   *     malformed.
+   */
+  private String nextString(char quote) throws IOException {
+    StringBuilder builder = null;
+    do {
+      /* the index of the first character not yet appended to the builder. */
+      int start = pos;
+      while (pos < limit) {
+        int c = buffer[pos++];
+
+        if (c == quote) {
+          if (skipping) {
+            return "skipped!";
+          } else if (builder == null) {
+            return new String(buffer, start, pos - start - 1);
+          } else {
+            builder.append(buffer, start, pos - start - 1);
+            return builder.toString();
+          }
+
+        } else if (c == '\\') {
+          if (builder == null) {
+            builder = new StringBuilder();
+          }
+          builder.append(buffer, start, pos - start - 1);
+          builder.append(readEscapeCharacter());
+          start = pos;
+        }
+      }
+
+      if (builder == null) {
+        builder = new StringBuilder();
+      }
+      builder.append(buffer, start, pos - start);
+    } while (fillBuffer(1));
+
+    throw syntaxError("Unterminated string");
+  }
+
+  /**
+   * Returns the string up to but not including any delimiter characters. This
+   * does not consume the delimiter character.
+   */
+  private String nextLiteral() throws IOException {
+    StringBuilder builder = null;
+    do {
+      /* the index of the first character not yet appended to the builder. */
+      int start = pos;
+      while (pos < limit) {
+        int c = buffer[pos++];
+        switch (c) {
+        case '/':
+        case '\\':
+        case ';':
+        case '#':
+        case '=':
+          checkLenient(); // fall-through
+
+        case '{':
+        case '}':
+        case '[':
+        case ']':
+        case ':':
+        case ',':
+        case ' ':
+        case '\t':
+        case '\f':
+        case '\r':
+        case '\n':
+          pos--;
+          if (skipping) {
+            return "skipped!";
+          } else if (builder == null) {
+            return new String(buffer, start, pos - start);
+          } else {
+            builder.append(buffer, start, pos - start);
+            return builder.toString();
+          }
+        }
+      }
+
+      if (builder == null) {
+        builder = new StringBuilder();
+      }
+      builder.append(buffer, start, pos - start);
+    } while (fillBuffer(1));
+
+    return builder.toString();
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName() + " near " + getSnippet();
+  }
+
+  /**
+   * Unescapes the character identified by the character or characters that
+   * immediately follow a backslash. The backslash '\' should have already
+   * been read. This supports both unicode escapes "u000A" and two-character
+   * escapes "\n".
+   *
+   * @throws NumberFormatException if any unicode escape sequences are
+   *     malformed.
+   */
+  private char readEscapeCharacter() throws IOException {
+    if (pos == limit && !fillBuffer(1)) {
+      throw syntaxError("Unterminated escape sequence");
+    }
+
+    char escaped = buffer[pos++];
+    switch (escaped) {
+    case 'u':
+      if (pos + 4 > limit && !fillBuffer(4)) {
+        throw syntaxError("Unterminated escape sequence");
+      }
+      String hex = new String(buffer, pos, 4);
+      pos += 4;
+      return (char) Integer.parseInt(hex, 16);
+
+    case 't':
+      return '\t';
+
+    case 'b':
+      return '\b';
+
+    case 'n':
+      return '\n';
+
+    case 'r':
+      return '\r';
+
+    case 'f':
+      return '\f';
+
+    case '\'':
+    case '"':
+    case '\\':
+    default:
+      return escaped;
+    }
+  }
+
+  /**
+   * Reads a null, boolean, numeric or unquoted string literal value.
+   */
+  private JsonToken readLiteral() throws IOException {
+    String literal = nextLiteral();
+    if (literal.isEmpty()) {
+      throw syntaxError("Expected literal value");
+    }
+    value = literal;
+    hasToken = true;
+    return token = null; // use decodeLiteral() to get the token type
+  }
+
+  /**
+   * Assigns {@code nextToken} based on the value of {@code nextValue}.
+   */
+  private void decodeLiteral() throws IOException {
+    if (value.equalsIgnoreCase("null")) {
+      token = JsonToken.NULL;
+    } else if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) {
+      token = JsonToken.BOOLEAN;
+    } else {
+      try {
+        Double.parseDouble(value); // this work could potentially be cached
+        token = JsonToken.NUMBER;
+      } catch (NumberFormatException ignored) {
+        // this must be an unquoted string
+        checkLenient();
+        token = JsonToken.STRING;
+      }
+    }
+  }
+
+  /**
+   * Throws a new IO exception with the given message and a context snippet
+   * with this reader's content.
+   */
+  private IOException syntaxError(String message) throws IOException {
+    throw new JsonSyntaxException(message + " near " + getSnippet());
+  }
+
+  private CharSequence getSnippet() {
+    StringBuilder snippet = new StringBuilder();
+    int beforePos = Math.min(pos, 20);
+    snippet.append(buffer, pos - beforePos, beforePos);
+    int afterPos = Math.min(limit - pos, 20);
+    snippet.append(buffer, pos, afterPos);
+    return snippet;
+  }
+
+  @SuppressWarnings("serial")
+  private static class JsonSyntaxException extends IOException {
+    private JsonSyntaxException(String s) {
+      super(s);
+    }
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/stream/JsonScope.java b/gson/src/main/java/com/google/gson/stream/JsonScope.java
new file mode 100644
index 0000000..5fea655
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/stream/JsonScope.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.stream;
+
+/**
+ * Lexical scoping elements within a JSON reader or writer.
+ *
+ * @author Jesse Wilson
+ */
+enum JsonScope {
+
+    /**
+     * An array with no elements requires no separators or newlines before
+     * it is closed.
+     */
+    EMPTY_ARRAY,
+
+    /**
+     * A array with at least one value requires a comma and newline before
+     * the next element.
+     */
+    NONEMPTY_ARRAY,
+
+    /**
+     * An object with no name/value pairs requires no separators or newlines
+     * before it is closed.
+     */
+    EMPTY_OBJECT,
+
+    /**
+     * An object whose most recent element is a key. The next element must
+     * be a value.
+     */
+    DANGLING_NAME,
+
+    /**
+     * An object with at least one name/value pair requires a comma and
+     * newline before the next element.
+     */
+    NONEMPTY_OBJECT,
+
+    /**
+     * No object or array has been started.
+     */
+    EMPTY_DOCUMENT,
+
+    /**
+     * A document with at an array or object.
+     */
+    NONEMPTY_DOCUMENT,
+
+    /**
+     * A document that's been closed and cannot be accessed.
+     */
+    CLOSED,
+}
diff --git a/gson/src/main/java/com/google/gson/stream/JsonToken.java b/gson/src/main/java/com/google/gson/stream/JsonToken.java
new file mode 100644
index 0000000..5ab3934
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/stream/JsonToken.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.stream;
+
+/**
+ * A structure, name or value type in a JSON-encoded string.
+ *
+ * @author Jesse Wilson
+ */
+public enum JsonToken {
+
+  /**
+   * The opening of a JSON array. Written using {@link JsonWriter#beginObject}
+   * and read using {@link JsonReader#beginObject}.
+   */
+  BEGIN_ARRAY,
+
+  /**
+   * The closing of a JSON array. Written using {@link JsonWriter#endArray}
+   * and read using {@link JsonReader#endArray}.
+   */
+  END_ARRAY,
+
+  /**
+   * The opening of a JSON object. Written using {@link JsonWriter#beginObject}
+   * and read using {@link JsonReader#beginObject}.
+   */
+  BEGIN_OBJECT,
+
+  /**
+   * The closing of a JSON object. Written using {@link JsonWriter#endObject}
+   * and read using {@link JsonReader#endObject}.
+   */
+  END_OBJECT,
+
+  /**
+   * A JSON property name. Within objects, tokens alternate between names and
+   * their values. Written using {@link JsonWriter#name} and read using {@link
+   * JsonReader#nextName}
+   */
+  NAME,
+
+  /**
+   * A JSON string.
+   */
+  STRING,
+
+  /**
+   * A JSON number represented in this API by a Java {@code double}, {@code
+   * long}, or {@code int}.
+   */
+  NUMBER,
+
+  /**
+   * A JSON {@code true} or {@code false}.
+   */
+  BOOLEAN,
+
+  /**
+   * A JSON {@code null}.
+   */
+  NULL,
+
+  /**
+   * The end of the JSON stream. This sentinel value is returned by {@link
+   * JsonReader#peek()} to signal that the JSON-encoded value has no more
+   * tokens.
+   */
+  END_DOCUMENT
+}
diff --git a/gson/src/main/java/com/google/gson/stream/JsonWriter.java b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
new file mode 100644
index 0000000..e60b75d
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
@@ -0,0 +1,495 @@
+/*
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.stream;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Writes a JSON (<a href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>)
+ * encoded value to a stream, one token at a time. The stream includes both
+ * literal values (strings, numbers, booleans and nulls) as well as the begin
+ * and end delimiters of objects and arrays.
+ *
+ * <h3>Encoding JSON</h3>
+ * To encode your data as JSON, create a new {@code JsonWriter}. Each JSON
+ * document must contain one top-level array or object. Call methods on the
+ * writer as you walk the structure's contents, nesting arrays and objects as
+ * necessary:
+ * <ul>
+ *   <li>To write <strong>arrays</strong>, first call {@link #beginArray()}.
+ *       Write each of the array's elements with the appropriate {@link #value}
+ *       methods or by nesting other arrays and objects. Finally close the array
+ *       using {@link #endArray()}.
+ *   <li>To write <strong>objects</strong>, first call {@link #beginObject()}.
+ *       Write each of the object's properties by alternating calls to
+ *       {@link #name} with the property's value. Write property values with the
+ *       appropriate {@link #value} method or by nesting other objects or arrays.
+ *       Finally close the object using {@link #endObject()}.
+ * </ul>
+ *
+ * <h3>Example</h3>
+ * Suppose we'd like to encode a stream of messages such as the following: <pre> {@code
+ * [
+ *   {
+ *     "id": 912345678901,
+ *     "text": "How do I stream JSON in Java?",
+ *     "geo": null,
+ *     "user": {
+ *       "name": "json_newb",
+ *       "followers_count": 41
+ *      }
+ *   },
+ *   {
+ *     "id": 912345678902,
+ *     "text": "@json_newb just use JsonWriter!",
+ *     "geo": [50.454722, -104.606667],
+ *     "user": {
+ *       "name": "jesse",
+ *       "followers_count": 2
+ *     }
+ *   }
+ * ]}</pre>
+ * This code encodes the above structure: <pre>   {@code
+ *   public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {
+ *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, "UTF-8"));
+ *     writer.setIndentSpaces(4);
+ *     writeMessagesArray(writer, messages);
+ *     writer.close();
+ *   }
+ *
+ *   public void writeMessagesArray(JsonWriter writer, List<Message> messages) throws IOException {
+ *     writer.beginArray();
+ *     for (Message message : messages) {
+ *       writeMessage(writer, message);
+ *     }
+ *     writer.endArray();
+ *   }
+ *
+ *   public void writeMessage(JsonWriter writer, Message message) throws IOException {
+ *     writer.beginObject();
+ *     writer.name("id").value(message.getId());
+ *     writer.name("text").value(message.getText());
+ *     if (message.getGeo() != null) {
+ *       writer.name("geo");
+ *       writeDoublesArray(writer, message.getGeo());
+ *     } else {
+ *       writer.name("geo").nullValue();
+ *     }
+ *     writer.name("user");
+ *     writeUser(writer, message.getUser());
+ *     writer.endObject();
+ *   }
+ *
+ *   public void writeUser(JsonWriter writer, User user) throws IOException {
+ *     writer.beginObject();
+ *     writer.name("name").value(user.getName());
+ *     writer.name("followers_count").value(user.getFollowersCount());
+ *     writer.endObject();
+ *   }
+ *
+ *   public void writeDoublesArray(JsonWriter writer, List<Double> doubles) throws IOException {
+ *     writer.beginArray();
+ *     for (Double value : doubles) {
+ *       writer.value(value);
+ *     }
+ *     writer.endArray();
+ *   }}</pre>
+ *
+ * <p>Each {@code JsonWriter} may be used to write a single JSON stream.
+ * Instances of this class are not thread safe. Calls that would result in a
+ * malformed JSON string will fail with an {@link IllegalStateException}.
+ * 
+ * @author Jesse Wilson
+ */
+public final class JsonWriter implements Closeable {
+
+  /** The output data, containing at most one top-level array or object. */
+  private final Writer out;
+
+  private final List<JsonScope> stack = new ArrayList<JsonScope>();
+  {
+    stack.add(JsonScope.EMPTY_DOCUMENT);
+  }
+
+  /**
+   * A string containing a full set of spaces for a single level of
+   * indentation, or null for no pretty printing.
+   */
+  private String indent;
+
+  /**
+   * The name/value separator; either ":" or ": ".
+   */
+  private String separator = ":";
+
+  /**
+   * Creates a new instance that writes a JSON-encoded stream to {@code out}.
+   * For best performance, ensure {@link Writer} is buffered; wrapping in
+   * {@link java.io.BufferedWriter BufferedWriter} if necessary.
+   */
+  public JsonWriter(Writer out) {
+    if (out == null) {
+      throw new NullPointerException("out == null");
+    }
+    this.out = out;
+  }
+
+  /**
+   * Sets the indentation string to be repeated for each level of indentation
+   * in the encoded document. If {@code indent.isEmpty()} the encoded document
+   * will be compact. Otherwise the encoded document will be more
+   * human-readable.
+   *
+   * @param indent a string containing only whitespace.
+   */
+  public void setIndent(String indent) {
+    if (indent.isEmpty()) {
+      this.indent = null;
+      this.separator = ":";
+    } else {
+      this.indent = indent;
+      this.separator = ": ";
+    }
+  }
+
+  /**
+   * Begins encoding a new array. Each call to this method must be paired with
+   * a call to {@link #endArray}.
+   *
+   * @return this writer.
+   */
+  public JsonWriter beginArray() throws IOException {
+    return open(JsonScope.EMPTY_ARRAY, "[");
+  }
+
+  /**
+   * Ends encoding the current array.
+   *
+   * @return this writer.
+   */
+  public JsonWriter endArray() throws IOException {
+    return close(JsonScope.EMPTY_ARRAY, JsonScope.NONEMPTY_ARRAY, "]");
+  }
+
+  /**
+   * Begins encoding a new object. Each call to this method must be paired
+   * with a call to {@link #endObject}.
+   *
+   * @return this writer.
+   */
+  public JsonWriter beginObject() throws IOException {
+    return open(JsonScope.EMPTY_OBJECT, "{");
+  }
+
+  /**
+   * Ends encoding the current object.
+   *
+   * @return this writer.
+   */
+  public JsonWriter endObject() throws IOException {
+    return close(JsonScope.EMPTY_OBJECT, JsonScope.NONEMPTY_OBJECT, "}");
+  }
+
+  /**
+   * Enters a new scope by appending any necessary whitespace and the given
+   * bracket.
+   */
+  private JsonWriter open(JsonScope empty, String openBracket) throws IOException {
+    beforeValue(true);
+    stack.add(empty);
+    out.write(openBracket);
+    return this;
+  }
+
+  /**
+   * Closes the current scope by appending any necessary whitespace and the
+   * given bracket.
+   */
+  private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket)
+      throws IOException {
+    JsonScope context = peek();
+    if (context != nonempty && context != empty) {
+      throw new IllegalStateException("Nesting problem: " + stack);
+    }
+
+    stack.remove(stack.size() - 1);
+    if (context == nonempty) {
+      newline();
+    }
+    out.write(closeBracket);
+    return this;
+  }
+
+  /**
+   * Returns the value on the top of the stack.
+   */
+  private JsonScope peek() {
+    return stack.get(stack.size() - 1);
+  }
+
+  /**
+   * Replace the value on the top of the stack with the given value.
+   */
+  private void replaceTop(JsonScope topOfStack) {
+    stack.set(stack.size() - 1, topOfStack);
+  }
+
+  /**
+   * Encodes the property name.
+   *
+   * @param name the name of the forthcoming value. May not be null.
+   * @return this writer.
+   */
+  public JsonWriter name(String name) throws IOException {
+    if (name == null) {
+      throw new NullPointerException("name == null");
+    }
+    beforeName();
+    string(name);
+    return this;
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @param value the literal string value, or null to encode a null literal.
+   * @return this writer.
+   */
+  public JsonWriter value(String value) throws IOException {
+    if (value == null) {
+      return nullValue();
+    }
+    beforeValue(false);
+    string(value);
+    return this;
+  }
+
+  /**
+   * Encodes {@code null}.
+   *
+   * @return this writer.
+   */
+  public JsonWriter nullValue() throws IOException {
+    beforeValue(false);
+    out.write("null");
+    return this;
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @return this writer.
+   */
+  public JsonWriter value(boolean value) throws IOException {
+    beforeValue(false);
+    out.write(value ? "true" : "false");
+    return this;
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
+   *     {@link Double#isInfinite() infinities}.
+   * @return this writer.
+   */
+  public JsonWriter value(double value) throws IOException {
+    if (Double.isNaN(value) || Double.isInfinite(value)) {
+      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
+    }
+    beforeValue(false);
+    out.append(Double.toString(value));
+    return this;
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @return this writer.
+   */
+  public JsonWriter value(long value) throws IOException {
+    beforeValue(false);
+    out.write(Long.toString(value));
+    return this;
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
+   *     {@link Double#isInfinite() infinities}.
+   * @return this writer.
+   */
+  public JsonWriter value(Number value) throws IOException {
+    if (value == null) {
+      return nullValue();
+    }
+
+    String string = value.toString();
+    if (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN")) {
+      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
+    }
+    beforeValue(false);
+    out.append(string);
+    return this;
+  }
+
+  /**
+   * Ensures all buffered data is written to the underlying {@link Writer}
+   * and flushes that writer.
+   */
+  public void flush() throws IOException {
+    out.flush();
+  }
+
+  /**
+   * Flushes and closes this writer and the underlying {@link Writer}.
+   *
+   * @throws IOException if the JSON document is incomplete.
+   */
+  public void close() throws IOException {
+    out.close();
+
+    if (peek() != JsonScope.NONEMPTY_DOCUMENT) {
+      throw new IOException("Incomplete document");
+    }
+  }
+
+  private void string(String value) throws IOException {
+    out.write("\"");
+    for (int i = 0, length = value.length(); i < length; i++) {
+      char c = value.charAt(i);
+
+      /*
+       * From RFC 4627, "All Unicode characters may be placed within the
+       * quotation marks except for the characters that must be escaped:
+       * quotation mark, reverse solidus, and the control characters
+       * (U+0000 through U+001F)."
+       */
+      switch (c) {
+      case '"':
+      case '\\':
+      case '/':
+        out.write('\\');
+        out.write(c);
+        break;
+
+      case '\t':
+        out.write("\\t");
+        break;
+
+      case '\b':
+        out.write("\\b");
+        break;
+
+      case '\n':
+        out.write("\\n");
+        break;
+
+      case '\r':
+        out.write("\\r");
+        break;
+
+      case '\f':
+        out.write("\\f");
+        break;
+
+      default:
+        if (c <= 0x1F) {
+          out.write(String.format("\\u%04x", (int) c));
+        } else {
+          out.write(c);
+        }
+        break;
+      }
+
+    }
+    out.write("\"");
+  }
+
+  private void newline() throws IOException {
+    if (indent == null) {
+      return;
+    }
+
+    out.write("\n");
+    for (int i = 1; i < stack.size(); i++) {
+      out.write(indent);
+    }
+  }
+
+  /**
+   * Inserts any necessary separators and whitespace before a name. Also
+   * adjusts the stack to expect the name's value.
+   */
+  private void beforeName() throws IOException {
+    JsonScope context = peek();
+    if (context == JsonScope.NONEMPTY_OBJECT) { // first in object
+      out.write(',');
+    } else if (context != JsonScope.EMPTY_OBJECT) { // not in an object!
+      throw new IllegalStateException("Nesting problem: " + stack);
+    }
+    newline();
+    replaceTop(JsonScope.DANGLING_NAME);
+  }
+
+  /**
+   * Inserts any necessary separators and whitespace before a literal value,
+   * inline array, or inline object. Also adjusts the stack to expect either a
+   * closing bracket or another element.
+   *
+   * @param root true if the value is a new array or object, the two values
+   *     permitted as top-level elements.
+   */
+  private void beforeValue(boolean root) throws IOException {
+    switch (peek()) {
+    case EMPTY_DOCUMENT: // first in document
+      if (!root) {
+        throw new IllegalStateException(
+            "JSON must start with an array or an object.");
+      }
+      replaceTop(JsonScope.NONEMPTY_DOCUMENT);
+      break;
+
+    case EMPTY_ARRAY: // first in array
+      replaceTop(JsonScope.NONEMPTY_ARRAY);
+      newline();
+      break;
+
+    case NONEMPTY_ARRAY: // another in array
+      out.append(',');
+      newline();
+      break;
+
+    case DANGLING_NAME: // value for name
+      out.append(separator);
+      replaceTop(JsonScope.NONEMPTY_OBJECT);
+      break;
+
+    case NONEMPTY_DOCUMENT:
+        throw new IllegalStateException(
+            "JSON must have only one top-level value.");
+
+    default:
+      throw new IllegalStateException("Nesting problem: " + stack);
+    }
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
new file mode 100644
index 0000000..fcc1b45
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
@@ -0,0 +1,767 @@
+/*
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.stream;
+
+import junit.framework.TestCase;
+
+import java.io.IOException;
+import java.io.StringReader;
+
+public final class JsonReaderTest extends TestCase {
+
+  public void testReadArray() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[true, true]"));
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    assertEquals(true, reader.nextBoolean());
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testReadEmptyArray() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[]"));
+    reader.beginArray();
+    assertFalse(reader.hasNext());
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testReadObject() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader(
+        "{\"a\": \"android\", \"b\": \"banana\"}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    assertEquals("android", reader.nextString());
+    assertEquals("b", reader.nextName());
+    assertEquals("banana", reader.nextString());
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testReadEmptyObject() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("{}"));
+    reader.beginObject();
+    assertFalse(reader.hasNext());
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testSkipObject() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader(
+        "{\"a\": { \"c\": [], \"d\": [true, true, {}] }, \"b\": \"banana\"}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    reader.skipValue();
+    assertEquals("b", reader.nextName());
+    reader.skipValue();
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testHelloWorld() throws IOException {
+    String json = "{\n" +
+        "   \"hello\": true,\n" +
+        "   \"foo\": [\"world\"]\n" +
+        "}";
+    JsonReader reader = new JsonReader(new StringReader(json));
+    reader.beginObject();
+    assertEquals("hello", reader.nextName());
+    assertEquals(true, reader.nextBoolean());
+    assertEquals("foo", reader.nextName());
+    reader.beginArray();
+    assertEquals("world", reader.nextString());
+    reader.endArray();
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testNulls() {
+    try {
+      new JsonReader(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  public void testEmptyString() throws IOException {
+    try {
+      new JsonReader(new StringReader("")).beginArray();
+    } catch (IOException expected) {
+    }
+    try {
+      new JsonReader(new StringReader("")).beginObject();
+    } catch (IOException expected) {
+    }
+  }
+
+  public void testNoTopLevelObject() throws IOException {
+    try {
+      new JsonReader(new StringReader("true")).nextBoolean();
+    } catch (IOException expected) {
+    }
+  }
+
+  public void testCharacterUnescaping() throws IOException {
+    String json = "[\"a\","
+        + "\"a\\\"\","
+        + "\"\\\"\","
+        + "\":\","
+        + "\",\","
+        + "\"\\b\","
+        + "\"\\f\","
+        + "\"\\n\","
+        + "\"\\r\","
+        + "\"\\t\","
+        + "\" \","
+        + "\"\\\\\","
+        + "\"{\","
+        + "\"}\","
+        + "\"[\","
+        + "\"]\","
+        + "\"\\u0000\","
+        + "\"\\u0019\","
+        + "\"\\u20AC\""
+        + "]";
+    JsonReader reader = new JsonReader(new StringReader(json));
+    reader.beginArray();
+    assertEquals("a", reader.nextString());
+    assertEquals("a\"", reader.nextString());
+    assertEquals("\"", reader.nextString());
+    assertEquals(":", reader.nextString());
+    assertEquals(",", reader.nextString());
+    assertEquals("\b", reader.nextString());
+    assertEquals("\f", reader.nextString());
+    assertEquals("\n", reader.nextString());
+    assertEquals("\r", reader.nextString());
+    assertEquals("\t", reader.nextString());
+    assertEquals(" ", reader.nextString());
+    assertEquals("\\", reader.nextString());
+    assertEquals("{", reader.nextString());
+    assertEquals("}", reader.nextString());
+    assertEquals("[", reader.nextString());
+    assertEquals("]", reader.nextString());
+    assertEquals("\0", reader.nextString());
+    assertEquals("\u0019", reader.nextString());
+    assertEquals("\u20AC", reader.nextString());
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testIntegersWithFractionalPartSpecified() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[1.0,1.0,1.0]"));
+    reader.beginArray();
+    assertEquals(1.0, reader.nextDouble());
+    assertEquals(1, reader.nextInt());
+    assertEquals(1L, reader.nextLong());
+  }
+
+  public void testDoubles() throws IOException {
+    String json = "[-0.0,"
+        + "1.0,"
+        + "1.7976931348623157E308,"
+        + "4.9E-324,"
+        + "0.0,"
+        + "-0.5,"
+        + "2.2250738585072014E-308,"
+        + "3.141592653589793,"
+        + "2.718281828459045]";
+    JsonReader reader = new JsonReader(new StringReader(json));
+    reader.beginArray();
+    assertEquals(-0.0, reader.nextDouble());
+    assertEquals(1.0, reader.nextDouble());
+    assertEquals(1.7976931348623157E308, reader.nextDouble());
+    assertEquals(4.9E-324, reader.nextDouble());
+    assertEquals(0.0, reader.nextDouble());
+    assertEquals(-0.5, reader.nextDouble());
+    assertEquals(2.2250738585072014E-308, reader.nextDouble());
+    assertEquals(3.141592653589793, reader.nextDouble());
+    assertEquals(2.718281828459045, reader.nextDouble());
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testStrictNonFiniteDoubles() throws IOException {
+    String json = "[NaN]";
+    JsonReader reader = new JsonReader(new StringReader(json));
+    reader.beginArray();
+    try {
+      reader.nextDouble();
+      fail();
+    } catch (NumberFormatException expected) {
+    }
+  }
+
+  public void testLenientNonFiniteDoubles() throws IOException {
+    String json = "[NaN, -Infinity, Infinity]";
+    JsonReader reader = new JsonReader(new StringReader(json));
+    reader.setLenient(true);
+    reader.beginArray();
+    assertTrue(Double.isNaN(reader.nextDouble()));
+    assertEquals(Double.NEGATIVE_INFINITY, reader.nextDouble());
+    assertEquals(Double.POSITIVE_INFINITY, reader.nextDouble());
+    reader.endArray();
+  }
+
+  public void testLongs() throws IOException {
+    String json = "[0,0,0,"
+        + "1,1,1,"
+        + "-1,-1,-1,"
+        + "-9223372036854775808,"
+        + "9223372036854775807]";
+    JsonReader reader = new JsonReader(new StringReader(json));
+    reader.beginArray();
+    assertEquals(0L, reader.nextLong());
+    assertEquals(0, reader.nextInt());
+    assertEquals(0.0, reader.nextDouble());
+    assertEquals(1L, reader.nextLong());
+    assertEquals(1, reader.nextInt());
+    assertEquals(1.0, reader.nextDouble());
+    assertEquals(-1L, reader.nextLong());
+    assertEquals(-1, reader.nextInt());
+    assertEquals(-1.0, reader.nextDouble());
+    try {
+      reader.nextInt();
+      fail();
+    } catch (NumberFormatException expected) {
+    }
+    assertEquals(Long.MIN_VALUE, reader.nextLong());
+    try {
+      reader.nextInt();
+      fail();
+    } catch (NumberFormatException expected) {
+    }
+    assertEquals(Long.MAX_VALUE, reader.nextLong());
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  /**
+   * This test fails because there's no double for 9223372036854775806, and
+   * our long parsing uses Double.parseDouble() for fractional values.
+   */
+  public void testHighPrecisionLong() throws IOException {
+    String json = "[9223372036854775806.000]";
+    JsonReader reader = new JsonReader(new StringReader(json));
+    reader.beginArray();
+    assertEquals(9223372036854775806L, reader.nextLong());
+    reader.endArray();
+  }
+
+  public void testNumberWithOctalPrefix() throws IOException {
+    String json = "[01]";
+    JsonReader reader = new JsonReader(new StringReader(json));
+    reader.beginArray();
+    try {
+      reader.nextInt();
+      fail();
+    } catch (NumberFormatException expected) {
+    }
+    try {
+      reader.nextLong();
+      fail();
+    } catch (NumberFormatException expected) {
+    }
+    try {
+      reader.nextDouble();
+      fail();
+    } catch (NumberFormatException expected) {
+    }
+    assertEquals("01", reader.nextString());
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testBooleans() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[true,false]"));
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    assertEquals(false, reader.nextBoolean());
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testMixedCaseLiterals() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[True,TruE,False,FALSE,NULL,nulL]"));
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    assertEquals(true, reader.nextBoolean());
+    assertEquals(false, reader.nextBoolean());
+    assertEquals(false, reader.nextBoolean());
+    reader.nextNull();
+    reader.nextNull();
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testMissingValue() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("{\"a\":}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    try {
+      reader.nextString();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  public void testPrematureEndOfInput() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("{\"a\":true,"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    assertEquals(true, reader.nextBoolean());
+    try {
+      reader.nextName();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  public void testPrematurelyClosed() throws IOException {
+    try {
+      JsonReader reader = new JsonReader(new StringReader("{\"a\":[]}"));
+      reader.beginObject();
+      reader.close();
+      reader.nextName();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    try {
+      JsonReader reader = new JsonReader(new StringReader("{\"a\":[]}"));
+      reader.close();
+      reader.beginObject();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    try {
+      JsonReader reader = new JsonReader(new StringReader("{\"a\":true}"));
+      reader.beginObject();
+      reader.nextName();
+      reader.peek();
+      reader.close();
+      reader.nextBoolean();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  public void testNextFailuresDoNotAdvance() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("{\"a\":true}"));
+    reader.beginObject();
+    try {
+      reader.nextString();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    assertEquals("a", reader.nextName());
+    try {
+      reader.nextName();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      reader.beginArray();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      reader.endArray();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      reader.beginObject();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      reader.endObject();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    assertEquals(true, reader.nextBoolean());
+    try {
+      reader.nextString();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      reader.nextName();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      reader.beginArray();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      reader.endArray();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+    reader.close();
+  }
+
+  public void testStringNullIsNotNull() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[\"null\"]"));
+    reader.beginArray();
+    try {
+      reader.nextNull();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  public void testNullLiteralIsNotAString() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[null]"));
+    reader.beginArray();
+    try {
+      reader.nextString();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  public void testStrictNameValueSeparator() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("{\"a\"=true}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    try {
+      reader.nextBoolean();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    reader = new JsonReader(new StringReader("{\"a\"=>true}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    try {
+      reader.nextBoolean();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  public void testLenientNameValueSeparator() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("{\"a\"=true}"));
+    reader.setLenient(true);
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    assertEquals(true, reader.nextBoolean());
+
+    reader = new JsonReader(new StringReader("{\"a\"=>true}"));
+    reader.setLenient(true);
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    assertEquals(true, reader.nextBoolean());
+  }
+
+  public void testStrictComments() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[// comment \n true]"));
+    reader.beginArray();
+    try {
+      reader.nextBoolean();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    reader = new JsonReader(new StringReader("[# comment \n true]"));
+    reader.beginArray();
+    try {
+      reader.nextBoolean();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    reader = new JsonReader(new StringReader("[/* comment */ true]"));
+    reader.beginArray();
+    try {
+      reader.nextBoolean();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  public void testLenientComments() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[// comment \n true]"));
+    reader.setLenient(true);
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+
+    reader = new JsonReader(new StringReader("[# comment \n true]"));
+    reader.setLenient(true);
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+
+    reader = new JsonReader(new StringReader("[/* comment */ true]"));
+    reader.setLenient(true);
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+  }
+
+  public void testStrictUnquotedNames() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("{a:true}"));
+    reader.beginObject();
+    try {
+      reader.nextName();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  public void testLenientUnquotedNames() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("{a:true}"));
+    reader.setLenient(true);
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+  }
+
+  public void testStrictSingleQuotedNames() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("{'a':true}"));
+    reader.beginObject();
+    try {
+      reader.nextName();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  public void testLenientSingleQuotedNames() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("{'a':true}"));
+    reader.setLenient(true);
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+  }
+
+  public void testStrictUnquotedStrings() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[a]"));
+    reader.beginArray();
+    try {
+      reader.nextString();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  public void testLenientUnquotedStrings() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[a]"));
+    reader.setLenient(true);
+    reader.beginArray();
+    assertEquals("a", reader.nextString());
+  }
+
+  public void testStrictSingleQuotedStrings() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("['a']"));
+    reader.beginArray();
+    try {
+      reader.nextString();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  public void testLenientSingleQuotedStrings() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("['a']"));
+    reader.setLenient(true);
+    reader.beginArray();
+    assertEquals("a", reader.nextString());
+  }
+
+  public void testStrictSemicolonDelimitedArray() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[true;true]"));
+    reader.beginArray();
+    try {
+      reader.nextBoolean();
+      reader.nextBoolean();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  public void testLenientSemicolonDelimitedArray() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[true;true]"));
+    reader.setLenient(true);
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    assertEquals(true, reader.nextBoolean());
+  }
+
+  public void testStrictSemicolonDelimitedNameValuePair() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("{\"a\":true;\"b\":true}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    try {
+      reader.nextBoolean();
+      reader.nextName();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  public void testLenientSemicolonDelimitedNameValuePair() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("{\"a\":true;\"b\":true}"));
+    reader.setLenient(true);
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    assertEquals(true, reader.nextBoolean());
+    assertEquals("b", reader.nextName());
+  }
+
+  public void testStrictUnnecessaryArraySeparators() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[true,,true]"));
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    try {
+      reader.nextNull();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    reader = new JsonReader(new StringReader("[,true]"));
+    reader.beginArray();
+    try {
+      reader.nextNull();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    reader = new JsonReader(new StringReader("[true,]"));
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    try {
+      reader.nextNull();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    reader = new JsonReader(new StringReader("[,]"));
+    reader.beginArray();
+    try {
+      reader.nextNull();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  public void testLenientUnnecessaryArraySeparators() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[true,,true]"));
+    reader.setLenient(true);
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    reader.nextNull();
+    assertEquals(true, reader.nextBoolean());
+    reader.endArray();
+
+    reader = new JsonReader(new StringReader("[,true]"));
+    reader.setLenient(true);
+    reader.beginArray();
+    reader.nextNull();
+    assertEquals(true, reader.nextBoolean());
+    reader.endArray();
+
+    reader = new JsonReader(new StringReader("[true,]"));
+    reader.setLenient(true);
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    reader.nextNull();
+    reader.endArray();
+
+    reader = new JsonReader(new StringReader("[,]"));
+    reader.setLenient(true);
+    reader.beginArray();
+    reader.nextNull();
+    reader.nextNull();
+    reader.endArray();
+  }
+
+  public void testStrictMultipleTopLevelValues() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[] []"));
+    reader.beginArray();
+    reader.endArray();
+    try {
+      reader.peek();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  public void testLenientMultipleTopLevelValues() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("[] true {}"));
+    reader.setLenient(true);
+    reader.beginArray();
+    reader.endArray();
+    assertEquals(true, reader.nextBoolean());
+    reader.beginObject();
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testStrictTopLevelValueType() {
+    JsonReader reader = new JsonReader(new StringReader("true"));
+    try {
+      reader.nextBoolean();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  public void testLenientTopLevelValueType() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("true"));
+    reader.setLenient(true);
+    assertEquals(true, reader.nextBoolean());
+  }
+
+  public void testStrictNonExecutePrefix() {
+    JsonReader reader = new JsonReader(new StringReader(")]}'\n []"));
+    try {
+      reader.beginArray();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  public void testLenientNonExecutePrefix() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader(")]}'\n []"));
+    reader.setLenient(true);
+    reader.beginArray();
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testLenientNonExecutePrefixWithLeadingWhitespace() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader("\r\n \t)]}'\n []"));
+    reader.setLenient(true);
+    reader.beginArray();
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testLenientPartialNonExecutePrefix() throws IOException {
+    JsonReader reader = new JsonReader(new StringReader(")]}' []"));
+    reader.setLenient(true);
+    assertEquals(")", reader.nextString()); // lenient is almost too lenient!
+    try {
+      reader.peek();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java b/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java
new file mode 100644
index 0000000..490a385
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java
@@ -0,0 +1,458 @@
+/*
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.stream;
+
+import junit.framework.TestCase;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+public final class JsonWriterTest extends TestCase {
+
+  public void testWrongTopLevelType() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    try {
+      jsonWriter.value("a");
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  public void testTwoNames() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    jsonWriter.name("a");
+    try {
+      jsonWriter.name("a");
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  public void testNameWithoutValue() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    jsonWriter.name("a");
+    try {
+      jsonWriter.endObject();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  public void testValueWithoutName() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    try {
+      jsonWriter.value(true);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  public void testMultipleTopLevelValues() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginArray().endArray();
+    try {
+      jsonWriter.beginArray();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  public void testBadNestingObject() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginArray();
+    jsonWriter.beginObject();
+    try {
+      jsonWriter.endArray();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  public void testBadNestingArray() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginArray();
+    jsonWriter.beginArray();
+    try {
+      jsonWriter.endObject();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  public void testNullName() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    try {
+      jsonWriter.name(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  public void testNullStringValue() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    jsonWriter.name("a");
+    jsonWriter.value((String) null);
+    jsonWriter.endObject();
+    assertEquals("{\"a\":null}", stringWriter.toString());
+  }
+
+  public void testNonFiniteDoubles() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginArray();
+    try {
+      jsonWriter.value(Double.NaN);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      jsonWriter.value(Double.NEGATIVE_INFINITY);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      jsonWriter.value(Double.POSITIVE_INFINITY);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  public void testNonFiniteBoxedDoubles() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginArray();
+    try {
+      jsonWriter.value(new Double(Double.NaN));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      jsonWriter.value(new Double(Double.NEGATIVE_INFINITY));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      jsonWriter.value(new Double(Double.POSITIVE_INFINITY));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  public void testDoubles() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginArray();
+    jsonWriter.value(-0.0);
+    jsonWriter.value(1.0);
+    jsonWriter.value(Double.MAX_VALUE);
+    jsonWriter.value(Double.MIN_VALUE);
+    jsonWriter.value(0.0);
+    jsonWriter.value(-0.5);
+    jsonWriter.value(Double.MIN_NORMAL);
+    jsonWriter.value(Math.PI);
+    jsonWriter.value(Math.E);
+    jsonWriter.endArray();
+    jsonWriter.close();
+    assertEquals("[-0.0,"
+        + "1.0,"
+        + "1.7976931348623157E308,"
+        + "4.9E-324,"
+        + "0.0,"
+        + "-0.5,"
+        + "2.2250738585072014E-308,"
+        + "3.141592653589793,"
+        + "2.718281828459045]", stringWriter.toString());
+  }
+
+  public void testLongs() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginArray();
+    jsonWriter.value(0);
+    jsonWriter.value(1);
+    jsonWriter.value(-1);
+    jsonWriter.value(Long.MIN_VALUE);
+    jsonWriter.value(Long.MAX_VALUE);
+    jsonWriter.endArray();
+    jsonWriter.close();
+    assertEquals("[0,"
+        + "1,"
+        + "-1,"
+        + "-9223372036854775808,"
+        + "9223372036854775807]", stringWriter.toString());
+  }
+
+  public void testNumbers() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginArray();
+    jsonWriter.value(new BigInteger("0"));
+    jsonWriter.value(new BigInteger("9223372036854775808"));
+    jsonWriter.value(new BigInteger("-9223372036854775809"));
+    jsonWriter.value(new BigDecimal("3.141592653589793238462643383"));
+    jsonWriter.endArray();
+    jsonWriter.close();
+    assertEquals("[0,"
+        + "9223372036854775808,"
+        + "-9223372036854775809,"
+        + "3.141592653589793238462643383]", stringWriter.toString());
+  }
+
+  public void testBooleans() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginArray();
+    jsonWriter.value(true);
+    jsonWriter.value(false);
+    jsonWriter.endArray();
+    assertEquals("[true,false]", stringWriter.toString());
+  }
+
+  public void testNulls() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginArray();
+    jsonWriter.nullValue();
+    jsonWriter.endArray();
+    assertEquals("[null]", stringWriter.toString());
+  }
+
+  public void testStrings() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginArray();
+    jsonWriter.value("a");
+    jsonWriter.value("a\"");
+    jsonWriter.value("\"");
+    jsonWriter.value(":");
+    jsonWriter.value(",");
+    jsonWriter.value("\b");
+    jsonWriter.value("\f");
+    jsonWriter.value("\n");
+    jsonWriter.value("\r");
+    jsonWriter.value("\t");
+    jsonWriter.value(" ");
+    jsonWriter.value("\\");
+    jsonWriter.value("{");
+    jsonWriter.value("}");
+    jsonWriter.value("[");
+    jsonWriter.value("]");
+    jsonWriter.value("\0");
+    jsonWriter.value("\u0019");
+    jsonWriter.endArray();
+    assertEquals("[\"a\","
+        + "\"a\\\"\","
+        + "\"\\\"\","
+        + "\":\","
+        + "\",\","
+        + "\"\\b\","
+        + "\"\\f\","
+        + "\"\\n\","
+        + "\"\\r\","
+        + "\"\\t\","
+        + "\" \","
+        + "\"\\\\\","
+        + "\"{\","
+        + "\"}\","
+        + "\"[\","
+        + "\"]\","
+        + "\"\\u0000\","
+        + "\"\\u0019\"]", stringWriter.toString());
+  }
+
+  public void testEmptyArray() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginArray();
+    jsonWriter.endArray();
+    assertEquals("[]", stringWriter.toString());
+  }
+
+  public void testEmptyObject() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    jsonWriter.endObject();
+    assertEquals("{}", stringWriter.toString());
+  }
+
+  public void testObjectsInArrays() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginArray();
+    jsonWriter.beginObject();
+    jsonWriter.name("a").value(5);
+    jsonWriter.name("b").value(false);
+    jsonWriter.endObject();
+    jsonWriter.beginObject();
+    jsonWriter.name("c").value(6);
+    jsonWriter.name("d").value(true);
+    jsonWriter.endObject();
+    jsonWriter.endArray();
+    assertEquals("[{\"a\":5,\"b\":false},"
+        + "{\"c\":6,\"d\":true}]", stringWriter.toString());
+  }
+
+  public void testArraysInObjects() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    jsonWriter.name("a");
+    jsonWriter.beginArray();
+    jsonWriter.value(5);
+    jsonWriter.value(false);
+    jsonWriter.endArray();
+    jsonWriter.name("b");
+    jsonWriter.beginArray();
+    jsonWriter.value(6);
+    jsonWriter.value(true);
+    jsonWriter.endArray();
+    jsonWriter.endObject();
+    assertEquals("{\"a\":[5,false],"
+        + "\"b\":[6,true]}", stringWriter.toString());
+  }
+
+  public void testDeepNestingArrays() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    for (int i = 0; i < 20; i++) {
+      jsonWriter.beginArray();
+    }
+    for (int i = 0; i < 20; i++) {
+      jsonWriter.endArray();
+    }
+    assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString());
+  }
+
+  public void testDeepNestingObjects() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    for (int i = 0; i < 20; i++) {
+      jsonWriter.name("a");
+      jsonWriter.beginObject();
+    }
+    for (int i = 0; i < 20; i++) {
+      jsonWriter.endObject();
+    }
+    jsonWriter.endObject();
+    assertEquals("{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":"
+        + "{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{"
+        + "}}}}}}}}}}}}}}}}}}}}}", stringWriter.toString());
+  }
+
+  public void testRepeatedName() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    jsonWriter.name("a").value(true);
+    jsonWriter.name("a").value(false);
+    jsonWriter.endObject();
+    // JsonWriter doesn't attempt to detect duplicate names
+    assertEquals("{\"a\":true,\"a\":false}", stringWriter.toString());
+  }
+
+  public void testPrettyPrintObject() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.setIndent("   ");
+
+    jsonWriter.beginObject();
+    jsonWriter.name("a").value(true);
+    jsonWriter.name("b").value(false);
+    jsonWriter.name("c").value(5.0);
+    jsonWriter.name("e").nullValue();
+    jsonWriter.name("f").beginArray();
+    jsonWriter.value(6.0);
+    jsonWriter.value(7.0);
+    jsonWriter.endArray();
+    jsonWriter.name("g").beginObject();
+    jsonWriter.name("h").value(8.0);
+    jsonWriter.name("i").value(9.0);
+    jsonWriter.endObject();
+    jsonWriter.endObject();
+
+    String expected = "{\n"
+        + "   \"a\": true,\n"
+        + "   \"b\": false,\n"
+        + "   \"c\": 5.0,\n"
+        + "   \"e\": null,\n"
+        + "   \"f\": [\n"
+        + "      6.0,\n"
+        + "      7.0\n"
+        + "   ],\n"
+        + "   \"g\": {\n"
+        + "      \"h\": 8.0,\n"
+        + "      \"i\": 9.0\n"
+        + "   }\n"
+        + "}";
+    assertEquals(expected, stringWriter.toString());
+  }
+
+  public void testPrettyPrintArray() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.setIndent("   ");
+
+    jsonWriter.beginArray();
+    jsonWriter.value(true);
+    jsonWriter.value(false);
+    jsonWriter.value(5.0);
+    jsonWriter.nullValue();
+    jsonWriter.beginObject();
+    jsonWriter.name("a").value(6.0);
+    jsonWriter.name("b").value(7.0);
+    jsonWriter.endObject();
+    jsonWriter.beginArray();
+    jsonWriter.value(8.0);
+    jsonWriter.value(9.0);
+    jsonWriter.endArray();
+    jsonWriter.endArray();
+
+    String expected = "[\n"
+        + "   true,\n"
+        + "   false,\n"
+        + "   5.0,\n"
+        + "   null,\n"
+        + "   {\n"
+        + "      \"a\": 6.0,\n"
+        + "      \"b\": 7.0\n"
+        + "   },\n"
+        + "   [\n"
+        + "      8.0,\n"
+        + "      9.0\n"
+        + "   ]\n"
+        + "]";
+    assertEquals(expected, stringWriter.toString());
+  }
+}
