{
  "logger": {
    "currentLogLevel": 20,
    "name": "root.bean.benchmarks.Defects4JBug"
  },
  "d4jCmd": "/home/liumengjiao/Desktop/defects4j/framework/bin/defects4j",
  "dataDir": "data/changesInfo/",
  "timeoutSecond": 300,
  "proj": "Math",
  "id": "25",
  "workingDir": "../bugs/Math_25_buggy",
  "inducingCommit": "b67bf47e45fa177c25fd5c445011d868a5383a6d",
  "originalCommit": "b8a0427d9e70b2da0e88edebcb76371bc5cd3c84",
  "bug_name": "Math_25",
  "derive": "defects4j",
  "original_fixing_commit": "996dd998e3081e4a842017b8ebcdae9b6059b530",
  "buildFiles_changed": false,
  "inducing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java",
        "src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "gradient",
            "HarmonicFitter",
            "value",
            "addObservedPoint",
            "fit",
            "HarmonicFitter"
          ],
          "num": 6
        },
        {
          "qualified_names": [
            "HarmonicFitter",
            "guess",
            "fit",
            "ParameterGuesser",
            "guessAOmega",
            "sortObservations",
            "guessPhi",
            "fit"
          ],
          "num": 8
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "22",
            "23",
            "24",
            "27",
            "28",
            "32",
            "36",
            "37",
            "38",
            "39",
            "40",
            "41",
            "42",
            "43",
            "44",
            "45",
            "48",
            "49",
            "50",
            "51",
            "52",
            "53",
            "54",
            "55",
            "56",
            "57",
            "58",
            "59",
            "60",
            "61",
            "62",
            "63",
            "64",
            "65",
            "66",
            "67",
            "68",
            "69",
            "70",
            "71",
            "72",
            "78",
            "79",
            "80",
            "81",
            "83",
            "84",
            "85",
            "86",
            "92",
            "93",
            "94",
            "95",
            "96",
            "97",
            "98",
            "101",
            "102",
            "104",
            "105",
            "106",
            "107",
            "108",
            "109",
            "110",
            "111",
            "112",
            "113",
            "114",
            "115",
            "116",
            "117",
            "118",
            "119",
            "120",
            "121",
            "122",
            "123",
            "124",
            "125",
            "126",
            "127",
            "128"
          ],
          "num": 83
        },
        {
          "qualified_names": [
            "20",
            "21",
            "22",
            "27",
            "28",
            "29",
            "30",
            "34",
            "35",
            "39",
            "40",
            "41",
            "42",
            "45",
            "51",
            "52",
            "53",
            "54",
            "55",
            "56",
            "57",
            "58",
            "60",
            "61",
            "62",
            "63",
            "64",
            "65",
            "66",
            "67",
            "68",
            "69",
            "70",
            "71",
            "72",
            "73",
            "74",
            "75",
            "76",
            "77",
            "78",
            "79",
            "80",
            "81",
            "82",
            "83",
            "84",
            "85",
            "86",
            "87",
            "88",
            "89",
            "90",
            "91",
            "92",
            "93",
            "94",
            "95",
            "96",
            "97",
            "98",
            "99",
            "100",
            "101",
            "102",
            "103",
            "104",
            "105",
            "106",
            "107",
            "108",
            "109",
            "110",
            "111",
            "112",
            "113",
            "114",
            "115",
            "116",
            "117",
            "118",
            "119",
            "120",
            "121",
            "122",
            "123",
            "124",
            "125",
            "126",
            "127",
            "128",
            "129",
            "130",
            "131",
            "132",
            "133",
            "134",
            "135",
            "136",
            "137",
            "138",
            "139",
            "140",
            "141",
            "142",
            "143",
            "144",
            "145",
            "146",
            "147",
            "148",
            "149",
            "150",
            "151",
            "152",
            "153",
            "154",
            "155",
            "156",
            "157",
            "158",
            "159",
            "160",
            "161",
            "162",
            "163",
            "164",
            "165",
            "166",
            "167",
            "168",
            "169",
            "170",
            "171",
            "172",
            "173",
            "174",
            "175",
            "176",
            "177",
            "178",
            "179",
            "180",
            "181",
            "182",
            "183",
            "184",
            "185",
            "186",
            "187",
            "188",
            "189",
            "190",
            "191",
            "192",
            "193",
            "194",
            "200",
            "203",
            "204",
            "205",
            "206",
            "207",
            "208",
            "209",
            "210",
            "211",
            "212",
            "213",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "220",
            "221",
            "222",
            "223",
            "224",
            "225",
            "226",
            "227",
            "228",
            "229",
            "230",
            "231",
            "232",
            "233",
            "234",
            "235",
            "236",
            "237",
            "238",
            "239",
            "240",
            "241",
            "242",
            "243",
            "244",
            "245",
            "246",
            "247",
            "248",
            "249",
            "250",
            "251",
            "252",
            "253",
            "254",
            "255",
            "256",
            "257",
            "258",
            "259",
            "260",
            "261",
            "262",
            "263",
            "264",
            "265",
            "266",
            "267",
            "268",
            "269",
            "270",
            "271",
            "272",
            "273",
            "274",
            "275",
            "276",
            "277",
            "278",
            "279",
            "280",
            "281",
            "282",
            "283",
            "284",
            "285",
            "286",
            "287",
            "288",
            "289",
            "290",
            "291",
            "292",
            "293",
            "294",
            "295",
            "296",
            "297",
            "298",
            "299",
            "300",
            "301",
            "302",
            "303",
            "304",
            "305",
            "306",
            "307",
            "308",
            "309",
            "310",
            "311",
            "312",
            "313",
            "314",
            "315",
            "316",
            "317",
            "318",
            "319",
            "320",
            "321",
            "322",
            "323",
            "324",
            "325",
            "326",
            "327",
            "328",
            "329",
            "330",
            "331",
            "332",
            "333",
            "334",
            "335",
            "336",
            "337",
            "338",
            "339",
            "340",
            "341"
          ],
          "num": 297
        }
      ],
      "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\nindex 02dd08e..41261ac 100644\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n@@ -17,113 +17,327 @@\n \n package org.apache.commons.math.optimization.fitting;\n \n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.analysis.function.HarmonicOscillator;\n+import org.apache.commons.math.exception.ZeroException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n-import org.apache.commons.math.optimization.OptimizationException;\n-import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n \n-/** This class implements a curve fitting specialized for sinusoids.\n- * \u003cp\u003eHarmonic fitting is a very simple case of curve fitting. The\n+/**\n+ * Class that implements a curve fitting specialized for sinusoids.\n+ *\n+ * Harmonic fitting is a very simple case of curve fitting. The\n  * estimated coefficients are the amplitude a, the pulsation \u0026omega; and\n  * the phase \u0026phi;: \u003ccode\u003ef (t) \u003d a cos (\u0026omega; t + \u0026phi;)\u003c/code\u003e. They are\n  * searched by a least square estimator initialized with a rough guess\n- * based on integrals.\u003c/p\u003e\n+ * based on integrals.\n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public class HarmonicFitter {\n-\n-    /** Fitter for the coefficients. */\n-    private final CurveFitter fitter;\n-\n-    /** Values for amplitude, pulsation \u0026omega; and phase \u0026phi;. */\n-    private double[] parameters;\n-\n-    /** Simple constructor.\n-     * @param optimizer optimizer to use for the fitting\n+public class HarmonicFitter extends CurveFitter {\n+    /**\n+     * Simple constructor.\n+     * @param optimizer Optimizer to use for the fitting.\n      */\n     public HarmonicFitter(final DifferentiableMultivariateVectorialOptimizer optimizer) {\n-        this.fitter \u003d new CurveFitter(optimizer);\n-        parameters  \u003d null;\n-    }\n-\n-    /** Simple constructor.\n-     * \u003cp\u003eThis constructor can be used when a first guess of the\n-     * coefficients is already known.\u003c/p\u003e\n-     * @param optimizer optimizer to use for the fitting\n-     * @param initialGuess guessed values for amplitude (index 0),\n-     * pulsation \u0026omega; (index 1) and phase \u0026phi; (index 2)\n-     */\n-    public HarmonicFitter(final DifferentiableMultivariateVectorialOptimizer optimizer,\n-                          final double[] initialGuess) {\n-        this.fitter     \u003d new CurveFitter(optimizer);\n-        this.parameters \u003d initialGuess.clone();\n-    }\n-\n-    /** Add an observed weighted (x,y) point to the sample.\n-     * @param weight weight of the observed point in the fit\n-     * @param x abscissa of the point\n-     * @param y observed value of the point at x, after fitting we should\n-     * have P(x) as close as possible to this value\n-     */\n-    public void addObservedPoint(double weight, double x, double y) {\n-        fitter.addObservedPoint(weight, x, y);\n+        super(optimizer);\n     }\n \n     /**\n      * Fit an harmonic function to the observed points.\n      *\n-     * @return harmonic Function that best fits the observed points.\n-     * @throws NumberIsTooSmallException if the sample is too short or if\n-     * the first guess cannot be computed.\n-     * @throws OptimizationException\n+     * @param initialGuess First guess values in the following order:\n+     * \u003cul\u003e\n+     *  \u003cli\u003eAmplitude\u003c/li\u003e\n+     *  \u003cli\u003eAngular frequency\u003c/li\u003e\n+     *  \u003cli\u003ePhase\u003c/li\u003e\n+     * \u003c/ul\u003e\n+     * @return the parameters of the harmonic function that best fits the\n+     * observed points (in the same order as above).\n      */\n-    public HarmonicFunction fit() throws OptimizationException {\n-        // shall we compute the first guess of the parameters ourselves ?\n-        if (parameters \u003d\u003d null) {\n-            final WeightedObservedPoint[] observations \u003d fitter.getObservations();\n+    public double[] fit(double[] initialGuess) {\n+        return fit(new HarmonicOscillator.Parametric(), initialGuess);\n+    }\n+\n+    /**\n+     * Fit an harmonic function to the observed points.\n+     * An initial guess will be automatically computed.\n+     *\n+     * @return the parameters of the harmonic function that best fits the\n+     * observed points (see the other {@link #fit(double[]) fit} method.\n+     * @throws NumberIsTooSmallException if the sample is too short for the\n+     * the first guess to be computed.\n+     * @throws ZeroException if the first guess cannot be computed because\n+     * the abscissa range is zero.\n+     */\n+    public double[] fit() {\n+        return fit((new ParameterGuesser(getObservations())).guess());\n+    }\n+\n+    /**\n+     * This class guesses harmonic coefficients from a sample.\n+     * \u003cp\u003eThe algorithm used to guess the coefficients is as follows:\u003c/p\u003e\n+     *\n+     * \u003cp\u003eWe know f (t) at some sampling points t\u003csub\u003ei\u003c/sub\u003e and want to find a,\n+     * \u0026omega; and \u0026phi; such that f (t) \u003d a cos (\u0026omega; t + \u0026phi;).\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eFrom the analytical expression, we can compute two primitives :\n+     * \u003cpre\u003e\n+     *     If2  (t) \u003d \u0026int; f\u003csup\u003e2\u003c/sup\u003e  \u003d a\u003csup\u003e2\u003c/sup\u003e \u0026times; [t + S (t)] / 2\n+     *     If\u00272 (t) \u003d \u0026int; f\u0027\u003csup\u003e2\u003c/sup\u003e \u003d a\u003csup\u003e2\u003c/sup\u003e \u0026omega;\u003csup\u003e2\u003c/sup\u003e \u0026times; [t - S (t)] / 2\n+     *     where S (t) \u003d sin (2 (\u0026omega; t + \u0026phi;)) / (2 \u0026omega;)\n+     * \u003c/pre\u003e\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eWe can remove S between these expressions :\n+     * \u003cpre\u003e\n+     *     If\u00272 (t) \u003d a\u003csup\u003e2\u003c/sup\u003e \u0026omega;\u003csup\u003e2\u003c/sup\u003e t - \u0026omega;\u003csup\u003e2\u003c/sup\u003e If2 (t)\n+     * \u003c/pre\u003e\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eThe preceding expression shows that If\u00272 (t) is a linear\n+     * combination of both t and If2 (t): If\u00272 (t) \u003d A \u0026times; t + B \u0026times; If2 (t)\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eFrom the primitive, we can deduce the same form for definite\n+     * integrals between t\u003csub\u003e1\u003c/sub\u003e and t\u003csub\u003ei\u003c/sub\u003e for each t\u003csub\u003ei\u003c/sub\u003e :\n+     * \u003cpre\u003e\n+     *   If2 (t\u003csub\u003ei\u003c/sub\u003e) - If2 (t\u003csub\u003e1\u003c/sub\u003e) \u003d A \u0026times; (t\u003csub\u003ei\u003c/sub\u003e - t\u003csub\u003e1\u003c/sub\u003e) + B \u0026times; (If2 (t\u003csub\u003ei\u003c/sub\u003e) - If2 (t\u003csub\u003e1\u003c/sub\u003e))\n+     * \u003c/pre\u003e\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eWe can find the coefficients A and B that best fit the sample\n+     * to this linear expression by computing the definite integrals for\n+     * each sample points.\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eFor a bilinear expression z (x\u003csub\u003ei\u003c/sub\u003e, y\u003csub\u003ei\u003c/sub\u003e) \u003d A \u0026times; x\u003csub\u003ei\u003c/sub\u003e + B \u0026times; y\u003csub\u003ei\u003c/sub\u003e, the\n+     * coefficients A and B that minimize a least square criterion\n+     * \u0026sum; (z\u003csub\u003ei\u003c/sub\u003e - z (x\u003csub\u003ei\u003c/sub\u003e, y\u003csub\u003ei\u003c/sub\u003e))\u003csup\u003e2\u003c/sup\u003e are given by these expressions:\u003c/p\u003e\n+     * \u003cpre\u003e\n+     *\n+     *         \u0026sum;y\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;x\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e - \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;y\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e\n+     *     A \u003d ------------------------\n+     *         \u0026sum;x\u003csub\u003ei\u003c/sub\u003ex\u003csub\u003ei\u003c/sub\u003e \u0026sum;y\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e - \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e\n+     *\n+     *         \u0026sum;x\u003csub\u003ei\u003c/sub\u003ex\u003csub\u003ei\u003c/sub\u003e \u0026sum;y\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e - \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;x\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e\n+     *     B \u003d ------------------------\n+     *         \u0026sum;x\u003csub\u003ei\u003c/sub\u003ex\u003csub\u003ei\u003c/sub\u003e \u0026sum;y\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e - \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e\n+     * \u003c/pre\u003e\n+     * \u003c/p\u003e\n+     *\n+     *\n+     * \u003cp\u003eIn fact, we can assume both a and \u0026omega; are positive and\n+     * compute them directly, knowing that A \u003d a\u003csup\u003e2\u003c/sup\u003e \u0026omega;\u003csup\u003e2\u003c/sup\u003e and that\n+     * B \u003d - \u0026omega;\u003csup\u003e2\u003c/sup\u003e. The complete algorithm is therefore:\u003c/p\u003e\n+     * \u003cpre\u003e\n+     *\n+     * for each t\u003csub\u003ei\u003c/sub\u003e from t\u003csub\u003e1\u003c/sub\u003e to t\u003csub\u003en-1\u003c/sub\u003e, compute:\n+     *   f  (t\u003csub\u003ei\u003c/sub\u003e)\n+     *   f\u0027 (t\u003csub\u003ei\u003c/sub\u003e) \u003d (f (t\u003csub\u003ei+1\u003c/sub\u003e) - f(t\u003csub\u003ei-1\u003c/sub\u003e)) / (t\u003csub\u003ei+1\u003c/sub\u003e - t\u003csub\u003ei-1\u003c/sub\u003e)\n+     *   x\u003csub\u003ei\u003c/sub\u003e \u003d t\u003csub\u003ei\u003c/sub\u003e - t\u003csub\u003e1\u003c/sub\u003e\n+     *   y\u003csub\u003ei\u003c/sub\u003e \u003d \u0026int; f\u003csup\u003e2\u003c/sup\u003e from t\u003csub\u003e1\u003c/sub\u003e to t\u003csub\u003ei\u003c/sub\u003e\n+     *   z\u003csub\u003ei\u003c/sub\u003e \u003d \u0026int; f\u0027\u003csup\u003e2\u003c/sup\u003e from t\u003csub\u003e1\u003c/sub\u003e to t\u003csub\u003ei\u003c/sub\u003e\n+     *   update the sums \u0026sum;x\u003csub\u003ei\u003c/sub\u003ex\u003csub\u003ei\u003c/sub\u003e, \u0026sum;y\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e, \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e, \u0026sum;x\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e and \u0026sum;y\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e\n+     * end for\n+     *\n+     *            |--------------------------\n+     *         \\  | \u0026sum;y\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;x\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e - \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;y\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e\n+     * a     \u003d  \\ | ------------------------\n+     *           \\| \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;x\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e - \u0026sum;x\u003csub\u003ei\u003c/sub\u003ex\u003csub\u003ei\u003c/sub\u003e \u0026sum;y\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e\n+     *\n+     *\n+     *            |--------------------------\n+     *         \\  | \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;x\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e - \u0026sum;x\u003csub\u003ei\u003c/sub\u003ex\u003csub\u003ei\u003c/sub\u003e \u0026sum;y\u003csub\u003ei\u003c/sub\u003ez\u003csub\u003ei\u003c/sub\u003e\n+     * \u0026omega;     \u003d  \\ | ------------------------\n+     *           \\| \u0026sum;x\u003csub\u003ei\u003c/sub\u003ex\u003csub\u003ei\u003c/sub\u003e \u0026sum;y\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e - \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e \u0026sum;x\u003csub\u003ei\u003c/sub\u003ey\u003csub\u003ei\u003c/sub\u003e\n+     *\n+     * \u003c/pre\u003e\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eOnce we know \u0026omega;, we can compute:\n+     * \u003cpre\u003e\n+     *    fc \u003d \u0026omega; f (t) cos (\u0026omega; t) - f\u0027 (t) sin (\u0026omega; t)\n+     *    fs \u003d \u0026omega; f (t) sin (\u0026omega; t) + f\u0027 (t) cos (\u0026omega; t)\n+     * \u003c/pre\u003e\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eIt appears that \u003ccode\u003efc \u003d a \u0026omega; cos (\u0026phi;)\u003c/code\u003e and\n+     * \u003ccode\u003efs \u003d -a \u0026omega; sin (\u0026phi;)\u003c/code\u003e, so we can use these\n+     * expressions to compute \u0026phi;. The best estimate over the sample is\n+     * given by averaging these expressions.\n+     * \u003c/p\u003e\n+     *\n+     * \u003cp\u003eSince integrals and means are involved in the preceding\n+     * estimations, these operations run in O(n) time, where n is the\n+     * number of measurements.\u003c/p\u003e\n+     */\n+    public static class ParameterGuesser {\n+        /** Sampled observations. */\n+        private final WeightedObservedPoint[] observations;\n+        /** Amplitude. */\n+        private double a;\n+        /** Angular frequency. */\n+        private double omega;\n+        /** Phase. */\n+        private double phi;\n+\n+        /**\n+         * Simple constructor.\n+         * @param observations sampled observations\n+         * @throws NumberIsTooSmallException if the sample is too short or if\n+         * the first guess cannot be computed.\n+         */\n+        public ParameterGuesser(WeightedObservedPoint[] observations) {\n             if (observations.length \u003c 4) {\n                 throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,\n                                                     observations.length, 4, true);\n             }\n \n-            HarmonicCoefficientsGuesser guesser \u003d new HarmonicCoefficientsGuesser(observations);\n-            guesser.guess();\n-            parameters \u003d new double[] {\n-                guesser.getGuessedAmplitude(),\n-                guesser.getGuessedPulsation(),\n-                guesser.getGuessedPhase()\n-            };\n+            this.observations \u003d observations.clone();\n         }\n \n-        double[] fitted \u003d fitter.fit(new ParametricHarmonicFunction(), parameters);\n-        return new HarmonicFunction(fitted[0], fitted[1], fitted[2]);\n+        /**\n+         * Estimate a first guess of the coefficients.\n+         *\n+         * @return the guessed coefficients, in the following order:\n+         * \u003cul\u003e\n+         *  \u003cli\u003eAmplitude\u003c/li\u003e\n+         *  \u003cli\u003eAngular frequency\u003c/li\u003e\n+         *  \u003cli\u003ePhase\u003c/li\u003e\n+         * \u003c/ul\u003e\n+         */\n+        public double[] guess() {\n+            sortObservations();\n+            guessAOmega();\n+            guessPhi();\n+            return new double[] { a, omega, phi };\n+        }\n+\n+        /**\n+         * Sort the observations with respect to the abscissa.\n+         */\n+        private void sortObservations() {\n+            // Since the samples are almost always already sorted, this\n+            // method is implemented as an insertion sort that reorders the\n+            // elements in place. Insertion sort is very efficient in this case.\n+            WeightedObservedPoint curr \u003d observations[0];\n+            for (int j \u003d 1; j \u003c observations.length; ++j) {\n+                WeightedObservedPoint prec \u003d curr;\n+                curr \u003d observations[j];\n+                if (curr.getX() \u003c prec.getX()) {\n+                    // the current element should be inserted closer to the beginning\n+                    int i \u003d j - 1;\n+                    WeightedObservedPoint mI \u003d observations[i];\n+                    while ((i \u003e\u003d 0) \u0026\u0026 (curr.getX() \u003c mI.getX())) {\n+                        observations[i + 1] \u003d mI;\n+                        if (i-- !\u003d 0) {\n+                            mI \u003d observations[i];\n+                        }\n+                    }\n+                    observations[i + 1] \u003d curr;\n+                    curr \u003d observations[j];\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Estimate a first guess of the amplitude and angular frequency.\n+         * This method assumes that the {@link #sortObservations()} method\n+         * has been called previously.\n+         *\n+         * @throws ZeroException if the abscissa range is zero.\n+         */\n+        private void guessAOmega() {\n+            // initialize the sums for the linear model between the two integrals\n+            double sx2 \u003d 0;\n+            double sy2 \u003d 0;\n+            double sxy \u003d 0;\n+            double sxz \u003d 0;\n+            double syz \u003d 0;\n+\n+            double currentX \u003d observations[0].getX();\n+            double currentY \u003d observations[0].getY();\n+            double f2Integral \u003d 0;\n+            double fPrime2Integral \u003d 0;\n+            final double startX \u003d currentX;\n+            for (int i \u003d 1; i \u003c observations.length; ++i) {\n+                // one step forward\n+                final double previousX \u003d currentX;\n+                final double previousY \u003d currentY;\n+                currentX \u003d observations[i].getX();\n+                currentY \u003d observations[i].getY();\n+\n+                // update the integrals of f\u003csup\u003e2\u003c/sup\u003e and f\u0027\u003csup\u003e2\u003c/sup\u003e\n+                // considering a linear model for f (and therefore constant f\u0027)\n+                final double dx \u003d currentX - previousX;\n+                final double dy \u003d currentY - previousY;\n+                final double f2StepIntegral \u003d\n+                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n+                final double fPrime2StepIntegral \u003d dy * dy / dx;\n+\n+                final double x \u003d currentX - startX;\n+                f2Integral +\u003d f2StepIntegral;\n+                fPrime2Integral +\u003d fPrime2StepIntegral;\n+\n+                sx2 +\u003d x * x;\n+                sy2 +\u003d f2Integral * f2Integral;\n+                sxy +\u003d x * f2Integral;\n+                sxz +\u003d x * fPrime2Integral;\n+                syz +\u003d f2Integral * fPrime2Integral;\n+            }\n+\n+            // compute the amplitude and pulsation coefficients\n+            double c1 \u003d sy2 * sxz - sxy * syz;\n+            double c2 \u003d sxy * sxz - sx2 * syz;\n+            double c3 \u003d sx2 * sy2 - sxy * sxy;\n+            if ((c1 / c2 \u003c 0) || (c2 / c3 \u003c 0)) {\n+                a \u003d 0;\n+\n+                // Range of the observations, assuming that the\n+                // observations are sorted.\n+                final double range \u003d observations[observations.length - 1].getX() -\n+                    observations[0].getX();\n+\n+                if (range \u003d\u003d 0) {\n+                    throw new ZeroException();\n+                }\n+                omega \u003d 2 * Math.PI / range;\n+            } else {\n+                a \u003d FastMath.sqrt(c1 / c2);\n+                omega \u003d FastMath.sqrt(c2 / c3);\n+            }\n+        }\n+\n+        /**\n+         * Estimate a first guess of the phase.\n+         */\n+        private void guessPhi() {\n+            // initialize the means\n+            double fcMean \u003d 0;\n+            double fsMean \u003d 0;\n+\n+            double currentX \u003d observations[0].getX();\n+            double currentY \u003d observations[0].getY();\n+            for (int i \u003d 1; i \u003c observations.length; ++i) {\n+                // one step forward\n+                final double previousX \u003d currentX;\n+                final double previousY \u003d currentY;\n+                currentX \u003d observations[i].getX();\n+                currentY \u003d observations[i].getY();\n+                final double currentYPrime \u003d (currentY - previousY) / (currentX - previousX);\n+\n+                double omegaX \u003d omega * currentX;\n+                double cosine \u003d FastMath.cos(omegaX);\n+                double sine \u003d FastMath.sin(omegaX);\n+                fcMean +\u003d omega * currentY * cosine - currentYPrime * sine;\n+                fsMean +\u003d omega * currentY * sine + currentYPrime * cosine;\n+            }\n+\n+            phi \u003d FastMath.atan2(-fsMean, fcMean);\n+        }\n     }\n-\n-    /** Parametric harmonic function. */\n-    private static class ParametricHarmonicFunction implements ParametricUnivariateRealFunction {\n-\n-        /** {@inheritDoc} */\n-        public double value(double x, double[] parameters) {\n-            final double a     \u003d parameters[0];\n-            final double omega \u003d parameters[1];\n-            final double phi   \u003d parameters[2];\n-            return a * FastMath.cos(omega * x + phi);\n-        }\n-\n-        /** {@inheritDoc} */\n-        public double[] gradient(double x, double[] parameters) {\n-            final double a     \u003d parameters[0];\n-            final double omega \u003d parameters[1];\n-            final double phi   \u003d parameters[2];\n-            final double alpha \u003d omega * x + phi;\n-            final double cosAlpha \u003d FastMath.cos(alpha);\n-            final double sinAlpha \u003d FastMath.sin(alpha);\n-            return new double[] { cosAlpha, -a * x * sinAlpha, -a * sinAlpha };\n-        }\n-\n-    }\n-\n }\n",
      "operations": [
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [949,1017]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [1018,1073]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SimpleType [1723,1734]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [1965,2472]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Javadoc [2478,2980]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ArrayType [2992,3000]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Modifier: static [8161,8167]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SuperConstructorInvocation [1936,1953]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [2608,2747]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TagElement [2755,2862]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [2870,2972]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ReturnStatement [3017,3079]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Javadoc [8298,8315]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Javadoc [8350,8375]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Javadoc [8414,8427]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Javadoc [9084,9364]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ArrayType [9380,9388]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Javadoc [10744,11022]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Javadoc [13480,13543]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: An initial guess will be automatically computed. [2545,2593]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement:  if the sample is too short for the [2788,2823]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: the first guess to be computed. [2831,2862]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [8563,8676]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [8773,9009]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [9165,9352]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ReturnStatement [9494,9532]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [12891,13460]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [12895,12925]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Block [12927,13347]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [13353,13460]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ImportDeclaration [1081,1147]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ImportDeclaration [1148,1221]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "FieldDeclaration [1736,1809]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "FieldDeclaration [1815,1911]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [2104,2145]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [2154,2173]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [2185,2761]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [2767,3178]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TagElement [3258,3319]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement:  if the sample is too short or if [3360,3393]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: the first guess cannot be computed. [3401,3436]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TagElement [3327,3436]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TagElement [3444,3473]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Javadoc [3184,3481]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SimpleType [3493,3509]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SimpleType [3523,3544]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [3629,4314]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [4324,4399]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ReturnStatement [4408,4469]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TypeDeclaration [4481,5415]",
          "to": ""
        }
      ]
    }
  ],
  "inducing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [
        "src/main/java/org/apache/commons/math/optimization/fitting/HarmonicCoefficientsGuesser.java"
      ],
      "num": 1
    },
    "add_functions": {
      "qualified_names": [
        "sortObservations",
        "guess",
        "ParameterGuesser",
        "guessAOmega",
        "guessPhi"
      ],
      "num": 5
    },
    "delete_functions": {
      "qualified_names": [
        "gradient",
        "addObservedPoint",
        "value"
      ],
      "num": 3
    }
  },
  "trigger_tests": [],
  "fixing_changes": [],
  "fixing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [],
      "num": 0
    },
    "add_functions": {
      "qualified_names": [],
      "num": 0
    },
    "delete_functions": {
      "qualified_names": [],
      "num": 0
    }
  }
}