diff --git a/javadoc/allclasses-frame.html b/javadoc/allclasses-frame.html
index fc120dc..a0ead1c 100644
--- a/javadoc/allclasses-frame.html
+++ b/javadoc/allclasses-frame.html
@@ -293,6 +293,8 @@
 <BR>
 <A HREF="com/google/javascript/rhino/jstype/SimpleSlot.html" title="class in com.google.javascript.rhino.jstype" target="classFrame">SimpleSlot</A>
 <BR>
+<A HREF="com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html" title="class in com.google.javascript.jscomp.testing" target="classFrame">SimpleSourceExcerptProvider</A>
+<BR>
 <A HREF="com/google/javascript/jscomp/SourceAst.html" title="interface in com.google.javascript.jscomp" target="classFrame"><I>SourceAst</I></A>
 <BR>
 <A HREF="com/google/javascript/jscomp/SourceExcerptProvider.html" title="interface in com.google.javascript.jscomp" target="classFrame"><I>SourceExcerptProvider</I></A>
@@ -325,6 +327,8 @@
 <BR>
 <A HREF="com/google/javascript/rhino/jstype/TernaryValue.html" title="enum in com.google.javascript.rhino.jstype" target="classFrame">TernaryValue</A>
 <BR>
+<A HREF="com/google/javascript/jscomp/testing/TestErrorReporter.html" title="class in com.google.javascript.jscomp.testing" target="classFrame">TestErrorReporter</A>
+<BR>
 <A HREF="com/google/javascript/rhino/Token.html" title="class in com.google.javascript.rhino" target="classFrame">Token</A>
 <BR>
 <A HREF="com/google/javascript/rhino/TokenStream.html" title="class in com.google.javascript.rhino" target="classFrame">TokenStream</A>
diff --git a/javadoc/allclasses-noframe.html b/javadoc/allclasses-noframe.html
index e167954..9c4c4ca 100644
--- a/javadoc/allclasses-noframe.html
+++ b/javadoc/allclasses-noframe.html
@@ -293,6 +293,8 @@
 <BR>
 <A HREF="com/google/javascript/rhino/jstype/SimpleSlot.html" title="class in com.google.javascript.rhino.jstype">SimpleSlot</A>
 <BR>
+<A HREF="com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html" title="class in com.google.javascript.jscomp.testing">SimpleSourceExcerptProvider</A>
+<BR>
 <A HREF="com/google/javascript/jscomp/SourceAst.html" title="interface in com.google.javascript.jscomp"><I>SourceAst</I></A>
 <BR>
 <A HREF="com/google/javascript/jscomp/SourceExcerptProvider.html" title="interface in com.google.javascript.jscomp"><I>SourceExcerptProvider</I></A>
@@ -325,6 +327,8 @@
 <BR>
 <A HREF="com/google/javascript/rhino/jstype/TernaryValue.html" title="enum in com.google.javascript.rhino.jstype">TernaryValue</A>
 <BR>
+<A HREF="com/google/javascript/jscomp/testing/TestErrorReporter.html" title="class in com.google.javascript.jscomp.testing">TestErrorReporter</A>
+<BR>
 <A HREF="com/google/javascript/rhino/Token.html" title="class in com.google.javascript.rhino">Token</A>
 <BR>
 <A HREF="com/google/javascript/rhino/TokenStream.html" title="class in com.google.javascript.rhino">TokenStream</A>
diff --git a/javadoc/com/google/javascript/jscomp/Compiler.html b/javadoc/com/google/javascript/jscomp/Compiler.html
index 08b01a1..b3afd8c 100644
--- a/javadoc/com/google/javascript/jscomp/Compiler.html
+++ b/javadoc/com/google/javascript/jscomp/Compiler.html
@@ -177,14 +177,6 @@
 <TD><CODE><B><A HREF="../../../../com/google/javascript/jscomp/Compiler.html#OPTIMIZE_LOOP_ERROR">OPTIMIZE_LOOP_ERROR</A></B></CODE>
 
 <BR>
-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
-</TR>
-<TR BGCOLOR="white" CLASS="TableRowColor">
-<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
-<CODE>static&nbsp;<A HREF="../../../../com/google/javascript/jscomp/DiagnosticType.html" title="class in com.google.javascript.jscomp">DiagnosticType</A></CODE></FONT></TD>
-<TD><CODE><B><A HREF="../../../../com/google/javascript/jscomp/Compiler.html#READ_ERROR">READ_ERROR</A></B></CODE>
-
-<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error strings used for reporting JSErrors</TD>
 </TR>
 <TR BGCOLOR="white" CLASS="TableRowColor">
@@ -671,23 +663,13 @@
 </DL>
 <HR>
 
-<A NAME="READ_ERROR"><!-- --></A><H3>
-READ_ERROR</H3>
-<PRE>
-public static final <A HREF="../../../../com/google/javascript/jscomp/DiagnosticType.html" title="class in com.google.javascript.jscomp">DiagnosticType</A> <B>READ_ERROR</B></PRE>
-<DL>
-<DD>Error strings used for reporting JSErrors
-<P>
-<DL>
-</DL>
-</DL>
-<HR>
-
 <A NAME="OPTIMIZE_LOOP_ERROR"><!-- --></A><H3>
 OPTIMIZE_LOOP_ERROR</H3>
 <PRE>
 public static final <A HREF="../../../../com/google/javascript/jscomp/DiagnosticType.html" title="class in com.google.javascript.jscomp">DiagnosticType</A> <B>OPTIMIZE_LOOP_ERROR</B></PRE>
 <DL>
+<DD>Error strings used for reporting JSErrors
+<P>
 <DL>
 </DL>
 </DL>
diff --git a/javadoc/com/google/javascript/jscomp/SourceExcerptProvider.html b/javadoc/com/google/javascript/jscomp/SourceExcerptProvider.html
index c82cc61..6a409e2 100644
--- a/javadoc/com/google/javascript/jscomp/SourceExcerptProvider.html
+++ b/javadoc/com/google/javascript/jscomp/SourceExcerptProvider.html
@@ -89,7 +89,7 @@
 <BR>
 Interface SourceExcerptProvider</H2>
 <DL>
-<DT><B>All Known Implementing Classes:</B> <DD><A HREF="../../../../com/google/javascript/jscomp/AbstractCompiler.html" title="class in com.google.javascript.jscomp">AbstractCompiler</A>, <A HREF="../../../../com/google/javascript/jscomp/Compiler.html" title="class in com.google.javascript.jscomp">Compiler</A></DD>
+<DT><B>All Known Implementing Classes:</B> <DD><A HREF="../../../../com/google/javascript/jscomp/AbstractCompiler.html" title="class in com.google.javascript.jscomp">AbstractCompiler</A>, <A HREF="../../../../com/google/javascript/jscomp/Compiler.html" title="class in com.google.javascript.jscomp">Compiler</A>, <A HREF="../../../../com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html" title="class in com.google.javascript.jscomp.testing">SimpleSourceExcerptProvider</A></DD>
 </DL>
 <HR>
 <DL>
diff --git a/javadoc/com/google/javascript/jscomp/parsing/package-summary.html b/javadoc/com/google/javascript/jscomp/parsing/package-summary.html
index a6ae923..f36c7d3 100644
--- a/javadoc/com/google/javascript/jscomp/parsing/package-summary.html
+++ b/javadoc/com/google/javascript/jscomp/parsing/package-summary.html
@@ -53,7 +53,7 @@
 <TR>
 <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
 &nbsp;<A HREF="../../../../../com/google/javascript/jscomp/graph/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
-&nbsp;<A HREF="../../../../../com/google/javascript/rhino/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
+&nbsp;<A HREF="../../../../../com/google/javascript/jscomp/testing/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
 <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
   <A HREF="../../../../../index.html?com/google/javascript/jscomp/parsing/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
 &nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
@@ -154,7 +154,7 @@
 <TR>
 <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
 &nbsp;<A HREF="../../../../../com/google/javascript/jscomp/graph/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
-&nbsp;<A HREF="../../../../../com/google/javascript/rhino/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
+&nbsp;<A HREF="../../../../../com/google/javascript/jscomp/testing/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
 <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
   <A HREF="../../../../../index.html?com/google/javascript/jscomp/parsing/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
 &nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
diff --git a/javadoc/com/google/javascript/jscomp/parsing/package-tree.html b/javadoc/com/google/javascript/jscomp/parsing/package-tree.html
index dc8681f..ae123e1 100644
--- a/javadoc/com/google/javascript/jscomp/parsing/package-tree.html
+++ b/javadoc/com/google/javascript/jscomp/parsing/package-tree.html
@@ -53,7 +53,7 @@
 <TR>
 <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
 &nbsp;<A HREF="../../../../../com/google/javascript/jscomp/graph/package-tree.html"><B>PREV</B></A>&nbsp;
-&nbsp;<A HREF="../../../../../com/google/javascript/rhino/package-tree.html"><B>NEXT</B></A></FONT></TD>
+&nbsp;<A HREF="../../../../../com/google/javascript/jscomp/testing/package-tree.html"><B>NEXT</B></A></FONT></TD>
 <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
   <A HREF="../../../../../index.html?com/google/javascript/jscomp/parsing/package-tree.html" target="_top"><B>FRAMES</B></A>  &nbsp;
 &nbsp;<A HREF="package-tree.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
@@ -121,7 +121,7 @@
 <TR>
 <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
 &nbsp;<A HREF="../../../../../com/google/javascript/jscomp/graph/package-tree.html"><B>PREV</B></A>&nbsp;
-&nbsp;<A HREF="../../../../../com/google/javascript/rhino/package-tree.html"><B>NEXT</B></A></FONT></TD>
+&nbsp;<A HREF="../../../../../com/google/javascript/jscomp/testing/package-tree.html"><B>NEXT</B></A></FONT></TD>
 <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
   <A HREF="../../../../../index.html?com/google/javascript/jscomp/parsing/package-tree.html" target="_top"><B>FRAMES</B></A>  &nbsp;
 &nbsp;<A HREF="package-tree.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
diff --git a/javadoc/com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html b/javadoc/com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html
new file mode 100644
index 0000000..28d6c27
--- /dev/null
+++ b/javadoc/com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html
@@ -0,0 +1,331 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<!--NewPage-->
+<HTML>
+<HEAD>
+<TITLE>
+SimpleSourceExcerptProvider (Compiler)
+</TITLE>
+
+
+<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../dev_javadoc.css" TITLE="Style">
+
+<SCRIPT type="text/javascript">
+function windowTitle()
+{
+    if (location.href.indexOf('is-external=true') == -1) {
+        parent.document.title="SimpleSourceExcerptProvider (Compiler)";
+    }
+}
+</SCRIPT>
+<NOSCRIPT>
+</NOSCRIPT>
+
+</HEAD>
+
+<BODY BGCOLOR="white" onload="windowTitle();">
+<HR>
+
+
+<!-- ========= START OF TOP NAVBAR ======= -->
+<A NAME="navbar_top"><!-- --></A>
+<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
+<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
+<TR>
+<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
+<A NAME="navbar_top_firstrow"><!-- --></A>
+<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
+  <TR ALIGN="center" VALIGN="top">
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
+  </TR>
+</TABLE>
+</TD>
+<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
+</EM>
+</TD>
+</TR>
+
+<TR>
+<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
+&nbsp;PREV CLASS&nbsp;
+&nbsp;<A HREF="../../../../../com/google/javascript/jscomp/testing/TestErrorReporter.html" title="class in com.google.javascript.jscomp.testing"><B>NEXT CLASS</B></A></FONT></TD>
+<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
+  <A HREF="../../../../../index.html?com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html" target="_top"><B>FRAMES</B></A>  &nbsp;
+&nbsp;<A HREF="SimpleSourceExcerptProvider.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
+&nbsp;<SCRIPT type="text/javascript">
+  <!--
+  if(window==top) {
+    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
+  }
+  //-->
+</SCRIPT>
+<NOSCRIPT>
+  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
+</NOSCRIPT>
+
+
+</FONT></TD>
+</TR>
+<TR>
+<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
+  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
+<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
+DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
+</TR>
+</TABLE>
+<A NAME="skip-navbar_top"></A>
+<!-- ========= END OF TOP NAVBAR ========= -->
+
+<HR>
+<!-- ======== START OF CLASS DATA ======== -->
+<H2>
+<FONT SIZE="-1">
+com.google.javascript.jscomp.testing</FONT>
+<BR>
+Class SimpleSourceExcerptProvider</H2>
+<PRE>
+<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</A>
+  <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by "><B>com.google.javascript.jscomp.testing.SimpleSourceExcerptProvider</B>
+</PRE>
+<DL>
+<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../../../com/google/javascript/jscomp/SourceExcerptProvider.html" title="interface in com.google.javascript.jscomp">SourceExcerptProvider</A></DD>
+</DL>
+<HR>
+<DL>
+<DT><PRE>public class <B>SimpleSourceExcerptProvider</B><DT>extends <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</A><DT>implements <A HREF="../../../../../com/google/javascript/jscomp/SourceExcerptProvider.html" title="interface in com.google.javascript.jscomp">SourceExcerptProvider</A></DL>
+</PRE>
+
+<P>
+A simple source excerpt provider for testing.
+<P>
+
+<P>
+<HR>
+
+<P>
+<!-- ======== NESTED CLASS SUMMARY ======== -->
+
+<A NAME="nested_class_summary"><!-- --></A>
+<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
+<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
+<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
+<B>Nested Class Summary</B></FONT></TH>
+</TR>
+</TABLE>
+&nbsp;<A NAME="nested_classes_inherited_from_class_com.google.javascript.jscomp.SourceExcerptProvider"><!-- --></A>
+<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
+<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
+<TH ALIGN="left"><B>Nested classes/interfaces inherited from interface com.google.javascript.jscomp.<A HREF="../../../../../com/google/javascript/jscomp/SourceExcerptProvider.html" title="interface in com.google.javascript.jscomp">SourceExcerptProvider</A></B></TH>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD><CODE><A HREF="../../../../../com/google/javascript/jscomp/SourceExcerptProvider.ExcerptFormatter.html" title="interface in com.google.javascript.jscomp">SourceExcerptProvider.ExcerptFormatter</A>, <A HREF="../../../../../com/google/javascript/jscomp/SourceExcerptProvider.SourceExcerpt.html" title="enum in com.google.javascript.jscomp">SourceExcerptProvider.SourceExcerpt</A></CODE></TD>
+</TR>
+</TABLE>
+&nbsp;
+
+<!-- ======== CONSTRUCTOR SUMMARY ======== -->
+
+<A NAME="constructor_summary"><!-- --></A>
+<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
+<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
+<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
+<B>Constructor Summary</B></FONT></TH>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD><CODE><B><A HREF="../../../../../com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html#SimpleSourceExcerptProvider(java.lang.String)">SimpleSourceExcerptProvider</A></B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;source)</CODE>
+
+<BR>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
+</TR>
+</TABLE>
+&nbsp;
+<!-- ========== METHOD SUMMARY =========== -->
+
+<A NAME="method_summary"><!-- --></A>
+<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
+<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
+<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
+<B>Method Summary</B></FONT></TH>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
+<CODE>&nbsp;<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
+<TD><CODE><B><A HREF="../../../../../com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html#getSourceLine(java.lang.String, int)">getSourceLine</A></B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;sourceName,
+              int&nbsp;lineNumber)</CODE>
+
+<BR>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the line indicated by the line number.</TD>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
+<CODE>&nbsp;<A HREF="../../../../../com/google/javascript/jscomp/Region.html" title="interface in com.google.javascript.jscomp">Region</A></CODE></FONT></TD>
+<TD><CODE><B><A HREF="../../../../../com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html#getSourceRegion(java.lang.String, int)">getSourceRegion</A></B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;sourceName,
+                int&nbsp;lineNumber)</CODE>
+
+<BR>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a region around the indicated line number.</TD>
+</TR>
+</TABLE>
+&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
+<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
+<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
+<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</A></B></TH>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD><CODE><A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#toString()" title="class or interface in java.lang">toString</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
+</TR>
+</TABLE>
+&nbsp;
+<P>
+
+<!-- ========= CONSTRUCTOR DETAIL ======== -->
+
+<A NAME="constructor_detail"><!-- --></A>
+<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
+<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
+<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
+<B>Constructor Detail</B></FONT></TH>
+</TR>
+</TABLE>
+
+<A NAME="SimpleSourceExcerptProvider(java.lang.String)"><!-- --></A><H3>
+SimpleSourceExcerptProvider</H3>
+<PRE>
+public <B>SimpleSourceExcerptProvider</B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;source)</PRE>
+<DL>
+</DL>
+
+<!-- ============ METHOD DETAIL ========== -->
+
+<A NAME="method_detail"><!-- --></A>
+<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
+<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
+<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
+<B>Method Detail</B></FONT></TH>
+</TR>
+</TABLE>
+
+<A NAME="getSourceLine(java.lang.String, int)"><!-- --></A><H3>
+getSourceLine</H3>
+<PRE>
+public <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>getSourceLine</B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;sourceName,
+                            int&nbsp;lineNumber)</PRE>
+<DL>
+<DD><B>Description copied from interface: <CODE><A HREF="../../../../../com/google/javascript/jscomp/SourceExcerptProvider.html#getSourceLine(java.lang.String, int)">SourceExcerptProvider</A></CODE></B></DD>
+<DD>Get the line indicated by the line number. This call will return only the
+ specific line.
+<P>
+<DD><DL>
+<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../com/google/javascript/jscomp/SourceExcerptProvider.html#getSourceLine(java.lang.String, int)">getSourceLine</A></CODE> in interface <CODE><A HREF="../../../../../com/google/javascript/jscomp/SourceExcerptProvider.html" title="interface in com.google.javascript.jscomp">SourceExcerptProvider</A></CODE></DL>
+</DD>
+<DD><DL>
+<DD><CODE>lineNumber</CODE> - the line number, 1 being the first line of the file
+<DT><B>Returns:</B><DD>the line indicated, or <code>null</code> if it does not exist</DL>
+</DD>
+</DL>
+<HR>
+
+<A NAME="getSourceRegion(java.lang.String, int)"><!-- --></A><H3>
+getSourceRegion</H3>
+<PRE>
+public <A HREF="../../../../../com/google/javascript/jscomp/Region.html" title="interface in com.google.javascript.jscomp">Region</A> <B>getSourceRegion</B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;sourceName,
+                              int&nbsp;lineNumber)</PRE>
+<DL>
+<DD><B>Description copied from interface: <CODE><A HREF="../../../../../com/google/javascript/jscomp/SourceExcerptProvider.html#getSourceRegion(java.lang.String, int)">SourceExcerptProvider</A></CODE></B></DD>
+<DD>Get a region around the indicated line number. The exact definition of a
+ region is implementation specific, but it must contain the line indicated
+ by the line number. A region must not start or end by a carriage return.
+<P>
+<DD><DL>
+<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../com/google/javascript/jscomp/SourceExcerptProvider.html#getSourceRegion(java.lang.String, int)">getSourceRegion</A></CODE> in interface <CODE><A HREF="../../../../../com/google/javascript/jscomp/SourceExcerptProvider.html" title="interface in com.google.javascript.jscomp">SourceExcerptProvider</A></CODE></DL>
+</DD>
+<DD><DL>
+<DD><CODE>lineNumber</CODE> - the line number, 1 being the first line of the file
+<DT><B>Returns:</B><DD>the region around the line number indicated, or <code>null</null>
+ if it does not exist</DL>
+</DD>
+</DL>
+<!-- ========= END OF CLASS DATA ========= -->
+<HR>
+
+
+<!-- ======= START OF BOTTOM NAVBAR ====== -->
+<A NAME="navbar_bottom"><!-- --></A>
+<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
+<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
+<TR>
+<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
+<A NAME="navbar_bottom_firstrow"><!-- --></A>
+<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
+  <TR ALIGN="center" VALIGN="top">
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
+  </TR>
+</TABLE>
+</TD>
+<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
+</EM>
+</TD>
+</TR>
+
+<TR>
+<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
+&nbsp;PREV CLASS&nbsp;
+&nbsp;<A HREF="../../../../../com/google/javascript/jscomp/testing/TestErrorReporter.html" title="class in com.google.javascript.jscomp.testing"><B>NEXT CLASS</B></A></FONT></TD>
+<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
+  <A HREF="../../../../../index.html?com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html" target="_top"><B>FRAMES</B></A>  &nbsp;
+&nbsp;<A HREF="SimpleSourceExcerptProvider.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
+&nbsp;<SCRIPT type="text/javascript">
+  <!--
+  if(window==top) {
+    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
+  }
+  //-->
+</SCRIPT>
+<NOSCRIPT>
+  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
+</NOSCRIPT>
+
+
+</FONT></TD>
+</TR>
+<TR>
+<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
+  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
+<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
+DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
+</TR>
+</TABLE>
+<A NAME="skip-navbar_bottom"></A>
+<!-- ======== END OF BOTTOM NAVBAR ======= -->
+
+<HR>
+
+        <div id="footer">
+          <div id="footerlogo">
+            <img src="http://www.google.com/images/art.gif"
+                 alt="Google colored balls">
+          </div>
+
+          <div id="copyright">
+          <p>&copy; 2009 Google -
+            <a href="http://www.google.com/privacy.html">Privacy Policy</a> -
+            <a href="http://www.google.com/terms_of_service.html">Terms and Conditions</a> -
+            <a href="http://www.google.com/about.html">About Google</a>
+          </p>
+          </div>
+        </div>
+      
+      
+</BODY>
+</HTML>
diff --git a/javadoc/com/google/javascript/jscomp/testing/TestErrorReporter.html b/javadoc/com/google/javascript/jscomp/testing/TestErrorReporter.html
new file mode 100644
index 0000000..0bc99d5
--- /dev/null
+++ b/javadoc/com/google/javascript/jscomp/testing/TestErrorReporter.html
@@ -0,0 +1,411 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<!--NewPage-->
+<HTML>
+<HEAD>
+<TITLE>
+TestErrorReporter (Compiler)
+</TITLE>
+
+
+<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../dev_javadoc.css" TITLE="Style">
+
+<SCRIPT type="text/javascript">
+function windowTitle()
+{
+    if (location.href.indexOf('is-external=true') == -1) {
+        parent.document.title="TestErrorReporter (Compiler)";
+    }
+}
+</SCRIPT>
+<NOSCRIPT>
+</NOSCRIPT>
+
+</HEAD>
+
+<BODY BGCOLOR="white" onload="windowTitle();">
+<HR>
+
+
+<!-- ========= START OF TOP NAVBAR ======= -->
+<A NAME="navbar_top"><!-- --></A>
+<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
+<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
+<TR>
+<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
+<A NAME="navbar_top_firstrow"><!-- --></A>
+<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
+  <TR ALIGN="center" VALIGN="top">
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
+  </TR>
+</TABLE>
+</TD>
+<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
+</EM>
+</TD>
+</TR>
+
+<TR>
+<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
+&nbsp;<A HREF="../../../../../com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html" title="class in com.google.javascript.jscomp.testing"><B>PREV CLASS</B></A>&nbsp;
+&nbsp;NEXT CLASS</FONT></TD>
+<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
+  <A HREF="../../../../../index.html?com/google/javascript/jscomp/testing/TestErrorReporter.html" target="_top"><B>FRAMES</B></A>  &nbsp;
+&nbsp;<A HREF="TestErrorReporter.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
+&nbsp;<SCRIPT type="text/javascript">
+  <!--
+  if(window==top) {
+    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
+  }
+  //-->
+</SCRIPT>
+<NOSCRIPT>
+  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
+</NOSCRIPT>
+
+
+</FONT></TD>
+</TR>
+<TR>
+<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
+  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
+<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
+DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
+</TR>
+</TABLE>
+<A NAME="skip-navbar_top"></A>
+<!-- ========= END OF TOP NAVBAR ========= -->
+
+<HR>
+<!-- ======== START OF CLASS DATA ======== -->
+<H2>
+<FONT SIZE="-1">
+com.google.javascript.jscomp.testing</FONT>
+<BR>
+Class TestErrorReporter</H2>
+<PRE>
+<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</A>
+  <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by ">junit.framework.Assert
+      <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by "><B>com.google.javascript.jscomp.testing.TestErrorReporter</B>
+</PRE>
+<DL>
+<DT><B>All Implemented Interfaces:</B> <DD>com.google.javascript.jscomp.mozilla.rhino.ErrorReporter</DD>
+</DL>
+<HR>
+<DL>
+<DT><PRE>public final class <B>TestErrorReporter</B><DT>extends junit.framework.Assert<DT>implements com.google.javascript.jscomp.mozilla.rhino.ErrorReporter</DL>
+</PRE>
+
+<P>
+<p>An error reporter for testing that verifies that messages reported to the
+ reporter are expected.</p>
+
+ <p>Sample use</p>
+ <pre>
+ TestErrorReporter e =
+   new TestErrorReporter(null, new String[] { "first warning" });
+ ...
+ assertTrue(e.hasEncounteredAllWarnings());
+ </pre>
+<P>
+
+<P>
+<HR>
+
+<P>
+
+<!-- ======== CONSTRUCTOR SUMMARY ======== -->
+
+<A NAME="constructor_summary"><!-- --></A>
+<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
+<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
+<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
+<B>Constructor Summary</B></FONT></TH>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD><CODE><B><A HREF="../../../../../com/google/javascript/jscomp/testing/TestErrorReporter.html#TestErrorReporter(java.lang.String[], java.lang.String[])">TestErrorReporter</A></B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>[]&nbsp;errors,
+                  <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>[]&nbsp;warnings)</CODE>
+
+<BR>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
+</TR>
+</TABLE>
+&nbsp;
+<!-- ========== METHOD SUMMARY =========== -->
+
+<A NAME="method_summary"><!-- --></A>
+<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
+<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
+<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
+<B>Method Summary</B></FONT></TH>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
+<CODE>&nbsp;void</CODE></FONT></TD>
+<TD><CODE><B><A HREF="../../../../../com/google/javascript/jscomp/testing/TestErrorReporter.html#error(java.lang.String, java.lang.String, int, java.lang.String, int)">error</A></B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;message,
+      <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;sourceName,
+      int&nbsp;line,
+      <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;lineSource,
+      int&nbsp;lineOffset)</CODE>
+
+<BR>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
+<CODE>&nbsp;boolean</CODE></FONT></TD>
+<TD><CODE><B><A HREF="../../../../../com/google/javascript/jscomp/testing/TestErrorReporter.html#hasEncounteredAllErrors()">hasEncounteredAllErrors</A></B>()</CODE>
+
+<BR>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether all errors were reported to this reporter.</TD>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
+<CODE>&nbsp;boolean</CODE></FONT></TD>
+<TD><CODE><B><A HREF="../../../../../com/google/javascript/jscomp/testing/TestErrorReporter.html#hasEncounteredAllWarnings()">hasEncounteredAllWarnings</A></B>()</CODE>
+
+<BR>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether all warnings were reported to this reporter.</TD>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
+<CODE>&nbsp;com.google.javascript.jscomp.mozilla.rhino.EvaluatorException</CODE></FONT></TD>
+<TD><CODE><B><A HREF="../../../../../com/google/javascript/jscomp/testing/TestErrorReporter.html#runtimeError(java.lang.String, java.lang.String, int, java.lang.String, int)">runtimeError</A></B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;message,
+             <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;sourceName,
+             int&nbsp;line,
+             <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;lineSource,
+             int&nbsp;lineOffset)</CODE>
+
+<BR>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
+<CODE>&nbsp;void</CODE></FONT></TD>
+<TD><CODE><B><A HREF="../../../../../com/google/javascript/jscomp/testing/TestErrorReporter.html#warning(java.lang.String, java.lang.String, int, java.lang.String, int)">warning</A></B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;message,
+        <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;sourceName,
+        int&nbsp;line,
+        <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;lineSource,
+        int&nbsp;lineOffset)</CODE>
+
+<BR>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
+</TR>
+</TABLE>
+&nbsp;<A NAME="methods_inherited_from_class_junit.framework.Assert"><!-- --></A>
+<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
+<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
+<TH ALIGN="left"><B>Methods inherited from class junit.framework.Assert</B></TH>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD><CODE>assertEquals, assertEquals, assertEquals, assertEquals, assertEquals, assertEquals, assertEquals, assertEquals, assertEquals, assertEquals, assertEquals, assertEquals, assertEquals, assertEquals, assertEquals, assertEquals, assertEquals, assertEquals, assertEquals, assertEquals, assertFalse, assertFalse, assertNotNull, assertNotNull, assertNotSame, assertNotSame, assertNull, assertNull, assertSame, assertSame, assertTrue, assertTrue, fail, fail</CODE></TD>
+</TR>
+</TABLE>
+&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
+<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
+<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
+<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</A></B></TH>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD><CODE><A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#toString()" title="class or interface in java.lang">toString</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
+</TR>
+</TABLE>
+&nbsp;
+<P>
+
+<!-- ========= CONSTRUCTOR DETAIL ======== -->
+
+<A NAME="constructor_detail"><!-- --></A>
+<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
+<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
+<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
+<B>Constructor Detail</B></FONT></TH>
+</TR>
+</TABLE>
+
+<A NAME="TestErrorReporter(java.lang.String[], java.lang.String[])"><!-- --></A><H3>
+TestErrorReporter</H3>
+<PRE>
+public <B>TestErrorReporter</B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>[]&nbsp;errors,
+                         <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>[]&nbsp;warnings)</PRE>
+<DL>
+</DL>
+
+<!-- ============ METHOD DETAIL ========== -->
+
+<A NAME="method_detail"><!-- --></A>
+<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
+<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
+<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
+<B>Method Detail</B></FONT></TH>
+</TR>
+</TABLE>
+
+<A NAME="error(java.lang.String, java.lang.String, int, java.lang.String, int)"><!-- --></A><H3>
+error</H3>
+<PRE>
+public void <B>error</B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;message,
+                  <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;sourceName,
+                  int&nbsp;line,
+                  <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;lineSource,
+                  int&nbsp;lineOffset)</PRE>
+<DL>
+<DD><DL>
+<DT><B>Specified by:</B><DD><CODE>error</CODE> in interface <CODE>com.google.javascript.jscomp.mozilla.rhino.ErrorReporter</CODE></DL>
+</DD>
+<DD><DL>
+</DL>
+</DD>
+</DL>
+<HR>
+
+<A NAME="warning(java.lang.String, java.lang.String, int, java.lang.String, int)"><!-- --></A><H3>
+warning</H3>
+<PRE>
+public void <B>warning</B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;message,
+                    <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;sourceName,
+                    int&nbsp;line,
+                    <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;lineSource,
+                    int&nbsp;lineOffset)</PRE>
+<DL>
+<DD><DL>
+<DT><B>Specified by:</B><DD><CODE>warning</CODE> in interface <CODE>com.google.javascript.jscomp.mozilla.rhino.ErrorReporter</CODE></DL>
+</DD>
+<DD><DL>
+</DL>
+</DD>
+</DL>
+<HR>
+
+<A NAME="runtimeError(java.lang.String, java.lang.String, int, java.lang.String, int)"><!-- --></A><H3>
+runtimeError</H3>
+<PRE>
+public com.google.javascript.jscomp.mozilla.rhino.EvaluatorException <B>runtimeError</B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;message,
+                                                                                  <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;sourceName,
+                                                                                  int&nbsp;line,
+                                                                                  <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;lineSource,
+                                                                                  int&nbsp;lineOffset)</PRE>
+<DL>
+<DD><DL>
+<DT><B>Specified by:</B><DD><CODE>runtimeError</CODE> in interface <CODE>com.google.javascript.jscomp.mozilla.rhino.ErrorReporter</CODE></DL>
+</DD>
+<DD><DL>
+</DL>
+</DD>
+</DL>
+<HR>
+
+<A NAME="hasEncounteredAllWarnings()"><!-- --></A><H3>
+hasEncounteredAllWarnings</H3>
+<PRE>
+public boolean <B>hasEncounteredAllWarnings</B>()</PRE>
+<DL>
+<DD>Returns whether all warnings were reported to this reporter.
+<P>
+<DD><DL>
+</DL>
+</DD>
+<DD><DL>
+</DL>
+</DD>
+</DL>
+<HR>
+
+<A NAME="hasEncounteredAllErrors()"><!-- --></A><H3>
+hasEncounteredAllErrors</H3>
+<PRE>
+public boolean <B>hasEncounteredAllErrors</B>()</PRE>
+<DL>
+<DD>Returns whether all errors were reported to this reporter.
+<P>
+<DD><DL>
+</DL>
+</DD>
+<DD><DL>
+</DL>
+</DD>
+</DL>
+<!-- ========= END OF CLASS DATA ========= -->
+<HR>
+
+
+<!-- ======= START OF BOTTOM NAVBAR ====== -->
+<A NAME="navbar_bottom"><!-- --></A>
+<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
+<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
+<TR>
+<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
+<A NAME="navbar_bottom_firstrow"><!-- --></A>
+<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
+  <TR ALIGN="center" VALIGN="top">
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
+  </TR>
+</TABLE>
+</TD>
+<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
+</EM>
+</TD>
+</TR>
+
+<TR>
+<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
+&nbsp;<A HREF="../../../../../com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html" title="class in com.google.javascript.jscomp.testing"><B>PREV CLASS</B></A>&nbsp;
+&nbsp;NEXT CLASS</FONT></TD>
+<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
+  <A HREF="../../../../../index.html?com/google/javascript/jscomp/testing/TestErrorReporter.html" target="_top"><B>FRAMES</B></A>  &nbsp;
+&nbsp;<A HREF="TestErrorReporter.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
+&nbsp;<SCRIPT type="text/javascript">
+  <!--
+  if(window==top) {
+    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
+  }
+  //-->
+</SCRIPT>
+<NOSCRIPT>
+  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
+</NOSCRIPT>
+
+
+</FONT></TD>
+</TR>
+<TR>
+<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
+  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
+<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
+DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
+</TR>
+</TABLE>
+<A NAME="skip-navbar_bottom"></A>
+<!-- ======== END OF BOTTOM NAVBAR ======= -->
+
+<HR>
+
+        <div id="footer">
+          <div id="footerlogo">
+            <img src="http://www.google.com/images/art.gif"
+                 alt="Google colored balls">
+          </div>
+
+          <div id="copyright">
+          <p>&copy; 2009 Google -
+            <a href="http://www.google.com/privacy.html">Privacy Policy</a> -
+            <a href="http://www.google.com/terms_of_service.html">Terms and Conditions</a> -
+            <a href="http://www.google.com/about.html">About Google</a>
+          </p>
+          </div>
+        </div>
+      
+      
+</BODY>
+</HTML>
diff --git a/javadoc/com/google/javascript/jscomp/testing/package-frame.html b/javadoc/com/google/javascript/jscomp/testing/package-frame.html
new file mode 100644
index 0000000..70b6bdc
--- /dev/null
+++ b/javadoc/com/google/javascript/jscomp/testing/package-frame.html
@@ -0,0 +1,32 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<!--NewPage-->
+<HTML>
+<HEAD>
+<TITLE>
+com.google.javascript.jscomp.testing (Compiler)
+</TITLE>
+
+
+<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../dev_javadoc.css" TITLE="Style">
+
+
+</HEAD>
+
+<BODY BGCOLOR="white">
+<FONT size="+1" CLASS="FrameTitleFont">
+<A HREF="../../../../../com/google/javascript/jscomp/testing/package-summary.html" target="classFrame">com.google.javascript.jscomp.testing</A></FONT>
+<TABLE BORDER="0" WIDTH="100%" SUMMARY="">
+<TR>
+<TD NOWRAP><FONT size="+1" CLASS="FrameHeadingFont">
+Classes</FONT>&nbsp;
+<FONT CLASS="FrameItemFont">
+<BR>
+<A HREF="SimpleSourceExcerptProvider.html" title="class in com.google.javascript.jscomp.testing" target="classFrame">SimpleSourceExcerptProvider</A>
+<BR>
+<A HREF="TestErrorReporter.html" title="class in com.google.javascript.jscomp.testing" target="classFrame">TestErrorReporter</A></FONT></TD>
+</TR>
+</TABLE>
+
+
+</BODY>
+</HTML>
diff --git a/javadoc/com/google/javascript/jscomp/testing/package-summary.html b/javadoc/com/google/javascript/jscomp/testing/package-summary.html
new file mode 100644
index 0000000..892a6e7
--- /dev/null
+++ b/javadoc/com/google/javascript/jscomp/testing/package-summary.html
@@ -0,0 +1,174 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<!--NewPage-->
+<HTML>
+<HEAD>
+<TITLE>
+com.google.javascript.jscomp.testing (Compiler)
+</TITLE>
+
+
+<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../dev_javadoc.css" TITLE="Style">
+
+<SCRIPT type="text/javascript">
+function windowTitle()
+{
+    if (location.href.indexOf('is-external=true') == -1) {
+        parent.document.title="com.google.javascript.jscomp.testing (Compiler)";
+    }
+}
+</SCRIPT>
+<NOSCRIPT>
+</NOSCRIPT>
+
+</HEAD>
+
+<BODY BGCOLOR="white" onload="windowTitle();">
+<HR>
+
+
+<!-- ========= START OF TOP NAVBAR ======= -->
+<A NAME="navbar_top"><!-- --></A>
+<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
+<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
+<TR>
+<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
+<A NAME="navbar_top_firstrow"><!-- --></A>
+<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
+  <TR ALIGN="center" VALIGN="top">
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
+  </TR>
+</TABLE>
+</TD>
+<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
+</EM>
+</TD>
+</TR>
+
+<TR>
+<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
+&nbsp;<A HREF="../../../../../com/google/javascript/jscomp/parsing/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
+&nbsp;<A HREF="../../../../../com/google/javascript/rhino/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
+<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
+  <A HREF="../../../../../index.html?com/google/javascript/jscomp/testing/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
+&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
+&nbsp;<SCRIPT type="text/javascript">
+  <!--
+  if(window==top) {
+    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
+  }
+  //-->
+</SCRIPT>
+<NOSCRIPT>
+  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
+</NOSCRIPT>
+
+
+</FONT></TD>
+</TR>
+</TABLE>
+<A NAME="skip-navbar_top"></A>
+<!-- ========= END OF TOP NAVBAR ========= -->
+
+<HR>
+<H2>
+Package com.google.javascript.jscomp.testing
+</H2>
+
+<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
+<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
+<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
+<B>Class Summary</B></FONT></TH>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD WIDTH="15%"><B><A HREF="../../../../../com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html" title="class in com.google.javascript.jscomp.testing">SimpleSourceExcerptProvider</A></B></TD>
+<TD>A simple source excerpt provider for testing.</TD>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD WIDTH="15%"><B><A HREF="../../../../../com/google/javascript/jscomp/testing/TestErrorReporter.html" title="class in com.google.javascript.jscomp.testing">TestErrorReporter</A></B></TD>
+<TD>An error reporter for testing that verifies that messages reported to the
+ reporter are expected.</TD>
+</TR>
+</TABLE>
+&nbsp;
+
+<P>
+<DL>
+</DL>
+<HR>
+
+
+<!-- ======= START OF BOTTOM NAVBAR ====== -->
+<A NAME="navbar_bottom"><!-- --></A>
+<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
+<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
+<TR>
+<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
+<A NAME="navbar_bottom_firstrow"><!-- --></A>
+<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
+  <TR ALIGN="center" VALIGN="top">
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
+  </TR>
+</TABLE>
+</TD>
+<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
+</EM>
+</TD>
+</TR>
+
+<TR>
+<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
+&nbsp;<A HREF="../../../../../com/google/javascript/jscomp/parsing/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
+&nbsp;<A HREF="../../../../../com/google/javascript/rhino/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
+<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
+  <A HREF="../../../../../index.html?com/google/javascript/jscomp/testing/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
+&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
+&nbsp;<SCRIPT type="text/javascript">
+  <!--
+  if(window==top) {
+    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
+  }
+  //-->
+</SCRIPT>
+<NOSCRIPT>
+  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
+</NOSCRIPT>
+
+
+</FONT></TD>
+</TR>
+</TABLE>
+<A NAME="skip-navbar_bottom"></A>
+<!-- ======== END OF BOTTOM NAVBAR ======= -->
+
+<HR>
+
+        <div id="footer">
+          <div id="footerlogo">
+            <img src="http://www.google.com/images/art.gif"
+                 alt="Google colored balls">
+          </div>
+
+          <div id="copyright">
+          <p>&copy; 2009 Google -
+            <a href="http://www.google.com/privacy.html">Privacy Policy</a> -
+            <a href="http://www.google.com/terms_of_service.html">Terms and Conditions</a> -
+            <a href="http://www.google.com/about.html">About Google</a>
+          </p>
+          </div>
+        </div>
+      
+      
+</BODY>
+</HTML>
diff --git a/javadoc/com/google/javascript/jscomp/testing/package-tree.html b/javadoc/com/google/javascript/jscomp/testing/package-tree.html
new file mode 100644
index 0000000..c734f02
--- /dev/null
+++ b/javadoc/com/google/javascript/jscomp/testing/package-tree.html
@@ -0,0 +1,169 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<!--NewPage-->
+<HTML>
+<HEAD>
+<TITLE>
+com.google.javascript.jscomp.testing Class Hierarchy (Compiler)
+</TITLE>
+
+
+<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../dev_javadoc.css" TITLE="Style">
+
+<SCRIPT type="text/javascript">
+function windowTitle()
+{
+    if (location.href.indexOf('is-external=true') == -1) {
+        parent.document.title="com.google.javascript.jscomp.testing Class Hierarchy (Compiler)";
+    }
+}
+</SCRIPT>
+<NOSCRIPT>
+</NOSCRIPT>
+
+</HEAD>
+
+<BODY BGCOLOR="white" onload="windowTitle();">
+<HR>
+
+
+<!-- ========= START OF TOP NAVBAR ======= -->
+<A NAME="navbar_top"><!-- --></A>
+<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
+<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
+<TR>
+<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
+<A NAME="navbar_top_firstrow"><!-- --></A>
+<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
+  <TR ALIGN="center" VALIGN="top">
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
+  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Tree</B></FONT>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
+  </TR>
+</TABLE>
+</TD>
+<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
+</EM>
+</TD>
+</TR>
+
+<TR>
+<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
+&nbsp;<A HREF="../../../../../com/google/javascript/jscomp/parsing/package-tree.html"><B>PREV</B></A>&nbsp;
+&nbsp;<A HREF="../../../../../com/google/javascript/rhino/package-tree.html"><B>NEXT</B></A></FONT></TD>
+<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
+  <A HREF="../../../../../index.html?com/google/javascript/jscomp/testing/package-tree.html" target="_top"><B>FRAMES</B></A>  &nbsp;
+&nbsp;<A HREF="package-tree.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
+&nbsp;<SCRIPT type="text/javascript">
+  <!--
+  if(window==top) {
+    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
+  }
+  //-->
+</SCRIPT>
+<NOSCRIPT>
+  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
+</NOSCRIPT>
+
+
+</FONT></TD>
+</TR>
+</TABLE>
+<A NAME="skip-navbar_top"></A>
+<!-- ========= END OF TOP NAVBAR ========= -->
+
+<HR>
+<CENTER>
+<H2>
+Hierarchy For Package com.google.javascript.jscomp.testing
+</H2>
+</CENTER>
+<DL>
+<DT><B>Package Hierarchies:</B><DD><A HREF="../../../../../overview-tree.html">All Packages</A></DL>
+<HR>
+<H2>
+Class Hierarchy
+</H2>
+<UL>
+<LI TYPE="circle">java.lang.<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang"><B>Object</B></A><UL>
+<LI TYPE="circle">junit.framework.Assert<UL>
+<LI TYPE="circle">com.google.javascript.jscomp.testing.<A HREF="../../../../../com/google/javascript/jscomp/testing/TestErrorReporter.html" title="class in com.google.javascript.jscomp.testing"><B>TestErrorReporter</B></A> (implements com.google.javascript.jscomp.mozilla.rhino.ErrorReporter)
+</UL>
+<LI TYPE="circle">com.google.javascript.jscomp.testing.<A HREF="../../../../../com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html" title="class in com.google.javascript.jscomp.testing"><B>SimpleSourceExcerptProvider</B></A> (implements com.google.javascript.jscomp.<A HREF="../../../../../com/google/javascript/jscomp/SourceExcerptProvider.html" title="interface in com.google.javascript.jscomp">SourceExcerptProvider</A>)
+</UL>
+</UL>
+<HR>
+
+
+<!-- ======= START OF BOTTOM NAVBAR ====== -->
+<A NAME="navbar_bottom"><!-- --></A>
+<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
+<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
+<TR>
+<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
+<A NAME="navbar_bottom_firstrow"><!-- --></A>
+<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
+  <TR ALIGN="center" VALIGN="top">
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
+  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Tree</B></FONT>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
+  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
+  </TR>
+</TABLE>
+</TD>
+<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
+</EM>
+</TD>
+</TR>
+
+<TR>
+<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
+&nbsp;<A HREF="../../../../../com/google/javascript/jscomp/parsing/package-tree.html"><B>PREV</B></A>&nbsp;
+&nbsp;<A HREF="../../../../../com/google/javascript/rhino/package-tree.html"><B>NEXT</B></A></FONT></TD>
+<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
+  <A HREF="../../../../../index.html?com/google/javascript/jscomp/testing/package-tree.html" target="_top"><B>FRAMES</B></A>  &nbsp;
+&nbsp;<A HREF="package-tree.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
+&nbsp;<SCRIPT type="text/javascript">
+  <!--
+  if(window==top) {
+    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
+  }
+  //-->
+</SCRIPT>
+<NOSCRIPT>
+  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
+</NOSCRIPT>
+
+
+</FONT></TD>
+</TR>
+</TABLE>
+<A NAME="skip-navbar_bottom"></A>
+<!-- ======== END OF BOTTOM NAVBAR ======= -->
+
+<HR>
+
+        <div id="footer">
+          <div id="footerlogo">
+            <img src="http://www.google.com/images/art.gif"
+                 alt="Google colored balls">
+          </div>
+
+          <div id="copyright">
+          <p>&copy; 2009 Google -
+            <a href="http://www.google.com/privacy.html">Privacy Policy</a> -
+            <a href="http://www.google.com/terms_of_service.html">Terms and Conditions</a> -
+            <a href="http://www.google.com/about.html">About Google</a>
+          </p>
+          </div>
+        </div>
+      
+      
+</BODY>
+</HTML>
diff --git a/javadoc/com/google/javascript/rhino/package-summary.html b/javadoc/com/google/javascript/rhino/package-summary.html
index b6cc6f0..79ad93a 100644
--- a/javadoc/com/google/javascript/rhino/package-summary.html
+++ b/javadoc/com/google/javascript/rhino/package-summary.html
@@ -52,7 +52,7 @@
 
 <TR>
 <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
-&nbsp;<A HREF="../../../../com/google/javascript/jscomp/parsing/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
+&nbsp;<A HREF="../../../../com/google/javascript/jscomp/testing/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
 &nbsp;<A HREF="../../../../com/google/javascript/rhino/jstype/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
 <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
   <A HREF="../../../../index.html?com/google/javascript/rhino/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
@@ -301,7 +301,7 @@
 
 <TR>
 <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
-&nbsp;<A HREF="../../../../com/google/javascript/jscomp/parsing/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
+&nbsp;<A HREF="../../../../com/google/javascript/jscomp/testing/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
 &nbsp;<A HREF="../../../../com/google/javascript/rhino/jstype/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
 <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
   <A HREF="../../../../index.html?com/google/javascript/rhino/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
diff --git a/javadoc/com/google/javascript/rhino/package-tree.html b/javadoc/com/google/javascript/rhino/package-tree.html
index 260b7b1..ef5e48f 100644
--- a/javadoc/com/google/javascript/rhino/package-tree.html
+++ b/javadoc/com/google/javascript/rhino/package-tree.html
@@ -52,7 +52,7 @@
 
 <TR>
 <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
-&nbsp;<A HREF="../../../../com/google/javascript/jscomp/parsing/package-tree.html"><B>PREV</B></A>&nbsp;
+&nbsp;<A HREF="../../../../com/google/javascript/jscomp/testing/package-tree.html"><B>PREV</B></A>&nbsp;
 &nbsp;<A HREF="../../../../com/google/javascript/rhino/jstype/package-tree.html"><B>NEXT</B></A></FONT></TD>
 <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
   <A HREF="../../../../index.html?com/google/javascript/rhino/package-tree.html" target="_top"><B>FRAMES</B></A>  &nbsp;
@@ -159,7 +159,7 @@
 
 <TR>
 <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
-&nbsp;<A HREF="../../../../com/google/javascript/jscomp/parsing/package-tree.html"><B>PREV</B></A>&nbsp;
+&nbsp;<A HREF="../../../../com/google/javascript/jscomp/testing/package-tree.html"><B>PREV</B></A>&nbsp;
 &nbsp;<A HREF="../../../../com/google/javascript/rhino/jstype/package-tree.html"><B>NEXT</B></A></FONT></TD>
 <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
   <A HREF="../../../../index.html?com/google/javascript/rhino/package-tree.html" target="_top"><B>FRAMES</B></A>  &nbsp;
diff --git a/javadoc/index-all.html b/javadoc/index-all.html
index 166c353..adccb0e 100644
--- a/javadoc/index-all.html
+++ b/javadoc/index-all.html
@@ -739,7 +739,7 @@
 <DD>The column number of the location of the error, or zero if unknown.
 <DT><A HREF="./com/google/javascript/jscomp/package-summary.html"><B>com.google.javascript.jscomp</B></A> - package com.google.javascript.jscomp<DD>Provides the core compiler and its public API.<DT><A HREF="./com/google/javascript/jscomp/graph/package-summary.html"><B>com.google.javascript.jscomp.graph</B></A> - package com.google.javascript.jscomp.graph<DD>Provides graph data structures and algorithms for coloring and fixed-point
 computations.<DT><A HREF="./com/google/javascript/jscomp/parsing/package-summary.html"><B>com.google.javascript.jscomp.parsing</B></A> - package com.google.javascript.jscomp.parsing<DD>Provides utilities to help with parsing JSDoc annotations and performing AST
-transformations.<DT><A HREF="./com/google/javascript/rhino/package-summary.html"><B>com.google.javascript.rhino</B></A> - package com.google.javascript.rhino<DD>The core parsing functionality for
+transformations.<DT><A HREF="./com/google/javascript/jscomp/testing/package-summary.html"><B>com.google.javascript.jscomp.testing</B></A> - package com.google.javascript.jscomp.testing<DD>&nbsp;<DT><A HREF="./com/google/javascript/rhino/package-summary.html"><B>com.google.javascript.rhino</B></A> - package com.google.javascript.rhino<DD>The core parsing functionality for
 <a href="http://www.mozilla.org/rhino/">Rhino</a> but with the support for
 embedding and scripting removed.<DT><A HREF="./com/google/javascript/rhino/jstype/package-summary.html"><B>com.google.javascript.rhino.jstype</B></A> - package com.google.javascript.rhino.jstype<DD>Provides abstractions to represent types in JavaScript.<DT><A HREF="./com/google/javascript/rhino/Token.html#COMMA"><B>COMMA</B></A> - 
 Static variable in class com.google.javascript.rhino.<A HREF="./com/google/javascript/rhino/Token.html" title="class in com.google.javascript.rhino">Token</A>
@@ -1375,6 +1375,9 @@
 <DT><A HREF="./com/google/javascript/jscomp/parsing/NullErrorReporter.html#error(java.lang.String, java.lang.String, int, java.lang.String, int)"><B>error(String, String, int, String, int)</B></A> - 
 Method in class com.google.javascript.jscomp.parsing.<A HREF="./com/google/javascript/jscomp/parsing/NullErrorReporter.html" title="class in com.google.javascript.jscomp.parsing">NullErrorReporter</A>
 <DD>&nbsp;
+<DT><A HREF="./com/google/javascript/jscomp/testing/TestErrorReporter.html#error(java.lang.String, java.lang.String, int, java.lang.String, int)"><B>error(String, String, int, String, int)</B></A> - 
+Method in class com.google.javascript.jscomp.testing.<A HREF="./com/google/javascript/jscomp/testing/TestErrorReporter.html" title="class in com.google.javascript.jscomp.testing">TestErrorReporter</A>
+<DD>&nbsp;
 <DT><A HREF="./com/google/javascript/rhino/ErrorReporter.html#error(java.lang.String, java.lang.String, int, java.lang.String, int)"><B>error(String, String, int, String, int)</B></A> - 
 Method in interface com.google.javascript.rhino.<A HREF="./com/google/javascript/rhino/ErrorReporter.html" title="interface in com.google.javascript.rhino">ErrorReporter</A>
 <DD>Report an error.
@@ -3014,6 +3017,9 @@
 <DT><A HREF="./com/google/javascript/jscomp/SourceExcerptProvider.html#getSourceLine(java.lang.String, int)"><B>getSourceLine(String, int)</B></A> - 
 Method in interface com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/SourceExcerptProvider.html" title="interface in com.google.javascript.jscomp">SourceExcerptProvider</A>
 <DD>Get the line indicated by the line number.
+<DT><A HREF="./com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html#getSourceLine(java.lang.String, int)"><B>getSourceLine(String, int)</B></A> - 
+Method in class com.google.javascript.jscomp.testing.<A HREF="./com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html" title="class in com.google.javascript.jscomp.testing">SimpleSourceExcerptProvider</A>
+<DD>&nbsp;
 <DT><A HREF="./com/google/javascript/jscomp/Compiler.html#getSourceMap()"><B>getSourceMap()</B></A> - 
 Method in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/Compiler.html" title="class in com.google.javascript.jscomp">Compiler</A>
 <DD>&nbsp;
@@ -3035,6 +3041,9 @@
 <DT><A HREF="./com/google/javascript/jscomp/SourceExcerptProvider.html#getSourceRegion(java.lang.String, int)"><B>getSourceRegion(String, int)</B></A> - 
 Method in interface com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/SourceExcerptProvider.html" title="interface in com.google.javascript.jscomp">SourceExcerptProvider</A>
 <DD>Get a region around the indicated line number.
+<DT><A HREF="./com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html#getSourceRegion(java.lang.String, int)"><B>getSourceRegion(String, int)</B></A> - 
+Method in class com.google.javascript.jscomp.testing.<A HREF="./com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html" title="class in com.google.javascript.jscomp.testing">SimpleSourceExcerptProvider</A>
+<DD>&nbsp;
 <DT><A HREF="./com/google/javascript/rhino/SourcePosition.html#getStartLine()"><B>getStartLine()</B></A> - 
 Method in class com.google.javascript.rhino.<A HREF="./com/google/javascript/rhino/SourcePosition.html" title="class in com.google.javascript.rhino">SourcePosition</A>
 <DD>Returns the starting line number of this position.
@@ -3301,6 +3310,12 @@
 Method in class com.google.javascript.rhino.<A HREF="./com/google/javascript/rhino/JSDocInfo.html" title="class in com.google.javascript.rhino">JSDocInfo</A>
 <DD>Returns whether a description exists for the parameter with the specified
  name.
+<DT><A HREF="./com/google/javascript/jscomp/testing/TestErrorReporter.html#hasEncounteredAllErrors()"><B>hasEncounteredAllErrors()</B></A> - 
+Method in class com.google.javascript.jscomp.testing.<A HREF="./com/google/javascript/jscomp/testing/TestErrorReporter.html" title="class in com.google.javascript.jscomp.testing">TestErrorReporter</A>
+<DD>Returns whether all errors were reported to this reporter.
+<DT><A HREF="./com/google/javascript/jscomp/testing/TestErrorReporter.html#hasEncounteredAllWarnings()"><B>hasEncounteredAllWarnings()</B></A> - 
+Method in class com.google.javascript.jscomp.testing.<A HREF="./com/google/javascript/jscomp/testing/TestErrorReporter.html" title="class in com.google.javascript.jscomp.testing">TestErrorReporter</A>
+<DD>Returns whether all warnings were reported to this reporter.
 <DT><A HREF="./com/google/javascript/rhino/JSDocInfo.html#hasEnumParameterType()"><B>hasEnumParameterType()</B></A> - 
 Method in class com.google.javascript.rhino.<A HREF="./com/google/javascript/rhino/JSDocInfo.html" title="class in com.google.javascript.rhino">JSDocInfo</A>
 <DD>Returns whether an enum parameter type, specified using the <code>@enum</code>
@@ -4950,7 +4965,7 @@
 <DD>&nbsp;
 <DT><A HREF="./com/google/javascript/jscomp/Compiler.html#OPTIMIZE_LOOP_ERROR"><B>OPTIMIZE_LOOP_ERROR</B></A> - 
 Static variable in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/Compiler.html" title="class in com.google.javascript.jscomp">Compiler</A>
-<DD>&nbsp;
+<DD>Error strings used for reporting JSErrors
 <DT><A HREF="./com/google/javascript/jscomp/CompilerOptions.html#optimizeArgumentsArray"><B>optimizeArgumentsArray</B></A> - 
 Variable in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/CompilerOptions.html" title="class in com.google.javascript.jscomp">CompilerOptions</A>
 <DD>Provide formal names for elements of arguments array.
@@ -5156,9 +5171,6 @@
 <DT><A HREF="./com/google/javascript/jscomp/graph/GraphReachability.html#REACHABLE"><B>REACHABLE</B></A> - 
 Static variable in class com.google.javascript.jscomp.graph.<A HREF="./com/google/javascript/jscomp/graph/GraphReachability.html" title="class in com.google.javascript.jscomp.graph">GraphReachability</A>
 <DD>&nbsp;
-<DT><A HREF="./com/google/javascript/jscomp/Compiler.html#READ_ERROR"><B>READ_ERROR</B></A> - 
-Static variable in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/Compiler.html" title="class in com.google.javascript.jscomp">Compiler</A>
-<DD>Error strings used for reporting JSErrors
 <DT><A HREF="./com/google/javascript/rhino/Kit.html#readReader(java.io.Reader)"><B>readReader(Reader)</B></A> - 
 Static method in class com.google.javascript.rhino.<A HREF="./com/google/javascript/rhino/Kit.html" title="class in com.google.javascript.rhino">Kit</A>
 <DD>&nbsp;
@@ -5514,6 +5526,9 @@
 Method in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/AbstractCompilerRunner.html" title="class in com.google.javascript.jscomp">AbstractCompilerRunner</A>
 <DD>Runs the Compiler and calls System.exit() with the exit status of the
  compiler.
+<DT><A HREF="./com/google/javascript/jscomp/testing/TestErrorReporter.html#runtimeError(java.lang.String, java.lang.String, int, java.lang.String, int)"><B>runtimeError(String, String, int, String, int)</B></A> - 
+Method in class com.google.javascript.jscomp.testing.<A HREF="./com/google/javascript/jscomp/testing/TestErrorReporter.html" title="class in com.google.javascript.jscomp.testing">TestErrorReporter</A>
+<DD>&nbsp;
 <DT><A HREF="./com/google/javascript/rhino/ErrorReporter.html#runtimeError(java.lang.String, java.lang.String, int, java.lang.String, int)"><B>runtimeError(String, String, int, String, int)</B></A> - 
 Method in interface com.google.javascript.rhino.<A HREF="./com/google/javascript/rhino/ErrorReporter.html" title="interface in com.google.javascript.rhino">ErrorReporter</A>
 <DD>Creates an EvaluatorException that may be thrown.
@@ -5921,6 +5936,9 @@
 <DT><A HREF="./com/google/javascript/rhino/jstype/SimpleSlot.html" title="class in com.google.javascript.rhino.jstype"><B>SimpleSlot</B></A> - Class in <A HREF="./com/google/javascript/rhino/jstype/package-summary.html">com.google.javascript.rhino.jstype</A><DD>The minimum implementation of StaticSlot<JSType>.<DT><A HREF="./com/google/javascript/rhino/jstype/SimpleSlot.html#SimpleSlot(java.lang.String, com.google.javascript.rhino.jstype.JSType, boolean)"><B>SimpleSlot(String, JSType, boolean)</B></A> - 
 Constructor for class com.google.javascript.rhino.jstype.<A HREF="./com/google/javascript/rhino/jstype/SimpleSlot.html" title="class in com.google.javascript.rhino.jstype">SimpleSlot</A>
 <DD>&nbsp;
+<DT><A HREF="./com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html" title="class in com.google.javascript.jscomp.testing"><B>SimpleSourceExcerptProvider</B></A> - Class in <A HREF="./com/google/javascript/jscomp/testing/package-summary.html">com.google.javascript.jscomp.testing</A><DD>A simple source excerpt provider for testing.<DT><A HREF="./com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html#SimpleSourceExcerptProvider(java.lang.String)"><B>SimpleSourceExcerptProvider(String)</B></A> - 
+Constructor for class com.google.javascript.jscomp.testing.<A HREF="./com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html" title="class in com.google.javascript.jscomp.testing">SimpleSourceExcerptProvider</A>
+<DD>&nbsp;
 <DT><A HREF="./com/google/javascript/rhino/ObjArray.html#size()"><B>size()</B></A> - 
 Method in class com.google.javascript.rhino.<A HREF="./com/google/javascript/rhino/ObjArray.html" title="class in com.google.javascript.rhino">ObjArray</A>
 <DD>&nbsp;
@@ -6065,7 +6083,11 @@
 <DT><A HREF="./com/google/javascript/rhino/Node.html#TEMP_PROP"><B>TEMP_PROP</B></A> - 
 Static variable in class com.google.javascript.rhino.<A HREF="./com/google/javascript/rhino/Node.html" title="class in com.google.javascript.rhino">Node</A>
 <DD>&nbsp;
-<DT><A HREF="./com/google/javascript/rhino/jstype/TemplateType.html" title="class in com.google.javascript.rhino.jstype"><B>TemplateType</B></A> - Class in <A HREF="./com/google/javascript/rhino/jstype/package-summary.html">com.google.javascript.rhino.jstype</A><DD>&nbsp;<DT><A HREF="./com/google/javascript/rhino/jstype/TernaryValue.html" title="enum in com.google.javascript.rhino.jstype"><B>TernaryValue</B></A> - Enum in <A HREF="./com/google/javascript/rhino/jstype/package-summary.html">com.google.javascript.rhino.jstype</A><DD>An enum for ternary logic.<DT><A HREF="./com/google/javascript/rhino/jstype/AllType.html#testForEquality(com.google.javascript.rhino.jstype.JSType)"><B>testForEquality(JSType)</B></A> - 
+<DT><A HREF="./com/google/javascript/rhino/jstype/TemplateType.html" title="class in com.google.javascript.rhino.jstype"><B>TemplateType</B></A> - Class in <A HREF="./com/google/javascript/rhino/jstype/package-summary.html">com.google.javascript.rhino.jstype</A><DD>&nbsp;<DT><A HREF="./com/google/javascript/rhino/jstype/TernaryValue.html" title="enum in com.google.javascript.rhino.jstype"><B>TernaryValue</B></A> - Enum in <A HREF="./com/google/javascript/rhino/jstype/package-summary.html">com.google.javascript.rhino.jstype</A><DD>An enum for ternary logic.<DT><A HREF="./com/google/javascript/jscomp/testing/TestErrorReporter.html" title="class in com.google.javascript.jscomp.testing"><B>TestErrorReporter</B></A> - Class in <A HREF="./com/google/javascript/jscomp/testing/package-summary.html">com.google.javascript.jscomp.testing</A><DD>An error reporter for testing that verifies that messages reported to the
+ reporter are expected.<DT><A HREF="./com/google/javascript/jscomp/testing/TestErrorReporter.html#TestErrorReporter(java.lang.String[], java.lang.String[])"><B>TestErrorReporter(String[], String[])</B></A> - 
+Constructor for class com.google.javascript.jscomp.testing.<A HREF="./com/google/javascript/jscomp/testing/TestErrorReporter.html" title="class in com.google.javascript.jscomp.testing">TestErrorReporter</A>
+<DD>&nbsp;
+<DT><A HREF="./com/google/javascript/rhino/jstype/AllType.html#testForEquality(com.google.javascript.rhino.jstype.JSType)"><B>testForEquality(JSType)</B></A> - 
 Method in class com.google.javascript.rhino.jstype.<A HREF="./com/google/javascript/rhino/jstype/AllType.html" title="class in com.google.javascript.rhino.jstype">AllType</A>
 <DD>&nbsp;
 <DT><A HREF="./com/google/javascript/rhino/jstype/BooleanType.html#testForEquality(com.google.javascript.rhino.jstype.JSType)"><B>testForEquality(JSType)</B></A> - 
@@ -6637,6 +6659,9 @@
 <DT><A HREF="./com/google/javascript/jscomp/parsing/NullErrorReporter.html#warning(java.lang.String, java.lang.String, int, java.lang.String, int)"><B>warning(String, String, int, String, int)</B></A> - 
 Method in class com.google.javascript.jscomp.parsing.<A HREF="./com/google/javascript/jscomp/parsing/NullErrorReporter.html" title="class in com.google.javascript.jscomp.parsing">NullErrorReporter</A>
 <DD>&nbsp;
+<DT><A HREF="./com/google/javascript/jscomp/testing/TestErrorReporter.html#warning(java.lang.String, java.lang.String, int, java.lang.String, int)"><B>warning(String, String, int, String, int)</B></A> - 
+Method in class com.google.javascript.jscomp.testing.<A HREF="./com/google/javascript/jscomp/testing/TestErrorReporter.html" title="class in com.google.javascript.jscomp.testing">TestErrorReporter</A>
+<DD>&nbsp;
 <DT><A HREF="./com/google/javascript/rhino/ErrorReporter.html#warning(java.lang.String, java.lang.String, int, java.lang.String, int)"><B>warning(String, String, int, String, int)</B></A> - 
 Method in interface com.google.javascript.rhino.<A HREF="./com/google/javascript/rhino/ErrorReporter.html" title="interface in com.google.javascript.rhino">ErrorReporter</A>
 <DD>Report a warning.
diff --git a/javadoc/overview-frame.html b/javadoc/overview-frame.html
index 47ce109..5b71e36 100644
--- a/javadoc/overview-frame.html
+++ b/javadoc/overview-frame.html
@@ -34,6 +34,8 @@
 <BR>
 <FONT CLASS="FrameItemFont"><A HREF="com/google/javascript/jscomp/parsing/package-frame.html" target="packageFrame">com.google.javascript.jscomp.parsing</A></FONT>
 <BR>
+<FONT CLASS="FrameItemFont"><A HREF="com/google/javascript/jscomp/testing/package-frame.html" target="packageFrame">com.google.javascript.jscomp.testing</A></FONT>
+<BR>
 <FONT CLASS="FrameItemFont"><A HREF="com/google/javascript/rhino/package-frame.html" target="packageFrame">com.google.javascript.rhino</A></FONT>
 <BR>
 <FONT CLASS="FrameItemFont"><A HREF="com/google/javascript/rhino/jstype/package-frame.html" target="packageFrame">com.google.javascript.rhino.jstype</A></FONT>
diff --git a/javadoc/overview-summary.html b/javadoc/overview-summary.html
index f7f264f..34a12cf 100644
--- a/javadoc/overview-summary.html
+++ b/javadoc/overview-summary.html
@@ -97,6 +97,10 @@
 transformations.</TD>
 </TR>
 <TR BGCOLOR="white" CLASS="TableRowColor">
+<TD WIDTH="20%"><B><A HREF="com/google/javascript/jscomp/testing/package-summary.html">com.google.javascript.jscomp.testing</A></B></TD>
+<TD>&nbsp;</TD>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
 <TD WIDTH="20%"><B><A HREF="com/google/javascript/rhino/package-summary.html">com.google.javascript.rhino</A></B></TD>
 <TD>The core parsing functionality for
 <a href="http://www.mozilla.org/rhino/">Rhino</a> but with the support for
diff --git a/javadoc/overview-tree.html b/javadoc/overview-tree.html
index 6b02af7..0534e54 100644
--- a/javadoc/overview-tree.html
+++ b/javadoc/overview-tree.html
@@ -81,7 +81,7 @@
 Hierarchy For All Packages</H2>
 </CENTER>
 <DL>
-<DT><B>Package Hierarchies:</B><DD><A HREF="com/google/javascript/jscomp/package-tree.html">com.google.javascript.jscomp</A>, <A HREF="com/google/javascript/jscomp/graph/package-tree.html">com.google.javascript.jscomp.graph</A>, <A HREF="com/google/javascript/jscomp/parsing/package-tree.html">com.google.javascript.jscomp.parsing</A>, <A HREF="com/google/javascript/rhino/package-tree.html">com.google.javascript.rhino</A>, <A HREF="com/google/javascript/rhino/jstype/package-tree.html">com.google.javascript.rhino.jstype</A></DL>
+<DT><B>Package Hierarchies:</B><DD><A HREF="com/google/javascript/jscomp/package-tree.html">com.google.javascript.jscomp</A>, <A HREF="com/google/javascript/jscomp/graph/package-tree.html">com.google.javascript.jscomp.graph</A>, <A HREF="com/google/javascript/jscomp/parsing/package-tree.html">com.google.javascript.jscomp.parsing</A>, <A HREF="com/google/javascript/jscomp/testing/package-tree.html">com.google.javascript.jscomp.testing</A>, <A HREF="com/google/javascript/rhino/package-tree.html">com.google.javascript.rhino</A>, <A HREF="com/google/javascript/rhino/jstype/package-tree.html">com.google.javascript.rhino.jstype</A></DL>
 <HR>
 <H2>
 Class Hierarchy
@@ -96,6 +96,9 @@
 <LI TYPE="circle">com.google.javascript.jscomp.<A HREF="com/google/javascript/jscomp/AbstractMessageFormatter.html" title="class in com.google.javascript.jscomp"><B>AbstractMessageFormatter</B></A> (implements com.google.javascript.jscomp.<A HREF="com/google/javascript/jscomp/MessageFormatter.html" title="interface in com.google.javascript.jscomp">MessageFormatter</A>)
 <UL>
 <LI TYPE="circle">com.google.javascript.jscomp.<A HREF="com/google/javascript/jscomp/LightweightMessageFormatter.html" title="class in com.google.javascript.jscomp"><B>LightweightMessageFormatter</B></A></UL>
+<LI TYPE="circle">junit.framework.Assert<UL>
+<LI TYPE="circle">com.google.javascript.jscomp.testing.<A HREF="com/google/javascript/jscomp/testing/TestErrorReporter.html" title="class in com.google.javascript.jscomp.testing"><B>TestErrorReporter</B></A> (implements com.google.javascript.jscomp.mozilla.rhino.ErrorReporter)
+</UL>
 <LI TYPE="circle">com.google.javascript.jscomp.<A HREF="com/google/javascript/jscomp/BasicErrorManager.html" title="class in com.google.javascript.jscomp"><B>BasicErrorManager</B></A> (implements com.google.javascript.jscomp.<A HREF="com/google/javascript/jscomp/ErrorManager.html" title="interface in com.google.javascript.jscomp">ErrorManager</A>)
 <UL>
 <LI TYPE="circle">com.google.javascript.jscomp.<A HREF="com/google/javascript/jscomp/LoggerErrorManager.html" title="class in com.google.javascript.jscomp"><B>LoggerErrorManager</B></A><LI TYPE="circle">com.google.javascript.jscomp.<A HREF="com/google/javascript/jscomp/PrintStreamErrorManager.html" title="class in com.google.javascript.jscomp"><B>PrintStreamErrorManager</B></A></UL>
@@ -156,6 +159,7 @@
 <LI TYPE="circle">com.google.javascript.rhino.<A HREF="com/google/javascript/rhino/ScriptRuntime.html" title="class in com.google.javascript.rhino"><B>ScriptRuntime</B></A><LI TYPE="circle">com.google.javascript.rhino.<A HREF="com/google/javascript/rhino/SimpleErrorReporter.html" title="class in com.google.javascript.rhino"><B>SimpleErrorReporter</B></A> (implements com.google.javascript.rhino.<A HREF="com/google/javascript/rhino/ErrorReporter.html" title="interface in com.google.javascript.rhino">ErrorReporter</A>)
 <LI TYPE="circle">com.google.javascript.jscomp.<A HREF="com/google/javascript/jscomp/SimpleRegion.html" title="class in com.google.javascript.jscomp"><B>SimpleRegion</B></A> (implements com.google.javascript.jscomp.<A HREF="com/google/javascript/jscomp/Region.html" title="interface in com.google.javascript.jscomp">Region</A>)
 <LI TYPE="circle">com.google.javascript.rhino.jstype.<A HREF="com/google/javascript/rhino/jstype/SimpleSlot.html" title="class in com.google.javascript.rhino.jstype"><B>SimpleSlot</B></A> (implements com.google.javascript.rhino.jstype.<A HREF="com/google/javascript/rhino/jstype/StaticSlot.html" title="interface in com.google.javascript.rhino.jstype">StaticSlot</A>&lt;T&gt;)
+<LI TYPE="circle">com.google.javascript.jscomp.testing.<A HREF="com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.html" title="class in com.google.javascript.jscomp.testing"><B>SimpleSourceExcerptProvider</B></A> (implements com.google.javascript.jscomp.<A HREF="com/google/javascript/jscomp/SourceExcerptProvider.html" title="interface in com.google.javascript.jscomp">SourceExcerptProvider</A>)
 <LI TYPE="circle">com.google.javascript.jscomp.<A HREF="com/google/javascript/jscomp/SourceFile.html" title="class in com.google.javascript.jscomp"><B>SourceFile</B></A><UL>
 <LI TYPE="circle">com.google.javascript.jscomp.<A HREF="com/google/javascript/jscomp/JSSourceFile.html" title="class in com.google.javascript.jscomp"><B>JSSourceFile</B></A></UL>
 <LI TYPE="circle">com.google.javascript.jscomp.<A HREF="com/google/javascript/jscomp/SourceMap.html" title="class in com.google.javascript.jscomp"><B>SourceMap</B></A><LI TYPE="circle">com.google.javascript.rhino.<A HREF="com/google/javascript/rhino/SourcePosition.html" title="class in com.google.javascript.rhino"><B>SourcePosition</B></A>&lt;T&gt;<UL>
diff --git a/javadoc/package-list b/javadoc/package-list
index 15ca231..b0a2faf 100644
--- a/javadoc/package-list
+++ b/javadoc/package-list
@@ -1,5 +1,6 @@
 com.google.javascript.jscomp
 com.google.javascript.jscomp.graph
 com.google.javascript.jscomp.parsing
+com.google.javascript.jscomp.testing
 com.google.javascript.rhino
 com.google.javascript.rhino.jstype
diff --git a/javadoc/serialized-form.html b/javadoc/serialized-form.html
index 357686e..17b3636 100644
--- a/javadoc/serialized-form.html
+++ b/javadoc/serialized-form.html
@@ -170,15 +170,6 @@
 </DL>
 <HR>
 <H3>
-functionNames</H3>
-<PRE>
-com.google.javascript.jscomp.FunctionNames <B>functionNames</B></PRE>
-<DL>
-<DL>
-</DL>
-</DL>
-<HR>
-<H3>
 passConfigState</H3>
 <PRE>
 com.google.javascript.jscomp.PassConfig.State <B>passConfigState</B></PRE>
diff --git a/lib/google_common_deploy.jar b/lib/google_common_deploy.jar
index d8624f7..397bccc 100755
--- a/lib/google_common_deploy.jar
+++ b/lib/google_common_deploy.jar
Binary files differ
diff --git a/lib/libtrunk_rhino_parser_jarjared.jar b/lib/libtrunk_rhino_parser_jarjared.jar
index 98a7736..7be9bfe 100644
--- a/lib/libtrunk_rhino_parser_jarjared.jar
+++ b/lib/libtrunk_rhino_parser_jarjared.jar
Binary files differ
diff --git a/src/com/google/javascript/jscomp/AbstractCompiler.java b/src/com/google/javascript/jscomp/AbstractCompiler.java
index 44846ec..2c9881d 100644
--- a/src/com/google/javascript/jscomp/AbstractCompiler.java
+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java
@@ -31,6 +31,9 @@
 *
  */
 public abstract class AbstractCompiler implements SourceExcerptProvider {
+  static final DiagnosticType READ_ERROR = DiagnosticType.error(
+      "JSC_READ_ERROR", "Cannot read: {0}");
+
   // TODO(nicksantos): Decide if all of these are really necessary.
   // Many of them are just accessors that should be passed to the
   // CompilerPass's constructor.
@@ -202,4 +205,16 @@
    * Gets the error manager.
    */
   abstract public ErrorManager getErrorManager();
+
+  /**
+   * Set if the normalization pass has been done.
+   * Note: non-private to enable test cases that require the Normalize pass.
+   */
+  abstract void setNormalized();
+
+  /**
+   * Set once unnormalizing passes have been start.
+   * Note: non-private to enable test cases that require the Normalize pass.
+   */
+  abstract void setUnnormalized();
 }
diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java
index 2980574..040bbf1 100644
--- a/src/com/google/javascript/jscomp/Compiler.java
+++ b/src/com/google/javascript/jscomp/Compiler.java
@@ -29,11 +29,9 @@
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.jstype.JSTypeRegistry;
 
-import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.io.Serializable;
-import java.text.ParseException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -90,15 +88,6 @@
 
   private Map<String, CompilerInput> inputsByName_;
 
-  /** Fully qualified function names and globally unique ids */
-  private FunctionNames functionNames_;
-
-  /** The variable renaming map */
-  private VariableMap variableMap_;
-
-  /** The property renaming map */
-  private VariableMap propertyMap_;
-
   /** The source code map */
   private SourceMap sourceMap_;
 
@@ -120,9 +109,6 @@
   /** Whether to use threads. */
   private boolean useThreads = true;
 
-  /** The naming map for anonymous functions */
-  private VariableMap anonFunctionNameMap_;
-
   /** The function information map */
   private FunctionInformationMap functionInformationMap_;
 
@@ -148,20 +134,12 @@
       RhinoErrorReporter.forNewRhino(this);
 
   /** Error strings used for reporting JSErrors */
-  public static final DiagnosticType READ_ERROR = DiagnosticType.error(
-      "JSC_READ_ERROR", "Cannot read: {0}");
   public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(
       "JSC_OPTIMIZE_LOOP_ERROR",
       "Exceeded max number of optimization iterations: {0}");
   public static final DiagnosticType MOTION_ITERATIONS_ERROR =
       DiagnosticType.error("JSC_OPTIMIZE_LOOP_ERROR",
           "Exceeded max number of code motion iterations: {0}");
-  private static final DiagnosticType INPUT_MAP_PROP_PARSE =
-      DiagnosticType.error("JSC_INPUT_MAP_PROP_PARSE",
-          "Input property map parse error: {0}");
-  private static final DiagnosticType INPUT_VAR_PROP_PARSE =
-      DiagnosticType.error("JSC_INPUT_MAP_VAR_PARSE",
-          "Input variable map parse error: {0}");
 
   private static final long COMPILER_STACK_SIZE = 1048576L;
 
@@ -528,7 +506,8 @@
     }
 
     if (options_.nameAnonymousFunctionsOnly) {
-      nameAnonymousFunctions(options_.anonymousFunctionNaming);
+      // TODO(nicksantos): Move this into an instrument() phase maybe?
+      check();
       return;
     }
 
@@ -614,9 +593,9 @@
       return;
     }
 
-    if (options_.instrumentationTemplate != null ||
-        options_.recordFunctionInformation) {
-      computeFunctionNames();
+    // TODO(nicksantos): clean this up. The flow here is too hard to follow.
+    if (options_.nameAnonymousFunctionsOnly) {
+      return;
     }
 
     if (options_.removeTryCatchFinally) {
@@ -702,34 +681,6 @@
   }
 
   /**
-   * Alias string literals with global variables, to avoid creating lots of
-   * transient objects.
-   */
-  private void aliasStrings(Set<String> aliasableStrings,
-                            boolean aliasAllStrings,
-                            String aliasStringsBlacklist,
-                            boolean outputStringUsage) {
-    logger_.info("Aliasing strings");
-    startPass("aliasStrings");
-    AliasStrings aliasStrings = new AliasStrings(
-        this,
-        getModuleGraph(),
-        aliasAllStrings ? null : aliasableStrings,
-        aliasStringsBlacklist,
-        outputStringUsage);
-    process(aliasStrings);
-    endPass();
-  }
-
-  private void aliasKeywords() {
-    logger_.info("Aliasing true/false/null");
-    startPass("aliasKeywords");
-    AliasKeywords aliasKeywords = new AliasKeywords(this);
-    process(aliasKeywords);
-    endPass();
-  }
-
-  /**
    * Runs custom passes that are designated to run at a particular time.
    */
   private void runCustomPasses(CustomPassExecutionTime executionTime) {
@@ -794,10 +745,11 @@
    * Returns the result of the compilation.
    */
   public Result getResult() {
+    PassConfig.State state = getPassConfig().getIntermediateState();
     return new Result(getErrors(), getWarnings(), debugLog_.toString(),
-                      variableMap_, propertyMap_, anonFunctionNameMap_,
-                      functionInformationMap_, sourceMap_, externExports_,
-                      getPassConfig().getCssNames());
+        state.variableMap, state.propertyMap,
+        state.anonymousFunctionNameMap, functionInformationMap_,
+        sourceMap_, externExports_, state.cssNames);
   }
 
   /**
@@ -857,6 +809,7 @@
    * Set if the normalization pass has been done.
    * Note: non-private to enable test cases that require the Normalize pass.
    */
+  @Override
   void setNormalized() {
     normalized = true;
   }
@@ -865,6 +818,7 @@
    * Set once unnormalizing passes have been start.
    * Note: non-private to enable test cases that require the Normalize pass.
    */
+  @Override
   void setUnnormalized() {
     normalized = false;
   }
@@ -1307,160 +1261,6 @@
     if (hasErrors()) {
       return;
     }
-
-    if (options_.flowSensitiveInlineVariables) {
-      flowSensitiveInlineVariables();
-    }
-
-    if (options_.collapseAnonymousFunctions) {
-      collapseAnonymousFunctions();
-    }
-
-    // Move functions before extracting prototype member declarations.
-    if (options_.moveFunctionDeclarations) {
-      moveFunctionDeclarations();
-    }
-
-    if (options_.anonymousFunctionNaming ==
-        AnonymousFunctionNamingPolicy.MAPPED) {
-      nameAnonymousFunctions(AnonymousFunctionNamingPolicy.MAPPED);
-    }
-
-    // The mapped name anonymous function pass makes use of information that
-    // the extract prototype member declarations pass removes so the former
-    // happens before the latter.
-    //
-    // Extracting prototype properties screws up the heuristic renaming
-    // policies, so never run it when those policies are requested.
-    if (options_.extractPrototypeMemberDeclarations &&
-        (options_.propertyRenaming != PropertyRenamingPolicy.HEURISTIC &&
-         options_.propertyRenaming !=
-            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC)) {
-      extractPrototypeMemberDeclarations();
-    }
-
-    if (options_.coalesceVariableNames) {
-      coalesceVariableNames();
-    }
-
-    VariableMap prevPropertyMap = null;
-    if (options_.inputPropertyMapSerialized != null) {
-      try {
-        prevPropertyMap =
-            VariableMap.fromBytes(options_.inputPropertyMapSerialized);
-      } catch (ParseException e) {
-        report(JSError.make(INPUT_MAP_PROP_PARSE, e.getMessage()));
-      }
-    }
-
-    if (options_.ambiguateProperties && (options_.propertyRenaming
-        == PropertyRenamingPolicy.ALL_UNQUOTED)) {
-      ambiguateProperties(options_.anonymousFunctionNaming
-          .getReservedCharacters());
-    }
-
-    switch (options_.propertyRenaming) {
-      case HEURISTIC:
-        renamePrototypes(false,
-            options_.anonymousFunctionNaming,
-            prevPropertyMap);
-        break;
-      case AGGRESSIVE_HEURISTIC:
-        renamePrototypes(true,
-            options_.anonymousFunctionNaming,
-            prevPropertyMap);
-        break;
-      case ALL_UNQUOTED:
-        renameProperties(options_.generatePseudoNames,
-            options_.anonymousFunctionNaming,
-            prevPropertyMap);
-        break;
-    }
-
-    // This comes after property renaming because quoted property names must
-    // not be renamed.
-    if (options_.convertToDottedProperties) {
-      convertToDottedProperties();
-    }
-
-    // Property renaming must happen before this pass runs since this
-    // pass may convert dotted properties into quoted properties.  It
-    // is beneficial to run before alias strings, alias keywords and
-    // variable renaming.
-    if (options_.rewriteFunctionExpressions) {
-      rewriteFunctionExpressions();
-    }
-
-    // This comes after converting quoted property accesses to dotted property
-    // accesses in order to avoid aliasing property names.
-    if (!options_.aliasableStrings.isEmpty() || options_.aliasAllStrings) {
-      aliasStrings(options_.aliasableStrings,
-                   options_.aliasAllStrings,
-                   options_.aliasStringsBlacklist,
-                   options_.outputJsStringUsage);
-    }
-
-    if (options_.aliasExternals) {
-      aliasExternals();
-    }
-
-    if (options_.aliasKeywords) {
-      aliasKeywords();
-    }
-
-    if (options_.collapseVariableDeclarations) {
-      collapseVariableDeclarations();
-    }
-
-    denormalize();
-
-    if (options_.instrumentationTemplate != null) {
-      instrumentFunctions();
-    }
-
-    if (options_.variableRenaming != VariableRenamingPolicy.ALL) {
-      // If we're leaving some (or all) variables with their old names,
-      // then we need to undo any of the markers we added for distinguishing
-      // local variables ("$$1") or constants ("$$constant").
-      invertContextualRenaming();
-    }
-
-    if (options_.variableRenaming != VariableRenamingPolicy.OFF) {
-      VariableMap prevVariableMap = null;
-      if (options_.inputVariableMapSerialized != null) {
-        try {
-          prevVariableMap =
-              VariableMap.fromBytes(options_.inputVariableMapSerialized);
-        } catch (ParseException e) {
-          report(JSError.make(INPUT_VAR_PROP_PARSE, e.getMessage()));
-        }
-      }
-
-      renameVars(options_.renamePrefix,
-          options_.variableRenaming == VariableRenamingPolicy.LOCAL,
-          options_.anonymousFunctionNaming,
-          options_.generatePseudoNames,
-          prevVariableMap);
-    }
-
-    // This pass should run after names stop changing.
-    if (options_.processObjectPropertyString) {
-      objectPropertyStringPostprocess();
-    }
-
-    if (options_.labelRenaming) {
-      renameLabels();
-    }
-
-    if (options_.anonymousFunctionNaming ==
-        AnonymousFunctionNamingPolicy.UNMAPPED) {
-      nameAnonymousFunctions(AnonymousFunctionNamingPolicy.UNMAPPED);
-    }
-
-    // Safety check
-    if (options_.checkSymbols) {
-      sanityCheckVars();
-    }
   }
 
   @Override
@@ -1473,16 +1273,6 @@
     return options_.cssRenamingMap;
   }
 
-
-  /** Checks that all variables are defined. */
-  void sanityCheckVars() {
-    logger_.info("Checking for undefined vars");
-    startPass("sanityCheckVars");
-    VarCheck v = new VarCheck(this, true);
-    process(v);
-    endPass();
-  }
-
   /**
    * Reprocesses the current defines over the AST.  This is used by GwtCompiler
    * to generate N outputs for different targets from the same (checked) AST.
@@ -1495,66 +1285,6 @@
         .process(externsRoot, jsRoot);
   }
 
-  void computeFunctionNames() {
-    logger_.info("Computing fully-qualified function names and ids");
-    startPass("computeFunctionNames");
-    functionNames_ = new FunctionNames(this);
-    process(functionNames_);
-    endPass();
-  }
-
-  void flowSensitiveInlineVariables() {
-    logger_.info("Flow Sensitive Inline Variables");
-    startPass("flowSensitiveInlineVariables");
-    process(new FlowSensitiveInlineVariables(this));
-    endPass();
-  }
-
-  void coalesceVariableNames() {
-    logger_.info("Coalesce Variable Names");
-    startPass("coalesceVariableNames");
-    process(new CoalesceVariableNames(this));
-    endPass();
-  }
-
-  void collapseVariableDeclarations() {
-    logger_.info("Collapsing variable declarations");
-    startPass("collapseVariableDeclarations");
-    process(new CollapseVariableDeclarations(this));
-    setUnnormalized();
-    endPass();
-  }
-
-  void extractPrototypeMemberDeclarations() {
-    logger_.info("Extracting Common Prototype Member Declarations");
-    startPass("extractPrototypeMemberDeclarations");
-    process(new ExtractPrototypeMemberDeclarations(this));
-    endPass();
-  }
-
-  void rewriteFunctionExpressions() {
-    logger_.info("Rewrite function expressions");
-    startPass("rewriteFunctionExpressions");
-    process(new FunctionRewriter(this));
-    endPass();
-  }
-
-  void collapseAnonymousFunctions() {
-    logger_.info("Collapsing anonymous functions");
-    startPass("collapseAnonymousFunctions");
-    process(new CollapseAnonymousFunctions(this));
-    endPass();
-  }
-
-
-
-  void moveFunctionDeclarations() {
-    logger_.info("Move function declarations");
-    startPass("moveFunctionDeclarations");
-    process(new MoveFunctionDeclarations(this));
-    endPass();
-  }
-
   boolean isInliningForbidden() {
     return options_.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||
         options_.propertyRenaming ==
@@ -1571,44 +1301,6 @@
     return cfa.getCfg();
   }
 
-  void nameAnonymousFunctions(AnonymousFunctionNamingPolicy policy) {
-    logger_.info("Naming anonymous functions");
-    startPass("nameAnonymousFunctions");
-    if (policy == AnonymousFunctionNamingPolicy.UNMAPPED) {
-      process(new NameAnonymousFunctions(this));
-    } else if (policy == AnonymousFunctionNamingPolicy.MAPPED) {
-      NameAnonymousFunctionsMapped naf = new NameAnonymousFunctionsMapped(this);
-      process(naf);
-      anonFunctionNameMap_ = naf.getFunctionMap();
-    }
-    endPass();
-  }
-
-  void aliasExternals() {
-    logger_.info("Creating alias functions for externals");
-    startPass("aliasExternals");
-    AliasExternals ae = new AliasExternals(this,
-                                           getModuleGraph(),
-                                           options_.unaliasableGlobals,
-                                           options_.aliasableGlobals);
-    process(ae);
-    endPass();
-  }
-
-  void objectPropertyStringPostprocess() {
-    logger_.info("goog.testing.ObjectPropertyString postprocess");
-    startPass("ObjectPropertyStringPostprocess");
-    process(new ObjectPropertyStringPostprocess(this));
-    endPass();
-  }
-
-  void ambiguateProperties(char[] reservedCharacters) {
-    logger_.info("Ambiguating properties");
-    startPass("ambiguateProperties");
-    process(new AmbiguateProperties(this, reservedCharacters));
-    endPass();
-  }
-
   public void normalize() {
     logger_.info("Normalizing");
     startPass("normalize");
@@ -1617,14 +1309,6 @@
     endPass();
   }
 
-  private void denormalize() {
-    logger_.info("Denormalizing");
-    startPass("denormalize");
-    process(new Denormalize(this));
-    setUnnormalized();
-    endPass();
-  }
-
   @Override
   void normalizeNodeTypes(Node root) {
     Tracer tracer = newTracer("normalizeNodeTypes");
@@ -1647,97 +1331,12 @@
     stopTracer(tracer, "annotateCodingConvention");
   }
 
-  void renameVars(String renamePrefix, boolean renameLocalVarsOnly,
-      AnonymousFunctionNamingPolicy anonFunctionNamePolicy,
-      boolean generatePseudoNames,
-      VariableMap prevVariableMap) {
-    logger_.info("Renaming vars");
-    startPass("renameVars");
-    boolean preserveAnonymousFunctionNames =
-      anonFunctionNamePolicy != AnonymousFunctionNamingPolicy.OFF;
-    RenameVars rn = new RenameVars(
-        this, renamePrefix,
-        renameLocalVarsOnly, preserveAnonymousFunctionNames,
-        generatePseudoNames,
-        prevVariableMap,
-        anonFunctionNamePolicy.getReservedCharacters(),
-        getPassConfig().getExportedNames());
-    process(rn);
-    variableMap_ = rn.getVariableMap();
-    endPass();
-  }
-
-  void renameProperties(boolean generatePseudoNames,
-      AnonymousFunctionNamingPolicy anonFunctionNamePolicy,
-      VariableMap prevPropertyMap) {
-    logger_.info("Renaming properties");
-    startPass("renameProperties");
-    RenameProperties rp = new RenameProperties(
-        this, generatePseudoNames, prevPropertyMap,
-        anonFunctionNamePolicy.getReservedCharacters());
-    process(rp);
-    propertyMap_ = rp.getPropertyMap();
-    endPass();
-  }
-
-  void invertContextualRenaming() {
-    logger_.info("Denormalizing local names");
-    startPass("invertNames");
-    process(MakeDeclaredNamesUnique.getContextualRenameInverter(this));
-    endPass();
-  }
-
-  void renamePrototypes(boolean aggressive,
-      AnonymousFunctionNamingPolicy anonFunctionNamePolicy,
-      VariableMap prevPropertyMap) {
-    logger_.info("Renaming prototypes");
-    startPass("renamePrototypes");
-    RenamePrototypes rp = new RenamePrototypes(this, aggressive,
-        anonFunctionNamePolicy.getReservedCharacters(),
-        prevPropertyMap);
-    process(rp);
-    propertyMap_ = rp.getPropertyMap();
-    endPass();
-  }
-
-  void renameLabels() {
-    logger_.info("Renaming labels");
-    startPass("renameLabels");
-    RenameLabels rn = new RenameLabels(this);
-    process(rn);
-    endPass();
-  }
-
-  void convertToDottedProperties() {
-    logger_.info("Converting quoted property accesses to dot syntax");
-    startPass("convertToDottedProperties");
-    process(new ConvertToDottedProperties(this));
-    endPass();
-  }
-
-  void instrumentFunctions() {
-    logger_.info("Instrumenting functions");
-    startPass("instrumentFunctions");
-    try {
-      FileReader templateFile =
-          new FileReader(options_.instrumentationTemplate);
-
-      process(new InstrumentFunctions(this,
-                                      functionNames_,
-                                      options_.instrumentationTemplate,
-                                      options_.appNameStr,
-                                      templateFile));
-    } catch (IOException e) {
-      report(JSError.make(READ_ERROR, options_.instrumentationTemplate));
-    }
-    endPass();
-  }
-
   void recordFunctionInformation() {
     logger_.info("Recording function information");
     startPass("recordFunctionInformation");
     RecordFunctionInformation recordFunctionInfoPass =
-        new RecordFunctionInformation(this, functionNames_);
+        new RecordFunctionInformation(
+            this, getPassConfig().getIntermediateState().functionNames);
     process(recordFunctionInfoPass);
     functionInformationMap_ = recordFunctionInfoPass.getMap();
     endPass();
@@ -1926,11 +1525,11 @@
   }
 
   VariableMap getVariableMap() {
-    return variableMap_;
+    return getPassConfig().getIntermediateState().variableMap;
   }
 
   VariableMap getPropertyMap() {
-    return propertyMap_;
+    return getPassConfig().getIntermediateState().propertyMap;
   }
 
   CompilerOptions getOptions() {
@@ -1983,7 +1582,6 @@
     private CompilerInput[] externs;
     private CompilerInput[] inputs;
     private JSModule[] modules;
-    private FunctionNames functionNames;
     private PassConfig.State passConfigState;
     private JSTypeRegistry typeRegistry;
     private boolean normalized;
@@ -2001,7 +1599,6 @@
     state.externs = externs_;
     state.inputs = inputs_;
     state.modules = modules_;
-    state.functionNames = functionNames_;
     state.passConfigState = getPassConfig().getIntermediateState();
     state.typeRegistry = typeRegistry;
     state.normalized = normalized;
@@ -2019,7 +1616,6 @@
     externs_ = state.externs;
     inputs_ = state.inputs;
     modules_ = state.modules;
-    functionNames_ = state.functionNames;
     passes = createPassConfigInternal();
     getPassConfig().setIntermediateState(state.passConfigState);
     typeRegistry = state.typeRegistry;
diff --git a/src/com/google/javascript/jscomp/ControlStructureCheck.java b/src/com/google/javascript/jscomp/ControlStructureCheck.java
index 5c2c276..a2984f1 100644
--- a/src/com/google/javascript/jscomp/ControlStructureCheck.java
+++ b/src/com/google/javascript/jscomp/ControlStructureCheck.java
@@ -16,6 +16,7 @@
 
 package com.google.javascript.jscomp;
 
+import com.google.javascript.rhino.JSDocInfo;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 
@@ -48,6 +49,10 @@
       "JSC_INVALID_LABEL_CONTINUE",
       "continue can only target labels of loop structures");
 
+  static final DiagnosticType USE_OF_WITH = DiagnosticType.warning(
+      "JSC_USE_OF_WITH",
+      "The use of the 'with' structure should be avoided.");
+
   ControlStructureCheck(AbstractCompiler compiler) {
     this.compiler = compiler;
   }
@@ -79,6 +84,15 @@
    */
   private void check(Node node, boolean inLoop, boolean inSwitch) {
     switch (node.getType()) {
+      case Token.WITH:
+        JSDocInfo info = node.getJSDocInfo();
+        boolean allowWith =
+            info != null && info.getSuppressions().contains("with");
+        if (!allowWith) {
+          report(node, USE_OF_WITH);
+        }
+        break;
+
       case Token.FUNCTION:
         // Save the old labels because we are in a new scope.
         Deque<String> oldSwitchLabels = switchLabels;
diff --git a/src/com/google/javascript/jscomp/DefaultPassConfig.java b/src/com/google/javascript/jscomp/DefaultPassConfig.java
index 2f3afb4..ac82dcd 100644
--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java
+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java
@@ -21,6 +21,7 @@
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
 import com.google.common.io.Files;
 import com.google.javascript.jscomp.CheckLevel;
 import com.google.javascript.jscomp.NodeTraversal.Callback;
@@ -28,10 +29,14 @@
 import com.google.javascript.rhino.Token;
 
 import java.io.File;
+import java.io.FileReader;
 import java.io.IOException;
+import java.text.ParseException;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 /**
  * Pass factories and meta-data for native JSCompiler passes.
@@ -64,6 +69,14 @@
       DiagnosticType.error("JSC_REPORT_PATH_IO_ERROR",
           "Error writing compiler report to {0}");
 
+  private static final DiagnosticType INPUT_MAP_PROP_PARSE =
+      DiagnosticType.error("JSC_INPUT_MAP_PROP_PARSE",
+          "Input property map parse error: {0}");
+
+  private static final DiagnosticType INPUT_MAP_VAR_PARSE =
+      DiagnosticType.error("JSC_INPUT_MAP_VAR_PARSE",
+          "Input variable map parse error: {0}");
+
   /**
    * A global namespace to share across checking passes.
    * TODO(nicksantos): This is a hack until I can get the namespace into
@@ -76,14 +89,76 @@
    */
   private TightenTypes tightenTypes = null;
 
+  /** Names exported by goog.exportSymbol. */
+  private Set<String> exportedNames = null;
+
+  /**
+   * Ids for cross-module method stubbing, so that each method has
+   * a unique id.
+   */
+  private CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator =
+      new CrossModuleMethodMotion.IdGenerator();
+
+  /**
+   * Keys are arguments passed to getCssName() found during compilation; values
+   * are the number of times the key appeared as an argument to getCssName().
+   */
+  private Map<String, Integer> cssNames = null;
+
+  /** The variable renaming map */
+  private VariableMap variableMap = null;
+
+  /** The property renaming map */
+  private VariableMap propertyMap = null;
+
+  /** The naming map for anonymous functions */
+  private VariableMap anonymousFunctionNameMap = null;
+
+  /** Fully qualified function names and globally unique ids */
+  private FunctionNames functionNames = null;
+
   public DefaultPassConfig(CompilerOptions options) {
     super(options);
   }
 
   @Override
+  State getIntermediateState() {
+    return new State(
+        cssNames == null ? null : Maps.newHashMap(cssNames),
+        exportedNames == null ? null :
+            Collections.unmodifiableSet(exportedNames),
+        crossModuleIdGenerator, variableMap, propertyMap,
+        anonymousFunctionNameMap, functionNames);
+  }
+
+  @Override
+  void setIntermediateState(State state) {
+    this.cssNames = state.cssNames == null ? null :
+        Maps.newHashMap(state.cssNames);
+    this.exportedNames = state.exportedNames == null ? null :
+        Sets.newHashSet(state.exportedNames);
+    this.crossModuleIdGenerator = state.crossModuleIdGenerator;
+    this.variableMap = state.variableMap;
+    this.propertyMap = state.propertyMap;
+    this.anonymousFunctionNameMap = state.anonymousFunctionNameMap;
+    this.functionNames = state.functionNames;
+  }
+
+  @Override
   protected List<PassFactory> getChecks() {
     List<PassFactory> checks = Lists.newArrayList();
 
+    if (options.nameAnonymousFunctionsOnly) {
+      if (options.anonymousFunctionNaming ==
+          AnonymousFunctionNamingPolicy.MAPPED) {
+        checks.add(nameMappedAnonymousFunctions);
+      } else if (options.anonymousFunctionNaming ==
+          AnonymousFunctionNamingPolicy.UNMAPPED) {
+        checks.add(nameUnmappedAnonymousFunctions);
+      }
+      return checks;
+    }
+
     if (options.checkSuspiciousCode) {
       checks.add(suspiciousCode);
     }
@@ -198,6 +273,12 @@
 
     // Defines in code always need to be processed.
     checks.add(processDefines);
+
+    if (options.instrumentationTemplate != null ||
+        options.recordFunctionInformation) {
+      checks.add(computeFunctionNames);
+    }
+
     assertAllOneTimePasses(checks);
     return checks;
   }
@@ -318,6 +399,119 @@
           CustomPassExecutionTime.AFTER_OPTIMIZATION_LOOP));
     }
 
+    if (options.flowSensitiveInlineVariables) {
+      passes.add(flowSensitiveInlineVariables);
+    }
+
+    if (options.collapseAnonymousFunctions) {
+      passes.add(collapseAnonymousFunctions);
+    }
+
+    // Move functions before extracting prototype member declarations.
+    if (options.moveFunctionDeclarations) {
+      passes.add(moveFunctionDeclarations);
+    }
+
+    if (options.anonymousFunctionNaming ==
+        AnonymousFunctionNamingPolicy.MAPPED) {
+      passes.add(nameMappedAnonymousFunctions);
+    }
+
+    // The mapped name anonymous function pass makes use of information that
+    // the extract prototype member declarations pass removes so the former
+    // happens before the latter.
+    //
+    // Extracting prototype properties screws up the heuristic renaming
+    // policies, so never run it when those policies are requested.
+    if (options.extractPrototypeMemberDeclarations &&
+        (options.propertyRenaming != PropertyRenamingPolicy.HEURISTIC &&
+         options.propertyRenaming !=
+            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC)) {
+      passes.add(extractPrototypeMemberDeclarations);
+    }
+
+    if (options.coalesceVariableNames) {
+      passes.add(coalesceVariableNames);
+    }
+
+    if (options.ambiguateProperties &&
+        (options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED)) {
+      passes.add(ambiguateProperties);
+    }
+
+    if (options.propertyRenaming != PropertyRenamingPolicy.OFF) {
+      passes.add(renameProperties);
+    }
+
+    // This comes after property renaming because quoted property names must
+    // not be renamed.
+    if (options.convertToDottedProperties) {
+      passes.add(convertToDottedProperties);
+    }
+
+    // Property renaming must happen before this pass runs since this
+    // pass may convert dotted properties into quoted properties.  It
+    // is beneficial to run before alias strings, alias keywords and
+    // variable renaming.
+    if (options.rewriteFunctionExpressions) {
+      passes.add(rewriteFunctionExpressions);
+    }
+
+    // This comes after converting quoted property accesses to dotted property
+    // accesses in order to avoid aliasing property names.
+    if (!options.aliasableStrings.isEmpty() || options.aliasAllStrings) {
+      passes.add(aliasStrings);
+    }
+
+    if (options.aliasExternals) {
+      passes.add(aliasExternals);
+    }
+
+    if (options.aliasKeywords) {
+      passes.add(aliasKeywords);
+    }
+
+    if (options.collapseVariableDeclarations) {
+      passes.add(collapseVariableDeclarations);
+    }
+
+    passes.add(denormalize);
+
+    if (options.instrumentationTemplate != null) {
+      passes.add(instrumentFunctions);
+    }
+
+    if (options.variableRenaming != VariableRenamingPolicy.ALL) {
+      // If we're leaving some (or all) variables with their old names,
+      // then we need to undo any of the markers we added for distinguishing
+      // local variables ("$$1") or constants ("$$constant").
+      passes.add(invertContextualRenaming);
+    }
+
+
+    if (options.variableRenaming != VariableRenamingPolicy.OFF) {
+      passes.add(renameVars);
+    }
+
+    // This pass should run after names stop changing.
+    if (options.processObjectPropertyString) {
+      passes.add(objectPropertyStringPostprocess);
+    }
+
+    if (options.labelRenaming) {
+      passes.add(renameLabels);
+    }
+
+    if (options.anonymousFunctionNaming ==
+        AnonymousFunctionNamingPolicy.UNMAPPED) {
+      passes.add(nameUnmappedAnonymousFunctions);
+    }
+
+    // Safety check
+    if (options.checkSymbols) {
+      passes.add(sanityCheckVars);
+    }
+
     return passes;
   }
 
@@ -492,7 +686,7 @@
         @Override
         public void process(Node externs, Node root) {
           pass.process(externs, root);
-          setExportedNames(pass.getExportedVariableNames());
+          exportedNames = pass.getExportedVariableNames();
         }
       };
     }
@@ -523,13 +717,13 @@
       return new CompilerPass() {
         @Override
         public void process(Node externs, Node jsRoot) {
-          Map<String, Integer> cssNames = null;
+          Map<String, Integer> newCssNames = null;
           if (options.gatherCssNames) {
-            cssNames = Maps.newHashMap();
+            newCssNames = Maps.newHashMap();
           }
-          (new ReplaceCssNames(compiler, cssNames)).process(
+          (new ReplaceCssNames(compiler, newCssNames)).process(
               externs, jsRoot);
-          setCssNames(cssNames);
+          cssNames = newCssNames;
         }
       };
     }
@@ -792,6 +986,15 @@
     }
   };
 
+  /** Computes the names of functions for later analysis. */
+  private final PassFactory computeFunctionNames =
+      new PassFactory("computeFunctionNames", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return ((functionNames = new FunctionNames(compiler)));
+    }
+  };
+
   /** Generates unique ids. */
   private final PassFactory replaceIdGenerators =
       new PassFactory("replaceIdGenerators", true) {
@@ -1131,13 +1334,347 @@
     @Override
     protected CompilerPass createInternal(AbstractCompiler compiler) {
       return new CrossModuleMethodMotion(
-          compiler, getCrossModuleIdGenerator(),
+          compiler, crossModuleIdGenerator,
           // Only move properties in externs if we're not treating
           // them as exports.
           options.removeUnusedPrototypePropertiesInExterns);
     }
   };
 
+  /** A data-flow based variable inliner. */
+  private final PassFactory flowSensitiveInlineVariables =
+      new PassFactory("flowSensitiveInlineVariables", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return new FlowSensitiveInlineVariables(compiler);
+    }
+  };
+
+  /** Uses register-allocation algorithms to use fewer variables. */
+  private final PassFactory coalesceVariableNames =
+      new PassFactory("coalesceVariableNames", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return new CoalesceVariableNames(compiler);
+    }
+  };
+
+  /**
+   * Some simple, local collapses (e.g., {@code var x; var y;} becomes
+   * {@code var x,y;}.
+   */
+  private final PassFactory collapseVariableDeclarations =
+      new PassFactory("collapseVariableDeclarations", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      compiler.setUnnormalized();
+      return new CollapseVariableDeclarations(compiler);
+    }
+  };
+
+  /**
+   * Extracts common sub-expressions.
+   */
+  private final PassFactory extractPrototypeMemberDeclarations =
+      new PassFactory("extractPrototypeMemberDeclarations", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return new ExtractPrototypeMemberDeclarations(compiler);
+    }
+  };
+
+  /** Rewrites common function definitions to be more compact. */
+  private final PassFactory rewriteFunctionExpressions =
+      new PassFactory("rewriteFunctionExpressions", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return new FunctionRewriter(compiler);
+    }
+  };
+
+  /** Collapses functions to not use the VAR keyword. */
+  private final PassFactory collapseAnonymousFunctions =
+      new PassFactory("collapseAnonymousFunctions", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return new CollapseAnonymousFunctions(compiler);
+    }
+  };
+
+  /** Moves function declarations to the top, to simulate actual hoisting. */
+  private final PassFactory moveFunctionDeclarations =
+      new PassFactory("moveFunctionDeclarations", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return new MoveFunctionDeclarations(compiler);
+    }
+  };
+
+  private final PassFactory nameUnmappedAnonymousFunctions =
+      new PassFactory("nameAnonymousFunctions", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return new NameAnonymousFunctions(compiler);
+    }
+  };
+
+  private final PassFactory nameMappedAnonymousFunctions =
+      new PassFactory("nameAnonymousFunctions", true) {
+    @Override
+    protected CompilerPass createInternal(final AbstractCompiler compiler) {
+      return new CompilerPass() {
+        @Override public void process(Node externs, Node root) {
+          NameAnonymousFunctionsMapped naf =
+              new NameAnonymousFunctionsMapped(compiler);
+          naf.process(externs, root);
+          anonymousFunctionNameMap = naf.getFunctionMap();
+        }
+      };
+    }
+  };
+
+  /** Alias external symbols. */
+  private final PassFactory aliasExternals =
+      new PassFactory("aliasExternals", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return new AliasExternals(compiler, compiler.getModuleGraph(),
+          options.unaliasableGlobals, options.aliasableGlobals);
+    }
+  };
+
+  /**
+   * Alias string literals with global variables, to avoid creating lots of
+   * transient objects.
+   */
+  private final PassFactory aliasStrings =
+      new PassFactory("aliasStrings", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return new AliasStrings(
+          compiler,
+          compiler.getModuleGraph(),
+          options.aliasAllStrings ? null : options.aliasableStrings,
+          options.aliasStringsBlacklist,
+          options.outputJsStringUsage);
+    }
+  };
+
+  /** Aliases common keywords (true, false) */
+  private final PassFactory aliasKeywords =
+      new PassFactory("aliasKeywords", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return new AliasKeywords(compiler);
+    }
+  };
+
+  /** Handling for the ObjectPropertyString primitive. */
+  private final PassFactory objectPropertyStringPostprocess =
+      new PassFactory("ObjectPropertyStringPostprocess", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return new ObjectPropertyStringPostprocess(compiler);
+    }
+  };
+
+  /**
+   * Renames properties so that the two properties that never appear on
+   * the same object get the same name.
+   */
+  private final PassFactory ambiguateProperties =
+      new PassFactory("ambiguateProperties", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return new AmbiguateProperties(
+          compiler, options.anonymousFunctionNaming.getReservedCharacters());
+    }
+  };
+
+  /** Normalizes the AST for optimizations. */
+  private final PassFactory normalize =
+      new PassFactory("normalize", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      compiler.setNormalized();
+      return new Normalize(compiler, false);
+    }
+  };
+
+  /** Denormalize the AST for code generation. */
+  private final PassFactory denormalize =
+      new PassFactory("denormalize", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      compiler.setUnnormalized();
+      return new Denormalize(compiler);
+    }
+  };
+
+  /** Inverting name normalization. */
+  private final PassFactory invertContextualRenaming =
+      new PassFactory("invertNames", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return MakeDeclaredNamesUnique.getContextualRenameInverter(compiler);
+    }
+  };
+
+  /**
+   * Renames properties.
+   */
+  private final PassFactory renameProperties =
+      new PassFactory("renameProperties", true) {
+    @Override
+    protected CompilerPass createInternal(final AbstractCompiler compiler) {
+      VariableMap map = null;
+      if (options.inputPropertyMapSerialized != null) {
+        try {
+          map = VariableMap.fromBytes(options.inputPropertyMapSerialized);
+        } catch (ParseException e) {
+          return new ErrorPass(compiler,
+              JSError.make(INPUT_MAP_PROP_PARSE, e.getMessage()));
+        }
+      }
+
+      final VariableMap prevPropertyMap = map;
+      return new CompilerPass() {
+        @Override public void process(Node externs, Node root) {
+          propertyMap = runPropertyRenaming(
+              compiler, prevPropertyMap, externs, root);
+        }
+      };
+    }
+  };
+
+  private VariableMap runPropertyRenaming(
+      AbstractCompiler compiler, VariableMap prevPropertyMap,
+      Node externs, Node root) {
+    char[] reservedChars =
+        options.anonymousFunctionNaming.getReservedCharacters();
+    switch (options.propertyRenaming) {
+      case HEURISTIC:
+        RenamePrototypes rproto = new RenamePrototypes(compiler, false,
+            reservedChars, prevPropertyMap);
+        rproto.process(externs, root);
+        return rproto.getPropertyMap();
+
+      case AGGRESSIVE_HEURISTIC:
+        RenamePrototypes rproto2 = new RenamePrototypes(compiler, true,
+            reservedChars, prevPropertyMap);
+        rproto2.process(externs, root);
+        return rproto2.getPropertyMap();
+
+      case ALL_UNQUOTED:
+        RenameProperties rprop = new RenameProperties(
+            compiler, options.generatePseudoNames, prevPropertyMap,
+            reservedChars);
+        rprop.process(externs, root);
+        return rprop.getPropertyMap();
+
+      default:
+        throw new IllegalStateException(
+            "Unrecognized property renaming policy");
+    }
+  }
+
+  /** Renames variables. */
+  private final PassFactory renameVars =
+      new PassFactory("renameVars", true) {
+    @Override
+    protected CompilerPass createInternal(final AbstractCompiler compiler) {
+      VariableMap map = null;
+      if (options.inputVariableMapSerialized != null) {
+        try {
+          map = VariableMap.fromBytes(options.inputVariableMapSerialized);
+        } catch (ParseException e) {
+          return new ErrorPass(compiler,
+              JSError.make(INPUT_MAP_VAR_PARSE, e.getMessage()));
+        }
+      }
+
+      final VariableMap prevVariableMap = map;
+      return new CompilerPass() {
+        @Override public void process(Node externs, Node root) {
+          variableMap = runVariableRenaming(
+              compiler, prevVariableMap, externs, root);
+        }
+      };
+    }
+  };
+
+  private VariableMap runVariableRenaming(
+      AbstractCompiler compiler, VariableMap prevVariableMap,
+      Node externs, Node root) {
+    char[] reservedChars =
+        options.anonymousFunctionNaming.getReservedCharacters();
+    boolean preserveAnonymousFunctionNames =
+        options.anonymousFunctionNaming != AnonymousFunctionNamingPolicy.OFF;
+    RenameVars rn = new RenameVars(
+        compiler,
+        options.renamePrefix,
+        options.variableRenaming == VariableRenamingPolicy.LOCAL,
+        preserveAnonymousFunctionNames,
+        options.generatePseudoNames,
+        prevVariableMap,
+        reservedChars,
+        exportedNames);
+    rn.process(externs, root);
+    return rn.getVariableMap();
+  }
+
+  /** Renames labels */
+  private final PassFactory renameLabels =
+      new PassFactory("renameLabels", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return new RenameLabels(compiler);
+    }
+  };
+
+  /** Convert bracket access to dot access */
+  private final PassFactory convertToDottedProperties =
+      new PassFactory("convertToDottedProperties", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return new ConvertToDottedProperties(compiler);
+    }
+  };
+
+  /** Checks that all variables are defined. */
+  private final PassFactory sanityCheckVars =
+      new PassFactory("sanityCheckVars", true) {
+    @Override
+    protected CompilerPass createInternal(AbstractCompiler compiler) {
+      return new VarCheck(compiler, true);
+    }
+  };
+
+  /** Adds instrumentations according to an instrumentation template. */
+  private final PassFactory instrumentFunctions =
+      new PassFactory("instrumentFunctions", true) {
+    @Override
+    protected CompilerPass createInternal(final AbstractCompiler compiler) {
+      return new CompilerPass() {
+        @Override public void process(Node externs, Node root) {
+          try {
+            FileReader templateFile =
+                new FileReader(options.instrumentationTemplate);
+            (new InstrumentFunctions(
+                compiler, functionNames,
+                options.instrumentationTemplate,
+                options.appNameStr,
+                templateFile)).process(externs, root);
+          } catch (IOException e) {
+            compiler.report(
+                JSError.make(AbstractCompiler.READ_ERROR,
+                    options.instrumentationTemplate));
+          }
+        }
+      };
+    }
+  };
+
   /**
    * Create a no-op pass that can only run once. Used to break up loops.
    */
@@ -1210,16 +1747,20 @@
   /** A compiler pass that just reports an error. */
   private static class ErrorPass implements CompilerPass {
     private final AbstractCompiler compiler;
-    private final DiagnosticType error;
+    private final JSError error;
 
     private ErrorPass(AbstractCompiler compiler, DiagnosticType error) {
+      this(compiler, JSError.make(error));
+    }
+
+    private ErrorPass(AbstractCompiler compiler, JSError error) {
       this.compiler = compiler;
       this.error = error;
     }
 
     @Override
     public void process(Node externs, Node root) {
-      compiler.report(JSError.make(error));
+      compiler.report(error);
     }
   }
 
diff --git a/src/com/google/javascript/jscomp/JsAst.java b/src/com/google/javascript/jscomp/JsAst.java
index f3f4b5c..28f4c34 100644
--- a/src/com/google/javascript/jscomp/JsAst.java
+++ b/src/com/google/javascript/jscomp/JsAst.java
@@ -78,7 +78,7 @@
       parse(compiler, sourceFile.getName(), sourceFile.getCode());
     } catch (IOException e) {
       compiler.report(
-          JSError.make(Compiler.READ_ERROR, sourceFile.getName()));
+          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));
     }
   }
 
@@ -91,7 +91,7 @@
           compiler.getDefaultErrorReporter(),
           logger_);
     } catch (IOException e) {
-      compiler.report(JSError.make(Compiler.READ_ERROR, sourceName));
+      compiler.report(JSError.make(AbstractCompiler.READ_ERROR, sourceName));
     }
 
     if (root == null) {
diff --git a/src/com/google/javascript/jscomp/PassConfig.java b/src/com/google/javascript/jscomp/PassConfig.java
index 5be9c78..f080f9a 100644
--- a/src/com/google/javascript/jscomp/PassConfig.java
+++ b/src/com/google/javascript/jscomp/PassConfig.java
@@ -17,11 +17,8 @@
 package com.google.javascript.jscomp;
 
 
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
 
 import java.io.Serializable;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -36,16 +33,6 @@
   // Used by subclasses in this package.
   final CompilerOptions options;
 
-  /** Names exported by goog.exportSymbol. */
-  private Set<String> exportedNames = null;
-
-  /**
-   * Ids for cross-module method stubbing, so that each method has
-   * a unique id.
-   */
-  private CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator =
-      new CrossModuleMethodMotion.IdGenerator();
-
   /**
    * A memoized version of scopeCreator. It must be memoized so that
    * we can make two separate passes over the AST, one for inferring types
@@ -56,65 +43,10 @@
   /** The global typed scope. */
   Scope topScope = null;
 
-  /**
-   * Keys are arguments passed to getCssName() found during compilation; values
-   * are the number of times the key appeared as an argument to getCssName().
-   */
-  private Map<String, Integer> cssNames = null;
-
   public PassConfig(CompilerOptions options) {
     this.options = options;
   }
 
-  // Setters and getters for intermediate state.
-  //
-  // This makes it possible to start and stop the compiler mid-compile.
-  // Each getter and setter corresponds to a type of state that is produced
-  // by an earlier pass and consumed by a later pass. When the compiler is
-  // stopped mid-compile, the getter should return any state which has
-  // been produced, and the setter should restore that state when the compiler
-  // is restarted.
-  //
-  // TODO(nicksantos): Perhaps we should just make PassConfig serializable.
-
-  /**
-   * Gets a map of CSS names found in the JS code, to the number of times
-   * they appear.
-   */
-  Map<String, Integer> getCssNames() {
-    return cssNames == null ? null : Maps.newHashMap(cssNames);
-  }
-
-  /**
-   * Gets the symbols exported by the passes.
-   */
-  Set<String> getExportedNames() {
-    return exportedNames == null ? null :
-        Collections.unmodifiableSet(exportedNames);
-  }
-
-  /**
-   * Gets a generator for cross-module method ids, so that the ids
-   * are stable across compiled.
-   */
-  CrossModuleMethodMotion.IdGenerator getCrossModuleIdGenerator() {
-    return crossModuleIdGenerator;
-  }
-
-  /**
-   * Sets the map of CSS names found in the JS code during previous runs.
-   */
-  void setCssNames(Map<String, Integer> newVal) {
-    cssNames = newVal == null ? null : Maps.newHashMap(newVal);
-  }
-
-  /**
-   * Sets the symbols exported by previous passes.
-   */
-  void setExportedNames(Set<String> newVal) {
-    exportedNames = newVal == null ? null : Sets.newHashSet(newVal);
-  }
-
   /**
    * Gets the scope creator for typed scopes.
    */
@@ -202,20 +134,13 @@
    * Get intermediate state for a running pass config, so it can
    * be paused and started again later.
    */
-  State getIntermediateState() {
-    return new State(getCssNames(), getExportedNames(),
-                     crossModuleIdGenerator);
-  }
+  abstract State getIntermediateState();
 
   /**
    * Set the intermediate state for a pass config, to restart
    * a compilation process that had been previously paused.
    */
-  void setIntermediateState(State state) {
-    setCssNames(state.cssNames);
-    setExportedNames(state.exportedNames);
-    crossModuleIdGenerator = state.crossModuleIdGenerator;
-  }
+  abstract void setIntermediateState(State state);
 
   /**
    * An implementation of PassConfig that just proxies all its method calls
@@ -238,22 +163,6 @@
       return delegate.getOptimizations();
     }
 
-    @Override Map<String, Integer> getCssNames() {
-      return delegate.getCssNames();
-    }
-
-    @Override Set<String> getExportedNames() {
-      return delegate.getExportedNames();
-    }
-
-    @Override void setCssNames(Map<String, Integer> newVal) {
-      delegate.setCssNames(newVal);
-    }
-
-    @Override void setExportedNames(Set<String> newVal) {
-      delegate.setExportedNames(newVal);
-    }
-
     @Override ScopeCreator getScopeCreator() {
       return delegate.getScopeCreator();
     }
@@ -277,15 +186,25 @@
   static class State implements Serializable {
     private static final long serialVersionUID = 1L;
 
-    private final Map<String, Integer> cssNames;
-    private final Set<String> exportedNames;
-    private final CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator;
+    final Map<String, Integer> cssNames;
+    final Set<String> exportedNames;
+    final CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator;
+    final VariableMap variableMap;
+    final VariableMap propertyMap;
+    final VariableMap anonymousFunctionNameMap;
+    final FunctionNames functionNames;
 
-    private State(Map<String, Integer> cssNames, Set<String> exportedNames,
-                  CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator) {
+    State(Map<String, Integer> cssNames, Set<String> exportedNames,
+          CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator,
+          VariableMap variableMap, VariableMap propertyMap,
+          VariableMap anonymousFunctionNameMap, FunctionNames functionNames) {
       this.cssNames = cssNames;
       this.exportedNames = exportedNames;
       this.crossModuleIdGenerator = crossModuleIdGenerator;
+      this.variableMap = variableMap;
+      this.propertyMap = propertyMap;
+      this.anonymousFunctionNameMap = anonymousFunctionNameMap;
+      this.functionNames = functionNames;
     }
   }
 }
diff --git a/src/com/google/javascript/jscomp/TightenTypes.java b/src/com/google/javascript/jscomp/TightenTypes.java
index 9fd9512..7e0d309 100644
--- a/src/com/google/javascript/jscomp/TightenTypes.java
+++ b/src/com/google/javascript/jscomp/TightenTypes.java
@@ -107,6 +107,12 @@
   private final Map<ObjectType, ConcreteInstanceType> instanceFromJSType =
       Maps.newHashMap();
 
+  /**
+   * Memoized results of "createTypeIntersection" calls.
+   */
+  private final Map<ConcreteJSTypePair, ConcreteType> typeIntersectionMemos =
+      Maps.newHashMap();
+
   /** Scope storing the top-level variables and functions. */
   private ConcreteScope topScope;
 
@@ -433,8 +439,11 @@
       assigns.add(new Assignment((ConcreteSlot) fType.getThisSlot(), thisType));
       for (int i = 0; i < argTypes.size(); ++i) {
         ConcreteSlot variable = (ConcreteSlot) fType.getParameterSlot(i);
-        Preconditions.checkState(variable != null);
-        assigns.add(new Assignment(variable, argTypes.get(i)));
+        // TODO(johnlenz): Support "arguments" references in function bodies.
+        // For now, ignore anonymous arguments.
+        if (variable != null) {
+          assigns.add(new Assignment(variable, argTypes.get(i)));
+        }
       }
     }
     return assigns;
@@ -510,7 +519,11 @@
              : recvType.getFunctionInstanceTypes()) {
           thisType = thisType.unionWith(instType);
         }
-        allInstantiatedTypes.add(thisType);
+        boolean added = allInstantiatedTypes.add(thisType);
+        if (added) {
+          // A new type instance invalidates the cached type intersections.
+          typeIntersectionMemos.clear();
+        }
       }
 
       List<ConcreteType> argTypes = Lists.newArrayList();
@@ -537,7 +550,9 @@
     }
 
     public Collection<Assignment> getAssignments(ConcreteScope scope) {
-      ConcreteType thisType = inferConcreteType(scope, firstArgument);
+      ConcreteType thisType = (firstArgument != null)
+          ? inferConcreteType(scope, firstArgument)
+          : getTopScope().getTypeOfThis();
       ConcreteType recvType = inferConcreteType(scope, receiver);
 
       if (recvType instanceof ConcreteInstanceType &&
@@ -1028,6 +1043,8 @@
 
   /** Computes the concrete types that can result from the given expression. */
   ConcreteType inferConcreteType(ConcreteScope scope, Node expr) {
+    Preconditions.checkNotNull(scope);
+    Preconditions.checkNotNull(expr);
     ConcreteType ret;
     switch (expr.getType()) {
       case Token.NAME:
@@ -1161,7 +1178,15 @@
 
   private ConcreteType createTypeIntersection(
       ConcreteType concreteType, JSType jsType) {
-    ConcreteType ret;
+    // TODO(johnlenz): Even with memoizing all the time of this pass is still 
+    // spent in this function (due to invalidation caused by changes to
+    // allInstantiatedTypes), specifically calls to ConcreteUnionType.unionWith
+    ConcreteJSTypePair key = new ConcreteJSTypePair(concreteType, jsType);
+    ConcreteType ret = typeIntersectionMemos.get(key);
+    if (ret != null) {
+      return ret;
+    }
+
     if (jsType == null || jsType.isUnknownType() || concreteType.isNone()) {
       ret = concreteType;
     } else if (concreteType.isUnion() || concreteType.isSingleton()) {
@@ -1195,6 +1220,7 @@
       }
     }
 
+    typeIntersectionMemos.put(key, ret);
     return ret;
   }
 
@@ -1330,4 +1356,49 @@
     }
     return true;
   }
+
+  /**
+   * A simple class used to pair a concrete type and a js type.  Used to
+   * memoize the results of a "createTypeIntersection" call.
+   */
+  static class ConcreteJSTypePair {
+    final ConcreteType concrete;
+    final JSType jstype;
+    final int hashcode;
+
+    ConcreteJSTypePair(ConcreteType concrete, JSType jstype) {
+      this.concrete = concrete;
+      this.jstype = jstype;
+      this.hashcode = concrete.hashCode() + getJSTypeHashCode();
+    }
+
+    private int getJSTypeHashCode() {
+      return jstype != null ? jstype.hashCode() : 0;
+    }
+
+    private boolean equalsJSType(JSType jsType) {
+      if (jsType == null || jstype == null) {
+        return jstype == jsType;
+      } else {
+        return jsType.equals(this.jstype);
+      }
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof ConcreteJSTypePair) {
+        ConcreteJSTypePair pair = (ConcreteJSTypePair) o;
+        if ((pair.concrete.equals(this.concrete)
+            && equalsJSType(pair.jstype))) {
+          return true;
+        }
+      }
+      return false;
+    }
+
+    @Override
+    public int hashCode() {
+      return hashcode;
+    }
+  }
 }
diff --git a/src/com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.java b/src/com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.java
new file mode 100644
index 0000000..0b61407
--- /dev/null
+++ b/src/com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2009 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp.testing;
+
+import com.google.javascript.jscomp.Region;
+import com.google.javascript.jscomp.SourceExcerptProvider;
+import com.google.javascript.jscomp.SourceFile;
+
+
+
+/**
+ * A simple source excerpt provider for testing.
+*
+ */
+public class SimpleSourceExcerptProvider implements SourceExcerptProvider {
+
+  private final SourceFile sourceFile;
+
+  public SimpleSourceExcerptProvider(String source) {
+    sourceFile = SourceFile.fromCode("input", source);
+  }
+
+  @Override
+  public String getSourceLine(String sourceName, int lineNumber) {
+    return sourceFile.getLine(lineNumber);
+  }
+
+  @Override
+  public Region getSourceRegion(String sourceName, int lineNumber) {
+    return sourceFile.getRegion(lineNumber);
+  }
+}
diff --git a/src/com/google/javascript/jscomp/testing/TestErrorReporter.java b/src/com/google/javascript/jscomp/testing/TestErrorReporter.java
new file mode 100644
index 0000000..2e9cca9
--- /dev/null
+++ b/src/com/google/javascript/jscomp/testing/TestErrorReporter.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2007 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp.testing;
+
+import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;
+import com.google.javascript.jscomp.mozilla.rhino.EvaluatorException;
+
+import junit.framework.Assert;
+
+/**
+ * <p>An error reporter for testing that verifies that messages reported to the
+ * reporter are expected.</p>
+ *
+ * <p>Sample use</p>
+ * <pre>
+ * TestErrorReporter e =
+ *   new TestErrorReporter(null, new String[] { "first warning" });
+ * ...
+ * assertTrue(e.hasEncounteredAllWarnings());
+ * </pre>
+ *
+*
+ */
+public final class TestErrorReporter extends Assert implements ErrorReporter {
+  private final String[] errors;
+  private final String[] warnings;
+  private int errorsIndex = 0;
+  private int warningsIndex = 0;
+
+  public TestErrorReporter(String[] errors, String[] warnings) {
+    this.errors = errors;
+    this.warnings = warnings;
+  }
+
+  public void error(String message, String sourceName, int line,
+      String lineSource, int lineOffset) {
+    if (errors != null && errorsIndex < errors.length) {
+      assertEquals(errors[errorsIndex++], message);
+    } else {
+      fail("extra error: " + message);
+    }
+  }
+
+  public void warning(String message, String sourceName, int line,
+      String lineSource, int lineOffset) {
+    if (warnings != null && warningsIndex < warnings.length) {
+      assertEquals(warnings[warningsIndex++], message);
+    } else {
+      fail("extra warning: " + message);
+    }
+  }
+
+  public EvaluatorException runtimeError(String message, String sourceName,
+      int line, String lineSource, int lineOffset) {
+    return new EvaluatorException("JSCompiler test code: " + message);
+  }
+
+  /**
+   * Returns whether all warnings were reported to this reporter.
+   */
+  public boolean hasEncounteredAllWarnings() {
+    return (warnings == null) ?
+        warningsIndex == 0 :
+        warnings.length == warningsIndex;
+  }
+
+  /**
+   * Returns whether all errors were reported to this reporter.
+   */
+  public boolean hasEncounteredAllErrors() {
+    return (errors == null) ?
+        errorsIndex == 0 :
+        errors.length == errorsIndex;
+  }
+}
diff --git a/test/com/google/javascript/jscomp/ControlStructureCheckTest.java b/test/com/google/javascript/jscomp/ControlStructureCheckTest.java
index 8ea0171..202f906 100644
--- a/test/com/google/javascript/jscomp/ControlStructureCheckTest.java
+++ b/test/com/google/javascript/jscomp/ControlStructureCheckTest.java
@@ -80,6 +80,15 @@
     assertNoError("a:switch(1){case(1):function f(){a:while(1){continue a;}}}");
   }
 
+  public void testUseOfWith1() {
+    testSame("with(a){}", ControlStructureCheck.USE_OF_WITH);
+  }
+
+  public void testUseOfWith2() {
+    testSame("/** @suppress {with} */" +
+             "with(a){}");
+  }
+
   private void assertNoError(String js) {
     testSame(js);
   }
diff --git a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
index 2147311..f973172 100644
--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
@@ -66,40 +66,19 @@
     }
   };
 
-  // A scope creator that does scope creation and type inference.
-  private class MyScopeCreator implements ScopeCreator {
-    private final AbstractCompiler compiler;
-    private final TypedScopeCreator delegate;
-
-    MyScopeCreator(AbstractCompiler compiler) {
-      this.compiler = compiler;
-      this.delegate = new TypedScopeCreator(compiler);
-    }
-
-    public Scope createScope(Node root, Scope parent) {
-      Scope typedScope = delegate.createScope(root, parent);
-
-      TypeInference typeInference = new TypeInference(
-          compiler, computeCfg(root),
-          compiler.getReverseAbstractInterpreter(), typedScope);
-      typeInference.analyze();
-      return typedScope;
-    }
-
-    private ControlFlowGraph<Node> computeCfg(Node n) {
-      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);
-      cfa.process(null, n);
-      return cfa.getCfg();
-    }
-  }
-
   @Override
   public CompilerPass getProcessor(final Compiler compiler) {
     registry = compiler.getTypeRegistry();
     return new CompilerPass() {
       public void process(Node externs, Node root) {
+        ScopeCreator scopeCreator =
+            new MemoizedScopeCreator(new TypedScopeCreator(compiler));
+        Scope topScope = scopeCreator.createScope(root.getParent(), null);
+        (new TypeInferencePass(
+            compiler, compiler.getReverseAbstractInterpreter(),
+            topScope, scopeCreator)).process(externs, root);
         NodeTraversal t = new NodeTraversal(
-            compiler, callback, new MyScopeCreator(compiler));
+            compiler, callback, scopeCreator);
         t.traverseRoots(Lists.newArrayList(externs, root));
       }
     };
@@ -593,6 +572,47 @@
     assertEquals("number", findNameType("x", globalScope).toString());
   }
 
+  public void testAbstractMethod() {
+    testSame(
+        "/** @type {!Function} */ var abstractMethod;" +
+        "/** @constructor */ function Foo() {}" +
+        "/** @param {number} x */ Foo.prototype.bar = abstractMethod;");
+    assertEquals(
+        "Function", findNameType("abstractMethod", globalScope).toString());
+
+    FunctionType ctor = (FunctionType) findNameType("Foo", globalScope);
+    ObjectType instance = ctor.getInstanceType();
+    assertEquals("Foo", instance.toString());
+
+    ObjectType proto = instance.getImplicitPrototype();
+    assertEquals("Foo.prototype", proto.toString());
+
+    assertEquals(
+        "function (this:Foo, number): ?",
+        proto.getPropertyType("bar").toString());
+  }
+
+  public void testAbstractMethod2() {
+    testSame(
+        "/** @type {!Function} */ var abstractMethod;" +
+        "/** @param {number} x */ var y = abstractMethod;");
+    assertEquals(
+        "Function",
+        findNameType("y", globalScope).toString());
+    assertEquals(
+        "function (number): ?",
+        globalScope.getVar("y").getType().toString());
+  }
+
+  public void testAbstractMethod3() {
+    testSame(
+        "/** @type {!Function} */ var abstractMethod;" +
+        "/** @param {number} x */ var y = abstractMethod; y;");
+    assertEquals(
+        "function (number): ?",
+        findNameType("y", globalScope).toString());
+  }
+
   private JSType findNameType(String name, Scope scope) {
     Node root = scope.getRootNode();
     Deque<Node> queue = Lists.newLinkedList();
diff --git a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java
new file mode 100644
index 0000000..35f6f4e
--- /dev/null
+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java
@@ -0,0 +1,1000 @@
+/*
+ * Copyright 2009 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp.parsing;
+
+import com.google.javascript.jscomp.mozilla.rhino.CompilerEnvirons;
+import com.google.javascript.jscomp.mozilla.rhino.Parser;
+import com.google.javascript.jscomp.mozilla.rhino.ast.AstRoot;
+import com.google.javascript.jscomp.testing.TestErrorReporter;
+import com.google.javascript.rhino.JSDocInfo;
+import com.google.javascript.rhino.Node;
+import com.google.javascript.rhino.testing.BaseJSTypeTestCase;
+
+/**
+ * Tests {@link IRFactory}.
+ */
+public class IRFactoryTest extends BaseJSTypeTestCase {
+
+  public void testScript() throws Exception {
+    parse("");
+  }
+
+  public void testName() throws Exception {
+    parse("a");
+  }
+
+  public void testArrayLiteral() throws Exception {
+    parse("[a, b]");
+  }
+
+  public void testArrayLiteral2() throws Exception {
+    parse("[a, , b]");
+  }
+
+  public void testArrayLiteral3() throws Exception {
+    parse("[a, undefined, b]");
+  }
+
+  public void testArrayLiteral4() throws Exception {
+    parse("[,,,a,,b]");
+  }
+
+  public void testAssignment() throws Exception {
+    parse("a = b");
+  }
+
+  public void testAssignment2() throws Exception {
+    parse("a += b");
+  }
+
+  public void testInfix() throws Exception {
+    parse("a + b");
+  }
+
+  public void testScope() throws Exception {
+    parse("{ a; b; c; }");
+  }
+
+  public void testConditional() throws Exception {
+    parse("a ? b : c");
+  }
+
+  public void testEmpty() throws Exception {
+    parse(";;");
+  }
+
+  public void testIf() throws Exception {
+    parse("if (a) { b }");
+  }
+
+  public void testIf2() throws Exception {
+    parse("if (a) { b } else { c }");
+  }
+
+  public void testNumber() throws Exception {
+    parse("0");
+  }
+
+  public void testNumber2() throws Exception {
+    parse("1.2");
+  }
+
+  public void testString() throws Exception {
+    parse("'a'");
+  }
+
+  public void testString2() throws Exception {
+    parse("\"a\"");
+  }
+
+  public void testUnary() throws Exception {
+    parse("-a");
+  }
+
+  public void testUnary2() throws Exception {
+    parse("a++");
+  }
+
+  public void testUnary3() throws Exception {
+    parse("++a");
+  }
+
+  public void testVar() throws Exception {
+    parse("var a = 1");
+  }
+
+  public void testVar2() throws Exception {
+    parse("var a = 1, b = 2");
+  }
+
+  public void testVar3() throws Exception {
+    parse("var a, b = 1");
+  }
+
+  public void testElementGet() throws Exception {
+    parse("a[i]");
+  }
+
+  public void testPropertyGet() throws Exception {
+    parse("a.b");
+  }
+
+  public void testRegexp() throws Exception {
+    parse("/ab+c/");
+  }
+
+  public void testRegexp2() throws Exception {
+    parse("/ab+c/g");
+  }
+
+  public void testFunctionCall() throws Exception {
+    parse("a()");
+  }
+
+  public void testFunctionCall2() throws Exception {
+    parse("a(b)");
+  }
+
+  public void testFunctionCall3() throws Exception {
+    parse("a(b, c)");
+  }
+
+  public void testNew() throws Exception {
+    parse("new A()");
+  }
+
+  public void testNew2() throws Exception {
+    parse("new A(b)");
+  }
+
+  public void testNew3() throws Exception {
+    parse("new A(b, c)");
+  }
+
+  public void testTry() {
+    parse("try { a(); } catch (e) { b(); }");
+  }
+
+  public void testTry2() {
+    parse("try { a(); } finally { b(); }");
+  }
+
+  public void testTry3() {
+    parse("try { a(); } catch (e) { b(); } finally { c(); }");
+  }
+
+  public void testTry4() {
+    parse("try { a(); }" +
+        "catch (e if e == 'b') { b(); } " +
+        "catch (e if e == 'c') { c(); }");
+  }
+
+  public void testTry5() {
+    parse("try { a(); }" +
+        "catch (e if e == 'b') { b(); } " +
+        "catch (e if e == 'c') { c(); } " +
+        "catch (e) { d(); } " +
+        "finally { f(); }");
+  }
+
+  public void testFunction() {
+    parse("function f() {}");
+  }
+
+  public void testFunction2() {
+    parse("function() {}");
+  }
+
+  public void testFunction3() {
+    parse("function f(a) {}");
+  }
+
+  public void testFunction4() {
+    parse("function(a) {}");
+  }
+
+  public void testFunction5() {
+    parse("function f(a, b) {}");
+  }
+
+  public void testFunction6() {
+    parse("function(a, b) {}");
+  }
+
+  public void testReturn() {
+    parse("function() {return 1;}");
+  }
+
+  public void testReturn2() {
+    parse("function() {return;}");
+  }
+
+  public void testReturn3() {
+    parse("function(){return x?1:2}");
+  }
+
+  public void testThrow() {
+    parse("throw e");
+  }
+
+  public void testWith() {
+    parse("with (a) { b }");
+  }
+
+  public void testObjectLiteral() {
+    parse("var o = {}");
+  }
+
+  public void testObjectLiteral2() {
+    parse("var o = {a: 1}");
+  }
+
+  public void testObjectLiteral3() {
+    parse("var o = {a: 1, b: 2}");
+  }
+
+  public void testObjectLiteral4() {
+    parse("var o = {1: 'a'}");
+  }
+
+  public void testObjectLiteral5() {
+    parse("var o = {'a': 'a'}");
+  }
+
+  public void testKeywordLiteral() {
+    parse("true");
+  }
+
+  public void testWhile() {
+    parse("while (!a) { a--; }");
+  }
+
+  public void testParen() {
+    parse("(a)");
+  }
+
+  public void testParen2() {
+    parse("(1+1)*2");
+  }
+
+  public void testFor() {
+    parse("for (var i = 0; i < n; i++) { a(i); }");
+  }
+
+  public void testForIn() {
+    parse("for (i in a) { b(i); }");
+  }
+
+  public void testBreak() {
+    parse("while (true) { break; }");
+  }
+
+  public void testContinue() {
+    parse("while (true) { continue; }");
+  }
+
+  public void testDoLoop() {
+    parse("do { a() } while (b());");
+  }
+
+  public void testLabel() {
+    parse("foo: bar");
+  }
+
+  public void testLabel2() {
+    parse("l: while (f()) { if (g()) continue l;}");
+  }
+
+  public void testLabel3() {
+    parse("Foo:Bar:X:{ break Bar; }");
+  }
+
+  public void testSwitch() {
+    parse("switch (e) {" +
+        "case 'a': a(); break;" +
+        "case 'b': b();" +
+        "case 'c': c(); }");
+  }
+
+  public void testSwitch2() {
+    parse("switch (e) { case 'a': a(); break; default: b();}");
+  }
+
+  public void testSwitch3() {
+    parse("function(){switch(x){default:case 1:return 2}}");
+  }
+
+  public void testDebugger() {
+    parse("debugger;");
+  }
+
+  public void testCommentPositions() {
+    Node root = newParse("/** @param {string} x */function a(x) {};" +
+        "/** @param {string} x */function b(x) {}");
+    Node a = root.getFirstChild();
+    Node b = root.getLastChild();
+    assertMarkerPosition(a, 0, 4);
+    assertMarkerPosition(b, 0, 45);
+  }
+
+   public void testLiteralLocation() {
+    Node root = newParse(
+        "\nvar d =\n" +
+        "    \"foo\";\n" +
+        "var e =\n" +
+        "    1;\n" +
+        "var f = \n" +
+        "    1.2;\n" +
+        "var g = \n" +
+        "    2e5;\n" +
+        "var h = \n" +
+        "    'bar';\n");
+
+    Node firstStmt = root.getFirstChild();
+    Node firstLiteral = firstStmt.getFirstChild().getFirstChild();
+    Node secondStmt = firstStmt.getNext();
+    Node secondLiteral = secondStmt.getFirstChild().getFirstChild();
+    Node thirdStmt = secondStmt.getNext();
+    Node thirdLiteral = thirdStmt.getFirstChild().getFirstChild();
+    Node fourthStmt = thirdStmt.getNext();
+    Node fourthLiteral = fourthStmt.getFirstChild().getFirstChild();
+    Node fifthStmt = fourthStmt.getNext();
+    Node fifthLiteral = fifthStmt.getFirstChild().getFirstChild();
+
+    assertNodePosition(2, 4, firstLiteral);
+    assertNodePosition(4, 4, secondLiteral);
+    assertNodePosition(6, 4, thirdLiteral);
+    assertNodePosition(8, 4, fourthLiteral);
+    assertNodePosition(10, 4, fifthLiteral);
+  }
+
+  public void testSwitchLocation() {
+    Node root = newParse(
+        "\nswitch (a) {\n" +
+        "  //{\n" +
+        "   case 1:\n" +
+        "     b++;\n" +
+        "   case 2:\n" +
+        "   default:\n" +
+        "     b--;\n" +
+        "  }\n");
+
+    Node switchStmt = root.getFirstChild();
+    Node switchVar = switchStmt.getFirstChild();
+    Node firstCase = switchVar.getNext();
+    Node caseArg = firstCase.getFirstChild();
+    Node caseBody = caseArg.getNext();
+    Node caseExprStmt = caseBody.getFirstChild();
+    Node incrExpr = caseExprStmt.getFirstChild();
+    Node incrVar = incrExpr.getFirstChild();
+    Node secondCase = firstCase.getNext();
+    Node defaultCase = secondCase.getNext();
+
+    assertNodePosition(1, 0, switchStmt);
+    assertNodePosition(1, 8, switchVar);
+    assertNodePosition(3, 3, firstCase);
+    assertNodePosition(3, 8, caseArg);
+    assertNodePosition(3, 3, caseBody);
+    assertNodePosition(4, 5, caseExprStmt);
+    assertNodePosition(4, 5, incrExpr);
+    assertNodePosition(4, 5, incrVar);
+    assertNodePosition(5, 3, secondCase);
+    assertNodePosition(6, 3, defaultCase);
+  }
+
+  public void testFunctionParamLocation() {
+    Node root = newParse(
+        "\nfunction\n" +
+        "     foo(a,\n" +
+        "     b,\n" +
+        "     c)\n" +
+        "{}\n");
+
+    Node function = root.getFirstChild();
+    Node functionName = function.getFirstChild();
+    Node params = functionName.getNext();
+    Node param1 = params.getFirstChild();
+    Node param2 = param1.getNext();
+    Node param3 = param2.getNext();
+    Node body = params.getNext();
+
+    assertNodePosition(2, 5, function);
+    assertNodePosition(2, 5, functionName);
+    // params corresponds to the LP token.
+    // Can't be on a separate line because of inferred
+    // semicolons.
+    assertNodePosition(2, 8, params);
+    assertNodePosition(2, 9, param1);
+    assertNodePosition(3, 5, param2);
+    assertNodePosition(4, 5, param3);
+    assertNodePosition(5, 0, body);
+  }
+
+  public void testVarDeclLocation() {
+    Node root = newParse(
+        "\nvar\n" +
+        "    a =\n" +
+        "    3\n");
+    Node varDecl = root.getFirstChild();
+    Node varName = varDecl.getFirstChild();
+    Node varExpr = varName.getFirstChild();
+
+    assertNodePosition(1, 0, varDecl);
+    assertNodePosition(2, 4, varName);
+    assertNodePosition(3, 4, varExpr);
+  }
+
+  public void testReturnLocation() {
+    Node root = newParse(
+        "\nfunction\n" +
+        "    foo(\n" +
+        "    a,\n" +
+        "    b,\n" +
+        "    c) {\n" +
+        "    return\n" +
+        "    4;\n" +
+        "}\n");
+
+    Node function = root.getFirstChild();
+    Node functionName = function.getFirstChild();
+    Node params = functionName.getNext();
+    Node body = params.getNext();
+    Node returnStmt = body.getFirstChild();
+    Node exprStmt = returnStmt.getNext();
+    Node returnVal = exprStmt.getFirstChild();
+
+    assertNodePosition(6, 4, returnStmt);
+    assertNodePosition(7, 4, exprStmt);
+    assertNodePosition(7, 4, returnVal);
+  }
+
+  public void testLinenoFor() {
+    Node root = newParse(
+        "\nfor(\n" +
+        ";\n" +
+        ";\n" +
+        ") {\n" +
+        "}\n");
+
+    Node forNode = root.getFirstChild();
+    Node initClause= forNode.getFirstChild();
+    Node condClause = initClause.getNext();
+    Node incrClause = condClause.getNext();
+
+    assertNodePosition(1, 0, forNode);
+    assertNodePosition(2, 0, initClause);
+    assertNodePosition(3, 0, condClause);
+    // TODO(user) Incorrectly gets charno position when EmptyExpression
+    // has its absolute position on the carriage return.  For now, the
+    // line number gets reported correctly (on the next line) but the
+    // character position is -1, so the overall line/char pair in our tree
+    // is -1.
+    //assertNodePosition(4, 0, incrClause);
+  }
+
+  public void testBinaryExprLocation() {
+    Node root = newParse(
+        "\nvar d = a\n" +
+        "    + \n" +
+        "    b;\n" +
+        "var\n" +
+        "    e =\n" +
+        "    a +\n" +
+        "    c;\n" +
+        "var f = b\n" +
+        "    / c;\n");
+
+    Node firstVarDecl = root.getFirstChild();
+    Node firstVar = firstVarDecl.getFirstChild();
+    Node firstVarAdd = firstVar.getFirstChild();
+
+    Node secondVarDecl = firstVarDecl.getNext();
+    Node secondVar = secondVarDecl.getFirstChild();
+    Node secondVarAdd = secondVar.getFirstChild();
+
+    Node thirdVarDecl = secondVarDecl.getNext();
+    Node thirdVar = thirdVarDecl.getFirstChild();
+    Node thirdVarAdd = thirdVar.getFirstChild();
+
+    assertNodePosition(1, 0, firstVarDecl);
+    assertNodePosition(1, 4, firstVar);
+    assertNodePosition(2, 4, firstVarAdd);
+    assertNodePosition(1, 8, firstVarAdd.getFirstChild());
+    assertNodePosition(3, 4, firstVarAdd.getLastChild());
+
+    assertNodePosition(4, 0, secondVarDecl);
+    assertNodePosition(5, 4, secondVar);
+    assertNodePosition(6, 6, secondVarAdd);
+    assertNodePosition(6, 4, secondVarAdd.getFirstChild());
+    assertNodePosition(7, 4, secondVarAdd.getLastChild());
+
+    assertNodePosition(8, 0, thirdVarDecl);
+    assertNodePosition(8, 4, thirdVar);
+    assertNodePosition(9, 4, thirdVarAdd);
+    assertNodePosition(8, 8, thirdVarAdd.getFirstChild());
+    assertNodePosition(9, 6, thirdVarAdd.getLastChild());
+  }
+
+  public void testPrefixLocation() {
+    Node root = newParse(
+         "\na++;\n" +
+         "--\n" +
+         "b;\n");
+
+    Node firstStmt = root.getFirstChild();
+    Node secondStmt = firstStmt.getNext();
+    Node firstOp = firstStmt.getFirstChild();
+    Node secondOp = secondStmt.getFirstChild();
+
+    assertNodePosition(1, 0, firstOp);
+    assertNodePosition(2, 0, secondOp);
+  }
+
+  public void testIfLocation() {
+    Node root = newParse(
+        "\nif\n" +
+        "  (a == 3)\n" +
+        "{\n" +
+        "  b = 0;\n" +
+        "}\n" +
+        "  else\n" +
+        "{\n" +
+        "  c = 1;\n" +
+        "}\n");
+
+    Node ifStmt = root.getFirstChild();
+    Node eqClause = ifStmt.getFirstChild();
+    Node thenClause = eqClause.getNext();
+    Node elseClause = thenClause.getNext();
+
+    assertNodePosition(1, 0, ifStmt);
+    assertNodePosition(2, 5, eqClause);
+    assertNodePosition(3, 0, thenClause);
+    assertNodePosition(7, 0, elseClause);
+  }
+
+  public void testTryLocation() {
+     Node root = newParse(
+         "\ntry {\n" +
+         "  var x = 1;\n" +
+         "} catch\n" +
+         "   (err)\n" +
+         "{\n" +
+         "} finally {\n" +
+         "  var y = 2;\n" +
+         "}\n");
+
+    Node tryStmt = root.getFirstChild();
+    Node tryBlock = tryStmt.getFirstChild();
+    Node catchBlock = tryBlock.getNext();
+    Node catchVarBlock = catchBlock.getFirstChild();
+    Node catchVar = catchVarBlock.getFirstChild();
+    Node finallyBlock = catchBlock.getNext();
+    Node finallyStmt = finallyBlock.getFirstChild();
+
+    assertNodePosition(1, 0, tryStmt);
+    assertNodePosition(1, 4, tryBlock);
+    assertNodePosition(3, 2, catchVarBlock);
+    assertNodePosition(4, 4, catchVar);
+    assertNodePosition(3, 0, catchBlock);
+    assertNodePosition(6, 10, finallyBlock);
+    assertNodePosition(7, 2, finallyStmt);
+  }
+
+  public void testHookLocation() {
+    Node root = newParse(
+        "\na\n" +
+        "?\n" +
+        "b\n" +
+        ":\n" +
+        "c\n" +
+        ";\n");
+
+    Node hookExpr = root.getFirstChild().getFirstChild();
+    Node condExpr = hookExpr.getFirstChild();
+    Node thenExpr = condExpr.getNext();
+    Node elseExpr = thenExpr.getNext();
+
+    assertNodePosition(2, 0, hookExpr);
+    assertNodePosition(1, 0, condExpr);
+    assertNodePosition(3, 0, thenExpr);
+    assertNodePosition(5, 0, elseExpr);
+  }
+
+  public void testLabelLocation() {
+    Node root = newParse(
+        "\nfoo:\n" +
+        "a = 1;\n" +
+        "bar:\n" +
+        "b = 2;\n");
+
+    Node firstStmt = root.getFirstChild();
+    Node secondStmt = firstStmt.getNext();
+
+    assertNodePosition(1, 0, firstStmt);
+    assertNodePosition(3, 0, secondStmt);
+  }
+
+  public void testCompareLocation() {
+    Node root = newParse(
+        "\na\n" +
+        "<\n" +
+        "b\n");
+
+    Node condClause = root.getFirstChild().getFirstChild();
+    Node lhs = condClause.getFirstChild();
+    Node rhs = lhs.getNext();
+
+    assertNodePosition(2, 0, condClause);
+    assertNodePosition(1, 0, lhs);
+    assertNodePosition(3, 0, rhs);
+   }
+
+  public void testEqualityLocation() {
+    Node root = newParse(
+        "\na\n" +
+        "==\n" +
+        "b\n");
+
+    Node condClause = root.getFirstChild().getFirstChild();
+    Node lhs = condClause.getFirstChild();
+    Node rhs = lhs.getNext();
+
+    assertNodePosition(2, 0, condClause);
+    assertNodePosition(1, 0, lhs);
+    assertNodePosition(3, 0, rhs);
+  }
+
+  public void testPlusEqLocation() {
+    Node root = newParse(
+        "\na\n" +
+        "+=\n" +
+        "b\n");
+
+    Node condClause = root.getFirstChild().getFirstChild();
+    Node lhs = condClause.getFirstChild();
+    Node rhs = lhs.getNext();
+
+    assertNodePosition(2, 0, condClause);
+    assertNodePosition(1, 0, lhs);
+    assertNodePosition(3, 0, rhs);
+  }
+
+  public void testCommaLocation() {
+    Node root = newParse(
+        "\na,\n" +
+        "b,\n" +
+        "c;\n");
+
+    Node statement = root.getFirstChild();
+    Node comma1 = statement.getFirstChild();
+    Node comma2 = comma1.getFirstChild();
+    Node cRef = comma2.getNext();
+    Node aRef = comma2.getFirstChild();
+    Node bRef = aRef.getNext();
+
+    assertNodePosition(1, 1, comma2);
+    assertNodePosition(1, 0, aRef);
+    assertNodePosition(2, 0, bRef);
+    assertNodePosition(3, 0, cRef);
+  }
+
+  public void testRegexpLocation() {
+    Node root = newParse(
+        "\nvar path =\n" +
+        "replace(\n" +
+        "/a/g," +
+        "'/');\n");
+
+    Node firstVarDecl = root.getFirstChild();
+    Node firstVar = firstVarDecl.getFirstChild();
+    Node firstInitializer = firstVar.getFirstChild();
+    Node callNode = firstVar.getFirstChild();
+    Node fnName = callNode.getFirstChild();
+    Node regexObject = fnName.getNext();
+    Node aString = regexObject.getFirstChild();
+    Node endRegexString = regexObject.getNext();
+
+    assertNodePosition(1, 0, firstVarDecl);
+    assertNodePosition(1, 4, firstVar);
+    assertNodePosition(2, 7, callNode);
+    assertNodePosition(2, 0, fnName);
+    assertNodePosition(3, 0, regexObject);
+    assertNodePosition(3, 0, aString);
+    assertNodePosition(3, 5, endRegexString);
+  }
+
+  public void testNestedOr() {
+    Node root = newParse(
+        "\nif (a && \n" +
+        "    b() || \n" +
+        "    /* comment */\n" +
+        "    c) {\n" +
+        "}\n"
+    );
+
+    Node ifStmt = root.getFirstChild();
+    Node orClause = ifStmt.getFirstChild();
+    Node andClause = orClause.getFirstChild();
+    Node cName = andClause.getNext();
+
+    assertNodePosition(1, 0, ifStmt);
+    assertNodePosition(2, 8, orClause);
+    assertNodePosition(1, 6, andClause);
+    assertNodePosition(4, 4, cName);
+
+  }
+
+  public void testBitwiseOps() {
+      Node root = newParse(
+        "\nif (a & \n" +
+        "    b() | \n" +
+        "    /* comment */\n" +
+        "    c) {\n" +
+        "}\n"
+    );
+
+    Node ifStmt = root.getFirstChild();
+    Node bitOr = ifStmt.getFirstChild();
+    Node bitAnd = bitOr.getFirstChild();
+    Node cName = bitAnd.getNext();
+
+    assertNodePosition(1, 0, ifStmt);
+    assertNodePosition(2, 8, bitOr);
+    assertNodePosition(1, 6, bitAnd);
+    assertNodePosition(4, 4, cName);
+
+  }
+
+  public void testObjectLitLocation() {
+    Node root = newParse(
+        "\nvar foo =\n" +
+        "{ \n" +
+        "'A' : 'A', \n" +
+        "'B' : 'B', \n" +
+        "'C' :\n" +
+        "    'C' \n" +
+        "};\n");
+
+    Node firstVarDecl = root.getFirstChild();
+    Node firstVar = firstVarDecl.getFirstChild();
+    Node firstObjectLit = firstVar.getFirstChild();
+    Node firstKey = firstObjectLit.getFirstChild();
+    Node firstValue = firstKey.getNext();
+
+    Node secondKey = firstValue.getNext();
+    Node secondValue = secondKey.getNext();
+
+    Node thirdKey = secondValue.getNext();
+    Node thirdValue = thirdKey.getNext();
+
+    assertNodePosition(1, 4, firstVar);
+    assertNodePosition(2, 0, firstObjectLit);
+
+    assertNodePosition(3, 0, firstKey);
+    assertNodePosition(3, 6, firstValue);
+
+    assertNodePosition(4, 0, secondKey);
+    assertNodePosition(4, 6, secondValue);
+
+    assertNodePosition(5, 0, thirdKey);
+    assertNodePosition(6, 4, thirdValue);
+  }
+
+  public void testTryWithoutCatchLocation() {
+     Node root = newParse(
+         "\ntry {\n" +
+         "  var x = 1;\n" +
+         "} finally {\n" +
+         "  var y = 2;\n" +
+         "}\n");
+
+    Node tryStmt = root.getFirstChild();
+    Node tryBlock = tryStmt.getFirstChild();
+    Node catchBlock = tryBlock.getNext();
+    Node finallyBlock = catchBlock.getNext();
+    Node finallyStmt = finallyBlock.getFirstChild();
+
+    assertNodePosition(1, 0, tryStmt);
+    assertNodePosition(1, 4, tryBlock);
+    assertNodePosition(3, 0, catchBlock);
+    assertNodePosition(3, 10, finallyBlock);
+    assertNodePosition(4, 2, finallyStmt);
+  }
+
+  public void testTryWithoutFinallyLocation() {
+     Node root = newParse(
+         "\ntry {\n" +
+         "  var x = 1;\n" +
+         "} catch (ex) {\n" +
+         "  var y = 2;\n" +
+         "}\n");
+
+    Node tryStmt = root.getFirstChild();
+    Node tryBlock = tryStmt.getFirstChild();
+    Node catchBlock = tryBlock.getNext();
+    Node catchStmt = catchBlock.getFirstChild();
+    Node exceptionVar = catchStmt.getFirstChild();
+    Node catchCondition = exceptionVar.getNext();
+    Node exceptionBlock = catchCondition.getNext();
+    Node varDecl = exceptionBlock.getFirstChild();
+
+
+    assertNodePosition(1, 0, tryStmt);
+    assertNodePosition(1, 4, tryBlock);
+    assertNodePosition(3, 0, catchBlock);
+    assertNodePosition(3, 2, catchStmt);
+    assertNodePosition(3, 9, exceptionVar);
+    assertNodePosition(3, 9, catchCondition);
+    assertNodePosition(3, 13, exceptionBlock);
+    assertNodePosition(4, 2, varDecl);
+  }
+
+  public void testMultilineEqLocation() {
+    Node  root = newParse(
+        "\nif\n" +
+        "    (((a == \n" +
+        "  3) && \n" +
+        "  (b == 2)) || \n" +
+        " (c == 1)) {\n" +
+        "}\n");
+    Node ifStmt = root.getFirstChild();
+    Node orTest = ifStmt.getFirstChild();
+    Node andTest = orTest.getFirstChild();
+    Node cTest = andTest.getNext();
+    Node aTest = andTest.getFirstChild();
+    Node bTest = aTest.getNext();
+
+    assertNodePosition(1, 0, ifStmt);
+    assertNodePosition(4, 12, orTest);
+    assertNodePosition(3, 5, andTest);
+    assertNodePosition(2, 9, aTest);
+    assertNodePosition(4, 5, bTest);
+    assertNodePosition(5, 4, cTest);
+  }
+
+  public void testMultilineBitTestLocation() {
+    Node root = newParse(
+        "\nif (\n" +
+        "      ((a \n" +
+        "        | 3 \n" +
+        "       ) == \n" +
+        "       (b \n" +
+        "        & 2)) && \n" +
+        "      ((a \n" +
+        "         ^ 0xffff) \n" +
+        "       != \n" +
+        "       (c \n" +
+        "        << 1))) {\n" +
+        "}\n");
+
+    Node ifStmt = root.getFirstChild();
+    Node andTest = ifStmt.getFirstChild();
+    Node eqTest = andTest.getFirstChild();
+    Node notEqTest = eqTest.getNext();
+
+    Node bitOrTest = eqTest.getFirstChild();
+    Node bitAndTest = bitOrTest.getNext();
+
+    Node bitXorTest = notEqTest.getFirstChild();
+    Node bitShiftTest = bitXorTest.getNext();
+
+    assertNodePosition(1, 0, ifStmt);
+
+    assertNodePosition(4, 9, eqTest);
+    assertNodePosition(9, 7, notEqTest);
+
+    assertNodePosition(3, 8, bitOrTest);
+    assertNodePosition(6, 8, bitAndTest);
+    assertNodePosition(8, 9, bitXorTest);
+    assertNodePosition(11, 8, bitShiftTest);
+  }
+
+  public void testCallLocation() {
+    Node root = newParse(
+        "\na.\n" +
+        "b.\n" +
+        "cccc(1);\n");
+
+    Node exprStmt = root.getFirstChild();
+    Node functionCall = exprStmt.getFirstChild();
+    Node functionProp = functionCall.getFirstChild();
+    Node firstNameComponent = functionProp.getFirstChild();
+    Node lastNameComponent = firstNameComponent.getNext();
+
+    assertNodePosition(3, 4, functionCall);
+    // TODO(user) New Rhino doesn't keep the position of the dot handy.
+    // New Rhino treats the location of the qualified name as the beginning of
+    // the whole name.
+    // assertNodePosition(1, 0, firstNameComponent);
+    assertNodePosition(3, 0, lastNameComponent);
+  }
+
+  public void testLinenoDeclaration() {
+    Node root = newParse(
+        "\na.\n" +
+        "b=\n" +
+        "function() {};\n");
+
+    Node exprStmt = root.getFirstChild();
+    Node fnAssignment =  exprStmt.getFirstChild();
+    Node aDotbName = fnAssignment.getFirstChild();
+    Node aName = aDotbName.getFirstChild();
+    Node bName = aName.getNext();
+    Node fnNode = aDotbName.getNext();
+    Node fnName = fnNode.getFirstChild();
+
+    assertNodePosition(2, 1, fnAssignment);
+    // TODO(user) New Rhino doesn't keep track of the position of the dot.
+    //assertNodePosition(1, 1, aDotbName);
+    assertNodePosition(1, 0, aName);
+    assertNodePosition(2, 0, bName);
+    assertNodePosition(3, 8, fnNode);
+    assertNodePosition(3, 8, fnName);
+   }
+
+  private void assertMarkerPosition(Node n, int lineno, int charno) {
+    int count = 0;
+    for (JSDocInfo.Marker marker : n.getJSDocInfo().getMarkers()) {
+      assertEquals(lineno, marker.annotation.getStartLine());
+      assertEquals(charno, marker.annotation.getPositionOnStartLine());
+      count++;
+    }
+    assertEquals(1, count);
+  }
+
+  private void assertNodePosition(int lineno, int charno, Node n) {
+    assertEquals("Line number", lineno, n.getLineno());
+    assertEquals("Column position", charno, n.getCharno());
+  }
+
+  private void parse(String string) {
+    String compare = newParse(string).checkTreeEquals(oldParse(string));
+    assertTrue(compare, compare == null);
+  }
+
+  private Node newParse(String string) {
+    CompilerEnvirons environment = new CompilerEnvirons();
+
+    environment.setRecordingComments(true);
+    environment.setRecordingLocalJsDocComments(true);
+
+    Parser p = new Parser(environment);
+    AstRoot script = p.parse(string, null, 0);
+
+    Config config = new Config(
+        registry, ParserRunner.getAnnotationNames(), true);
+    Node root = IRFactory.transformTree(script, string, config,
+        new TestErrorReporter(null, null));
+
+    return root;
+  }
+
+  private Node oldParse(String string) {
+    com.google.javascript.rhino.CompilerEnvirons environment =
+        new com.google.javascript.rhino.CompilerEnvirons();
+
+    environment.setParseJSDoc(true);
+
+    com.google.javascript.rhino.Parser p =
+        new com.google.javascript.rhino.Parser(environment, null);
+
+    Node root = p.parse(string, null, 0);
+
+    return root;
+  }
+}
diff --git a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
new file mode 100644
index 0000000..9c37fc4
--- /dev/null
+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
@@ -0,0 +1,2312 @@
+/*
+ * Copyright 2007 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp.parsing;
+
+import com.google.common.collect.Sets;
+import com.google.javascript.jscomp.mozilla.rhino.CompilerEnvirons;
+import com.google.javascript.jscomp.mozilla.rhino.Parser;
+import com.google.javascript.jscomp.mozilla.rhino.ast.AstRoot;
+import com.google.javascript.jscomp.mozilla.rhino.ast.Comment;
+import com.google.javascript.jscomp.testing.TestErrorReporter;
+import com.google.javascript.rhino.JSDocInfo;
+import com.google.javascript.rhino.JSDocInfo.Visibility;
+import com.google.javascript.rhino.JSTypeExpression;
+import com.google.javascript.rhino.Node;
+import com.google.javascript.rhino.Token;
+import com.google.javascript.rhino.jstype.JSType;
+import com.google.javascript.rhino.jstype.NamedType;
+import com.google.javascript.rhino.jstype.ObjectType;
+import com.google.javascript.rhino.testing.BaseJSTypeTestCase;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+
+public class JsDocInfoParserTest extends BaseJSTypeTestCase {
+
+  private Set<String> extraAnnotations;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    extraAnnotations = Sets.newHashSet(ParserRunner.getAnnotationNames());
+  }
+
+  public void testParseTypeViaStatic1() throws Exception {
+    Node typeNode = parseType("null");
+    assertTypeEquals(NULL_TYPE, typeNode);
+  }
+
+  public void testParseTypeViaStatic2() throws Exception {
+    Node typeNode = parseType("string");
+    assertTypeEquals(STRING_TYPE, typeNode);
+  }
+
+  public void testParseTypeViaStatic3() throws Exception {
+    Node typeNode = parseType("!Date");
+    assertTypeEquals(DATE_TYPE, typeNode);
+  }
+
+  public void testParseTypeViaStatic4() throws Exception {
+    Node typeNode = parseType("boolean|string");
+    assertTypeEquals(createUnionType(BOOLEAN_TYPE, STRING_TYPE), typeNode);
+  }
+
+  public void testParseInvalidTypeViaStatic() throws Exception {
+    Node typeNode = parseType("sometype.<anothertype");
+    assertNull(typeNode);
+  }
+
+  public void testParseInvalidTypeViaStatic2() throws Exception {
+    Node typeNode = parseType("");
+    assertNull(typeNode);
+  }
+
+  public void testParseNamedType1() throws Exception {
+    assertNull(parse("@type null", "Unexpected end of file"));
+  }
+
+  public void testParseNamedType2() throws Exception {
+    JSDocInfo info = parse("@type null*/");
+    assertTypeEquals(NULL_TYPE, info.getType());
+  }
+
+  public void testParseNamedType3() throws Exception {
+    JSDocInfo info = parse("@type {string}*/");
+    assertTypeEquals(STRING_TYPE, info.getType());
+  }
+
+  public void testParseNamedType4() throws Exception {
+    // Multi-line @type.
+    JSDocInfo info = parse("@type \n {string}*/");
+    assertTypeEquals(STRING_TYPE, info.getType());
+  }
+
+  public void testTypedefType1() throws Exception {
+    JSDocInfo info = parse("@typedef string */");
+    assertTrue(info.hasTypedefType());
+    assertTypeEquals(STRING_TYPE, info.getTypedefType());
+  }
+
+  public void testTypedefType2() throws Exception {
+    JSDocInfo info = parse("@typedef \n {string}*/");
+    assertTrue(info.hasTypedefType());
+    assertTypeEquals(STRING_TYPE, info.getTypedefType());
+  }
+
+  public void testTypedefType3() throws Exception {
+    JSDocInfo info = parse("@typedef \n {(string|number)}*/");
+    assertTrue(info.hasTypedefType());
+    assertTypeEquals(
+        createUnionType(NUMBER_TYPE, STRING_TYPE),
+        info.getTypedefType());
+  }
+
+  public void testParseStringType1() throws Exception {
+    assertTypeEquals(STRING_TYPE, parse("@type {string}*/").getType());
+  }
+
+  public void testParseStringType2() throws Exception {
+    assertTypeEquals(STRING_OBJECT_TYPE, parse("@type {!String}*/").getType());
+  }
+
+  public void testParseBooleanType1() throws Exception {
+    assertTypeEquals(BOOLEAN_TYPE, parse("@type {boolean}*/").getType());
+  }
+
+  public void testParseBooleanType2() throws Exception {
+    assertTypeEquals(BOOLEAN_OBJECT_TYPE, parse("@type {!Boolean}*/").getType());
+  }
+
+  public void testParseNumberType1() throws Exception {
+    assertTypeEquals(NUMBER_TYPE, parse("@type {number}*/").getType());
+  }
+
+  public void testParseNumberType2() throws Exception {
+    assertTypeEquals(NUMBER_OBJECT_TYPE, parse("@type {!Number}*/").getType());
+  }
+
+  public void testParseNullType1() throws Exception {
+    assertTypeEquals(NULL_TYPE, parse("@type {null}*/").getType());
+  }
+
+  public void testParseNullType2() throws Exception {
+    assertTypeEquals(NULL_TYPE, parse("@type {Null}*/").getType());
+  }
+
+  public void testParseAllType1() throws Exception {
+    testParseType("*");
+  }
+
+  public void testParseAllType2() throws Exception {
+    testParseType("*?", "*");
+  }
+
+  public void testParseObjectType() throws Exception {
+    assertTypeEquals(OBJECT_TYPE, parse("@type {!Object}*/").getType());
+  }
+
+  public void testParseDateType() throws Exception {
+    assertTypeEquals(DATE_TYPE, parse("@type {!Date}*/").getType());
+  }
+
+  public void testParseFunctionType() throws Exception {
+    assertTypeEquals(
+        createNullableType(U2U_CONSTRUCTOR_TYPE),
+        parse("@type {Function}*/").getType());
+  }
+
+  public void testParseRegExpType() throws Exception {
+    assertTypeEquals(REGEXP_TYPE, parse("@type {!RegExp}*/").getType());
+  }
+
+  public void testParseErrorTypes() throws Exception {
+    assertTypeEquals(ERROR_TYPE, parse("@type {!Error}*/").getType());
+    assertTypeEquals(URI_ERROR_TYPE, parse("@type {!URIError}*/").getType());
+    assertTypeEquals(EVAL_ERROR_TYPE, parse("@type {!EvalError}*/").getType());
+    assertTypeEquals(REFERENCE_ERROR_TYPE,
+        parse("@type {!ReferenceError}*/").getType());
+    assertTypeEquals(TYPE_ERROR_TYPE, parse("@type {!TypeError}*/").getType());
+    assertTypeEquals(RANGE_ERROR_TYPE, parse("@type {!RangeError}*/").getType());
+    assertTypeEquals(SYNTAX_ERROR_TYPE, parse("@type {!SyntaxError}*/").getType());
+  }
+
+  public void testParseUndefinedType1() throws Exception {
+    assertTypeEquals(VOID_TYPE, parse("@type {undefined}*/").getType());
+  }
+
+  public void testParseUndefinedType2() throws Exception {
+    assertTypeEquals(VOID_TYPE, parse("@type {Undefined}*/").getType());
+  }
+
+  public void testParseUndefinedType3() throws Exception {
+    assertTypeEquals(VOID_TYPE, parse("@type {void}*/").getType());
+  }
+
+  public void testParseParametrizedType1() throws Exception {
+    JSDocInfo info = parse("@type !Array.<number> */");
+    assertTypeEquals(ARRAY_TYPE, info.getType());
+  }
+
+  public void testParseParametrizedType2() throws Exception {
+    JSDocInfo info = parse("@type {!Array.<number>}*/");
+    assertTypeEquals(ARRAY_TYPE, info.getType());
+  }
+
+  public void testParseParametrizedType3() throws Exception {
+    JSDocInfo info = parse("@type !Array.<(number,null)>*/");
+    assertTypeEquals(ARRAY_TYPE, info.getType());
+  }
+
+  public void testParseParametrizedType4() throws Exception {
+    JSDocInfo info = parse("@type {!Array.<(number|null)>}*/");
+    assertTypeEquals(ARRAY_TYPE, info.getType());
+  }
+
+  public void testParseParametrizedType5() throws Exception {
+    JSDocInfo info = parse("@type {!Array.<Array.<(number|null)>>}*/");
+    assertTypeEquals(ARRAY_TYPE, info.getType());
+  }
+
+  public void testParseParametrizedType6() throws Exception {
+    JSDocInfo info = parse("@type {!Array.<!Array.<(number|null)>>}*/");
+    assertTypeEquals(ARRAY_TYPE, info.getType());
+  }
+
+  public void testParseParametrizedType7() throws Exception {
+    JSDocInfo info = parse("@type {!Array.<function():Date>}*/");
+    assertTypeEquals(ARRAY_TYPE, info.getType());
+  }
+
+  public void testParseParametrizedType8() throws Exception {
+    JSDocInfo info = parse("@type {!Array.<function():!Date>}*/");
+    assertTypeEquals(ARRAY_TYPE, info.getType());
+  }
+
+  public void testParseParametrizedType9() throws Exception {
+    JSDocInfo info = parse("@type {!Array.<Date|number>}*/");
+    assertTypeEquals(ARRAY_TYPE, info.getType());
+  }
+
+  public void testParseParametrizedType10() throws Exception {
+    JSDocInfo info = parse("@type {!Array.<Date|number|boolean>}*/");
+    assertTypeEquals(ARRAY_TYPE, info.getType());
+  }
+
+  public void testParseParamterizedType11() throws Exception {
+    JSDocInfo info = parse("@type {!Object.<number>}*/");
+    assertTypeEquals(OBJECT_TYPE, info.getType());
+    assertParameterTypeEquals(NUMBER_TYPE, info.getType());
+  }
+
+  public void testParseParamterizedType12() throws Exception {
+    JSDocInfo info = parse("@type {!Object.<string,number>}*/");
+    assertTypeEquals(OBJECT_TYPE, info.getType());
+    assertParameterTypeEquals(NUMBER_TYPE, info.getType());
+    assertIndexTypeEquals(STRING_TYPE, info.getType());
+  }
+
+  public void testParseUnionType1() throws Exception {
+    JSDocInfo info = parse("@type {(boolean,null)}*/");
+    assertTypeEquals(createUnionType(BOOLEAN_TYPE, NULL_TYPE), info.getType());
+  }
+
+  public void testParseUnionType2() throws Exception {
+    JSDocInfo info = parse("@type {boolean|null}*/");
+    assertTypeEquals(createUnionType(BOOLEAN_TYPE, NULL_TYPE), info.getType());
+  }
+
+  public void testParseUnionType3() throws Exception {
+    JSDocInfo info = parse("@type {boolean||null}*/");
+    assertTypeEquals(createUnionType(BOOLEAN_TYPE, NULL_TYPE), info.getType());
+  }
+
+  public void testParseUnionType4() throws Exception {
+    JSDocInfo info = parse("@type {(Array.<boolean>,null)}*/");
+    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());
+  }
+
+  public void testParseUnionType5() throws Exception {
+    JSDocInfo info = parse("@type {(null, Array.<boolean>)}*/");
+    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());
+  }
+
+  public void testParseUnionType6() throws Exception {
+    JSDocInfo info = parse("@type {Array.<boolean>|null}*/");
+    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());
+  }
+
+  public void testParseUnionType7() throws Exception {
+    JSDocInfo info = parse("@type {null|Array.<boolean>}*/");
+    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());
+  }
+
+  public void testParseUnionType8() throws Exception {
+    JSDocInfo info = parse("@type {null||Array.<boolean>}*/");
+    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());
+  }
+
+  public void testParseUnionType9() throws Exception {
+    JSDocInfo info = parse("@type {Array.<boolean>||null}*/");
+    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());
+  }
+
+  public void testParseUnionType10() throws Exception {
+    parse("@type {string|}*/", "type not recognized due to syntax error");
+  }
+
+  public void testParseUnionType11() throws Exception {
+    parse("@type {(string,)}*/", "type not recognized due to syntax error");
+  }
+
+  public void testParseUnionType12() throws Exception {
+    parse("@type {()}*/", "type not recognized due to syntax error");
+  }
+
+  public void testParseUnionType13() throws Exception {
+    testParseType(
+        "(function(this:Date),function(this:String):number)",
+        "(function (this:Date): ?|function (this:String): number)");
+  }
+
+  public void testParseUnionType14() throws Exception {
+    testParseType(
+        "(function(...[function(number):boolean]):number)|" +
+        "function(this:String, string):number",
+        "(function (...[function (number): boolean]): number|" +
+        "function (this:String, string): number)");
+  }
+
+  public void testParseUnionType15() throws Exception {
+    testParseType("*|number", "*");
+  }
+
+  public void testParseUnionType16() throws Exception {
+    testParseType("number|*", "*");
+  }
+
+  public void testParseUnionType17() throws Exception {
+    testParseType("string|number|*", "*");
+  }
+
+  public void testParseUnionType18() throws Exception {
+    testParseType("(string,*,number)", "*");
+  }
+
+  public void testParseUnionTypeError1() throws Exception {
+    parse("@type {(string,|number)} */",
+        "type not recognized due to syntax error");
+  }
+
+  public void testParseFunctionalType1() throws Exception {
+    testParseType("function (): number");
+  }
+
+  public void testParseFunctionalType2() throws Exception {
+    testParseType("function (number, string): boolean");
+  }
+
+  public void testParseFunctionalType3() throws Exception {
+    testParseType(
+        "function(this:Array)", "function (this:Array): ?");
+  }
+
+  public void testParseFunctionalType4() throws Exception {
+    testParseType("function (...[number]): boolean");
+  }
+
+  public void testParseFunctionalType5() throws Exception {
+    testParseType("function (number, ...[string]): boolean");
+  }
+
+  public void testParseFunctionalType6() throws Exception {
+    testParseType(
+        "function (this:Date, number): (boolean|number|string)");
+  }
+
+  public void testParseFunctionalType7() throws Exception {
+    testParseType("function()", "function (): ?");
+  }
+
+  public void testParseFunctionalType8() throws Exception {
+    testParseType(
+        "function(this:Array,...[boolean])",
+        "function (this:Array, ...[boolean]): ?");
+  }
+
+  public void testParseFunctionalType9() throws Exception {
+    testParseType(
+        "function(this:Array,!Date,...[boolean?])",
+        "function (this:Array, Date, ...[(boolean|null)]): ?");
+  }
+
+  public void testParseFunctionalType10() throws Exception {
+    testParseType(
+        "function(...[Object?]):boolean?",
+        "function (...[(Object|null)]): (boolean|null)");
+  }
+
+  public void testParseFunctionalType11() throws Exception {
+    testParseType(
+        "function(...[[number]]):[number?]",
+        "function (...[Array]): Array");
+  }
+
+  public void testParseFunctionalType12() throws Exception {
+    testParseType(
+        "function(...)",
+        "function (...[?]): ?");
+  }
+
+  public void testParseFunctionalType13() throws Exception {
+    testParseType(
+        "function(...): void",
+        "function (...[?]): undefined");
+  }
+
+  public void testParseFunctionalType14() throws Exception {
+    testParseType("function (*, string, number): boolean");
+  }
+
+  public void testBug1419535() throws Exception {
+    parse("@type {function(Object, string, *)?} */");
+    parse("@type {function(Object, string, *)|null} */");
+  }
+
+  public void testParseFunctionalTypeError1() throws Exception {
+    parse("@type {function number):string}*/", "missing opening (");
+  }
+
+  public void testParseFunctionalTypeError2() throws Exception {
+    parse("@type {function( number}*/", "missing closing )");
+  }
+
+  public void testParseFunctionalTypeError3() throws Exception {
+    parse("@type {function(...[number], string)}*/",
+        "variable length argument must be last");
+  }
+
+  public void testParseFunctionalTypeError4() throws Exception {
+    parse("@type {function(string, ...[number], boolean):string}*/",
+        "variable length argument must be last");
+  }
+
+  public void testParseFunctionalTypeError5() throws Exception {
+    parse("@type {function (thi:Array)}*/", "missing closing )");
+  }
+
+  public void testParseFunctionalTypeError6() throws Exception {
+    resolve(parse("@type {function (this:number)}*/").getType(),
+        "this type must be an object type");
+  }
+
+  public void testParseFunctionalTypeError7() throws Exception {
+    parse("@type {function(...[number)}*/", "missing closing ]");
+  }
+
+  public void testParseFunctionalTypeError8() throws Exception {
+    parse("@type {function(...number])}*/", "missing opening [");
+  }
+
+  public void testParseArrayType1() throws Exception {
+    testParseType("[number]", "Array");
+  }
+
+  public void testParseArrayType2() throws Exception {
+    testParseType("[(number,boolean,[Object?])]", "Array");
+  }
+
+  public void testParseArrayType3() throws Exception {
+    testParseType("[[number],[string]]?", "(Array|null)");
+  }
+
+  public void testParseArrayTypeError1() throws Exception {
+    parse("@type {[number}*/", "missing closing ]");
+  }
+
+  public void testParseArrayTypeError2() throws Exception {
+    parse("@type {number]}*/", "expected closing }");
+  }
+
+  public void testParseArrayTypeError3() throws Exception {
+    parse("@type {[(number,boolean,Object?])]}*/", "missing closing )");
+  }
+
+  public void testParseArrayTypeError4() throws Exception {
+    parse("@type {(number,boolean,[Object?)]}*/",
+        "missing closing ]");
+  }
+
+  private void testParseType(String type) throws Exception {
+    testParseType(type, type);
+  }
+
+  private void testParseType(
+      String type, String typeExpected) throws Exception {
+    JSDocInfo info = parse("@type {" + type + "}*/");
+
+    assertNotNull(info);
+    assertTrue(info.hasType());
+    assertEquals(typeExpected, resolve(info.getType()).toString());
+  }
+
+  public void testParseNullableModifiers1() throws Exception {
+    JSDocInfo info = parse("@type {string?}*/");
+    assertTypeEquals(createNullableType(STRING_TYPE), info.getType());
+  }
+
+  public void testParseNullableModifiers2() throws Exception {
+    JSDocInfo info = parse("@type {!Array.<string?>}*/");
+    assertTypeEquals(ARRAY_TYPE, info.getType());
+  }
+
+  public void testParseNullableModifiers3() throws Exception {
+    JSDocInfo info = parse("@type {Array.<boolean>?}*/");
+    assertTypeEquals(createNullableType(ARRAY_TYPE), info.getType());
+  }
+
+  public void testParseNullableModifiers4() throws Exception {
+    JSDocInfo info = parse("@type {(string,boolean)?}*/");
+    assertTypeEquals(
+        createNullableType(createUnionType(STRING_TYPE, BOOLEAN_TYPE)),
+        info.getType());
+  }
+
+  public void testParseNullableModifiers5() throws Exception {
+    JSDocInfo info = parse("@type {(string?,boolean)}*/");
+    assertTypeEquals(
+        createUnionType(createNullableType(STRING_TYPE), BOOLEAN_TYPE),
+        info.getType());
+  }
+
+  public void testParseNullableModifiers6() throws Exception {
+    JSDocInfo info = parse("@type {(string,boolean?)}*/");
+    assertTypeEquals(
+        createUnionType(STRING_TYPE, createNullableType(BOOLEAN_TYPE)),
+        info.getType());
+  }
+
+  public void testParseNullableModifiers7() throws Exception {
+    JSDocInfo info = parse("@type {string?|boolean}*/");
+    assertTypeEquals(
+        createUnionType(createNullableType(STRING_TYPE), BOOLEAN_TYPE),
+        info.getType());
+  }
+
+  public void testParseNullableModifiers8() throws Exception {
+    JSDocInfo info = parse("@type {string|boolean?}*/");
+    assertTypeEquals(
+        createUnionType(STRING_TYPE, createNullableType(BOOLEAN_TYPE)),
+        info.getType());
+  }
+
+  public void testParseNullableModifiers9() throws Exception {
+    JSDocInfo info = parse("@type {foo.Hello.World?}*/");
+    assertTypeEquals(createNullableType(new NamedType(
+        registry, "foo.Hello.World", null, -1, -1)),
+        info.getType());
+  }
+
+  public void testParseOptionalModifier() throws Exception {
+    JSDocInfo info = parse("@type {function(number=)}*/");
+    assertTypeEquals(
+        registry.createFunctionType(
+            UNKNOWN_TYPE, createUnionType(VOID_TYPE, NUMBER_TYPE)),
+        info.getType());
+  }
+
+  public void testParseNewline1() throws Exception {
+    JSDocInfo info = parse("@type {string\n* }\n*/");
+    assertTypeEquals(STRING_TYPE, info.getType());
+  }
+
+  public void testParseNewline2() throws Exception {
+    JSDocInfo info = parse("@type !Array.<\n* number\n* > */");
+    assertTypeEquals(ARRAY_TYPE, info.getType());
+  }
+
+  public void testParseNewline3() throws Exception {
+    JSDocInfo info = parse("@type !Array.<(number,\n* null)>*/");
+    assertTypeEquals(ARRAY_TYPE, info.getType());
+  }
+
+  public void testParseNewline4() throws Exception {
+    JSDocInfo info = parse("@type !Array.<(number|\n* null)>*/");
+    assertTypeEquals(ARRAY_TYPE, info.getType());
+  }
+
+  public void testParseNewline5() throws Exception {
+    JSDocInfo info = parse("@type !Array.<function(\n* )\n* :\n* Date>*/");
+    assertTypeEquals(ARRAY_TYPE, info.getType());
+  }
+
+  public void testParseReturnType1() throws Exception {
+    JSDocInfo info =
+        parse("@return {null|string|Array.<boolean>}*/");
+    assertTypeEquals(
+        createUnionType(ARRAY_TYPE, NULL_TYPE, STRING_TYPE),
+        info.getReturnType());
+  }
+
+  public void testParseReturnType2() throws Exception {
+    JSDocInfo info =
+        parse("@returns {null|(string,Array.<boolean>)}*/");
+    assertTypeEquals(
+        createUnionType(ARRAY_TYPE, NULL_TYPE, STRING_TYPE),
+        info.getReturnType());
+  }
+
+  public void testParseReturnType3() throws Exception {
+    JSDocInfo info =
+        parse("@return {((null||Array.<boolean>,string),boolean)}*/");
+    assertTypeEquals(
+        createUnionType(ARRAY_TYPE, NULL_TYPE, STRING_TYPE, BOOLEAN_TYPE),
+        info.getReturnType());
+  }
+
+  public void testParseThisType1() throws Exception {
+    JSDocInfo info =
+        parse("@this {goog.foo.Bar}*/");
+    assertTypeEquals(
+        new NamedType(registry, "goog.foo.Bar", null, -1, -1),
+        info.getThisType());
+  }
+
+  public void testParseThisType2() throws Exception {
+    JSDocInfo info =
+        parse("@this goog.foo.Bar*/");
+    assertTypeEquals(
+        new NamedType(registry, "goog.foo.Bar", null, -1, -1),
+        info.getThisType());
+  }
+
+  public void testParseThisType3() throws Exception {
+    parse("@type {number}\n@this goog.foo.Bar*/",
+        "type annotation incompatible with other annotations");
+  }
+
+  public void testParseThisType4() throws Exception {
+    resolve(parse("@this number*/").getThisType(),
+        "@this must specify an object type");
+  }
+
+  public void testParseThisType5() throws Exception {
+    parse("@this {Date|Error}*/");
+  }
+
+  public void testParseThisType6() throws Exception {
+    resolve(parse("@this {Date|number}*/").getThisType(),
+        "@this must specify an object type");
+  }
+
+  public void testParseParam1() throws Exception {
+    JSDocInfo info = parse("@param {number} index*/");
+    assertEquals(1, info.getParameterCount());
+    assertTypeEquals(NUMBER_TYPE, info.getParameterType("index"));
+  }
+
+  public void testParseParam2() throws Exception {
+    JSDocInfo info = parse("@param index*/");
+    assertEquals(1, info.getParameterCount());
+    assertEquals(null, info.getParameterType("index"));
+  }
+
+  public void testParseParam3() throws Exception {
+    JSDocInfo info = parse("@param {number} index useful comments*/");
+    assertEquals(1, info.getParameterCount());
+    assertTypeEquals(NUMBER_TYPE, info.getParameterType("index"));
+  }
+
+  public void testParseParam4() throws Exception {
+    JSDocInfo info = parse("@param index useful comments*/");
+    assertEquals(1, info.getParameterCount());
+    assertEquals(null, info.getParameterType("index"));
+  }
+
+  public void testParseParam5() throws Exception {
+    // Test for multi-line @param.
+    JSDocInfo info = parse("@param {number} \n index */");
+    assertEquals(1, info.getParameterCount());
+    assertTypeEquals(NUMBER_TYPE, info.getParameterType("index"));
+  }
+
+  public void testParseParam6() throws Exception {
+    // Test for multi-line @param.
+    JSDocInfo info = parse("@param {number} \n * index */");
+    assertEquals(1, info.getParameterCount());
+    assertTypeEquals(NUMBER_TYPE, info.getParameterType("index"));
+  }
+
+  public void testParseParam7() throws Exception {
+    // Optional @param
+    JSDocInfo info = parse("@param {number=} index */");
+    assertTypeEquals(
+        registry.createOptionalType(NUMBER_TYPE),
+        info.getParameterType("index"));
+  }
+
+  public void testParseParam8() throws Exception {
+    // Var args @param
+    JSDocInfo info = parse("@param {...number} index */");
+    assertTypeEquals(
+        registry.createOptionalType(NUMBER_TYPE),
+        info.getParameterType("index"));
+  }
+
+  public void testParseParam9() throws Exception {
+    parse("@param {...number=} index */",
+        "expected closing }", "expecting a variable name in a @param tag");
+  }
+
+  public void testParseParam10() throws Exception {
+    parse("@param {...number index */", "expected closing }");
+  }
+
+  public void testParseParam11() throws Exception {
+    parse("@param {number= index */", "expected closing }");
+  }
+
+  public void testParseParam12() throws Exception {
+    JSDocInfo info = parse("@param {...number|string} index */");
+    assertTypeEquals(
+        registry.createOptionalType(
+            registry.createUnionType(STRING_TYPE, NUMBER_TYPE)),
+        info.getParameterType("index"));
+  }
+
+  public void testParseParam13() throws Exception {
+    JSDocInfo info = parse("@param {...(number|string)} index */");
+    assertTypeEquals(
+        registry.createOptionalType(
+            registry.createUnionType(STRING_TYPE, NUMBER_TYPE)),
+        info.getParameterType("index"));
+  }
+
+  public void testParseParam14() throws Exception {
+    JSDocInfo info = parse("@param {string} [index] */");
+    assertEquals(1, info.getParameterCount());
+    assertTypeEquals(
+        registry.createOptionalType(STRING_TYPE),
+        info.getParameterType("index"));
+  }
+
+  public void testParseParam15() throws Exception {
+    JSDocInfo info = parse("@param {string} [index */", "missing closing ]");
+    assertEquals(1, info.getParameterCount());
+    assertTypeEquals(STRING_TYPE, info.getParameterType("index"));
+  }
+
+  public void testParseParam16() throws Exception {
+    JSDocInfo info = parse("@param {string} index] */");
+    assertEquals(1, info.getParameterCount());
+    assertTypeEquals(STRING_TYPE, info.getParameterType("index"));
+  }
+
+  public void testParseParam17() throws Exception {
+    JSDocInfo info = parse("@param {string=} [index] */");
+    assertEquals(1, info.getParameterCount());
+    assertTypeEquals(
+        registry.createOptionalType(STRING_TYPE),
+        info.getParameterType("index"));
+  }
+
+  public void testParseParam18() throws Exception {
+    JSDocInfo info = parse("@param {...string} [index] */");
+    assertEquals(1, info.getParameterCount());
+    assertTypeEquals(
+        registry.createOptionalType(STRING_TYPE),
+        info.getParameterType("index"));
+  }
+
+  public void testParseThrows1() throws Exception {
+    JSDocInfo info = parse("@throws {number} Some number */");
+    assertEquals(1, info.getThrownTypes().size());
+    assertTypeEquals(NUMBER_TYPE, info.getThrownTypes().get(0));
+  }
+
+  public void testParseThrows2() throws Exception {
+    JSDocInfo info = parse("@throws {number} Some number\n "
+                           + "*@throws {String} A string */");
+    assertEquals(2, info.getThrownTypes().size());
+    assertTypeEquals(NUMBER_TYPE, info.getThrownTypes().get(0));
+  }
+
+  public void testParseRecordType1() throws Exception {
+    parseFull("/** @param {{x}} n\n*/");
+  }
+
+  public void testParseRecordType2() throws Exception {
+    parseFull("/** @param {{z, y}} n\n*/");
+  }
+
+  public void testParseRecordType3() throws Exception {
+    parseFull("/** @param {{z, y, x, q, hello, thisisatest}} n\n*/");
+  }
+
+  public void testParseRecordType4() throws Exception {
+    parseFull("/** @param {{a, 'a', 'hello', 2, this, do, while, for}} n\n*/");
+  }
+
+  public void testParseRecordType5() throws Exception {
+    parseFull("/** @param {{x : hello}} n\n*/");
+  }
+
+  public void testParseRecordType6() throws Exception {
+    parseFull("/** @param {{'x' : hello}} n\n*/");
+  }
+
+  public void testParseRecordType7() throws Exception {
+    parseFull("/** @param {{'x' : !hello}} n\n*/");
+  }
+
+  public void testParseRecordType8() throws Exception {
+    parseFull("/** @param {{'x' : !hello, y : bar}} n\n*/");
+  }
+
+  public void testParseRecordType9() throws Exception {
+    parseFull("/** @param {{'x' : !hello, y : {z : bar, 3 : meh}}} n\n*/");
+  }
+
+  public void testParseRecordType10() throws Exception {
+    parseFull("/** @param {{__proto__ : moo}} n\n*/");
+  }
+
+  public void testParseRecordType11() throws Exception {
+    parseFull("/** @param {{a : b} n\n*/",
+              "expected closing }");
+  }
+
+  public void testParseRecordType12() throws Exception {
+    parseFull("/** @param {{!hello : hey}} n\n*/",
+              "type not recognized due to syntax error");
+  }
+
+  public void testParseRecordType13() throws Exception {
+    parseFull("/** @param {{x}|number} n\n*/");
+  }
+
+  public void testParseRecordType14() throws Exception {
+    parseFull("/** @param {{x : y}|number} n\n*/");
+  }
+
+  public void testParseRecordType15() throws Exception {
+    parseFull("/** @param {{'x' : y}|number} n\n*/");
+  }
+
+  public void testParseRecordType16() throws Exception {
+    parseFull("/** @param {{x, y}|number} n\n*/");
+  }
+
+  public void testParseRecordType17() throws Exception {
+    parseFull("/** @param {{x : hello, 'y'}|number} n\n*/");
+  }
+
+  public void testParseRecordType18() throws Exception {
+    parseFull("/** @param {number|{x : hello, 'y'}} n\n*/");
+  }
+
+  public void testParseRecordType19() throws Exception {
+    parseFull("/** @param {?{x : hello, 'y'}} n\n*/");
+  }
+
+  public void testParseRecordType20() throws Exception {
+    parseFull("/** @param {!{x : hello, 'y'}} n\n*/");
+  }
+
+  public void testParseRecordType21() throws Exception {
+    parseFull("/** @param {{x : hello, 'y'}|boolean} n\n*/");
+  }
+
+  public void testParseRecordType22() throws Exception {
+    parseFull("/** @param {{x : hello, 'y'}|function()} n\n*/");
+  }
+
+  public void testParseRecordType23() throws Exception {
+    parseFull("/** @param {{x : function(), 'y'}|function()} n\n*/");
+  }
+
+  public void testParseParamError1() throws Exception {
+    parseFull("/** @param\n*/",
+        "expecting a variable name in a @param tag");
+  }
+
+  public void testParseParamError2() throws Exception {
+    parseFull("/** @param {Number}*/",
+        "expecting a variable name in a @param tag");
+  }
+
+  public void testParseParamError3() throws Exception {
+    parseFull("/** @param {Number}\n*/",
+        "expecting a variable name in a @param tag");
+  }
+
+  public void testParseParamError4() throws Exception {
+    parseFull("/** @param {Number}\n* * num */",
+        "expecting a variable name in a @param tag");
+  }
+
+  public void testParseParamError5() throws Exception {
+    parse("@param {number} x \n * @param {string} x */",
+        "duplicate variable name \"x\"");
+  }
+
+  public void testParseExtends1() throws Exception {
+    assertTypeEquals(STRING_OBJECT_TYPE,
+                     parse("@extends String*/").getBaseType());
+  }
+
+  public void testParseExtends2() throws Exception {
+    JSDocInfo info = parse("@extends com.google.Foo.Bar.Hello.World*/");
+    assertTypeEquals(
+        new NamedType(registry, "com.google.Foo.Bar.Hello.World", null, -1, -1),
+        info.getBaseType());
+  }
+
+  public void testParseExtendsGenerics() throws Exception {
+    JSDocInfo info =
+        parse("@extends com.google.Foo.Bar.Hello.World.<Boolean,number>*/");
+    assertTypeEquals(
+        new NamedType(registry, "com.google.Foo.Bar.Hello.World", null, -1, -1),
+        info.getBaseType());
+  }
+
+  public void testParseImplementsGenerics() throws Exception {
+    // we ignore things inside <> for now
+    List<JSTypeExpression> interfaces =
+        parse("@implements {SomeInterface.<*>} */")
+        .getImplementedInterfaces();
+    assertEquals(1, interfaces.size());
+    assertTypeEquals(new NamedType(registry, "SomeInterface", null, -1, -1),
+        interfaces.get(0));
+  }
+
+  public void testParseExtends4() throws Exception {
+    assertTypeEquals(STRING_OBJECT_TYPE,
+        parse("@extends {String}*/").getBaseType());
+  }
+
+  public void testParseExtends5() throws Exception {
+    assertTypeEquals(STRING_OBJECT_TYPE,
+        parse("@extends {String*/", "expected closing }").getBaseType());
+  }
+
+  public void testParseExtends6() throws Exception {
+    // Multi-line extends
+    assertTypeEquals(STRING_OBJECT_TYPE,
+        parse("@extends \n * {String}*/").getBaseType());
+  }
+
+  public void testParseExtendsInvalidName() throws Exception {
+    // This looks bad, but for the time being it should be ok, as
+    // we will not find a type with this name in the js parsed tree.
+    // If this is fixed in the future, change this test to check for a
+    // warning/error message.
+    assertTypeEquals(
+        new NamedType(registry, "some_++#%$%_UglyString", null, -1, -1),
+        parse("@extends {some_++#%$%_UglyString} */").getBaseType());
+  }
+
+  public void testParseExtendsNullable1() throws Exception {
+    parse("@extends {Base?} */", "expected closing }");
+  }
+
+  public void testParseExtendsNullable2() throws Exception {
+    parse("@extends Base? */", "expected end of line or comment");
+  }
+
+  public void testParseEnum1() throws Exception {
+    assertTypeEquals(NUMBER_TYPE, parse("@enum*/").getEnumParameterType());
+  }
+
+  public void testParseEnum2() throws Exception {
+    assertTypeEquals(STRING_TYPE,
+        parse("@enum {string}*/").getEnumParameterType());
+  }
+
+  public void testParseEnum3() throws Exception {
+    assertTypeEquals(STRING_TYPE,
+        parse("@enum string*/").getEnumParameterType());
+  }
+
+  public void testParseDesc1() throws Exception {
+    assertEquals("hello world!",
+        parse("@desc hello world!*/").getDescription());
+  }
+
+  public void testParseDesc2() throws Exception {
+    assertEquals("hello world!",
+        parse("@desc hello world!\n*/").getDescription());
+  }
+
+  public void testParseDesc3() throws Exception {
+    assertEquals("", parse("@desc*/").getDescription());
+  }
+
+  public void testParseDesc4() throws Exception {
+    assertEquals("", parse("@desc\n*/").getDescription());
+  }
+
+  public void testParseDesc5() throws Exception {
+    assertEquals("hello world!",
+                 parse("@desc hello\nworld!\n*/").getDescription());
+  }
+
+  public void testParseDesc6() throws Exception {
+    assertEquals("hello world!",
+        parse("@desc hello\n* world!\n*/").getDescription());
+  }
+
+  public void testParseDesc7() throws Exception {
+    assertEquals("a b c", parse("@desc a\n\nb\nc*/").getDescription());
+  }
+
+  public void testParseDesc8() throws Exception {
+    assertEquals("a b c d",
+        parse("@desc a\n      *b\n\n  *c\n\nd*/").getDescription());
+  }
+
+  public void testParseDesc9() throws Exception {
+    String comment = "@desc\n.\n,\n{\n)\n}\n|\n.<\n>\n<\n?\n~\n+\n-\n;\n:\n*/";
+
+    assertEquals(". , { ) } | .< > < ? ~ + - ; :",
+        parse(comment).getDescription());
+  }
+
+  public void testParseDesc10() throws Exception {
+    String comment = "@desc\n?\n?\n?\n?*/";
+
+    assertEquals("? ? ? ?", parse(comment).getDescription());
+  }
+
+  public void testParseDesc11() throws Exception {
+    String comment = "@desc :[]*/";
+
+    assertEquals(":[]", parse(comment).getDescription());
+  }
+
+  public void testParseDesc12() throws Exception {
+    String comment = "@desc\n:\n[\n]\n...*/";
+
+    assertEquals(": [ ] ...", parse(comment).getDescription());
+  }
+
+  //public void testParsePreserveWithNoBuilderGivesWarning() throws Exception {
+  //  String comment = "@preserve Foo\nBar\n*/";
+  //  parse(comment,
+  //      "@preserve or @license annotation without file to associate it with");
+  //}
+
+  //public void testParsePreserve() throws Exception {
+  //  Node node = new Node(1);
+  //  this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();
+  //  String comment = "@preserve Foo\nBar\n\nBaz*/";
+  //  parse(comment);
+  //  assertEquals(" Foo\n Bar\n\n Baz", node.getJSDocInfo().getLicense());
+  //}
+
+  //public void testParseLicense() throws Exception {
+  //  Node node = new Node(1);
+  //  this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();
+  //  String comment = "@license Foo\nBar\n\nBaz*/";
+  //  parse(comment);
+  //  assertEquals(" Foo\n Bar\n\n Baz", node.getJSDocInfo().getLicense());
+  //}
+
+  public void testParseDefine1() throws Exception {
+    assertTypeEquals(STRING_TYPE,
+        parse("@define {string}*/").getType());
+  }
+
+  public void testParseDefine2() throws Exception {
+    assertTypeEquals(STRING_TYPE,
+        parse("@define {string*/", "expected closing }").getType());
+  }
+
+  public void testParseDefine3() throws Exception {
+    JSDocInfo info = parse("@define {boolean}*/");
+    assertTrue(info.isConstant());
+    assertTrue(info.isDefine());
+    assertTypeEquals(BOOLEAN_TYPE, info.getType());
+  }
+
+  public void testParseDefine4() throws Exception {
+    assertTypeEquals(NUMBER_TYPE, parse("@define {number}*/").getType());
+  }
+
+  public void testParseDefine5() throws Exception {
+    assertTypeEquals(createUnionType(NUMBER_TYPE, BOOLEAN_TYPE),
+        parse("@define {number|boolean}*/").getType());
+  }
+
+  public void testParseDefineErrors1() throws Exception {
+    parse("@enum {string}\n @define {string} */", "conflicting @define tag");
+  }
+
+  public void testParseDefineErrors2() throws Exception {
+    parse("@define {string}\n @enum {string} */",
+        "type annotation incompatible with other annotations");
+  }
+
+  public void testParseDefineErrors3() throws Exception {
+    parse("@const\n @define {string} */", "conflicting @define tag");
+  }
+
+  public void testParseDefineErrors4() throws Exception {
+    parse("@type string \n @define {string} */", "conflicting @define tag");
+  }
+
+  public void testParseDefineErrors5() throws Exception {
+    parse("@return {string}\n @define {string} */", "conflicting @define tag");
+  }
+
+  public void testParseDefineErrors6() throws Exception {
+    parse("@define {String}*/", "@define tag only permits literal types");
+  }
+
+  public void testParseDefineErrors7() throws Exception {
+    parse("@define {string}\n @const */", "conflicting @const tag");
+  }
+
+  public void testParseDefineErrors8() throws Exception {
+    parse("@define {string}\n @type string */",
+        "type annotation incompatible with other annotations");
+  }
+
+  public void testParseNoCheck1() throws Exception {
+    assertTrue(parse("@notypecheck*/").isNoTypeCheck());
+  }
+
+  public void testParseNoCheck2() throws Exception {
+    parse("@notypecheck\n@notypecheck*/", "extra @notypecheck tag");
+  }
+
+  public void testParseOverride1() throws Exception {
+    assertTrue(parse("@override*/").isOverride());
+  }
+
+  public void testParseOverride2() throws Exception {
+    parse("@override\n@override*/", "extra @override/@inheritDoc tag");
+  }
+
+  public void testParseInheritDoc1() throws Exception {
+    assertTrue(parse("@inheritDoc*/").isOverride());
+  }
+
+  public void testParseInheritDoc2() throws Exception {
+    parse("@override\n@inheritDoc*/", "extra @override/@inheritDoc tag");
+  }
+
+  public void testParseInheritDoc3() throws Exception {
+    parse("@inheritDoc\n@inheritDoc*/", "extra @override/@inheritDoc tag");
+  }
+
+  public void testParseNoAlias1() throws Exception {
+    assertTrue(parse("@noalias*/").isNoAlias());
+  }
+
+  public void testParseNoAlias2() throws Exception {
+    parse("@noalias\n@noalias*/", "extra @noalias tag");
+  }
+
+  public void testParseDeprecated1() throws Exception {
+    assertTrue(parse("@deprecated*/").isDeprecated());
+  }
+
+  public void testParseDeprecated2() throws Exception {
+    parse("@deprecated\n@deprecated*/", "extra @deprecated tag");
+  }
+
+  public void testParseExport1() throws Exception {
+    assertTrue(parse("@export*/").isExport());
+  }
+
+  public void testParseExport2() throws Exception {
+    parse("@export\n@export*/", "extra @export tag");
+  }
+
+  public void testParseExterns1() throws Exception {
+    assertTrue(parseFileOverview("@externs*/").isExterns());
+  }
+
+  public void testParseExterns2() throws Exception {
+    parseFileOverview("@externs\n@externs*/", "extra @externs tag");
+  }
+
+  public void testParseExterns3() throws Exception {
+    assertNull(parse("@externs*/"));
+  }
+
+  public void testBugAnnotation() throws Exception {
+    parse("@bug */");
+  }
+
+  public void testDescriptionAnnotation() throws Exception {
+    parse("@description */");
+  }
+
+  public void testRegression1() throws Exception {
+    String comment =
+        " * @param {number} index the index of blah\n" +
+        " * @return {boolean} whatever\n" +
+        " * @private\n" +
+        " */";
+
+    JSDocInfo info = parse(comment);
+    assertEquals(1, info.getParameterCount());
+    assertTypeEquals(NUMBER_TYPE, info.getParameterType("index"));
+    assertTypeEquals(BOOLEAN_TYPE, info.getReturnType());
+    assertEquals(Visibility.PRIVATE, info.getVisibility());
+  }
+
+  public void testRegression2() throws Exception {
+    String comment =
+        " * @return {boolean} whatever\n" +
+        " * but important\n" +
+        " *\n" +
+        " * @param {number} index the index of blah\n" +
+        " * some more comments here\n" +
+        " * @param name the name of the guy\n" +
+        " *\n" +
+        " * @protected\n" +
+        " */";
+
+    JSDocInfo info = parse(comment);
+    assertEquals(2, info.getParameterCount());
+    assertTypeEquals(NUMBER_TYPE, info.getParameterType("index"));
+    assertEquals(null, info.getParameterType("name"));
+    assertTypeEquals(BOOLEAN_TYPE, info.getReturnType());
+    assertEquals(Visibility.PROTECTED, info.getVisibility());
+  }
+
+  public void testRegression3() throws Exception {
+    String comment =
+        " * @param mediaTag this specified whether the @media tag is ....\n" +
+        " *\n" +
+        "\n" +
+        "@public\n" +
+        " *\n" +
+        "\n" +
+        " **********\n" +
+        " * @final\n" +
+        " */";
+
+    JSDocInfo info = parse(comment);
+    assertEquals(1, info.getParameterCount());
+    assertEquals(null, info.getParameterType("mediaTag"));
+    assertEquals(Visibility.PUBLIC, info.getVisibility());
+    assertTrue(info.isConstant());
+  }
+
+  public void testRegression4() throws Exception {
+    String comment =
+        " * @const\n" +
+        " * @hidden\n" +
+        " * @preserveTry\n" +
+        " * @constructor\n" +
+        " */";
+
+    JSDocInfo info = parse(comment);
+    assertTrue(info.isConstant());
+    assertFalse(info.isDefine());
+    assertTrue(info.isConstructor());
+    assertTrue(info.isHidden());
+    assertTrue(info.shouldPreserveTry());
+  }
+
+  public void testRegression5() throws Exception {
+    String comment = "@const\n@enum {string}\n@public*/";
+
+    JSDocInfo info = parse(comment);
+    assertTrue(info.isConstant());
+    assertFalse(info.isDefine());
+    assertTypeEquals(STRING_TYPE, info.getEnumParameterType());
+    assertEquals(Visibility.PUBLIC, info.getVisibility());
+  }
+
+  public void testRegression6() throws Exception {
+    String comment = "@hidden\n@enum\n@public*/";
+
+    JSDocInfo info = parse(comment);
+    assertTrue(info.isHidden());
+    assertTypeEquals(NUMBER_TYPE, info.getEnumParameterType());
+    assertEquals(Visibility.PUBLIC, info.getVisibility());
+  }
+
+  public void testRegression7() throws Exception {
+    String comment =
+        " * @desc description here\n" +
+        " * @param {boolean} flag and some more description\n" +
+        " *     nicely formatted\n" +
+        " */";
+
+    JSDocInfo info = parse(comment);
+    assertEquals(1, info.getParameterCount());
+    assertTypeEquals(BOOLEAN_TYPE, info.getParameterType("flag"));
+    assertEquals("description here", info.getDescription());
+  }
+
+  public void testRegression8() throws Exception {
+    String comment =
+        " * @name random tag here\n" +
+        " * @desc description here\n" +
+        " *\n" +
+        " * @param {boolean} flag and some more description\n" +
+        " *     nicely formatted\n" +
+        " */";
+
+    JSDocInfo info = parse(comment);
+    assertEquals(1, info.getParameterCount());
+    assertTypeEquals(BOOLEAN_TYPE, info.getParameterType("flag"));
+    assertEquals("description here", info.getDescription());
+  }
+
+  public void testRegression9() throws Exception {
+    JSDocInfo jsdoc = parse(
+        " * @param {string} p0 blah blah blah\n" +
+        " */");
+
+    assertNull(jsdoc.getBaseType());
+    assertFalse(jsdoc.isConstant());
+    assertNull(jsdoc.getDescription());
+    assertNull(jsdoc.getEnumParameterType());
+    assertFalse(jsdoc.isHidden());
+    assertEquals(1, jsdoc.getParameterCount());
+    assertTypeEquals(STRING_TYPE, jsdoc.getParameterType("p0"));
+    assertNull(jsdoc.getReturnType());
+    assertNull(jsdoc.getType());
+    assertEquals(Visibility.INHERITED, jsdoc.getVisibility());
+  }
+
+  public void testRegression10() throws Exception {
+    JSDocInfo jsdoc = parse(
+        " * @param {!String} p0 blah blah blah\n" +
+        " * @param {boolean} p1 fobar\n" +
+        " * @return {!Date} jksjkash dshad\n" +
+        " */");
+
+    assertNull(jsdoc.getBaseType());
+    assertFalse(jsdoc.isConstant());
+    assertNull(jsdoc.getDescription());
+    assertNull(jsdoc.getEnumParameterType());
+    assertFalse(jsdoc.isHidden());
+    assertEquals(2, jsdoc.getParameterCount());
+    assertTypeEquals(STRING_OBJECT_TYPE, jsdoc.getParameterType("p0"));
+    assertTypeEquals(BOOLEAN_TYPE, jsdoc.getParameterType("p1"));
+    assertTypeEquals(DATE_TYPE, jsdoc.getReturnType());
+    assertNull(jsdoc.getType());
+    assertEquals(Visibility.INHERITED, jsdoc.getVisibility());
+  }
+
+  public void testRegression11() throws Exception {
+    JSDocInfo jsdoc = parse(
+        " * @constructor\n" +
+        " */");
+
+    assertNull(jsdoc.getBaseType());
+    assertFalse(jsdoc.isConstant());
+    assertNull(jsdoc.getDescription());
+    assertNull(jsdoc.getEnumParameterType());
+    assertFalse(jsdoc.isHidden());
+    assertEquals(0, jsdoc.getParameterCount());
+    assertNull(jsdoc.getReturnType());
+    assertNull(jsdoc.getType());
+    assertEquals(Visibility.INHERITED, jsdoc.getVisibility());
+  }
+
+  public void testRegression12() throws Exception {
+    JSDocInfo jsdoc = parse(
+        " * @extends FooBar\n" +
+        " */");
+
+    assertTypeEquals(new NamedType(registry, "FooBar", null, 0, 0),
+        jsdoc.getBaseType());
+    assertFalse(jsdoc.isConstant());
+    assertNull(jsdoc.getDescription());
+    assertNull(jsdoc.getEnumParameterType());
+    assertFalse(jsdoc.isHidden());
+    assertEquals(0, jsdoc.getParameterCount());
+    assertNull(jsdoc.getReturnType());
+    assertNull(jsdoc.getType());
+    assertEquals(Visibility.INHERITED, jsdoc.getVisibility());
+  }
+
+  public void testRegression13() throws Exception {
+    JSDocInfo jsdoc = parse(
+        " * @type {!RegExp}\n" +
+        " * @protected\n" +
+        " */");
+
+    assertNull(jsdoc.getBaseType());
+    assertFalse(jsdoc.isConstant());
+    assertNull(jsdoc.getDescription());
+    assertNull(jsdoc.getEnumParameterType());
+    assertFalse(jsdoc.isHidden());
+    assertEquals(0, jsdoc.getParameterCount());
+    assertNull(jsdoc.getReturnType());
+    assertTypeEquals(REGEXP_TYPE, jsdoc.getType());
+    assertEquals(Visibility.PROTECTED, jsdoc.getVisibility());
+  }
+
+  public void testRegression14() throws Exception {
+    JSDocInfo jsdoc = parse(
+        " * @const\n" +
+        " * @private\n" +
+        " */");
+
+    assertNull(jsdoc.getBaseType());
+    assertTrue(jsdoc.isConstant());
+    assertNull(jsdoc.getDescription());
+    assertNull(jsdoc.getEnumParameterType());
+    assertFalse(jsdoc.isHidden());
+    assertEquals(0, jsdoc.getParameterCount());
+    assertNull(jsdoc.getReturnType());
+    assertNull(jsdoc.getType());
+    assertEquals(Visibility.PRIVATE, jsdoc.getVisibility());
+  }
+
+  public void testRegression15() throws Exception {
+    JSDocInfo jsdoc = parse(
+        " * @desc Hello,\n" +
+        " * World!\n" +
+        " */");
+
+    assertNull(jsdoc.getBaseType());
+    assertFalse(jsdoc.isConstant());
+    assertEquals("Hello, World!", jsdoc.getDescription());
+    assertNull(jsdoc.getEnumParameterType());
+    assertFalse(jsdoc.isHidden());
+    assertEquals(0, jsdoc.getParameterCount());
+    assertNull(jsdoc.getReturnType());
+    assertNull(jsdoc.getType());
+    assertEquals(Visibility.INHERITED, jsdoc.getVisibility());
+    assertFalse(jsdoc.isExport());
+  }
+
+  public void testRegression16() throws Exception {
+    JSDocInfo jsdoc = parse(
+        " Email is plp@foo.bar\n" +
+        " @type {string}\n" +
+        " */");
+
+    assertNull(jsdoc.getBaseType());
+    assertFalse(jsdoc.isConstant());
+    assertTypeEquals(STRING_TYPE, jsdoc.getType());
+    assertFalse(jsdoc.isHidden());
+    assertEquals(0, jsdoc.getParameterCount());
+    assertNull(jsdoc.getReturnType());
+    assertEquals(Visibility.INHERITED, jsdoc.getVisibility());
+  }
+
+  public void testRegression17() throws Exception {
+    // verifying that if no @desc is present the description is empty
+    assertNull(parse("@private*/").getDescription());
+  }
+
+  public void testFullRegression1() throws Exception {
+    parseFull("/** @param (string,number) foo*/function bar(foo){}",
+        "expecting a variable name in a @param tag");
+  }
+
+  public void testFullRegression2() throws Exception {
+    parseFull("/** @param {string,number) foo*/function bar(foo){}",
+        "expected closing }",
+        "expecting a variable name in a @param tag");
+  }
+
+  public void testFullRegression3() throws Exception {
+    parseFull("/**..\n*/");
+  }
+
+  public void testBug907488() throws Exception {
+    parse("@type {number,null} */",
+        "expected closing }");
+  }
+
+  public void testBug907494() throws Exception {
+    parse("@return {Object,undefined} */",
+        "expected closing }");
+  }
+
+  public void testBug909468() throws Exception {
+    parse("@extends {(x)}*/",
+        "expecting a type name");
+  }
+
+  public void testParseInterface() throws Exception {
+    assertTrue(parse("@interface*/").isInterface());
+  }
+
+  public void testParseImplicitCast1() throws Exception {
+    assertTrue(parse("@type {string} \n * @implicitCast*/").isImplicitCast());
+  }
+
+  public void testParseImplicitCast2() throws Exception {
+    assertFalse(parse("@type {string}*/").isImplicitCast());
+  }
+
+  public void testParseDuplicateImplicitCast() throws Exception {
+    parse("@type {string} \n * @implicitCast \n * @implicitCast*/",
+          "extra @implicitCast tag");
+  }
+
+  public void testParseInterfaceDoubled() throws Exception {
+    parse(
+        "* @interface\n" +
+        "* @interface\n" +
+        "*/",
+        "type annotation incompatible with other annotations");
+  }
+
+  public void testParseImplements() throws Exception {
+    List<JSTypeExpression> interfaces = parse("@implements {SomeInterface}*/")
+        .getImplementedInterfaces();
+    assertEquals(1, interfaces.size());
+    assertTypeEquals(new NamedType(registry, "SomeInterface", null, -1, -1),
+        interfaces.get(0));
+  }
+
+  public void testParseImplementsTwo() throws Exception {
+    List<JSTypeExpression> interfaces =
+        parse(
+            "* @implements {SomeInterface1}\n" +
+            "* @implements {SomeInterface2}\n" +
+            "*/")
+        .getImplementedInterfaces();
+    assertEquals(2, interfaces.size());
+    assertTypeEquals(new NamedType(registry, "SomeInterface1", null, -1, -1),
+        interfaces.get(0));
+    assertTypeEquals(new NamedType(registry, "SomeInterface2", null, -1, -1),
+        interfaces.get(1));
+  }
+
+  public void testParseImplementsSameTwice() throws Exception {
+    parse(
+        "* @implements {Smth}\n" +
+        "* @implements {Smth}\n" +
+        "*/",
+        "duplicate @implements tag");
+  }
+
+  public void testParseImplementsNoName() throws Exception {
+    parse("* @implements {} */",
+        "expecting a type name");
+  }
+
+  public void testParseImplementsMissingRC() throws Exception {
+    parse("* @implements {Smth */",
+        "expected closing }");
+  }
+
+  public void testParseImplementsNullable1() throws Exception {
+    parse("@implements {Base?} */", "expected closing }");
+  }
+
+  public void testParseImplementsNullable2() throws Exception {
+    parse("@implements Base? */", "expected end of line or comment");
+  }
+
+  public void testInterfaceExtends() throws Exception {
+     JSDocInfo jsdoc = parse(
+         " * @interface \n" +
+         " * @extends {Extended} */");
+    assertTrue(jsdoc.isInterface());
+    assertTypeEquals(new NamedType(registry, "Extended", null, -1, -1),
+        jsdoc.getBaseType());
+  }
+
+  public void testBadExtendsWithNullable() throws Exception {
+    JSDocInfo jsdoc = parse("@constructor\n * @extends {Object?} */",
+        "expected closing }");
+    assertTrue(jsdoc.isConstructor());
+    assertTypeEquals(OBJECT_TYPE, jsdoc.getBaseType());
+  }
+
+  public void testBadImplementsWithNullable() throws Exception {
+  JSDocInfo jsdoc = parse("@implements {Disposable?}\n * @constructor */",
+      "expected closing }");
+    assertTrue(jsdoc.isConstructor());
+    assertTypeEquals(new NamedType(registry, "Disposable", null, -1, -1),
+        jsdoc.getImplementedInterfaces().get(0));
+  }
+
+  public void testBadTypeDefInterfaceAndConstructor1() throws Exception {
+    JSDocInfo jsdoc = parse("@interface\n@constructor*/",
+        "cannot be both an interface and a constructor");
+    assertTrue(jsdoc.isInterface());
+  }
+
+  public void testBadTypeDefInterfaceAndConstructor2() throws Exception {
+    JSDocInfo jsdoc = parse("@constructor\n@interface*/",
+        "cannot be both an interface and a constructor");
+    assertTrue(jsdoc.isConstructor());
+  }
+
+  public void testDocumentationThrows() throws Exception {
+    JSDocInfo jsdoc
+        = parse("@throws {Number} This is a description.*/", true);
+
+    assertEquals("This is a description.",
+                 jsdoc.getDescriptionForThrownType(NUMBER_TYPE, null));
+  }
+
+  public void testDocumentationParameter() throws Exception {
+    JSDocInfo jsdoc
+        = parse("@param {Number} number42 This is a description.*/", true);
+
+    assertTrue(jsdoc.hasDescriptionForParameter("number42"));
+    assertEquals("This is a description.",
+                 jsdoc.getDescriptionForParameter("number42"));
+  }
+
+  public void testMultilineDocumentationParameter() throws Exception {
+    JSDocInfo jsdoc
+        = parse("@param {Number} number42 This is a description"
+                + "\n* on multiple \n* lines.*/", true);
+
+    assertTrue(jsdoc.hasDescriptionForParameter("number42"));
+    assertEquals("This is a description on multiple lines.",
+                 jsdoc.getDescriptionForParameter("number42"));
+
+  }
+
+  public void testDocumentationMultipleParameter() throws Exception {
+    JSDocInfo jsdoc
+        = parse("@param {Number} number42 This is a description."
+                + "\n* @param {Integer} number87 This is another description.*/"
+                , true);
+
+    assertTrue(jsdoc.hasDescriptionForParameter("number42"));
+    assertEquals("This is a description.",
+                 jsdoc.getDescriptionForParameter("number42"));
+
+    assertTrue(jsdoc.hasDescriptionForParameter("number87"));
+    assertEquals("This is another description.",
+                 jsdoc.getDescriptionForParameter("number87"));
+  }
+
+  public void testDocumentationMultipleParameter2() throws Exception {
+    JSDocInfo jsdoc
+        = parse("@param {number} delta = 0 results in a redraw\n" +
+                "  != 0 ..... */", true);
+    assertTrue(jsdoc.hasDescriptionForParameter("delta"));
+    assertEquals("= 0 results in a redraw != 0 .....",
+                 jsdoc.getDescriptionForParameter("delta"));
+  }
+
+
+  public void testAuthors() throws Exception {
+    JSDocInfo jsdoc
+        = parse("@param {Number} number42 This is a description."
+                + "\n* @param {Integer} number87 This is another description."
+                + "\n* @author a@google.com (A Person)"
+                + "\n* @author b@google.com (B Person)"
+                + "\n* @author c@google.com (C Person)*/"
+                , true);
+
+    Collection<String> authors = jsdoc.getAuthors();
+
+    assertTrue(authors != null);
+    assertTrue(authors.size() == 3);
+
+    assertContains(authors, "a@google.com (A Person)");
+    assertContains(authors, "b@google.com (B Person)");
+    assertContains(authors, "c@google.com (C Person)");
+  }
+
+  public void testSuppress1() throws Exception {
+    JSDocInfo info = parse("@suppress {x} */");
+    assertEquals(Sets.newHashSet("x"), info.getSuppressions());
+  }
+
+  public void testSuppress2() throws Exception {
+    JSDocInfo info = parse("@suppress {x|y|x|z} */");
+    assertEquals(Sets.newHashSet("x", "y", "z"), info.getSuppressions());
+  }
+
+  public void testBadSuppress1() throws Exception {
+    parse("@suppress {} */", "malformed @suppress tag");
+  }
+
+  public void testBadSuppress2() throws Exception {
+    parse("@suppress {x|} */", "malformed @suppress tag");
+  }
+
+  public void testBadSuppress3() throws Exception {
+    parse("@suppress {|x} */", "malformed @suppress tag");
+  }
+
+  public void testBadSuppress4() throws Exception {
+    parse("@suppress {x|y */", "malformed @suppress tag");
+  }
+
+  public void testBadSuppress5() throws Exception {
+    parse("@suppress {x,y} */", "malformed @suppress tag");
+  }
+
+  public void testBadSuppress6() throws Exception {
+    parse("@suppress {x} \n * @suppress {y} */", "duplicate @suppress tag");
+  }
+
+  //public void testNoParseFileOverview() throws Exception {
+  //  JSDocInfo jsdoc = parseFileOverviewWithoutDoc("@fileoverview Hi mom! */");
+  //  assertNull(jsdoc.getFileOverview());
+  //  assertTrue(jsdoc.hasFileOverview());
+  //}
+
+  public void testFileOverviewSingleLine() throws Exception {
+    JSDocInfo jsdoc = parseFileOverview("@fileoverview Hi mom! */");
+    assertEquals("Hi mom!", jsdoc.getFileOverview());
+  }
+
+  public void testFileOverviewMultiLine() throws Exception {
+    JSDocInfo jsdoc = parseFileOverview("@fileoverview Pie is \n * good! */");
+    assertEquals("Pie is\n good!", jsdoc.getFileOverview());
+  }
+
+  public void testFileOverviewDuplicate() throws Exception {
+    JSDocInfo jsdoc = parseFileOverview(
+        "@fileoverview Pie \n * @fileoverview Cake */",
+        "extra @fileoverview tag");
+  }
+
+  public void testReferences() throws Exception {
+    JSDocInfo jsdoc
+        = parse("@see A cool place!"
+                + "\n* @see The world."
+                + "\n* @see SomeClass#SomeMember"
+                + "\n* @see A boring test case*/"
+                , true);
+
+    Collection<String> references = jsdoc.getReferences();
+
+    assertTrue(references != null);
+    assertTrue(references.size() == 4);
+
+    assertContains(references, "A cool place!");
+    assertContains(references, "The world.");
+    assertContains(references, "SomeClass#SomeMember");
+    assertContains(references, "A boring test case");
+  }
+
+  public void testSingleTags() throws Exception {
+    JSDocInfo jsdoc
+        = parse("@version Some old version"
+                + "\n* @deprecated In favor of the new one!"
+                + "\n* @return {SomeType} The most important object :-)*/"
+                , true);
+
+    assertTrue(jsdoc.isDeprecated());
+    assertEquals("In favor of the new one!", jsdoc.getDeprecationReason());
+    assertEquals("Some old version", jsdoc.getVersion());
+    assertEquals("The most important object :-)", jsdoc.getReturnDescription());
+  }
+
+  public void testSingleTagsReordered() throws Exception {
+    JSDocInfo jsdoc
+        = parse("@deprecated In favor of the new one!"
+                + "\n * @return {SomeType} The most important object :-)"
+                + "\n * @version Some old version*/"
+                , true);
+
+    assertTrue(jsdoc.isDeprecated());
+    assertEquals("In favor of the new one!", jsdoc.getDeprecationReason());
+    assertEquals("Some old version", jsdoc.getVersion());
+    assertEquals("The most important object :-)", jsdoc.getReturnDescription());
+  }
+
+  public void testVersionDuplication() throws Exception {
+    parse("* @version Some old version"
+          + "\n* @version Another version*/", true,
+          "conflicting @version tag");
+  }
+
+  public void testVersionMissing() throws Exception {
+    parse("* @version */", true,
+          "@version tag missing version information");
+  }
+
+  public void testAuthorMissing() throws Exception {
+    parse("* @author */", true,
+          "@author tag missing author");
+  }
+
+  public void testSeeMissing() throws Exception {
+    parse("* @see */", true,
+          "@see tag missing description");
+  }
+
+  public void testSourceName() throws Exception {
+    JSDocInfo jsdoc = parse("@deprecated */", true);
+    assertEquals("testcode", jsdoc.getSourceName());
+  }
+
+  public void testParseBlockComment() throws Exception {
+    JSDocInfo jsdoc = parse("this is a nice comment\n "
+                            + "* that is multiline \n"
+                            + "* @author abc@google.com */", true);
+
+    assertEquals("this is a nice comment\nthat is multiline",
+                 jsdoc.getBlockDescription());
+
+    assertDocumentationInMarker(
+        assertAnnotationMarker(jsdoc, "author", 2, 2),
+        "abc@google.com", 9, 2, 23);
+  }
+
+  public void testParseBlockComment2() throws Exception {
+    JSDocInfo jsdoc = parse("this is a nice comment\n "
+                            + "* that is *** multiline \n"
+                            + "* @author abc@google.com */", true);
+
+    assertEquals("this is a nice comment\nthat is *** multiline",
+                 jsdoc.getBlockDescription());
+
+    assertDocumentationInMarker(
+        assertAnnotationMarker(jsdoc, "author", 2, 2),
+        "abc@google.com", 9, 2, 23);
+  }
+
+  public void testParseBlockComment3() throws Exception {
+    JSDocInfo jsdoc = parse("\n "
+                            + "* hello world \n"
+                            + "* @author abc@google.com */", true);
+
+    assertEquals("hello world", jsdoc.getBlockDescription());
+
+    assertDocumentationInMarker(
+        assertAnnotationMarker(jsdoc, "author", 2, 2),
+        "abc@google.com", 9, 2, 23);
+  }
+
+  public void testParseWithMarkers1() throws Exception {
+    JSDocInfo jsdoc = parse("@author abc@google.com */", true);
+
+    assertDocumentationInMarker(
+        assertAnnotationMarker(jsdoc, "author", 0, 0),
+        "abc@google.com", 7, 0, 21);
+  }
+
+  public void testParseWithMarkers2() throws Exception {
+    JSDocInfo jsdoc = parse("@param {Foo} somename abc@google.com */", true);
+
+    assertDocumentationInMarker(
+        assertAnnotationMarker(jsdoc, "param", 0, 0),
+        "abc@google.com", 21, 0, 37);
+  }
+
+  public void testParseWithMarkers3() throws Exception {
+    JSDocInfo jsdoc =
+        parse("@return {Foo} some long \n * multiline" +
+              " \n * description */", true);
+
+    assertDocumentationInMarker(
+        assertAnnotationMarker(jsdoc, "return", 0, 0),
+        "some long multiline description", 13, 2, 15);
+  }
+
+  public void testParseWithMarkers4() throws Exception {
+    JSDocInfo jsdoc =
+        parse("@author foobar \n * @param {Foo} somename abc@google.com */",
+              true);
+
+    assertAnnotationMarker(jsdoc, "author", 0, 0);
+    assertAnnotationMarker(jsdoc, "param", 1, 3);
+  }
+
+  public void testParseWithMarkerNames1() throws Exception {
+    JSDocInfo jsdoc = parse("@param {SomeType} name somedescription */", true);
+
+    assertNameInMarker(
+        assertAnnotationMarker(jsdoc, "param", 0, 0),
+        "name", 18);
+  }
+
+  public void testParseWithMarkerNames2() throws Exception {
+    JSDocInfo jsdoc = parse("@param {SomeType} name somedescription \n" +
+                            "* @param {AnotherType} anothername des */", true);
+
+    assertTypeInMarker(
+        assertNameInMarker(
+            assertAnnotationMarker(jsdoc, "param", 0, 0, 0),
+            "name", 18),
+        "SomeType", 7, true);
+
+    assertTypeInMarker(
+        assertNameInMarker(
+            assertAnnotationMarker(jsdoc, "param", 1, 2, 1),
+            "anothername", 23),
+        "AnotherType", 9, true);
+  }
+
+  public void testParseWithoutMarkerName() throws Exception {
+    JSDocInfo jsdoc = parse("@author helloworld*/", true);
+    assertNull(assertAnnotationMarker(jsdoc, "author", 0, 0).name);
+  }
+
+  public void testParseWithMarkerType() throws Exception {
+    JSDocInfo jsdoc = parse("@extends {FooBar}*/", true);
+
+    assertTypeInMarker(
+        assertAnnotationMarker(jsdoc, "extends", 0, 0),
+        "FooBar", 9, true);
+  }
+
+  public void testParseWithMarkerType2() throws Exception {
+    JSDocInfo jsdoc = parse("@extends FooBar*/", true);
+
+    assertTypeInMarker(
+        assertAnnotationMarker(jsdoc, "extends", 0, 0),
+        "FooBar", 9, false);
+  }
+
+  public void testTypeTagConflict1() throws Exception {
+    parse("@constructor \n * @constructor */",
+        "type annotation incompatible with other annotations");
+  }
+
+  public void testTypeTagConflict2() throws Exception {
+    parse("@interface \n * @interface */",
+        "type annotation incompatible with other annotations");
+  }
+
+  public void testTypeTagConflict3() throws Exception {
+    parse("@constructor \n * @interface */",
+        "cannot be both an interface and a constructor");
+  }
+
+  public void testTypeTagConflict4() throws Exception {
+    parse("@interface \n * @constructor */",
+        "cannot be both an interface and a constructor");
+  }
+
+  public void testTypeTagConflict5() throws Exception {
+    parse("@interface \n * @type {string} */",
+        "type annotation incompatible with other annotations");
+  }
+
+  public void testTypeTagConflict6() throws Exception {
+    parse("@typedef {string} \n * @type {string} */",
+        "type annotation incompatible with other annotations");
+  }
+
+  public void testTypeTagConflict7() throws Exception {
+    parse("@typedef {string} \n * @constructor */",
+        "type annotation incompatible with other annotations");
+  }
+
+  public void testTypeTagConflict8() throws Exception {
+    parse("@typedef {string} \n * @return {boolean} */",
+        "type annotation incompatible with other annotations");
+  }
+
+  public void testTypeTagConflict9() throws Exception {
+    parse("@enum {string} \n * @return {boolean} */",
+        "type annotation incompatible with other annotations");
+  }
+
+  public void testTypeTagConflict10() throws Exception {
+    parse("@this {Object} \n * @enum {boolean} */",
+        "type annotation incompatible with other annotations");
+  }
+
+  public void testTypeTagConflict11() throws Exception {
+    parse("@param {Object} x \n * @type {boolean} */",
+        "type annotation incompatible with other annotations");
+  }
+
+  public void testTypeTagConflict12() throws Exception {
+    parse("@typedef {boolean} \n * @param {Object} x */",
+        "type annotation incompatible with other annotations");
+  }
+
+  public void testTypeTagConflict13() throws Exception {
+    parse("@typedef {boolean} \n * @extends {Object} */",
+        "type annotation incompatible with other annotations");
+  }
+
+  public void testParserWithTemplateTypeNameMisisng() {
+    parse("@template */", "@template tag missing type name");
+  }
+
+  public void testParserWithTemplateTypeNameMissing() {
+    parse("@template T\n@template V */", "@template tag at most once");
+  }
+
+  public void testWhitelistedNewAnnotations() {
+    parse("@foobar */",
+        "illegal use of unknown JSDoc tag \"foobar\"; ignoring it");
+    extraAnnotations.add("foobar");
+    parse("@foobar */");
+  }
+
+  public void testWhitelistedConflictingAnnotation() {
+    extraAnnotations.add("param");
+    JSDocInfo info = parse("@param {number} index */");
+    assertTypeEquals(NUMBER_TYPE, info.getParameterType("index"));
+  }
+
+  public void testNonIdentifierAnnotation() {
+    // Try to whitelist an annotation that is not a valid JS identifier.
+    // It should not work.
+    extraAnnotations.add("123");
+    parse("@123 */", "illegal use of unknown JSDoc tag \"\"; ignoring it");
+  }
+
+  public void testUnsupportedJsDocSyntax1() {
+    JSDocInfo info =
+        parse("@param {string} [accessLevel=\"author\"] The user level */",
+            true);
+    assertEquals(1, info.getParameterCount());
+    assertTypeEquals(
+        registry.createOptionalType(STRING_TYPE),
+        info.getParameterType("accessLevel"));
+    assertEquals("The user level",
+        info.getDescriptionForParameter("accessLevel"));
+  }
+
+  public void testUnsupportedJsDocSyntax2() {
+    JSDocInfo info =
+        parse("@param userInfo The user info. \n" +
+              " * @param userInfo.name The name of the user */", true);
+    assertEquals(1, info.getParameterCount());
+    assertEquals("The user info.",
+        info.getDescriptionForParameter("userInfo"));
+  }
+
+  public void testWhitelistedAnnotations() {
+    parse(
+      "* @addon \n" +
+      "* @augments \n" +
+      "* @base \n" +
+      "* @borrows \n" +
+      "* @bug \n" +
+      "* @class \n" +
+      "* @config \n" +
+      "* @constructs \n" +
+      "* @default \n" +
+      "* @description \n" +
+      "* @event \n" +
+      "* @example \n" +
+      "* @exception \n" +
+      "* @exec \n" +
+      "* @externs \n" +
+      "* @field \n" +
+      "* @function \n" +
+      "* @id \n" +
+      "* @ignore \n" +
+      "* @inner \n" +
+      "* @lends \n" +
+      "* @link \n" +
+      "* @member \n" +
+      "* @memberOf \n" +
+      "* @modName \n" +
+      "* @mods \n" +
+      "* @name \n" +
+      "* @namespace \n" +
+      "* @property \n" +
+      "* @requires \n" +
+      "* @since \n" +
+      "* @static \n" +
+      "* @supported */");
+  }
+
+  /**
+   * Asserts that a documentation field exists on the given marker.
+   *
+   * @param description The text of the documentation field expected.
+   * @param startCharno The starting character of the text.
+   * @param endLineno The ending line of the text.
+   * @param endCharno The ending character of the text.
+   * @return The marker, for chaining purposes.
+   */
+  private JSDocInfo.Marker assertDocumentationInMarker(JSDocInfo.Marker marker,
+                                                       String description,
+                                                       int startCharno,
+                                                       int endLineno,
+                                                       int endCharno) {
+    assertTrue(marker.description != null);
+    assertEquals(description, marker.description.getItem());
+
+    // Match positional information.
+    assertEquals(marker.annotation.getStartLine(),
+                 marker.description.getStartLine());
+    assertEquals(startCharno, marker.description.getPositionOnStartLine());
+    assertEquals(endLineno, marker.description.getEndLine());
+    assertEquals(endCharno, marker.description.getPositionOnEndLine());
+
+    return marker;
+  }
+
+  /**
+   * Asserts that a type field exists on the given marker.
+   *
+   * @param typeName The name of the type expected in the type field.
+   * @param startCharno The starting character of the type declaration.
+   * @param hasBrackets Whether the type in the type field is expected
+   *     to have brackets.
+   * @return The marker, for chaining purposes.
+   */
+  private JSDocInfo.Marker assertTypeInMarker(JSDocInfo.Marker marker,
+                                            String typeName, int startCharno,
+                                            boolean hasBrackets) {
+
+    assertTrue(marker.type != null);
+    assertTrue(marker.type.getItem().getType() == Token.STRING);
+
+    // Match the name and brackets information.
+    String foundName = marker.type.getItem().getString();
+
+    assertEquals(typeName, foundName);
+    assertEquals(hasBrackets, marker.type.hasBrackets);
+
+    // Match position information.
+    assertEquals(startCharno, marker.type.getPositionOnStartLine());
+
+    int endCharno = startCharno + foundName.length();
+
+    if (hasBrackets) {
+      endCharno += 1;
+    }
+
+    assertEquals(endCharno, marker.type.getPositionOnEndLine());
+    assertEquals(marker.annotation.getStartLine(), marker.type.getStartLine());
+    assertEquals(marker.annotation.getStartLine(), marker.type.getEndLine());
+
+    return marker;
+  }
+
+  /**
+   * Asserts that a name field exists on the given marker.
+   *
+   * @param name The name expected in the name field.
+   * @param startCharno The starting character of the text.
+   * @return The marker, for chaining purposes.
+   */
+  private JSDocInfo.Marker assertNameInMarker(JSDocInfo.Marker marker,
+                                            String name, int startCharno) {
+    assertTrue(marker.name != null);
+    assertEquals(name, marker.name.getItem());
+
+    assertEquals(startCharno, marker.name.getPositionOnStartLine());
+    assertEquals(startCharno + name.length(),
+                 marker.name.getPositionOnEndLine());
+
+    assertEquals(marker.annotation.getStartLine(), marker.name.getStartLine());
+    assertEquals(marker.annotation.getStartLine(), marker.name.getEndLine());
+
+    return marker;
+  }
+
+  /**
+   * Asserts that an annotation marker of a given annotation name
+   * is found in the given JSDocInfo.
+   *
+   * @param jsdoc The JSDocInfo in which to search for the annotation marker.
+   * @param annotationName The name/type of the annotation for which to
+   *   search. Example: "author" for an "@author" annotation.
+   * @param startLineno The expected starting line number of the marker.
+   * @param startCharno The expected character on the starting line.
+   * @return The marker found, for further testing.
+   */
+  private JSDocInfo.Marker assertAnnotationMarker(JSDocInfo jsdoc,
+                                                  String annotationName,
+                                                  int startLineno,
+                                                  int startCharno) {
+    return assertAnnotationMarker(jsdoc, annotationName, startLineno,
+                                  startCharno, 0);
+  }
+
+  /**
+   * Asserts that the index-th annotation marker of a given annotation name
+   * is found in the given JSDocInfo.
+   *
+   * @param jsdoc The JSDocInfo in which to search for the annotation marker.
+   * @param annotationName The name/type of the annotation for which to
+   *   search. Example: "author" for an "@author" annotation.
+   * @param startLineno The expected starting line number of the marker.
+   * @param startCharno The expected character on the starting line.
+   * @param index The index of the marker.
+   * @return The marker found, for further testing.
+   */
+  private JSDocInfo.Marker assertAnnotationMarker(JSDocInfo jsdoc,
+                                                  String annotationName,
+                                                  int startLineno,
+                                                  int startCharno,
+                                                  int index) {
+
+    Collection<JSDocInfo.Marker> markers = jsdoc.getMarkers();
+
+    assertTrue(markers.size() > 0);
+
+    int counter = 0;
+
+    for (JSDocInfo.Marker marker : markers) {
+      if (marker.annotation != null) {
+        if (annotationName.equals(marker.annotation.getItem())) {
+
+          if (counter == index) {
+            assertEquals(startLineno, marker.annotation.getStartLine());
+            assertEquals(startCharno,
+                         marker.annotation.getPositionOnStartLine());
+            assertEquals(startLineno, marker.annotation.getEndLine());
+            assertEquals(startCharno + annotationName.length(),
+                         marker.annotation.getPositionOnEndLine());
+
+            return marker;
+          }
+
+          counter++;
+        }
+      }
+    }
+
+    fail("No marker found");
+    return null;
+  }
+
+  private <T> void assertContains(Collection<T> collection, T item) {
+    assertTrue(collection.contains(item));
+  }
+
+  private void parseFull(String code, String... warnings) {
+    CompilerEnvirons environment = new CompilerEnvirons();
+
+    TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings);
+    environment.setErrorReporter(testErrorReporter);
+
+    environment.setRecordingComments(true);
+    environment.setRecordingLocalJsDocComments(true);
+
+    Parser p = new Parser(environment, testErrorReporter);
+    AstRoot script = p.parse(code, null, 0);
+
+    Config config = new Config(registry, extraAnnotations, true);
+    for (Comment comment : script.getComments()) {
+      JsDocInfoParser jsdocParser =
+        new JsDocInfoParser(
+            new JsDocTokenStream(comment.getValue().substring(3),
+                comment.getLineno()),
+            script.getSourceName(),
+            config,
+            testErrorReporter);
+      jsdocParser.parse();
+      jsdocParser.retrieveAndResetParsedJSDocInfo();
+    }
+
+    assertTrue("some expected warnings were not reported",
+        testErrorReporter.hasEncounteredAllWarnings());
+  }
+
+  private JSDocInfo parseFileOverviewWithoutDoc(String comment,
+                                                String... warnings) {
+    return parse(comment, false, true, warnings);
+  }
+
+  private JSDocInfo parseFileOverview(String comment, String... warnings) {
+    return parse(comment, true, true, warnings);
+  }
+
+  private JSDocInfo parse(String comment, String... warnings) {
+    return parse(comment, false, warnings);
+  }
+
+  private JSDocInfo parse(String comment, boolean parseDocumentation,
+                          String... warnings) {
+    return parse(comment, parseDocumentation, false, warnings);
+  }
+
+  private JSDocInfo parse(String comment, boolean parseDocumentation,
+      boolean parseFileOverview, String... warnings) {
+    TestErrorReporter errorReporter = new TestErrorReporter(null, warnings);
+
+    Config config = new Config(
+        registry, extraAnnotations, parseDocumentation);
+    JsDocInfoParser jsdocParser = new JsDocInfoParser(stream(comment),
+        "testcode", config, errorReporter);
+
+    //if (fileLevelJsDocBuilder != null) {
+    //  jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);
+    //}
+
+    jsdocParser.parse();
+
+    assertTrue("expected warnings were not reported",
+        errorReporter.hasEncounteredAllWarnings());
+
+    if (parseFileOverview) {
+      return jsdocParser.getFileOverviewJSDocInfo();
+    } else {
+      return jsdocParser.retrieveAndResetParsedJSDocInfo();
+    }
+  }
+
+  private Node parseType(String typeComment) {
+    return JsDocInfoParser.parseTypeString(typeComment);
+  }
+
+  private JsDocTokenStream stream(String source) {
+    return new JsDocTokenStream(source, 0);
+  }
+
+  private void assertParameterTypeEquals(JSType expected, JSTypeExpression te) {
+    assertEquals(expected, ((ObjectType) resolve(te)).getParameterType());
+  }
+
+  private void assertIndexTypeEquals(JSType expected, JSTypeExpression te) {
+    assertEquals(expected, ((ObjectType) resolve(te)).getIndexType());
+  }
+}
diff --git a/test/com/google/javascript/jscomp/parsing/JsDocTokenStreamTest.java b/test/com/google/javascript/jscomp/parsing/JsDocTokenStreamTest.java
new file mode 100644
index 0000000..100ffae
--- /dev/null
+++ b/test/com/google/javascript/jscomp/parsing/JsDocTokenStreamTest.java
@@ -0,0 +1,305 @@
+/*
+ * Copyright 2009 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp.parsing;
+
+import static com.google.javascript.jscomp.parsing.JsDocToken.ANNOTATION;
+import static com.google.javascript.jscomp.parsing.JsDocToken.BANG;
+import static com.google.javascript.jscomp.parsing.JsDocToken.COLON;
+import static com.google.javascript.jscomp.parsing.JsDocToken.COMMA;
+import static com.google.javascript.jscomp.parsing.JsDocToken.ELLIPSIS;
+import static com.google.javascript.jscomp.parsing.JsDocToken.EOC;
+import static com.google.javascript.jscomp.parsing.JsDocToken.EOF;
+import static com.google.javascript.jscomp.parsing.JsDocToken.EOL;
+import static com.google.javascript.jscomp.parsing.JsDocToken.EQUALS;
+import static com.google.javascript.jscomp.parsing.JsDocToken.GT;
+import static com.google.javascript.jscomp.parsing.JsDocToken.LB;
+import static com.google.javascript.jscomp.parsing.JsDocToken.LC;
+import static com.google.javascript.jscomp.parsing.JsDocToken.LP;
+import static com.google.javascript.jscomp.parsing.JsDocToken.LT;
+import static com.google.javascript.jscomp.parsing.JsDocToken.PIPE;
+import static com.google.javascript.jscomp.parsing.JsDocToken.QMARK;
+import static com.google.javascript.jscomp.parsing.JsDocToken.RB;
+import static com.google.javascript.jscomp.parsing.JsDocToken.RC;
+import static com.google.javascript.jscomp.parsing.JsDocToken.RP;
+import static com.google.javascript.jscomp.parsing.JsDocToken.STAR;
+import static com.google.javascript.jscomp.parsing.JsDocToken.STRING;
+
+import com.google.common.collect.ImmutableList;
+
+import junit.framework.TestCase;
+
+import java.util.List;
+import java.io.IOException;
+
+/**
+ * Tests for {@link JsDocTokenStream}.
+ */
+public class JsDocTokenStreamTest extends TestCase {
+
+  public void testJsDocTokenization1() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(
+        STAR, ANNOTATION, LC, STRING, RC, EOL, STAR, ANNOTATION);
+    List<String> strings = ImmutableList.of("type", "string", "private");
+    testJSDocTokenStream(" * @type {string}\n * @private", tokens, strings);
+    testJSDocTokenStream(" *    @type { string } \n * @private",
+        tokens, strings);
+    testJSDocTokenStream(" * @type   {  string}\n * @private", tokens, strings);
+    testJSDocTokenStream(" * @type {string  }\n * @private", tokens, strings);
+    testJSDocTokenStream(" * @type {string}\n *   @private", tokens, strings);
+    testJSDocTokenStream(" * @type {string}   \n * @private", tokens, strings);
+  }
+
+  public void testJsDocTokenization2() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(
+        ANNOTATION, LC, STRING, LT, STRING, PIPE, STRING, GT, RC);
+    List<String> strings = ImmutableList.of("param", "Array", "string", "null");
+    testJSDocTokenStream("@param {Array.<string|null>}", tokens, strings);
+    testJSDocTokenStream("@param {Array.<string|null>}", tokens, strings);
+    testJSDocTokenStream("@param {Array.<string |null>}", tokens, strings);
+    testJSDocTokenStream(" @param {Array.<string |  null>}", tokens, strings);
+    testJSDocTokenStream(" @param {Array.<string|null  >}", tokens, strings);
+    testJSDocTokenStream("@param {Array  .<string|null>}", tokens, strings);
+    testJSDocTokenStream("@param   {Array.<string|null>}", tokens, strings);
+    testJSDocTokenStream("@param {  Array.<string|null>}", tokens, strings);
+    testJSDocTokenStream("@param {Array.<string|   null>}  ", tokens, strings);
+    testJSDocTokenStream("@param {Array.<string|null>}", tokens, strings);
+    testJSDocTokenStream("     @param { Array .< string |null > } ",
+        tokens, strings);
+  }
+
+  public void testJsDocTokenization3() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(
+        ANNOTATION, LC, STRING, LT, STRING, PIPE, STRING, GT, RC);
+    List<String> strings = ImmutableList.of("param", "Array", "string", "null");
+    testJSDocTokenStream("@param {Array.<string||null>}", tokens, strings);
+    testJSDocTokenStream("@param {Array.< string || null> }", tokens, strings);
+    testJSDocTokenStream("@param {Array.<string || null >  } ",
+        tokens, strings);
+    testJSDocTokenStream("@param {Array .<string   ||null>}", tokens, strings);
+    testJSDocTokenStream("@param {Array.< string||null>}", tokens, strings);
+    testJSDocTokenStream("@param {  Array.<string||null>}", tokens, strings);
+    testJSDocTokenStream(" @param   {Array.<string||null>}", tokens, strings);
+    testJSDocTokenStream("@param   {   Array.<string|| null> }",
+        tokens, strings);
+  }
+
+  public void testJsDocTokenization4() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(
+        ANNOTATION, LC, STRING, LT, LP, STRING, COMMA, STRING, RP, GT, RC, EOF);
+    List<String> strings = ImmutableList.of("param", "Array", "string", "null");
+    testJSDocTokenStream("@param {Array.<(string,null)>}", tokens, strings);
+    testJSDocTokenStream("@param {Array  .<(string,null)> } ", tokens, strings);
+    testJSDocTokenStream(" @param {Array.<  (  string,null)>}",
+        tokens, strings);
+    testJSDocTokenStream("@param {Array.<(string  , null)>}", tokens, strings);
+    testJSDocTokenStream("@param {Array.<(string,   null)  > }  ",
+        tokens, strings);
+    testJSDocTokenStream("@param {  Array  .<  (string,null)>}   ",
+        tokens, strings);
+  }
+
+  public void testJsDocTokenization5() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(ANNOTATION, STRING, EOC, EOF);
+    List<String> strings = ImmutableList.of("param", "foo.Bar");
+    testJSDocTokenStream("@param foo.Bar*/", tokens, strings);
+    testJSDocTokenStream(" @param   foo.Bar*/", tokens, strings);
+    testJSDocTokenStream(" @param foo.Bar   */", tokens, strings);
+  }
+
+  public void testJsDocTokenization6() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(
+        ANNOTATION, EOL, ANNOTATION, EOL, ANNOTATION, EOC);
+    List<String> strings = ImmutableList.of("hidden", "static", "desc");
+    testJSDocTokenStream("@hidden\n@static\n@desc*/", tokens, strings);
+    testJSDocTokenStream("@hidden\n @static\n@desc*/", tokens, strings);
+    testJSDocTokenStream("@hidden\n@static\n @desc*/", tokens, strings);
+    testJSDocTokenStream("@hidden\n@static\n@desc */", tokens, strings);
+    testJSDocTokenStream(" @hidden \n@static\n @desc*/", tokens, strings);
+    testJSDocTokenStream("@hidden\n@static    \n @desc  */", tokens, strings);
+    testJSDocTokenStream("@hidden\n@static\n@desc*/", tokens, strings);
+    testJSDocTokenStream("@hidden   \n@static   \n @desc*/", tokens, strings);
+  }
+
+  public void testJsDocTokenization7() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(
+        ELLIPSIS, ELLIPSIS, ELLIPSIS, ELLIPSIS, ELLIPSIS, LT, EOC);
+    List<String> strings = ImmutableList.of();
+
+    testJSDocTokenStream("................<*/", tokens, strings);
+    testJSDocTokenStream("............... .<*/", tokens, strings);
+    testJSDocTokenStream("................< */", tokens, strings);
+    testJSDocTokenStream("............... .< */", tokens, strings);
+    testJSDocTokenStream("............... .< */ ", tokens, strings);
+    testJSDocTokenStream(" ............... .< */ ", tokens, strings);
+  }
+
+  public void testJsDocTokenization8() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(
+        STAR, ANNOTATION, STRING, STRING, STRING, STRING, STRING, STRING,
+        STRING, EOL, EOC);
+    List<String> strings = ImmutableList.of(
+        "param", "foo.Bar", "opt_name", "this", "parameter", "is", "a", "name");
+    testJSDocTokenStream(
+        " * @param foo.Bar opt_name this parameter is a name\n" +
+        " */", tokens, strings);
+    testJSDocTokenStream(
+        "  *  @param foo.Bar opt_name this parameter is a name \n" +
+        " */ ", tokens, strings);
+  }
+
+  public void testJsDocTokenization9() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(
+        STAR, ANNOTATION, STRING, STRING, STRING, STRING, STRING, ANNOTATION,
+        STRING, EOL, EOC);
+    List<String> strings = ImmutableList.of(
+        "param", "foo.Bar", "opt_name", "this", "parameter", "does",
+        "media", "blah");
+    testJSDocTokenStream(
+        " * @param foo.Bar opt_name this parameter does @media blah\n" +
+        " */", tokens, strings);
+  }
+
+  public void testJsDocTokenization10() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(STRING, GT, EOC);
+    List<String> strings = ImmutableList.of("Array<String");
+    testJSDocTokenStream("Array<String>*/", tokens, strings);
+  }
+
+  public void testJsDocTokenization11() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(
+        ANNOTATION, LC, STRING, QMARK, RC, EOC, EOF);
+    List<String> strings = ImmutableList.of("param", "string");
+    testJSDocTokenStream("@param {string?}*/", tokens, strings);
+    testJSDocTokenStream(" @param {string?}*/", tokens, strings);
+    testJSDocTokenStream("@param { string?}*/", tokens, strings);
+    testJSDocTokenStream("@param {string ?}*/", tokens, strings);
+    testJSDocTokenStream("@param  {string ?  } */", tokens, strings);
+    testJSDocTokenStream("@param { string  ?  }*/", tokens, strings);
+    testJSDocTokenStream("@param {string?  }*/", tokens, strings);
+  }
+
+  public void testJsDocTokenization12() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(STRING, ELLIPSIS, EOC);
+    List<String> strings = ImmutableList.of("function");
+
+    testJSDocTokenStream("function ...*/", tokens, strings);
+  }
+
+  public void testJsDocTokenization13() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(ELLIPSIS, LB, STRING, RB, EOC);
+    List<String> strings = ImmutableList.of("number");
+
+    testJSDocTokenStream("...[number]*/", tokens, strings);
+  }
+
+  public void testJsDocTokenization14() throws Exception {
+    // Since ES4 type parsing only requires to parse an ellispis when it is
+    // followed by a comma (,) we are allowing this case to parse this way.
+    // This is a simplification of the tokenizer, but the extra complexity is
+    // never used.
+    List<JsDocToken> tokens = ImmutableList.of(STRING, LB, STRING, EOC);
+    List<String> strings = ImmutableList.of("foo", "bar...");
+
+    testJSDocTokenStream("foo[ bar...*/", tokens, strings);
+  }
+
+  public void testJsDocTokenization15() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(
+        STRING, LB, STRING, COMMA, ELLIPSIS, EOC);
+    List<String> strings = ImmutableList.of("foo", "bar");
+
+    testJSDocTokenStream("foo[ bar,...*/", tokens, strings);
+    testJSDocTokenStream("foo[ bar ,...*/", tokens, strings);
+    testJSDocTokenStream("foo[bar, ...*/", tokens, strings);
+    testJSDocTokenStream("foo[ bar  ,   ...  */", tokens, strings);
+    testJSDocTokenStream("foo [bar,... */", tokens, strings);
+  }
+
+  public void testJsDocTokenization16() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(
+        STRING, COLON, COLON, COLON, ELLIPSIS, STRING, COLON, STRING, EOC);
+    List<String> strings = ImmutableList.of("foo", "bar", "bar2");
+
+    testJSDocTokenStream("foo:::...bar:bar2*/", tokens, strings);
+  }
+
+  public void testJsDocTokenization17() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(STRING, EOL, EOC);
+    List<String> strings = ImmutableList.of("..");
+
+    testJSDocTokenStream("..\n*/", tokens, strings);
+  }
+
+  public void testJsDocTokenization18() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(STRING, EOL, EOC);
+    List<String> strings = ImmutableList.of(".");
+
+    testJSDocTokenStream(".\n*/", tokens, strings);
+  }
+
+  public void testJsDocTokenization19() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(ANNOTATION, LC, STAR, RC, EOC);
+    List<String> strings = ImmutableList.of("type", "*");
+
+    testJSDocTokenStream("@type {*}*/", tokens, strings);
+  }
+
+  public void testJsDocTokenization20() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(
+        ANNOTATION, LC, BANG, STRING, RC, EOC, EOF);
+    List<String> strings = ImmutableList.of("param", "Object");
+    testJSDocTokenStream("@param {!Object}*/", tokens, strings);
+    testJSDocTokenStream(" @param {!Object}*/", tokens, strings);
+    testJSDocTokenStream("@param {! Object}*/", tokens, strings);
+    testJSDocTokenStream("@param { !Object}*/", tokens, strings);
+    testJSDocTokenStream("@param  {!Object  } */", tokens, strings);
+    testJSDocTokenStream("@param {  ! Object  }*/", tokens, strings);
+    testJSDocTokenStream("@param {!Object  }*/", tokens, strings);
+  }
+
+  public void testJsDocTokenization21() throws Exception {
+    List<JsDocToken> tokens = ImmutableList.of(
+        ANNOTATION, LC, STRING, EQUALS, RC, EOC, EOF);
+    List<String> strings = ImmutableList.of("param", "Object");
+    testJSDocTokenStream("@param {Object=}*/", tokens, strings);
+    testJSDocTokenStream(" @param {Object=}*/", tokens, strings);
+    testJSDocTokenStream("@param { Object =}*/", tokens, strings);
+    testJSDocTokenStream("@param { Object=}*/", tokens, strings);
+    testJSDocTokenStream("@param  {Object=  } */", tokens, strings);
+    testJSDocTokenStream("@param { Object = }*/", tokens, strings);
+    testJSDocTokenStream("@param {Object=  }*/", tokens, strings);
+  }
+
+  private void testJSDocTokenStream(String comment, List<JsDocToken> tokens,
+      List<String> strings) throws IOException {
+    JsDocTokenStream stream = new JsDocTokenStream(comment, 0);
+    int stringsIndex = 0;
+    for (JsDocToken token : tokens) {
+      JsDocToken readToken = stream.getJsDocToken();
+
+      // token equality
+      if (token != readToken) {
+        assertEquals(token, readToken);
+      }
+
+      // string equality
+      if (token == ANNOTATION || token == STRING) {
+        assertEquals(strings.get(stringsIndex++), stream.getString());
+      }
+    }
+  }
+}
diff --git a/test/com/google/javascript/jscomp/parsing/ParserTest.java b/test/com/google/javascript/jscomp/parsing/ParserTest.java
new file mode 100644
index 0000000..634b3fd
--- /dev/null
+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java
@@ -0,0 +1,727 @@
+/*
+ * Copyright 2007 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp.parsing;
+
+import com.google.common.base.Pair;
+import com.google.common.collect.ImmutableList;
+import com.google.javascript.jscomp.mozilla.rhino.ScriptRuntime;
+import com.google.javascript.jscomp.testing.TestErrorReporter;
+import com.google.javascript.rhino.JSDocInfo;
+import com.google.javascript.rhino.Node;
+import com.google.javascript.rhino.ScriptOrFnNode;
+import com.google.javascript.rhino.Token;
+import com.google.javascript.rhino.jstype.JSType;
+import com.google.javascript.rhino.jstype.JSTypeNative;
+import com.google.javascript.rhino.testing.BaseJSTypeTestCase;
+
+import java.io.IOException;
+import java.util.logging.Logger;
+import java.util.List;
+
+
+public class ParserTest extends BaseJSTypeTestCase {
+  private static final String TRAILING_COMMA_MESSAGE =
+      ScriptRuntime.getMessage0("msg.extra.trailing.comma");
+
+  private static final String BAD_PROPERTY_MESSAGE =
+      ScriptRuntime.getMessage0("msg.bad.prop");
+
+  private static final String MISSING_GT_MESSAGE =
+      com.google.javascript.rhino.ScriptRuntime.getMessage0(
+          "msg.jsdoc.missing.gt");
+
+  private JSType getNativeType(JSTypeNative typeId) {
+    return registry.getNativeType(typeId);
+  }
+
+  public void testLinenoCharnoAssign1() throws Exception {
+    Node assign = parse("a = b").getFirstChild().getFirstChild();
+
+    assertEquals(Token.ASSIGN, assign.getType());
+    assertEquals(1, assign.getLineno());
+    assertEquals(2, assign.getCharno());
+  }
+
+  public void testLinenoCharnoAssign2() throws Exception {
+    Node assign = parse("\n a.g.h.k    =  45").getFirstChild().getFirstChild();
+
+    assertEquals(Token.ASSIGN, assign.getType());
+    assertEquals(2, assign.getLineno());
+    assertEquals(12, assign.getCharno());
+  }
+
+  public void testLinenoCharnoCall() throws Exception {
+    Node call = parse("\n foo(123);").getFirstChild().getFirstChild();
+
+    assertEquals(Token.CALL, call.getType());
+    assertEquals(2, call.getLineno());
+    assertEquals(4, call.getCharno());
+  }
+
+  public void testLinenoCharnoGetProp1() throws Exception {
+    Node getprop = parse("\n foo.bar").getFirstChild().getFirstChild();
+
+    assertEquals(Token.GETPROP, getprop.getType());
+    assertEquals(2, getprop.getLineno());
+    assertEquals(1, getprop.getCharno());
+
+    Node name = getprop.getFirstChild().getNext();
+    assertEquals(Token.STRING, name.getType());
+    assertEquals(2, name.getLineno());
+    assertEquals(5, name.getCharno());
+  }
+
+  public void testLinenoCharnoGetProp2() throws Exception {
+    Node getprop = parse("\n foo.\nbar").getFirstChild().getFirstChild();
+
+    assertEquals(Token.GETPROP, getprop.getType());
+    assertEquals(2, getprop.getLineno());
+    assertEquals(1, getprop.getCharno());
+
+    Node name = getprop.getFirstChild().getNext();
+    assertEquals(Token.STRING, name.getType());
+    assertEquals(3, name.getLineno());
+    assertEquals(0, name.getCharno());
+  }
+
+  public void testLinenoCharnoGetelem1() throws Exception {
+    Node call = parse("\n foo[123]").getFirstChild().getFirstChild();
+
+    assertEquals(Token.GETELEM, call.getType());
+    assertEquals(2, call.getLineno());
+    assertEquals(1, call.getCharno());
+  }
+
+  public void testLinenoCharnoGetelem2() throws Exception {
+    Node call = parse("\n   \n foo()[123]").getFirstChild().getFirstChild();
+
+    assertEquals(Token.GETELEM, call.getType());
+    assertEquals(3, call.getLineno());
+    assertEquals(1, call.getCharno());
+  }
+
+  public void testLinenoCharnoGetelem3() throws Exception {
+    Node call = parse("\n   \n (8 + kl)[123]").getFirstChild().getFirstChild();
+
+    assertEquals(Token.GETELEM, call.getType());
+    assertEquals(3, call.getLineno());
+    assertEquals(2, call.getCharno());
+  }
+
+  public void testLinenoCharnoForComparison() throws Exception {
+    Node lt =
+      parse("for (; i < j;){}").getFirstChild().getFirstChild().getNext();
+
+    assertEquals(Token.LT, lt.getType());
+    assertEquals(1, lt.getLineno());
+    assertEquals(9, lt.getCharno());
+  }
+
+  public void testLinenoCharnoHook() throws Exception {
+    Node n = parse("\n a ? 9 : 0").getFirstChild().getFirstChild();
+
+    assertEquals(Token.HOOK, n.getType());
+    assertEquals(2, n.getLineno());
+    assertEquals(1, n.getCharno());
+  }
+
+  public void testLinenoCharnoArrayLiteral() throws Exception {
+    Node n = parse("\n  [8, 9]").getFirstChild().getFirstChild();
+
+    assertEquals(Token.ARRAYLIT, n.getType());
+    assertEquals(2, n.getLineno());
+    assertEquals(2, n.getCharno());
+
+    n = n.getFirstChild();
+
+    assertEquals(Token.NUMBER, n.getType());
+    assertEquals(2, n.getLineno());
+    assertEquals(3, n.getCharno());
+
+    n = n.getNext();
+
+    assertEquals(Token.NUMBER, n.getType());
+    assertEquals(2, n.getLineno());
+    assertEquals(6, n.getCharno());
+  }
+
+  public void testLinenoCharnoObjectLiteral() throws Exception {
+    Node n = parse("\n\n var a = {a:0\n,b :1};")
+        .getFirstChild().getFirstChild().getFirstChild();
+
+    assertEquals(Token.OBJECTLIT, n.getType());
+    assertEquals(3, n.getLineno());
+    assertEquals(9, n.getCharno());
+
+    n = n.getFirstChild();
+
+    assertEquals(Token.STRING, n.getType());
+    assertEquals(3, n.getLineno());
+    assertEquals(10, n.getCharno());
+
+    n = n.getNext();
+
+    assertEquals(Token.NUMBER, n.getType());
+    assertEquals(3, n.getLineno());
+    assertEquals(12, n.getCharno());
+
+    n = n.getNext();
+
+    assertEquals(Token.STRING, n.getType());
+    assertEquals(4, n.getLineno());
+    assertEquals(1, n.getCharno());
+
+    n = n.getNext();
+
+    assertEquals(Token.NUMBER, n.getType());
+    assertEquals(4, n.getLineno());
+    assertEquals(4, n.getCharno());
+  }
+
+  public void testLinenoCharnoAdd() throws Exception {
+    testLinenoCharnoBinop("+");
+  }
+
+  public void testLinenoCharnoSub() throws Exception {
+    testLinenoCharnoBinop("-");
+  }
+
+  public void testLinenoCharnoMul() throws Exception {
+    testLinenoCharnoBinop("*");
+  }
+
+  public void testLinenoCharnoDiv() throws Exception {
+    testLinenoCharnoBinop("/");
+  }
+
+  public void testLinenoCharnoMod() throws Exception {
+    testLinenoCharnoBinop("%");
+  }
+
+  public void testLinenoCharnoShift() throws Exception {
+    testLinenoCharnoBinop("<<");
+  }
+
+  public void testLinenoCharnoBinaryAnd() throws Exception {
+    testLinenoCharnoBinop("&");
+  }
+
+  public void testLinenoCharnoAnd() throws Exception {
+    testLinenoCharnoBinop("&&");
+  }
+
+  public void testLinenoCharnoBinaryOr() throws Exception {
+    testLinenoCharnoBinop("|");
+  }
+
+  public void testLinenoCharnoOr() throws Exception {
+    testLinenoCharnoBinop("||");
+  }
+
+  public void testLinenoCharnoLt() throws Exception {
+    testLinenoCharnoBinop("<");
+  }
+
+  public void testLinenoCharnoLe() throws Exception {
+    testLinenoCharnoBinop("<=");
+  }
+
+  public void testLinenoCharnoGt() throws Exception {
+    testLinenoCharnoBinop(">");
+  }
+
+  public void testLinenoCharnoGe() throws Exception {
+    testLinenoCharnoBinop(">=");
+  }
+
+  private void testLinenoCharnoBinop(String binop) {
+    Node op = parse("var a = 89 " + binop + " 76").getFirstChild().
+        getFirstChild().getFirstChild();
+
+    assertEquals(1, op.getLineno());
+    assertEquals(11, op.getCharno());
+  }
+
+  public void testJSDocAttachment1() {
+    Node varNode = parse("/** @type number */var a;").getFirstChild();
+
+    // VAR
+    assertEquals(Token.VAR, varNode.getType());
+    JSDocInfo info = varNode.getJSDocInfo();
+    assertNotNull(info);
+    assertTypeEquals(NUMBER_TYPE, info.getType());
+
+    // NAME
+    Node nameNode = varNode.getFirstChild();
+    assertEquals(Token.NAME, nameNode.getType());
+    assertNull(nameNode.getJSDocInfo());
+  }
+
+  public void testJSDocAttachment2() {
+    Node varNode = parse("/** @type number */var a,b;").getFirstChild();
+
+    // VAR
+    assertEquals(Token.VAR, varNode.getType());
+    JSDocInfo info = varNode.getJSDocInfo();
+    assertNotNull(info);
+    assertTypeEquals(NUMBER_TYPE, info.getType());
+
+    // First NAME
+    Node nameNode1 = varNode.getFirstChild();
+    assertEquals(Token.NAME, nameNode1.getType());
+    assertNull(nameNode1.getJSDocInfo());
+
+    // Second NAME
+    Node nameNode2 = nameNode1.getNext();
+    assertEquals(Token.NAME, nameNode2.getType());
+    assertNull(nameNode2.getJSDocInfo());
+  }
+
+  public void testJSDocAttachment3() {
+    Node assignNode = parse(
+        "/** @type number */goog.FOO = 5;").getFirstChild().getFirstChild();
+
+    // ASSIGN
+    assertEquals(Token.ASSIGN, assignNode.getType());
+    JSDocInfo info = assignNode.getJSDocInfo();
+    assertNotNull(info);
+    assertTypeEquals(NUMBER_TYPE, info.getType());
+  }
+
+  public void testJSDocAttachment4() {
+    Node varNode = parse(
+        "var a, /** @define {number} */b = 5;").getFirstChild();
+
+    // ASSIGN
+    assertEquals(Token.VAR, varNode.getType());
+    assertNull(varNode.getJSDocInfo());
+
+    // a
+    Node a = varNode.getFirstChild();
+    assertNull(a.getJSDocInfo());
+
+    // b
+    Node b = a.getNext();
+    JSDocInfo info = b.getJSDocInfo();
+    assertNotNull(info);
+    assertTrue(info.isDefine());
+    assertTypeEquals(NUMBER_TYPE, info.getType());
+  }
+
+  public void testJSDocAttachment5() {
+    Node varNode = parse(
+        "var /** @type number */a, /** @define {number} */b = 5;")
+        .getFirstChild();
+
+    // ASSIGN
+    assertEquals(Token.VAR, varNode.getType());
+    assertNull(varNode.getJSDocInfo());
+
+    // a
+    Node a = varNode.getFirstChild();
+    assertNotNull(a.getJSDocInfo());
+    JSDocInfo info = a.getJSDocInfo();
+    assertNotNull(info);
+    assertFalse(info.isDefine());
+    assertTypeEquals(NUMBER_TYPE, info.getType());
+
+    // b
+    Node b = a.getNext();
+    info = b.getJSDocInfo();
+    assertNotNull(info);
+    assertTrue(info.isDefine());
+    assertTypeEquals(NUMBER_TYPE, info.getType());
+  }
+
+  /**
+   * Tests that a JSDoc comment in an unexpected place of the code does not
+   * propagate to following code due to {@link JSDocInfo} aggregation.
+   */
+  public void testJSDocAttachment6() throws Exception {
+    Node functionNode = parse(
+        "var a = /** @param {number} index */5;" +
+        "/** @return boolean */function f(index){}")
+        .getFirstChild().getNext();
+
+    assertEquals(Token.FUNCTION, functionNode.getType());
+    JSDocInfo info = functionNode.getJSDocInfo();
+    assertNotNull(info);
+    assertFalse(info.hasParameter("index"));
+    assertTrue(info.hasReturnType());
+  }
+
+  public void testJSDocAttachment7() {
+    Node varNode = parse("/** */var a;").getFirstChild();
+
+    // VAR
+    assertEquals(Token.VAR, varNode.getType());
+
+    // NAME
+    Node nameNode = varNode.getFirstChild();
+    assertEquals(Token.NAME, nameNode.getType());
+    assertNull(nameNode.getJSDocInfo());
+  }
+
+  public void testJSDocAttachment8() {
+    Node varNode = parse("/** x */var a;").getFirstChild();
+
+    // VAR
+    assertEquals(Token.VAR, varNode.getType());
+
+    // NAME
+    Node nameNode = varNode.getFirstChild();
+    assertEquals(Token.NAME, nameNode.getType());
+    assertNull(nameNode.getJSDocInfo());
+  }
+
+  public void testJSDocAttachment9() {
+    Node varNode = parse("/** \n x */var a;").getFirstChild();
+
+    // VAR
+    assertEquals(Token.VAR, varNode.getType());
+
+    // NAME
+    Node nameNode = varNode.getFirstChild();
+    assertEquals(Token.NAME, nameNode.getType());
+    assertNull(nameNode.getJSDocInfo());
+  }
+
+  public void testJSDocAttachment10() {
+    Node varNode = parse("/** x\n */var a;").getFirstChild();
+
+    // VAR
+    assertEquals(Token.VAR, varNode.getType());
+
+    // NAME
+    Node nameNode = varNode.getFirstChild();
+    assertEquals(Token.NAME, nameNode.getType());
+    assertNull(nameNode.getJSDocInfo());
+  }
+
+  public void testJSDocAttachment11() {
+    Node varNode =
+       parse("/** @type {{x : number, 'y' : string, z}} */var a;")
+        .getFirstChild();
+
+    // VAR
+    assertEquals(Token.VAR, varNode.getType());
+    JSDocInfo info = varNode.getJSDocInfo();
+    assertNotNull(info);
+
+    assertTypeEquals(createRecordTypeBuilder().
+                     addProperty("x", NUMBER_TYPE).
+                     addProperty("y", STRING_TYPE).
+                     addProperty("z", UNKNOWN_TYPE).
+                     build(),
+                     info.getType());
+
+    // NAME
+    Node nameNode = varNode.getFirstChild();
+    assertEquals(Token.NAME, nameNode.getType());
+    assertNull(nameNode.getJSDocInfo());
+  }
+
+  public void testJSDocAttachment12() {
+    Node varNode =
+       parse("var a = {/** @type {Object} */ b: c};")
+        .getFirstChild();
+    Node objectLitNode = varNode.getFirstChild().getFirstChild();
+    assertEquals(Token.OBJECTLIT, objectLitNode.getType());
+    assertNotNull(objectLitNode.getFirstChild().getJSDocInfo());
+  }
+
+  public void testIncorrectJSDocDoesNotAlterJSParsing1() throws Exception {
+    assertNodeEquality(
+        parse("var a = [1,2]"),
+        parse("/** @type Array.<number*/var a = [1,2]",
+            MISSING_GT_MESSAGE));
+  }
+
+  public void testIncorrectJSDocDoesNotAlterJSParsing2() throws Exception {
+    assertNodeEquality(
+        parse("var a = [1,2]"),
+        parse("/** @type {Array.<number}*/var a = [1,2]",
+            MISSING_GT_MESSAGE));
+  }
+
+  public void testIncorrectJSDocDoesNotAlterJSParsing3() throws Exception {
+    assertNodeEquality(
+        parse("C.prototype.say=function(nums) {alert(nums.join(','));};"),
+        parse("/** @param {Array.<number} nums */" +
+            "C.prototype.say=function(nums) {alert(nums.join(','));};",
+            MISSING_GT_MESSAGE));
+  }
+
+  public void testIncorrectJSDocDoesNotAlterJSParsing4() throws Exception {
+    assertNodeEquality(
+        parse("C.prototype.say=function(nums) {alert(nums.join(','));};"),
+        parse("/** @return boolean */" +
+            "C.prototype.say=function(nums) {alert(nums.join(','));};"));
+  }
+
+  public void testIncorrectJSDocDoesNotAlterJSParsing5() throws Exception {
+    assertNodeEquality(
+        parse("C.prototype.say=function(nums) {alert(nums.join(','));};"),
+        parse("/** @param boolean this is some string*/" +
+            "C.prototype.say=function(nums) {alert(nums.join(','));};"));
+  }
+
+  public void testIncorrectJSDocDoesNotAlterJSParsing6() throws Exception {
+    assertNodeEquality(
+        parse("C.prototype.say=function(nums) {alert(nums.join(','));};"),
+        parse("/** @param {bool!*%E$} */" +
+            "C.prototype.say=function(nums) {alert(nums.join(','));};",
+              "expected closing }",
+              "expecting a variable name in a @param tag"));
+  }
+
+  public void testIncorrectJSDocDoesNotAlterJSParsing7() throws Exception {
+    assertNodeEquality(
+        parse("C.prototype.say=function(nums) {alert(nums.join(','));};"),
+        parse("/** @see */" +
+            "C.prototype.say=function(nums) {alert(nums.join(','));};",
+              "@see tag missing description"));
+  }
+
+  public void testIncorrectJSDocDoesNotAlterJSParsing8() throws Exception {
+    assertNodeEquality(
+        parse("C.prototype.say=function(nums) {alert(nums.join(','));};"),
+        parse("/** @author */" +
+            "C.prototype.say=function(nums) {alert(nums.join(','));};",
+              "@author tag missing author"));
+  }
+
+  public void testIncorrectJSDocDoesNotAlterJSParsing9() throws Exception {
+    assertNodeEquality(
+        parse("C.prototype.say=function(nums) {alert(nums.join(','));};"),
+        parse("/** @someillegaltag */" +
+              "C.prototype.say=function(nums) {alert(nums.join(','));};",
+              "illegal use of unknown JSDoc tag \"someillegaltag\";"
+              + " ignoring it"));
+  }
+
+  public void testUnescapedSlashInRegexpCharClass() throws Exception {
+    // The tokenizer without the fix for this bug throws an error.
+    parse("var foo = /[/]/;");
+    parse("var foo = /[hi there/]/;");
+    parse("var foo = /[/yo dude]/;");
+    parse("var foo = /\\/[@#$/watashi/wa/suteevu/desu]/;");
+  }
+
+  private void assertNodeEquality(Node expected, Node found) {
+    String message = expected.checkTreeEquals(found);
+    if (message != null) {
+      fail(message);
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  public void testParse() {
+    Node a = Node.newString(Token.NAME, "a");
+    a.addChildToFront(Node.newString(Token.NAME, "b"));
+    List<Pair<String, Node>> testCases = ImmutableList.of(
+        Pair.of(
+            "3;",
+            createScript(new Node(Token.EXPR_RESULT, Node.newNumber(3.0)))),
+        Pair.of(
+            "var a = b;",
+             createScript(new Node(Token.VAR, a))),
+        Pair.of(
+            "\"hell\\\no\\ world\\\n\\\n!\"",
+             createScript(new Node(Token.EXPR_RESULT,
+             Node.newString(Token.STRING, "hello world!")))));
+
+    for (Pair<String, Node> testCase : testCases) {
+      assertNodeEquality(testCase.second, parse(testCase.first));
+    }
+  }
+
+  private Node createScript(Node n) {
+    Node script = new ScriptOrFnNode(Token.SCRIPT);
+    script.addChildToBack(n);
+    return script;
+  }
+
+  public void testTrailingCommaWarning1() {
+    parse("var a = ['foo', 'bar'];");
+  }
+
+  public void testTrailingCommaWarning2() {
+    parse("var a = ['foo',,'bar'];");
+  }
+
+  public void testTrailingCommaWarning3() {
+    parse("var a = ['foo', 'bar',];", TRAILING_COMMA_MESSAGE);
+  }
+
+  public void testTrailingCommaWarning4() {
+    parse("var a = [,];", TRAILING_COMMA_MESSAGE);
+  }
+
+  public void testTrailingCommaWarning5() {
+    parse("var a = {'foo': 'bar'};");
+  }
+
+  public void testTrailingCommaWarning6() {
+    parse("var a = {'foo': 'bar',};", TRAILING_COMMA_MESSAGE);
+  }
+
+  public void testTrailingCommaWarning7() {
+    parseError("var a = {,};", BAD_PROPERTY_MESSAGE);
+  }
+
+  public void testConstForbidden() {
+    parseError("const x = 3;", "Unsupported syntax: CONST");
+  }
+
+  public void testDestructuringAssignForbidden() {
+    parseError("var [x, y] = foo();", "destructuring assignment forbidden");
+  }
+
+  public void testDestructuringAssignForbidden2() {
+    parseError("var {x, y} = foo();", "missing : after property id");
+  }
+
+  public void testDestructuringAssignForbidden3() {
+    parseError("var {x: x, y: y} = foo();",
+        "destructuring assignment forbidden");
+  }
+
+  public void testDestructuringAssignForbidden4() {
+    parseError("[x, y] = foo();", "destructuring assignment forbidden");
+  }
+
+  public void testLetForbidden() {
+    parseError("function f() { let (x = 3) { alert(x); }; }",
+        "missing ; before statement", "syntax error");
+  }
+
+  public void testYieldForbidden() {
+    parseError("function f() { yield 3; }", "missing ; before statement");
+  }
+
+  public void testBracelessFunctionForbidden() {
+    parseError("var sq = function(x) x * x;",
+        "missing { before function body");
+  }
+
+  public void testGeneratorsForbidden() {
+    parseError("var i = (x for (x in obj));",
+        "missing ) in parenthetical");
+  }
+
+  public void testFileOverviewJSDoc1() {
+    Node n = parse("/** @fileoverview Hi mom! */ function Foo() {}");
+    assertEquals(Token.FUNCTION, n.getFirstChild().getType());
+    assertTrue(n.getJSDocInfo() != null);
+    assertNull(n.getFirstChild().getJSDocInfo());
+    assertEquals("Hi mom!",
+        n.getJSDocInfo().getFileOverview());
+  }
+
+  public void testFileOverviewJSDocDoesNotHoseParsing() {
+    assertEquals(
+        Token.FUNCTION,
+        parse("/** @fileoverview Hi mom! \n */ function Foo() {}")
+            .getFirstChild().getType());
+    assertEquals(
+        Token.FUNCTION,
+        parse("/** @fileoverview Hi mom! \n * * * */ function Foo() {}")
+            .getFirstChild().getType());
+    assertEquals(
+        Token.FUNCTION,
+        parse("/** @fileoverview \n * x */ function Foo() {}")
+            .getFirstChild().getType());
+    assertEquals(
+        Token.FUNCTION,
+        parse("/** @fileoverview \n * x \n */ function Foo() {}")
+            .getFirstChild().getType());
+  }
+
+  public void testFileOverviewJSDoc2() {
+    Node n = parse("/** @fileoverview Hi mom! */ " +
+        "/** @constructor */ function Foo() {}");
+    assertTrue(n.getJSDocInfo() != null);
+    assertEquals("Hi mom!", n.getJSDocInfo().getFileOverview());
+    assertTrue(n.getFirstChild().getJSDocInfo() != null);
+    assertFalse(n.getFirstChild().getJSDocInfo().hasFileOverview());
+    assertTrue(n.getFirstChild().getJSDocInfo().isConstructor());
+  }
+
+  public void testObjectLiteralDoc1() {
+    Node n = parse("var x = {/** @type {number} */ 1: 2};");
+
+    Node objectLit = n.getFirstChild().getFirstChild().getFirstChild();
+    assertEquals(Token.OBJECTLIT, objectLit.getType());
+
+    Node number = objectLit.getFirstChild();
+    assertEquals(Token.NUMBER, number.getType());
+    assertNotNull(number.getJSDocInfo());
+  }
+
+  public void testDuplicatedParam() {
+    parse("function foo(x, x) {}", "Duplicate parameter name \"x\".");
+  }
+
+  public void testLamestWarningEver() {
+    // This used to be a warning.
+    parse("var x = /** @type {undefined} */ (y);");
+    parse("var x = /** @type {void} */ (y);");
+  }
+
+  public void testParseBlockDescription() {
+    Node n = parse("/** This is a variable. */ var x;");
+    Node var = n.getFirstChild();
+    assertNotNull(var.getJSDocInfo());
+    assertEquals("This is a variable.",
+        var.getJSDocInfo().getBlockDescription());
+  }
+
+  private void parseError(String string, String... errors) {
+    TestErrorReporter testErrorReporter = new TestErrorReporter(errors, null);
+    Node script = null;
+    try {
+      script = ParserRunner.parse(
+          "input", string, true, registry,
+          testErrorReporter, Logger.getAnonymousLogger());
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+
+    // verifying that all warnings were seen
+    assertTrue(testErrorReporter.hasEncounteredAllErrors());
+    assertTrue(testErrorReporter.hasEncounteredAllWarnings());
+  }
+
+  private Node parse(String string, String... warnings) {
+    TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings);
+    Node script = null;
+    try {
+      script = ParserRunner.parse(
+          "input", string,  true, registry,
+          testErrorReporter, Logger.getAnonymousLogger());
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+
+    // verifying that all warnings were seen
+    assertTrue(testErrorReporter.hasEncounteredAllErrors());
+    assertTrue(testErrorReporter.hasEncounteredAllWarnings());
+
+    return script;
+  }
+}
