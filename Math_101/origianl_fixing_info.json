{
  "logger": {
    "currentLogLevel": 20,
    "name": "root.bean.benchmarks.Defects4JBug"
  },
  "d4jCmd": "/home/liumengjiao/Desktop/defects4j/framework/bin/defects4j",
  "dataDir": "/home/liumengjiao/Desktop/CI/Benchmark/data/changesInfo/",
  "properties": {
    "trigger.tests": "org.apache.commons.math.complex.ComplexFormatTest::testForgottenImaginaryCharacter,org.apache.commons.math.complex.FrenchComplexFormatTest::testForgottenImaginaryCharacter",
    "test.dir": "src/test",
    "clz.modified": "org.apache.commons.math.complex.ComplexFormat",
    "src.dir": "src/java"
  },
  "timeoutSecond": 100,
  "proj": "Math",
  "id": "101",
  "workingDir": "../bugs/Math_101_buggy",
  "buggyCommit": "29b732ce0f974e2347b50477c401f0c503a8a981",
  "inducingCommit": "322706393973a99fc70f0cbd8cadee38bae3aa94",
  "originalCommit": "af6140fde695b8619531d04deb6d3e078f8cbfd1",
  "bug_name": "Math_101",
  "derive": "defects4j",
  "original_fixing_commit": "32643d19538ad853a1280eb4060c4f15ac6dc3dd",
  "buildFiles_changed": false,
  "regression": true,
  "inducing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/java/org/apache/commons/math/complex/ComplexFormat.java",
        "src/java/org/apache/commons/math/complex/ComplexFormat.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "org.apache.commons.math.complex.ComplexFormat:ComplexFormat:[String imaginaryCharacter]:null",
            "org.apache.commons.math.complex.ComplexFormat:ComplexFormat:[String imaginaryCharacter, int fractionDigits]:null",
            "org.apache.commons.math.complex.ComplexFormat:format:[Complex c]:String",
            "org.apache.commons.math.complex.ComplexFormat:ComplexFormat:[]:null"
          ],
          "num": 4
        },
        {
          "qualified_names": [
            "org.apache.commons.math.complex.ComplexFormat:ComplexFormat:[String imaginaryCharacter, NumberFormat realFormat, NumberFormat imaginaryFormat]:null",
            "org.apache.commons.math.complex.ComplexFormat:ComplexFormat:[NumberFormat realFormat, NumberFormat imaginaryFormat]:null",
            "org.apache.commons.math.complex.ComplexFormat:ComplexFormat:[String imaginaryCharacter]:null",
            "org.apache.commons.math.complex.ComplexFormat:format:[Complex complex, StringBuffer toAppendTo, FieldPosition pos]:StringBuffer",
            "org.apache.commons.math.complex.ComplexFormat:getImaginaryCharacter:[]:String",
            "org.apache.commons.math.complex.ComplexFormat:formatComplex:[Complex c]:String",
            "org.apache.commons.math.complex.ComplexFormat:formatDouble:[double value, NumberFormat format, StringBuffer toAppendTo, FieldPosition pos]:StringBuffer",
            "org.apache.commons.math.complex.ComplexFormat:ComplexFormat:[]:null",
            "org.apache.commons.math.complex.ComplexFormat:getRealFormat:[]:NumberFormat",
            "org.apache.commons.math.complex.ComplexFormat:parseNextCharacter:[String source, ParsePosition pos]:char",
            "org.apache.commons.math.complex.ComplexFormat:ComplexFormat:[String imaginaryCharacter, NumberFormat format]:null",
            "org.apache.commons.math.complex.ComplexFormat:format:[Object obj, StringBuffer toAppendTo, FieldPosition pos]:StringBuffer",
            "org.apache.commons.math.complex.ComplexFormat:ComplexFormat:[NumberFormat format]:null",
            "org.apache.commons.math.complex.ComplexFormat:setImaginaryCharacter:[String imaginaryCharacter]:void",
            "org.apache.commons.math.complex.ComplexFormat:parseObject:[String source, ParsePosition pos]:Object",
            "org.apache.commons.math.complex.ComplexFormat:setRealFormat:[NumberFormat realFormat]:void",
            "org.apache.commons.math.complex.ComplexFormat:setImaginaryFormat:[NumberFormat imaginaryFormat]:void",
            "org.apache.commons.math.complex.ComplexFormat:parse:[String source, ParsePosition pos]:Complex",
            "org.apache.commons.math.complex.ComplexFormat:parse:[String source]:Complex",
            "org.apache.commons.math.complex.ComplexFormat:getDefaultNumberFormat:[]:NumberFormat",
            "org.apache.commons.math.complex.ComplexFormat:getImaginaryFormat:[]:NumberFormat",
            "org.apache.commons.math.complex.ComplexFormat:parseNumber:[String source, double value, ParsePosition pos]:Number",
            "org.apache.commons.math.complex.ComplexFormat:parseAndIgnoreWhitespace:[String source, ParsePosition pos]:void",
            "org.apache.commons.math.complex.ComplexFormat:parseNumber:[String source, NumberFormat format, ParsePosition pos]:Number"
          ],
          "num": 24
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "23",
            "27",
            "29",
            "30",
            "34",
            "35",
            "37",
            "38",
            "39",
            "41",
            "42",
            "44",
            "47",
            "48",
            "52",
            "53",
            "54",
            "55",
            "56",
            "57",
            "58",
            "59",
            "60",
            "61",
            "62",
            "63",
            "64",
            "65",
            "66",
            "67",
            "68",
            "69",
            "70",
            "71",
            "72",
            "73",
            "74",
            "75",
            "76",
            "77",
            "78",
            "79",
            "80",
            "81",
            "82",
            "83",
            "84",
            "85",
            "86",
            "87",
            "88",
            "89",
            "90",
            "91",
            "92",
            "93",
            "94",
            "95",
            "96",
            "97",
            "98",
            "99",
            "100",
            "101",
            "102",
            "115",
            "116",
            "117"
          ],
          "num": 68
        },
        {
          "qualified_names": [
            "19",
            "20",
            "22",
            "23",
            "27",
            "31",
            "33",
            "34",
            "38",
            "39",
            "40",
            "41",
            "42",
            "43",
            "44",
            "45",
            "47",
            "48",
            "49",
            "51",
            "52",
            "54",
            "55",
            "56",
            "59",
            "60",
            "61",
            "62",
            "63",
            "64",
            "65",
            "66",
            "67",
            "68",
            "69",
            "70",
            "71",
            "72",
            "73",
            "74",
            "75",
            "76",
            "77",
            "78",
            "79",
            "80",
            "84",
            "88",
            "89",
            "90",
            "91",
            "92",
            "93",
            "94",
            "95",
            "96",
            "97",
            "98",
            "99",
            "100",
            "101",
            "102",
            "103",
            "104",
            "105",
            "106",
            "107",
            "108",
            "109",
            "110",
            "111",
            "112",
            "113",
            "124",
            "125",
            "126",
            "127",
            "128",
            "129",
            "130",
            "131",
            "132",
            "133",
            "134",
            "135",
            "136",
            "137",
            "138",
            "139",
            "140",
            "141",
            "142",
            "143",
            "144",
            "145",
            "146",
            "147",
            "148",
            "149",
            "150",
            "151",
            "152",
            "153",
            "154",
            "155",
            "156",
            "157",
            "158",
            "159",
            "160",
            "161",
            "162",
            "163",
            "164",
            "165",
            "166",
            "167",
            "168",
            "169",
            "170",
            "171",
            "172",
            "173",
            "174",
            "175",
            "176",
            "177",
            "178",
            "179",
            "180",
            "181",
            "182",
            "183",
            "184",
            "185",
            "186",
            "187",
            "188",
            "189",
            "190",
            "191",
            "192",
            "193",
            "194",
            "195",
            "196",
            "197",
            "198",
            "199",
            "200",
            "201",
            "202",
            "203",
            "204",
            "205",
            "206",
            "207",
            "208",
            "209",
            "210",
            "211",
            "212",
            "213",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "220",
            "221",
            "222",
            "223",
            "224",
            "225",
            "226",
            "227",
            "228",
            "229",
            "230",
            "231",
            "232",
            "233",
            "234",
            "235",
            "236",
            "237",
            "238",
            "239",
            "240",
            "241",
            "242",
            "243",
            "244",
            "245",
            "246",
            "247",
            "248",
            "249",
            "250",
            "251",
            "252",
            "253",
            "254",
            "255",
            "256",
            "257",
            "258",
            "259",
            "260",
            "261",
            "262",
            "263",
            "264",
            "265",
            "266",
            "267",
            "268",
            "269",
            "270",
            "271",
            "272",
            "273",
            "274",
            "275",
            "276",
            "277",
            "278",
            "279",
            "280",
            "281",
            "282",
            "283",
            "284",
            "285",
            "286",
            "287",
            "288",
            "289",
            "290",
            "291",
            "292",
            "293",
            "294",
            "295",
            "296",
            "297",
            "298",
            "299",
            "300",
            "301",
            "302",
            "303",
            "304",
            "305",
            "306",
            "307",
            "308",
            "309",
            "310",
            "311",
            "312",
            "313",
            "314",
            "315",
            "316",
            "317",
            "318",
            "319",
            "320",
            "321",
            "322",
            "323",
            "324",
            "325",
            "326",
            "327",
            "328",
            "329",
            "330",
            "331",
            "332",
            "333",
            "334",
            "335",
            "336",
            "337",
            "338",
            "339",
            "340",
            "341",
            "342",
            "343",
            "344",
            "345",
            "346",
            "347",
            "348",
            "349",
            "350",
            "351",
            "352",
            "353",
            "354",
            "355",
            "356",
            "357",
            "358",
            "359",
            "360",
            "361",
            "362",
            "363",
            "364",
            "365",
            "366",
            "367",
            "368",
            "369",
            "370",
            "371",
            "372",
            "373",
            "374",
            "375",
            "376",
            "377",
            "378",
            "379",
            "380",
            "381",
            "382",
            "383",
            "384",
            "385",
            "386",
            "387",
            "388",
            "389",
            "390",
            "391",
            "392",
            "393",
            "394",
            "395",
            "396",
            "397",
            "398",
            "399",
            "400",
            "401",
            "402",
            "403",
            "404",
            "405",
            "406",
            "407",
            "408",
            "409",
            "410",
            "411",
            "412",
            "413",
            "414",
            "415",
            "416",
            "417",
            "418",
            "419",
            "420",
            "421",
            "422",
            "423",
            "424",
            "425",
            "426",
            "427",
            "428",
            "429",
            "430",
            "431",
            "432",
            "433",
            "434",
            "435",
            "436",
            "437",
            "438",
            "439",
            "440",
            "441",
            "442",
            "443",
            "444",
            "445",
            "446",
            "447",
            "448",
            "449",
            "450",
            "451",
            "452",
            "453",
            "454",
            "455",
            "456",
            "457",
            "458",
            "459",
            "460",
            "461",
            "462",
            "463",
            "464",
            "465",
            "466",
            "467",
            "468",
            "469",
            "470",
            "471",
            "472",
            "473",
            "474",
            "475",
            "476",
            "477",
            "478",
            "479",
            "480",
            "481",
            "482",
            "483",
            "484",
            "485",
            "486",
            "487",
            "488",
            "489",
            "490",
            "491",
            "492",
            "493",
            "494",
            "495",
            "496",
            "497",
            "498",
            "499",
            "500",
            "501"
          ],
          "num": 451
        }
      ],
      "diff": "diff --git a/src/java/org/apache/commons/math/complex/ComplexFormat.java b/src/java/org/apache/commons/math/complex/ComplexFormat.java\nindex c36c542..d5c3484 100644\n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n@@ -16,93 +16,101 @@\n \n package org.apache.commons.math.complex;\n \n+import java.text.FieldPosition;\n+import java.text.Format;\n import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n \n /**\n  * Formats a Complex number in cartesian format \"Re(c) + Im(c)i\".  \u0027i\u0027 can\n- * be replaced with \u0027j\u0027, and the number of decimal places to display \n+ * be replaced with \u0027j\u0027, and the number format for both real and imaginary parts\n  * can be configured.\n  *\n  * @author Apache Software Foundation\n- * @version $Revision: 1.6 $ $Date: 2004/05/23 00:52:32 $\n+ * @version $Revision: 1.7 $ $Date: 2004/06/01 13:47:17 $\n  */\n-public class ComplexFormat {\n-\n+public class ComplexFormat extends Format {\n+    \n     /** The default complex format. */ \n \tprivate static final ComplexFormat DEFAULT \u003d new ComplexFormat();\n \n-\t/** The notation used to signify the imaginary part of the complex number. */\n-    private String imaginaryCharacter \u003d \"i\";\n+    /** The default imaginary character. */\n+    private static final String DEFAULT_IMAGINARY_CHARACTER \u003d \"i\";\n+    \n+    /** The notation used to signify the imaginary part of the complex number. */\n+    private String imaginaryCharacter;\n+    \n+    /** The format used for the imaginary part. */\n+    private NumberFormat imaginaryFormat;\n \n-    /** The maximum number of decimal digits in the formatted output. */ \n-    private int fractionDigits \u003d 2;\n-\n+    /** The format used for the real part. */\n+    private NumberFormat realFormat;\n+    \n     /**\n-     * Create an instance with the default imaginary character \u0027i\u0027, and the default\n-     * number of decimal places - 2.\n+     * Create an instance with the default imaginary character, \u0027i\u0027, and the\n+     * default number format for both real and imaginary parts.\n      */\n-    public ComplexFormat() {}\n+    public ComplexFormat() {\n+        this(DEFAULT_IMAGINARY_CHARACTER, getDefaultNumberFormat());\n+    }\n \n     /**\n-     * Create an instance with a custom imaginary character, and the default number\n-     * of decimal places - 2.\n+     * Create an instance with a custom number format for both real and\n+     * imaginary parts.\n+     * @param format the custom format for both real and imaginary parts.\n+     */\n+    public ComplexFormat(NumberFormat format) {\n+        this(DEFAULT_IMAGINARY_CHARACTER, format);\n+    }\n+    \n+    /**\n+     * Create an instance with a custom number format for the real part and a\n+     * custom number format for the imaginary part.\n+     * @param realFormat the custom format for the real part.\n+     * @param imaginaryFormat the custom format for the imaginary part.\n+     */\n+    public ComplexFormat(NumberFormat realFormat,\n+            NumberFormat imaginaryFormat) {\n+        this(DEFAULT_IMAGINARY_CHARACTER, realFormat, imaginaryFormat);\n+    }\n+    \n+    /**\n+     * Create an instance with a custom imaginary character, and the default\n+     * number format for both real and imaginary parts.\n      * @param imaginaryCharacter The custom imaginary character.\n      */\n     public ComplexFormat(String imaginaryCharacter) {\n-        this.imaginaryCharacter \u003d imaginaryCharacter;\n-    }\n-\n-    /**\n-     * Create an instance with a custom imaginary character, and a custom number of\n-     * decimal places.\n-     * @param imaginaryCharacter The custom imaginary character.\n-     * @param fractionDigits The custom number of decimal places.\n-     */\n-    public ComplexFormat(String imaginaryCharacter, int fractionDigits) {\n-        this.imaginaryCharacter \u003d imaginaryCharacter;\n-        this.fractionDigits \u003d fractionDigits;\n-    }\n-\n-    /**\n-     * Formats a Complex object and returns a String representing the \"cartesian\n-     * form\" of a complex number.\n-     *\n-     * @param c Complex object to format\n-     * @return A formatted number in the form \"Re(c) + Im(c)i\"\n-     */\n-    public String format(Complex c) {\n-\n-        NumberFormat format \u003d NumberFormat.getInstance();\n-        format.setMaximumFractionDigits( fractionDigits );\n-\n-        StringBuffer buffer \u003d new StringBuffer();\n-\n-\t\tif( Double.isNaN( c.getReal() ) || Double.isInfinite( c.getReal() ) ) {\n-\t\t\tbuffer.append( \"(\" + c.getReal() + \")\" );\n-\t\t} else {\n-\t\t\tbuffer.append( format.format( c.getReal() ) );\n-\t\t}\n-\n-        if( c.getImaginary() \u003c 0 ) {\n-            buffer.append( \" - \" );\n-        } else if( c.getImaginary() \u003e 0 || Double.isNaN( c.getImaginary() )) {\n-            buffer.append( \" + \" );\n-        }            \n-\n-\t\tif( c.getImaginary() !\u003d 0 ) {\n-\t\t\tif( Double.isNaN( c.getImaginary() ) || Double.isInfinite( c.getImaginary() ) ) {\n-\t\t\t\tbuffer.append( \"(\" + Math.abs( c.getImaginary() ) + \")\" );\n-\t\t\t} else {\n-\t\t\t\tbuffer.append( format.format( Math.abs(c.getImaginary()) ) );\n-\t\t\t}\n-\t\t\tbuffer.append( imaginaryCharacter );\n-\t\t}\n-        \n-        return( buffer.toString() );\n-\n+        this(imaginaryCharacter, getDefaultNumberFormat());\n     }\n     \n     /**\n+     * Create an instance with a custom imaginary character, and a custom number\n+     * format for both real and imaginary parts.\n+     * @param imaginaryCharacter The custom imaginary character.\n+     * @param format the custom format for both real and imaginary parts.\n+     */\n+    public ComplexFormat(String imaginaryCharacter, NumberFormat format) {\n+        this(imaginaryCharacter, format, (NumberFormat)format.clone());\n+    }\n+    \n+    /**\n+     * Create an instance with a custom imaginary character, a custom number\n+     * format for the real part, and a custom number format for the imaginary\n+     * part.\n+     * @param imaginaryCharacter The custom imaginary character.\n+     * @param realFormat the custom format for the real part.\n+     * @param imaginaryFormat the custom format for the imaginary part.\n+     */\n+    public ComplexFormat(String imaginaryCharacter, NumberFormat realFormat,\n+            NumberFormat imaginaryFormat) {\n+        super();\n+        setImaginaryCharacter(imaginaryCharacter);\n+        setImaginaryFormat(imaginaryFormat);\n+        setRealFormat(realFormat);\n+    }\n+\n+    /**\n      * This static method calls formatComplex() on a default instance of\n      * ComplexFormat.\n      *\n@@ -112,7 +120,382 @@\n     public static String formatComplex( Complex c ) {\n     \treturn DEFAULT.format( c );\n     }\n-}\n-\n-\n     \n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getInstance()} with the only customizing is the\n+     * maximum number of fraction digits, which is set to 2.  \n+     *\n+     * @return the default number format.\n+     */\n+    private static NumberFormat getDefaultNumberFormat() {\n+        NumberFormat nf \u003d NumberFormat.getInstance();\n+        nf.setMaximumFractionDigits(2);\n+        return nf;\n+    }\n+    \n+    /**\n+     * Formats a {@link Complex} object to produce a string.\n+     *\n+     * @param complex the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(Complex complex, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        \n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        // format real\n+        double re \u003d complex.getReal();\n+        formatDouble(re, getRealFormat(), toAppendTo, pos);\n+        \n+        // format sign and imaginary\n+        double im \u003d complex.getImaginary();\n+        if (im \u003c 0.0) {\n+            toAppendTo.append(\" - \");\n+            formatDouble(-im, getImaginaryFormat(), toAppendTo, pos);\n+            toAppendTo.append(getImaginaryCharacter());\n+        } else if (im \u003e 0.0 || Double.isNaN(im)) {\n+            toAppendTo.append(\" + \");\n+            formatDouble(im, getImaginaryFormat(), toAppendTo, pos);\n+            toAppendTo.append(getImaginaryCharacter());\n+        }\n+        \n+        return toAppendTo;\n+    }\n+    \n+    /**\n+     * Formats a object to produce a string.  \u003ccode\u003eobj\u003c/code\u003e must be either a \n+     * {@link Complex} object or a {@link Number} object.  Any other type of\n+     * object will result in an {@link IllegalArgumentException} being thrown.\n+     *\n+     * @param obj the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n+     * @throws IllegalArgumentException is \u003ccode\u003eobj\u003c/code\u003e is not a valid type.\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        \n+        StringBuffer ret \u003d null;\n+        \n+        if (obj instanceof Complex) {\n+            ret \u003d format( (Complex)obj, toAppendTo, pos);\n+        } else if (obj instanceof Number) {\n+            ret \u003d format( new Complex(((Number)obj).doubleValue(), 0.0),\n+                toAppendTo, pos);\n+        } else { \n+            throw new IllegalArgumentException(\n+                \"Cannot format given Object as a Date\");\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Formats a double value to produce a string.  In general, the value is\n+     * formatted using the formatting rules of \u003ccode\u003eformat\u003c/code\u003e.  There are\n+     * three exceptions to this:\n+     * \u003col\u003e\n+     * \u003cli\u003eNaN is formatted as \u0027(NaN)\u0027\u003c/li\u003e\n+     * \u003cli\u003ePositive infinity is formatted as \u0027(Infinity)\u0027\u003c/li\u003e\n+     * \u003cli\u003eNegative infinity is formatted as \u0027(-Infinity)\u0027\u003c/li\u003e\n+     * \u003c/ol\u003e\n+     *\n+     * @param value the double to format.\n+     * @param format the format used.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    private StringBuffer formatDouble(double value, NumberFormat format,\n+            StringBuffer toAppendTo, FieldPosition pos) {\n+        if( Double.isNaN(value) || Double.isInfinite(value) ) {\n+            toAppendTo.append(\u0027(\u0027);\n+            toAppendTo.append(value);\n+            toAppendTo.append(\u0027)\u0027);\n+        } else {\n+            getRealFormat().format(value, toAppendTo, pos);\n+        }\n+        return toAppendTo;\n+    }\n+    \n+    /**\n+     * Access the imaginaryCharacter.\n+     * @return the imaginaryCharacter.\n+     */\n+    public String getImaginaryCharacter() {\n+        return imaginaryCharacter;\n+    }\n+    \n+    /**\n+     * Access the imaginaryFormat.\n+     * @return the imaginaryFormat.\n+     */\n+    public NumberFormat getImaginaryFormat() {\n+        return imaginaryFormat;\n+    }\n+    \n+    /**\n+     * Access the realFormat.\n+     * @return the realFormat.\n+     */\n+    public NumberFormat getRealFormat() {\n+        return realFormat;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link Complex} object.\n+     *\n+     * @param source the string to parse\n+     * @return the parsed {@link Complex} object.\n+     * @exception ParseException if the beginning of the specified string\n+     *            cannot be parsed.\n+     */\n+    public Complex parse(String source) throws ParseException {\n+        ParsePosition parsePosition \u003d new ParsePosition(0);\n+        Complex result \u003d parse(source, parsePosition);\n+        if (parsePosition.getIndex() \u003d\u003d 0) {\n+            throw new ParseException(\"Unparseable complex number: \\\"\" + source +\n+                \"\\\"\", parsePosition.getErrorIndex());\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Parses a string to produce a {@link Complex} object.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link Complex} object.\n+     */\n+    public Complex parse(String source, ParsePosition pos) {\n+        int initialIndex \u003d pos.getIndex();\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse real\n+        Number re \u003d parseNumber(source, getRealFormat(), pos);\n+        if (re \u003d\u003d null) {\n+            // invalid real number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse sign\n+        int startIndex \u003d pos.getIndex();\n+        char c \u003d parseNextCharacter(source, pos);\n+        int sign \u003d 0;\n+        switch (c) {\n+        case 0 :\n+            // no sign\n+            // return real only complex number\n+            return new Complex(re.doubleValue(), 0.0);\n+        case \u0027-\u0027 :\n+            sign \u003d -1;\n+            break;\n+        case \u0027+\u0027 :\n+            sign \u003d 1;\n+            break;\n+        default :\n+            // invalid sign\n+            // set index back to initial, error index should be the last\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse imaginary\n+        Number im \u003d parseNumber(source, getRealFormat(), pos);\n+        if (im \u003d\u003d null) {\n+            // invalid imaginary number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse imaginary character\n+        int n \u003d getImaginaryCharacter().length();\n+        startIndex \u003d pos.getIndex();\n+        int endIndex \u003d startIndex + n;\n+        if (source.substring(startIndex, endIndex).compareTo(\n+            getImaginaryCharacter()) !\u003d 0) {\n+            // set index back to initial, error index should be the start index\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+        pos.setIndex(endIndex);\n+\n+        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n+    }\n+     \n+    /**\n+     * Parses \u003ccode\u003esource\u003c/code\u003e until a non-whitespace character is found.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.  On output, \u003ccode\u003epos\u003c/code\u003e\n+     *        holds the index of the next non-whitespace character.\n+     */\n+    private void parseAndIgnoreWhitespace(String source, ParsePosition pos) {\n+        parseNextCharacter(source, pos);\n+        pos.setIndex(pos.getIndex() - 1);\n+    }\n+\n+    /**\n+     * Parses \u003ccode\u003esource\u003c/code\u003e until a non-whitespace character is found.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the first non-whitespace character.\n+     */\n+    private char parseNextCharacter(String source, ParsePosition pos) {\n+         int index \u003d pos.getIndex();\n+         int n \u003d source.length();\n+         char ret \u003d 0;\n+\n+         if (index \u003c n) {\n+             char c;\n+             do {\n+                 c \u003d source.charAt(index++);\n+             } while (Character.isWhitespace(c) \u0026\u0026 index \u003c n);\n+             pos.setIndex(index);\n+         \n+             if (index \u003c n) {\n+                 ret \u003d c;\n+             }\n+         }\n+         \n+         return ret;\n+    }\n+    \n+    /**\n+     * Parses \u003ccode\u003esource\u003c/code\u003e for a special double values.  These values\n+     * include Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n+     *\n+     * @param source the string to parse\n+     * @param value the special value to parse.\n+     * @param pos input/ouput parsing parameter.\n+     * @return the special number.\n+     */\n+    private Number parseNumber(String source, double value, ParsePosition pos) {\n+        Number ret \u003d null;\n+        \n+        StringBuffer sb \u003d new StringBuffer();\n+        sb.append(\u0027(\u0027);\n+        sb.append(value);\n+        sb.append(\u0027)\u0027);\n+        \n+        int n \u003d sb.length();\n+        int startIndex \u003d pos.getIndex();\n+        int endIndex \u003d startIndex + n;\n+        if (endIndex \u003c source.length()) {\n+            if (source.substring(startIndex, endIndex).compareTo(sb.toString()) \u003d\u003d 0) {\n+                ret \u003d new Double(value);\n+                pos.setIndex(endIndex);\n+            }\n+        }\n+        \n+        return ret;\n+    }\n+    \n+    /**\n+     * Parses \u003ccode\u003esource\u003c/code\u003e for a number.  This method can parse normal,\n+     * numeric values as well as special values.  These special values include\n+     * Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n+     *\n+     * @param source the string to parse\n+     * @param format the number format used to parse normal, numeric values.\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed number.\n+     */\n+    private Number parseNumber(String source, NumberFormat format, ParsePosition pos) {\n+        int startIndex \u003d pos.getIndex();\n+        Number number \u003d getRealFormat().parse(source, pos);\n+        int endIndex \u003d pos.getIndex();\n+        \n+        // check for error parsing number\n+        if (startIndex \u003d\u003d endIndex) {\n+            // try parsing special numbers\n+            double[] special \u003d {Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};\n+            for (int i \u003d 0; i \u003c special.length; ++i) {\n+                number \u003d parseNumber(source, special[i], pos);\n+                if (number !\u003d null) {\n+                    break;\n+                }\n+            }\n+        }\n+        \n+        return number;\n+    }\n+\n+    /**\n+     * Parses a string to produce a object.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed object.\n+     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        return parse(source, pos);\n+    }\n+    /**\n+     * Modify the imaginaryCharacter.\n+     * @param imaginaryCharacter The new imaginaryCharacter value.\n+     * @throws IllegalArgumentException if \u003ccode\u003eimaginaryCharacter\u003c/code\u003e is\n+     *         \u003ccode\u003enull\u003c/code\u003e or an empty string.\n+     */\n+    public void setImaginaryCharacter(String imaginaryCharacter) {\n+        if (imaginaryCharacter \u003d\u003d null || imaginaryCharacter.length() \u003d\u003d 0) {\n+            throw new IllegalArgumentException(\n+                \"imaginaryCharacter must be a non-empty string.\");\n+        }\n+        this.imaginaryCharacter \u003d imaginaryCharacter;\n+    }\n+    \n+    /**\n+     * Modify the imaginaryFormat.\n+     * @param imaginaryFormat The new imaginaryFormat value.\n+     * @throws IllegalArgumentException if \u003ccode\u003eimaginaryFormat\u003c/code\u003e is\n+     *         \u003ccode\u003enull\u003c/code\u003e.\n+     */\n+    public void setImaginaryFormat(NumberFormat imaginaryFormat) {\n+        if (imaginaryFormat \u003d\u003d null) {\n+            throw new IllegalArgumentException(\n+                \"imaginaryFormat can not be null.\");\n+        }\n+        this.imaginaryFormat \u003d imaginaryFormat;\n+    }\n+    \n+    /**\n+     * Modify the realFormat.\n+     * @param realFormat The new realFormat value.\n+     * @throws IllegalArgumentException if \u003ccode\u003erealFormat\u003c/code\u003e is\n+     *         \u003ccode\u003enull\u003c/code\u003e.\n+     */\n+    public void setRealFormat(NumberFormat realFormat) {\n+        if (realFormat \u003d\u003d null) {\n+            throw new IllegalArgumentException(\n+                \"realFormat can not be null.\");\n+        }\n+        this.realFormat \u003d realFormat;\n+    }\n+}\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [662,693]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [694,718]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [750,782]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [783,814]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SimpleType [1136,1142]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "FieldDeclaration [1262,1368]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "FieldDeclaration [1504,1592]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "FieldDeclaration [1598,1676]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [1948,2234]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [2244,2691]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [3040,3473]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [3483,4136]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [4462,4916]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [4926,6121]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [6131,7409]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [7415,8555]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [8565,8738]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [8748,8915]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [8925,9072]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [9078,9755]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [9765,12221]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [12232,12681]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [12687,13426]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [13436,14408]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [14418,15586]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [15592,15969]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [15974,16551]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [16561,17048]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [17058,17495]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Javadoc [1686,1838]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ConstructorInvocation [1876,1936]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ConstructorInvocation [2973,3024]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "StringLiteral: \"i\" [1225,1228]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "FieldDeclaration [1235,1340]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "Javadoc [1346,1478]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [1767,1812]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [1824,2253]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [2259,3460]",
          "to": ""
        }
      ]
    }
  ],
  "inducing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [],
      "num": 0
    },
    "add_functions": {
      "qualified_names": [
        "org.apache.commons.math.complex.ComplexFormat:ComplexFormat:[NumberFormat format]:null",
        "org.apache.commons.math.complex.ComplexFormat:parseObject:[String source, ParsePosition pos]:Object",
        "org.apache.commons.math.complex.ComplexFormat:formatDouble:[double value, NumberFormat format, StringBuffer toAppendTo, FieldPosition pos]:StringBuffer",
        "org.apache.commons.math.complex.ComplexFormat:getImaginaryCharacter:[]:String",
        "org.apache.commons.math.complex.ComplexFormat:parseNextCharacter:[String source, ParsePosition pos]:char",
        "org.apache.commons.math.complex.ComplexFormat:ComplexFormat:[String imaginaryCharacter, NumberFormat realFormat, NumberFormat imaginaryFormat]:null",
        "org.apache.commons.math.complex.ComplexFormat:parseAndIgnoreWhitespace:[String source, ParsePosition pos]:void",
        "org.apache.commons.math.complex.ComplexFormat:ComplexFormat:[NumberFormat realFormat, NumberFormat imaginaryFormat]:null",
        "org.apache.commons.math.complex.ComplexFormat:ComplexFormat:[String imaginaryCharacter, NumberFormat format]:null",
        "org.apache.commons.math.complex.ComplexFormat:setImaginaryFormat:[NumberFormat imaginaryFormat]:void",
        "org.apache.commons.math.complex.ComplexFormat:getRealFormat:[]:NumberFormat",
        "org.apache.commons.math.complex.ComplexFormat:format:[Object obj, StringBuffer toAppendTo, FieldPosition pos]:StringBuffer",
        "org.apache.commons.math.complex.ComplexFormat:setImaginaryCharacter:[String imaginaryCharacter]:void",
        "org.apache.commons.math.complex.ComplexFormat:setRealFormat:[NumberFormat realFormat]:void",
        "org.apache.commons.math.complex.ComplexFormat:formatComplex:[Complex c]:String",
        "org.apache.commons.math.complex.ComplexFormat:parseNumber:[String source, NumberFormat format, ParsePosition pos]:Number",
        "org.apache.commons.math.complex.ComplexFormat:parse:[String source, ParsePosition pos]:Complex",
        "org.apache.commons.math.complex.ComplexFormat:format:[Complex complex, StringBuffer toAppendTo, FieldPosition pos]:StringBuffer",
        "org.apache.commons.math.complex.ComplexFormat:getDefaultNumberFormat:[]:NumberFormat",
        "org.apache.commons.math.complex.ComplexFormat:parse:[String source]:Complex",
        "org.apache.commons.math.complex.ComplexFormat:getImaginaryFormat:[]:NumberFormat",
        "org.apache.commons.math.complex.ComplexFormat:parseNumber:[String source, double value, ParsePosition pos]:Number"
      ],
      "num": 22
    },
    "delete_functions": {
      "qualified_names": [
        "org.apache.commons.math.complex.ComplexFormat:ComplexFormat:[String imaginaryCharacter, int fractionDigits]:null",
        "org.apache.commons.math.complex.ComplexFormat:format:[Complex c]:String"
      ],
      "num": 2
    }
  },
  "trigger_tests": [
    {
      "test_class": "org.apache.commons.math.complex.ComplexFormatTest",
      "test_function": "testForgottenImaginaryCharacter",
      "exception": "java.lang.StringIndexOutOfBoundsException",
      "message": "String index out of range: 6"
    }
  ],
  "fixing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/java/org/apache/commons/math/complex/ComplexFormat.java",
        "src/java/org/apache/commons/math/complex/ComplexFormat.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "org.apache.commons.math.complex.ComplexFormat:parse:[String source, ParsePosition pos]:Complex"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "org.apache.commons.math.complex.ComplexFormat:parse:[String source, ParsePosition pos]:Complex"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "377"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "377",
            "378",
            "379"
          ],
          "num": 3
        }
      ],
      "diff": "diff --git a/src/java/org/apache/commons/math/complex/ComplexFormat.java b/src/java/org/apache/commons/math/complex/ComplexFormat.java\nindex c22d873..0757d9b 100644\n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n@@ -374,7 +374,9 @@\n         int n \u003d getImaginaryCharacter().length();\n         startIndex \u003d pos.getIndex();\n         int endIndex \u003d startIndex + n;\n-        if (source.substring(startIndex, endIndex).compareTo(\n+        if ((startIndex \u003e\u003d source.length()) ||\n+            (endIndex \u003e source.length()) ||\n+            source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) !\u003d 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n",
      "operations": [
        {
          "type": "insert-node",
          "from": "",
          "to": "InfixExpression [13468,13650]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ParenthesizedExpression [13468,13499]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "INFIX_EXPRESSION_OPERATOR: || [13500,13502]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ParenthesizedExpression [13515,13543]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        }
      ]
    }
  ],
  "fixing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [],
      "num": 0
    },
    "add_functions": {
      "qualified_names": [],
      "num": 0
    },
    "delete_functions": {
      "qualified_names": [],
      "num": 0
    }
  },
  "patch_changed_mths": {
    "qualified_names": [
      "org.apache.commons.math.complex.ComplexFormat:parse(Ljava/lang/String;Ljava/text/ParsePosition;)Lorg/apache/commons/math/complex/Complex;"
    ],
    "num": 1
  }
}