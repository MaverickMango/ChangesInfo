diff -r -u inducing/src/com/google/javascript/jscomp/CodeGenerator.java buggy/src/com/google/javascript/jscomp/CodeGenerator.java
--- inducing/src/com/google/javascript/jscomp/CodeGenerator.java	2023-06-12 11:40:24.302814833 +0800
+++ buggy/src/com/google/javascript/jscomp/CodeGenerator.java	2023-06-12 11:40:24.070825571 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004 Google Inc.
+ * Copyright 2004 The Closure Compiler Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,26 +16,59 @@
 
 package com.google.javascript.jscomp;
 
+import com.google.common.base.Charsets;
 import com.google.common.base.Preconditions;
-import com.google.common.base.StringUtil;
+import com.google.common.collect.Maps;
+import com.google.javascript.jscomp.NodeUtil.MatchNotFunction;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.TokenStream;
 
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.nio.charset.CharsetEncoder;
+import java.util.Map;
 
 /**
  * CodeGenerator generates codes from a parse tree, sending it to the specified
  * CodeConsumer.
  *
-*
-*
  */
 class CodeGenerator {
+  // A memoizer for formatting strings as JS strings.
+  private final Map<String, String> ESCAPED_JS_STRINGS = Maps.newHashMap();
+
+  private static final char[] HEX_CHARS
+      = { '0', '1', '2', '3', '4', '5', '6', '7',
+          '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
 
   private final CodeConsumer cc;
 
-  CodeGenerator(CodeConsumer consumer) {
+  private final CharsetEncoder outputCharsetEncoder;
+
+  CodeGenerator(
+      CodeConsumer consumer, Charset outputCharset) {
     cc = consumer;
+    if (outputCharset == null || outputCharset == Charsets.US_ASCII) {
+      // If we want our default (pretending to be UTF-8, but escaping anything
+      // outside of straight ASCII), then don't use the encoder, but
+      // just special-case the code.  This keeps the normal path through
+      // the code identical to how it's been for years.
+      this.outputCharsetEncoder = null;
+    } else {
+      this.outputCharsetEncoder = outputCharset.newEncoder();
+    }
+  }
+
+  CodeGenerator(CodeConsumer consumer) {
+    this(consumer, null);
+  }
+
+  /**
+   * Insert a ECMASCRIPT 5 strict annotation.
+   */
+  public void tagAsStrict() {
+    add("'use strict';");
   }
 
   void add(String str) {
@@ -63,7 +96,10 @@
 
     // Handle all binary operators
     if (opstr != null && first != last) {
-      Preconditions.checkState(childCount == 2);
+      Preconditions.checkState(
+          childCount == 2,
+          "Bad binary operator \"%s\": expected 2 arguments but got %s",
+          opstr, childCount);
       int p = NodeUtil.precedence(type);
       addLeftExpr(first, p, context);
       cc.addOp(opstr, true);
@@ -92,7 +128,7 @@
     switch (type) {
       case Token.TRY: {
         Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&
-                first.getNext().getChildCount() <= 1);
+                !first.getNext().hasMoreThanOneChild());
         Preconditions.checkState(childCount >= 2 && childCount <= 3);
 
         add("try");
@@ -113,12 +149,7 @@
       }
 
       case Token.CATCH:
-        Preconditions.checkState(childCount == 3);
-        if (first.getNext().getType() != Token.EMPTY) {
-          throw new Error("Catch conditions not suppored because I think" +
-                          " that it may be a netscape only feature.");
-        }
-
+        Preconditions.checkState(childCount == 2);
         add("catch(");
         add(first);
         add(")");
@@ -152,6 +183,11 @@
         }
         break;
 
+      case Token.LABEL_NAME:
+        Preconditions.checkState(!n.getString().isEmpty());
+        addIdentifier(n.getString());
+        break;
+
       case Token.NAME:
         if (first == null || first.getType() == Token.EMPTY) {
           addIdentifier(n.getString());
@@ -167,12 +203,11 @@
             addExpr(first, 0, getContextForNoInOperator(context));
           }
         }
-
         break;
 
       case Token.ARRAYLIT:
         add("[");
-        addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));
+        addArrayList(first);
         add("]");
         break;
 
@@ -183,6 +218,7 @@
         break;
 
       case Token.COMMA:
+        Preconditions.checkState(childCount == 2);
         addList(first, false, context);
         break;
 
@@ -195,8 +231,7 @@
       case Token.VOID:
       case Token.NOT:
       case Token.BITNOT:
-      case Token.POS:
-      case Token.NEG: {
+      case Token.POS: {
         // All of these unary operators are right-associative
         Preconditions.checkState(childCount == 1);
         cc.addOp(NodeUtil.opToStrNoFail(type), false);
@@ -204,14 +239,30 @@
         break;
       }
 
+      case Token.NEG: {
+        Preconditions.checkState(childCount == 1);
+
+        // It's important to our sanity checker that the code
+        // we print produces the same AST as the code we parse back.
+        // NEG is a weird case because Rhino parses "- -2" as "2".
+        if (n.getFirstChild().getType() == Token.NUMBER) {
+          cc.addNumber(-n.getFirstChild().getDouble());
+        } else {
+          cc.addOp(NodeUtil.opToStrNoFail(type), false);
+          addExpr(first, NodeUtil.precedence(type));
+        }
+
+        break;
+      }
+
       case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
         addLeftExpr(first, p + 1, context);
         cc.addOp("?", true);
-        addExpr(first.getNext(), p);
+        addExpr(first.getNext(), 1);
         cc.addOp(":", true);
-        addExpr(last, p);
+        addExpr(last, 1);
         break;
       }
 
@@ -221,7 +272,7 @@
           throw new Error("Expected children to be strings");
         }
 
-        String regexp = regexpEscape(first.getString());
+        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
 
         // I only use one .add because whitespace matters
         if (childCount == 2) {
@@ -244,6 +295,9 @@
         break;
 
       case Token.FUNCTION:
+        if (n.getClass() != Node.class) {
+          throw new Error("Unexpected Node subclass.");
+        }
         Preconditions.checkState(childCount == 3);
         boolean funcNeedsParens = (context == Context.START_OF_EXPR);
         if (funcNeedsParens) {
@@ -262,13 +316,67 @@
         }
         break;
 
+      case Token.GET:
+      case Token.SET:
+        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);
+        Preconditions.checkState(childCount == 1);
+        Preconditions.checkState(first.getType() == Token.FUNCTION);
+
+        // Get methods are unnamed
+        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
+        if (type == Token.GET) {
+          // Get methods have no parameters.
+          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
+          add("get ");
+        } else {
+          // Set methods have one parameter.
+          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
+          add("set ");
+        }
+
+        // The name is on the GET or SET node.
+        String name = n.getString();
+        Node fn = first;
+        Node parameters = fn.getChildAtIndex(1);
+        Node body = fn.getLastChild();
+
+        // Add the property name.
+        if (!n.isQuotedString() &&
+            TokenStream.isJSIdentifier(name) &&
+            // do not encode literally any non-literal characters that were
+            // unicode escaped.
+            NodeUtil.isLatin(name)) {
+          add(name);
+        } else {
+          // Determine if the string is a simple number.
+          double d = getSimpleNumber(name);
+          if (!Double.isNaN(d)) {
+            cc.addNumber(d);
+          } else {
+            addJsString(n.getString());
+          }
+        }
+
+        add(parameters);
+        add(body, Context.PRESERVE_BLOCK);
+        break;
+
       case Token.SCRIPT:
       case Token.BLOCK: {
-        boolean stripBlock = n.isSyntheticBlock() ||
-            ((context != Context.PRESERVE_BLOCK) && (n.getChildCount() < 2));
-        if (!stripBlock) {
+        if (n.getClass() != Node.class) {
+          throw new Error("Unexpected Node subclass.");
+        }
+        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
+        if (preserveBlock) {
           cc.beginBlock();
         }
+
+        boolean preferLineBreaks =
+            type == Token.SCRIPT ||
+            (type == Token.BLOCK &&
+                !preserveBlock &&
+                n.getParent() != null &&
+                n.getParent().getType() == Token.SCRIPT);
         for (Node c = first; c != null; c = c.getNext()) {
           add(c, Context.STATEMENT);
 
@@ -283,12 +391,12 @@
 
           // Prefer to break lines in between top-level statements
           // because top level statements are more homogeneous.
-          if (type == Token.SCRIPT) {
+          if (preferLineBreaks) {
             cc.notePreferredLineBreak();
           }
         }
-        if (!stripBlock) {
-          cc.endBlock(context == Context.STATEMENT);
+        if (preserveBlock) {
+          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
         }
         break;
       }
@@ -306,7 +414,7 @@
           add(";");
           add(first.getNext().getNext());
           add(")");
-          addNonEmptyExpression(
+          addNonEmptyStatement(
               last, getContextForNonEmptyExpression(context), false);
         } else {
           Preconditions.checkState(childCount == 3);
@@ -315,7 +423,7 @@
           add("in");
           add(first.getNext());
           add(")");
-          addNonEmptyExpression(
+          addNonEmptyStatement(
               last, getContextForNonEmptyExpression(context), false);
         }
         break;
@@ -323,7 +431,7 @@
       case Token.DO:
         Preconditions.checkState(childCount == 2);
         add("do");
-        addNonEmptyExpression(first, Context.OTHER, false);
+        addNonEmptyStatement(first, Context.OTHER, false);
         add("while(");
         add(last);
         add(")");
@@ -335,7 +443,7 @@
         add("while(");
         add(first);
         add(")");
-        addNonEmptyExpression(
+        addNonEmptyStatement(
             last, getContextForNonEmptyExpression(context), false);
         break;
 
@@ -344,8 +452,12 @@
         break;
 
       case Token.GETPROP: {
-        Preconditions.checkState(childCount == 2);
-        Preconditions.checkState(last.getType() == Token.STRING);
+        Preconditions.checkState(
+            childCount == 2,
+            "Bad GETPROP: expected 2 children, but got %s", childCount);
+        Preconditions.checkState(
+            last.getType() == Token.STRING,
+            "Bad GETPROP: RHS should be STRING");
         boolean needsParens = (first.getType() == Token.NUMBER);
         if (needsParens) {
           add("(");
@@ -360,7 +472,9 @@
       }
 
       case Token.GETELEM:
-        Preconditions.checkState(childCount == 2);
+        Preconditions.checkState(
+            childCount == 2,
+            "Bad GETELEM: expected 2 children but got %s", childCount);
         addLeftExpr(first, NodeUtil.precedence(type), context);
         add("[");
         add(first.getNext());
@@ -372,7 +486,7 @@
         add("with(");
         add(first);
         add(")");
-        addNonEmptyExpression(
+        addNonEmptyStatement(
             last, getContextForNonEmptyExpression(context), false);
         break;
 
@@ -380,7 +494,7 @@
       case Token.DEC: {
         Preconditions.checkState(childCount == 1);
         String o = type == Token.INC ? "++" : "--";
-        int postProp = n.getIntProp(Node.INCRDECR_PROP, 0);
+        int postProp = n.getIntProp(Node.INCRDECR_PROP);
         // A non-zero post-prop value indicates a post inc/dec, default of zero
         // is a pre-inc/dec.
         if (postProp != 0) {
@@ -394,7 +508,23 @@
       }
 
       case Token.CALL:
-        addLeftExpr(first, NodeUtil.precedence(type), context);
+        // We have two special cases here:
+        // 1) If the left hand side of the call is a direct reference to eval,
+        // then it must have a DIRECT_EVAL annotation. If it does not, then
+        // that means it was originally an indirect call to eval, and that
+        // indirectness must be preserved.
+        // 2) If the left hand side of the call is a property reference,
+        // then the call must not a FREE_CALL annotation. If it does, then
+        // that means it was originally an call without an explicit this and
+        // that must be preserved.
+        if (isIndirectEval(first)
+            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
+          add("(0,");
+          addExpr(first, NodeUtil.precedence(Token.COMMA));
+          add(")");
+        } else {
+          addLeftExpr(first, NodeUtil.precedence(type), context);
+        }
         add("(");
         addList(first.getNext());
         add(")");
@@ -413,13 +543,13 @@
         add(")");
 
         if (hasElse) {
-          addNonEmptyExpression(
+          addNonEmptyStatement(
               first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
           add("else");
-          addNonEmptyExpression(
+          addNonEmptyStatement(
               last, getContextForNonEmptyExpression(context), false);
         } else {
-          addNonEmptyExpression(first.getNext(), Context.OTHER, false);
+          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
           Preconditions.checkState(childCount == 2);
         }
 
@@ -440,6 +570,9 @@
         Preconditions.checkState(childCount <= 1);
         add("continue");
         if (childCount == 1) {
+          if (first.getType() != Token.LABEL_NAME) {
+            throw new Error("Unexpected token type. Should be LABEL_NAME.");
+          }
           add(" ");
           add(first);
         }
@@ -456,6 +589,9 @@
         Preconditions.checkState(childCount <= 1);
         add("break");
         if (childCount == 1) {
+          if (first.getType() != Token.LABEL_NAME) {
+            throw new Error("Unexpected token type. Should be LABEL_NAME.");
+          }
           add(" ");
           add(first);
         }
@@ -463,9 +599,8 @@
         break;
 
       case Token.EXPR_VOID:
-        // TODO(johnlenz): Enable this exception once the external users of
-        //     CodePrinter have been corrected.
-        // throw new Error("EXPR_VOID should not be used in this codebase.");
+        throw new Error("Unexpected EXPR_VOID. Should be EXPR_RESULT.");
+
       case Token.EXPR_RESULT:
         Preconditions.checkState(childCount == 1);
         add(first, Context.START_OF_EXPR);
@@ -477,9 +612,9 @@
         int precedence = NodeUtil.precedence(type);
 
         // If the first child contains a CALL, then claim higher precedence
-        // to force parens. Otherwise, when parsed, NEW will bind to the
-        // first viable parens
-        if (NodeUtil.containsCall(first)) {
+        // to force parentheses. Otherwise, when parsed, NEW will bind to the
+        // first viable parentheses (don't traverse into functions).
+        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {
           precedence = NodeUtil.precedence(first.getType()) + 1;
         }
         addExpr(first, precedence);
@@ -494,8 +629,13 @@
         break;
 
       case Token.STRING:
-        Preconditions.checkState(childCount == 0);
-        add(jsString(n.getString()));
+        if (childCount !=
+            ((n.getParent() != null &&
+              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {
+          throw new IllegalStateException(
+              "Unexpected String children: " + n.getParent().toStringTree());
+        }
+        addJsString(n.getString());
         break;
 
       case Token.DELPROP:
@@ -505,31 +645,42 @@
         break;
 
       case Token.OBJECTLIT: {
-        Preconditions.checkState(childCount % 2 == 0);
         boolean needsParens = (context == Context.START_OF_EXPR);
         if (needsParens) {
           add("(");
         }
         add("{");
-        for (Node c = first; c != null; c = c.getNext().getNext()) {
+        for (Node c = first; c != null; c = c.getNext()) {
           if (c != first) {
             cc.listSeparator();
           }
 
-          // Object literal property names don't have to be quoted if they are
-          // not JavaScript keywords
-          if (c.getType() == Token.STRING &&
-              !TokenStream.isKeyword(c.getString()) &&
-              TokenStream.isJSIdentifier(c.getString()) &&
-              // do not encode literally any non-literal characters that were
-              // unicode escaped.
-              NodeUtil.isLatin(c.getString())) {
-            add(c.getString());
+          if (c.getType() == Token.GET || c.getType() == Token.SET) {
+            add(c);
           } else {
-            addExpr(c, 1);
+            Preconditions.checkState(c.getType() == Token.STRING);
+            String key = c.getString();
+            // Object literal property names don't have to be quoted if they
+            // are not JavaScript keywords
+            if (!c.isQuotedString() &&
+                !TokenStream.isKeyword(key) &&
+                TokenStream.isJSIdentifier(key) &&
+                // do not encode literally any non-literal characters that
+                // were unicode escaped.
+                NodeUtil.isLatin(key)) {
+              add(key);
+            } else {
+              // Determine if the string is a simple number.
+              double d = getSimpleNumber(key);
+              if (!Double.isNaN(d)) {
+                cc.addNumber(d);
+              } else {
+                addExpr(c, 1);
+              }
+            }
+            add(":");
+            addExpr(c.getFirstChild(), 1);
           }
-          add(":");
-          addExpr(c.getNext(), 1);
         }
         add("}");
         if (needsParens) {
@@ -562,9 +713,12 @@
 
       case Token.LABEL:
         Preconditions.checkState(childCount == 2);
+        if (first.getType() != Token.LABEL_NAME) {
+          throw new Error("Unexpected token type. Should be LABEL_NAME.");
+        }
         add(first);
         add(":");
-        addNonEmptyExpression(
+        addNonEmptyStatement(
             last, getContextForNonEmptyExpression(context), true);
         break;
 
@@ -580,6 +734,39 @@
     cc.endSourceMapping(n);
   }
 
+  static boolean isSimpleNumber(String s) {
+    int len = s.length();
+    for (int index = 0; index < len; index++) {
+      char c = s.charAt(index);
+      if (c < '0' || c > '9') {
+        return false;
+      }
+    }
+    return len > 0;
+  }
+
+  static double getSimpleNumber(String s) {
+    if (isSimpleNumber(s)) {
+      try {
+        long l = Long.parseLong(s);
+        if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {
+          return l;
+        }
+      } catch (NumberFormatException e) {
+        // The number was too long to parse. Fall through to NaN.
+      }
+    }
+    return Double.NaN;
+  }
+
+  /**
+   * @return Whether the name is an indirect eval.
+   */
+  private boolean isIndirectEval(Node n) {
+    return n.getType() == Token.NAME && "eval".equals(n.getString()) &&
+        !n.getBooleanProp(Node.DIRECT_EVAL);
+  }
+
   /**
    * Adds a block or expression, substituting a VOID with an empty statement.
    * This is used for "for (...);" and "if (...);" type statements.
@@ -587,20 +774,25 @@
    * @param n The node to print.
    * @param context The context to determine how the node should be printed.
    */
-  private void addNonEmptyExpression(
+  private void addNonEmptyStatement(
       Node n, Context context, boolean allowNonBlockChild) {
     Node nodeToProcess = n;
 
     if (!allowNonBlockChild && n.getType() != Token.BLOCK) {
-      // TODO(johnlenz) : Enable this when the JsMinifier is corrected.
-      // throw new Error("Missing BLOCK child.");
+      throw new Error("Missing BLOCK child.");
     }
 
-    // Strip unneeded blocks, that is blocks with <2 children.
+    // Strip unneeded blocks, that is blocks with <2 children unless
+    // the CodePrinter specifically wants to keep them.
     if (n.getType() == Token.BLOCK) {
-      int count = getNonEmptyChildCount(n);
+      int count = getNonEmptyChildCount(n, 2);
       if (count == 0) {
-        cc.endStatement(true);
+        if (cc.shouldPreserveExtraBlocks()) {
+          cc.beginBlock();
+          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
+        } else {
+          cc.endStatement(true);
+        }
         return;
       }
 
@@ -609,18 +801,22 @@
         //   Safari needs a block around function declarations.
         //   IE6/7 needs a block around DOs.
         Node firstAndOnlyChild = getFirstNonEmptyChild(n);
-        if (firstAndOnlyChild.getType() == Token.FUNCTION ||
-            firstAndOnlyChild.getType() == Token.DO) {
+        boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks();
+        if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {
           cc.beginBlock();
           add(firstAndOnlyChild, Context.STATEMENT);
           cc.maybeLineBreak();
-          cc.endBlock(context == Context.STATEMENT);
+          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
           return;
         } else {
           // Continue with the only child.
           nodeToProcess = firstAndOnlyChild;
         }
       }
+
+      if (count > 1) {
+        context = Context.PRESERVE_BLOCK;
+      }
     }
 
     if (nodeToProcess.getType() == Token.EMPTY) {
@@ -637,6 +833,32 @@
   }
 
   /**
+   * @return Whether the Node is a DO or FUNCTION (with or without
+   * labels).
+   */
+  private boolean isOneExactlyFunctionOrDo(Node n) {
+    if (n.getType() == Token.LABEL) {
+      Node labeledStatement = n.getLastChild();
+      if (labeledStatement.getType() != Token.BLOCK) {
+        return isOneExactlyFunctionOrDo(labeledStatement);
+      } else {
+        // For labels with block children, we need to ensure that a
+        // labeled FUNCTION or DO isn't generated when extraneous BLOCKs
+        // are skipped.
+        if (getNonEmptyChildCount(n, 2) == 1) {
+          return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));
+        } else {
+          // Either a empty statement or an block with more than one child,
+          // way it isn't a FUNCTION or DO.
+          return false;
+        }
+      }
+    } else {
+      return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);
+    }
+  }
+
+  /**
    * Adds a node at the left-hand side of an expression. Unlike
    * {@link #addExpr(Node,int)}, this preserves information about the context.
    *
@@ -693,27 +915,19 @@
    * slot.
    * @param firstInList The first in the node list (chained through the next
    * property).
-   * @param skipIndexes If not null, then the array of skipped entries in the
-   * array.
    */
-  void addList(Node firstInList, int[] skipIndexes) {
-    int nextSlot = 0;
-    int nextSkipSlot = 0;
+  void addArrayList(Node firstInList) {
+    boolean lastWasEmpty = false;
     for (Node n = firstInList; n != null; n = n.getNext()) {
-      while (skipIndexes != null && nextSkipSlot < skipIndexes.length) {
-        if (nextSlot == skipIndexes[nextSkipSlot]) {
-          cc.listSeparator();
-          nextSlot++;
-          nextSkipSlot++;
-        } else {
-          break;
-        }
-      }
       if (n != firstInList) {
         cc.listSeparator();
       }
       addExpr(n, 1);
-      nextSlot++;
+      lastWasEmpty = n.getType() == Token.EMPTY;
+    }
+
+    if (lastWasEmpty) {
+      cc.listSeparator();
     }
   }
 
@@ -730,7 +944,16 @@
   }
 
   /** Outputs a js string, using the optimal (single/double) quote character */
-  static String jsString(String s) {
+  void addJsString(String s) {
+    String cached = ESCAPED_JS_STRINGS.get(s);
+    if (cached == null) {
+      cached = jsString(s);
+      ESCAPED_JS_STRINGS.put(s, cached);
+    }
+    add(cached);
+  }
+
+  String jsString(String s) {
     int singleq = 0, doubleq = 0;
 
     // could count the quotes and pick the optimal quote character
@@ -755,24 +978,41 @@
       singlequote = "\'";
     }
 
-    return strEscape(s, quote, doublequote, singlequote, "\\\\");
+    return strEscape(s, quote, doublequote, singlequote, "\\\\",
+        outputCharsetEncoder);
   }
 
   /** Escapes regular expression */
+  static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) {
+    return strEscape(s, '/', "\"", "'", "\\", outputCharsetEncoder);
+  }
+
+  /**
+   * Escapes the given string to a double quoted (") JavaScript/JSON string
+   */
+  static String escapeToDoubleQuotedJsString(String s) {
+    return strEscape(s, '"',  "\\\"", "\'", "\\\\", null);
+  }
+
+  /* If the user doesn't want to specify an output charset encoder, assume
+     they want Latin/ASCII characters only.
+   */
   static String regexpEscape(String s) {
-    return strEscape(s, '/', "\"", "'", "\\");
+    return regexpEscape(s, null);
   }
 
   /** Helper to escape javascript string as well as regular expression */
   static String strEscape(String s, char quote,
                           String doublequoteEscape,
                           String singlequoteEscape,
-                          String backslashEscape) {
-    StringBuilder sb = new StringBuilder();
+                          String backslashEscape,
+                          CharsetEncoder outputCharsetEncoder) {
+    StringBuilder sb = new StringBuilder(s.length() + 2);
     sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
+        case '\0': sb.append("\\0"); break;
         case '\n': sb.append("\\n"); break;
         case '\r': sb.append("\\r"); break;
         case '\t': sb.append("\\t"); break;
@@ -788,25 +1028,45 @@
             sb.append(c);
           }
           break;
-        case '<':                       // Break </script into <\/script
+        case '<':
+          // Break </script into <\/script
           final String END_SCRIPT = "/script";
+
+          // Break <!-- into <\!--
+          final String START_COMMENT = "!--";
+
           if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
-              END_SCRIPT.length())) {
+                              END_SCRIPT.length())) {
+            sb.append("<\\");
+          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
+                                     START_COMMENT.length())) {
             sb.append("<\\");
           } else {
             sb.append(c);
           }
           break;
         default:
-          // Please keep in sync with the same code in identifierEscape().
-          if (c > 0x1F && c < 0x7F) {
-            // Non-control ASCII characters are safe to transmit
-            sb.append(c);
+          // If we're given an outputCharsetEncoder, then check if the
+          //  character can be represented in this character set.
+          if (outputCharsetEncoder != null) {
+            if (outputCharsetEncoder.canEncode(c)) {
+              sb.append(c);
+            } else {
+              // Unicode-escape the character.
+              appendHexJavaScriptRepresentation(sb, c);
+            }
           } else {
-            // Other characters can be misinterpreted by some js parsers,
-            // or perhaps mangled by proxies along the way,
-            // so we play it safe and unicode escape them.
-            StringUtil.appendHexJavaScriptRepresentation(sb, c);
+            // No charsetEncoder provided - pass straight latin characters
+            // through, and escape the rest.  Doing the explicit character
+            // check is measurably faster than using the CharsetEncoder.
+            if (c > 0x1f && c < 0x7f) {
+              sb.append(c);
+            } else {
+              // Other characters can be misinterpreted by some js parsers,
+              // or perhaps mangled by proxies along the way,
+              // so we play it safe and unicode escape them.
+              appendHexJavaScriptRepresentation(sb, c);
+            }
           }
       }
     }
@@ -824,21 +1084,29 @@
     StringBuilder sb = new StringBuilder();
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
-      // See comments for the same code in strEscape(). Please keep in sync.
+      // Identifiers should always go to Latin1/ ASCII characters because
+      // different browser's rules for valid identifier characters are
+      // crazy.
       if (c > 0x1F && c < 0x7F) {
         sb.append(c);
       } else {
-        StringUtil.appendHexJavaScriptRepresentation(sb, c);
+        appendHexJavaScriptRepresentation(sb, c);
       }
     }
     return sb.toString();
   }
-
-  /** Gets the number of children of this node that are non empty. */
-  private static int getNonEmptyChildCount(Node n) {
+  /**
+   * @param maxCount The maximum number of children to look for.
+   * @return The number of children of this node that are non empty up to
+   * maxCount.
+   */
+  private static int getNonEmptyChildCount(Node n, int maxCount) {
     int i = 0;
-    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
-      if (c.getType() != Token.EMPTY) {
+    Node c = n.getFirstChild();
+    for (; c != null && i < maxCount; c = c.getNext()) {
+      if (c.getType() == Token.BLOCK) {
+        i += getNonEmptyChildCount(c, maxCount-i);
+      } else if (c.getType() != Token.EMPTY) {
         i++;
       }
     }
@@ -848,7 +1116,12 @@
   /** Gets the first non-empty child of the given node. */
   private static Node getFirstNonEmptyChild(Node n) {
     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
-      if (c.getType() != Token.EMPTY) {
+      if (c.getType() == Token.BLOCK) {
+        Node result = getFirstNonEmptyChild(c);
+        if (result != null) {
+          return result;
+        }
+      } else if (c.getType() != Token.EMPTY) {
         return c;
       }
     }
@@ -894,4 +1167,44 @@
     return (context == Context.IN_FOR_INIT_CLAUSE
         ? Context.OTHER : context);
   }
+
+  /**
+   * @see #appendHexJavaScriptRepresentation(int, Appendable)
+   */
+  private static void appendHexJavaScriptRepresentation(
+      StringBuilder sb, char c) {
+    try {
+      appendHexJavaScriptRepresentation(c, sb);
+    } catch (IOException ex) {
+      // StringBuilder does not throw IOException.
+      throw new RuntimeException(ex);
+    }
+  }
+
+  /**
+   * Returns a javascript representation of the character in a hex escaped
+   * format.
+   *
+   * @param codePoint The codepoint to append.
+   * @param out The buffer to which the hex representation should be appended.
+   */
+  private static void appendHexJavaScriptRepresentation(
+      int codePoint, Appendable out)
+      throws IOException {
+    if (Character.isSupplementaryCodePoint(codePoint)) {
+      // Handle supplementary unicode values which are not representable in
+      // javascript.  We deal with these by escaping them as two 4B sequences
+      // so that they will round-trip properly when sent from java to javascript
+      // and back.
+      char[] surrogates = Character.toChars(codePoint);
+      appendHexJavaScriptRepresentation(surrogates[0], out);
+      appendHexJavaScriptRepresentation(surrogates[1], out);
+      return;
+    }
+    out.append("\\u")
+        .append(HEX_CHARS[(codePoint >>> 12) & 0xf])
+        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])
+        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])
+        .append(HEX_CHARS[codePoint & 0xf]);
+  }
 }
diff -r -u inducing/test/com/google/javascript/jscomp/CodePrinterTest.java buggy/test/com/google/javascript/jscomp/CodePrinterTest.java
--- inducing/test/com/google/javascript/jscomp/CodePrinterTest.java	2023-06-12 11:40:24.302814833 +0800
+++ buggy/test/com/google/javascript/jscomp/CodePrinterTest.java	2023-06-12 11:40:24.070825571 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004 Google Inc.
+ * Copyright 2004 The Closure Compiler Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,14 +16,12 @@
 
 package com.google.javascript.jscomp;
 
-import com.google.common.collect.ImmutableList;
+import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 
 import junit.framework.TestCase;
 
-import java.util.List;
-
 public class CodePrinterTest extends TestCase {
   static Node parse(String js) {
     return parse(js, false);
@@ -31,21 +29,43 @@
 
   static Node parse(String js, boolean checkTypes) {
     Compiler compiler = new Compiler();
+    CompilerOptions options = new CompilerOptions();
+    // Allow getters and setters.
+    options.setLanguageIn(LanguageMode.ECMASCRIPT5);
+    compiler.initOptions(options);
     Node n = compiler.parseTestCode(js);
 
     if (checkTypes) {
-      CompilerPass typeResolver = new DefaultPassConfig(null)
-          .resolveTypes.create(compiler);
+      DefaultPassConfig passConfig = new DefaultPassConfig(null);
+      CompilerPass typeResolver = passConfig.resolveTypes.create(compiler);
       Node externs = new Node(Token.SCRIPT);
+      externs.setIsSyntheticBlock(true);
       Node externAndJsRoot = new Node(Token.BLOCK, externs, n);
       externAndJsRoot.setIsSyntheticBlock(true);
       typeResolver.process(externs, n);
+      CompilerPass inferTypes = passConfig.inferTypes.create(compiler);
+      inferTypes.process(externs, n);
     }
 
-    assertEquals("Errors for: " + js, 0, compiler.getErrorCount());
+    checkUnexpectedErrorsOrWarnings(compiler, 0);
     return n;
   }
 
+  private static void checkUnexpectedErrorsOrWarnings(
+      Compiler compiler, int expected) {
+    int actual = compiler.getErrors().length + compiler.getWarnings().length;
+    if (actual != expected) {
+      String msg = "";
+      for (JSError err : compiler.getErrors()) {
+        msg += "Error:" + err.toString() + "\n";
+      }
+      for (JSError err : compiler.getWarnings()) {
+        msg += "Warning:" + err.toString() + "\n";
+      }
+      assertEquals("Unexpected warnings or errors.\n " + msg, expected, actual);
+    }
+  }
+
   String parsePrint(String js, boolean prettyprint, int lineThreshold) {
     return new CodePrinter.Builder(parse(js)).setPrettyPrint(prettyprint)
         .setLineLengthThreshold(lineThreshold).build();
@@ -61,9 +81,21 @@
       int lineThreshold, boolean outputTypes) {
     return new CodePrinter.Builder(parse(js, true)).setPrettyPrint(prettyprint)
         .setOutputTypes(outputTypes)
-        .setLineLengthThreshold(lineThreshold).setLineBreak(lineBreak).build();
+        .setLineLengthThreshold(lineThreshold).setLineBreak(lineBreak)
+        .build();
+  }
+
+  String parsePrint(String js, boolean prettyprint, boolean lineBreak,
+                    int lineThreshold, boolean outputTypes,
+                    boolean tagAsStrict) {
+    return new CodePrinter.Builder(parse(js, true)).setPrettyPrint(prettyprint)
+        .setOutputTypes(outputTypes)
+        .setLineLengthThreshold(lineThreshold).setLineBreak(lineBreak)
+        .setTagAsStrict(tagAsStrict)
+        .build();
   }
 
+
   String printNode(Node n) {
     return new CodePrinter.Builder(n).setLineLengthThreshold(
         CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD).build();
@@ -128,6 +160,10 @@
 
     assertPrint("/--> <\\/script>/g", "/--\\> <\\/script>/g");
 
+    // Break HTML start comments. Certain versions of Webkit
+    // begin an HTML comment when they see this.
+    assertPrint("'<!-- I am a string -->'", "\"<\\!-- I am a string --\\>\"");
+
     // Precedence
     assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");
     assertPrint("(delete a[0])/10", "delete a[0]/10");
@@ -178,11 +214,11 @@
     assertPrint("1 || ({})", "1||{}");
     assertPrint("({}) ? 1 : 2", "({})?1:2");
     assertPrint("0 ? ({}) : 2", "0?{}:2");
-    assertPrint("0 ? 1 : ({})", "0?1:{}");    
+    assertPrint("0 ? 1 : ({})", "0?1:{}");
     assertPrint("typeof ({})", "typeof{}");
     assertPrint("f({})", "f({})");
 
-    // Anonymous functions.
+    // Anonymous function expressions.
     assertPrint("(function(){})", "(function(){})");
     assertPrint("(function(){})()", "(function(){})()");
     assertPrint("(function(){})instanceof Object",
@@ -193,12 +229,28 @@
     assertPrint("var x = function() { }();", "var x=function(){}()");
     assertPrint("(function() {}), 2", "(function(){}),2");
 
-    // Named functions
+    // Name functions expression.
     assertPrint("(function f(){})", "(function f(){})");
+
+    // Function declaration.
     assertPrint("function f(){}", "function f(){}");
 
     // Make sure we don't treat non-latin character escapes as raw strings.
-    assertPrint("({ 'a': 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");
+    assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");
+    assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");
+
+    // Test if statement and for statements with single statements in body.
+    assertPrint("if (true) { alert();}", "if(true)alert()");
+    assertPrint("if (false) {} else {alert(\"a\");}",
+        "if(false);else alert(\"a\")");
+    assertPrint("for(;;) { alert();};", "for(;;)alert()");
+
+    assertPrint("do { alert(); } while(true);",
+        "do alert();while(true)");
+    assertPrint("myLabel: { alert();}",
+        "myLabel:alert()");
+    assertPrint("myLabel: for(;;) continue myLabel;",
+        "myLabel:for(;;)continue myLabel");
 
     // Test nested var statement
     assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");
@@ -219,7 +271,7 @@
     assertPrint("+ - + + - + 3", "+-+ +-+3"); // chained unary plus/minus
     assertPrint("+(--x)", "+--x");
     assertPrint("-(++x)", "-++x");
-    
+
     // needs a space to prevent an ambiguous parse
     assertPrint("-(--x)", "- --x");
     assertPrint("!(~~5)", "!~~5");
@@ -272,6 +324,32 @@
     assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");
   }
 
+  public void testPrintArray() {
+    assertPrint("[void 0, void 0]", "[void 0,void 0]");
+    assertPrint("[undefined, undefined]", "[undefined,undefined]");
+    assertPrint("[ , , , undefined]", "[,,,undefined]");
+    assertPrint("[ , , , 0]", "[,,,0]");
+  }
+
+  public void testHook() {
+    assertPrint("a ? b = 1 : c = 2", "a?b=1:c=2");
+    assertPrint("x = a ? b = 1 : c = 2", "x=a?b=1:c=2");
+    assertPrint("(x = a) ? b = 1 : c = 2", "(x=a)?b=1:c=2");
+
+    assertPrint("x, a ? b = 1 : c = 2", "x,a?b=1:c=2");
+    assertPrint("x, (a ? b = 1 : c = 2)", "x,a?b=1:c=2");
+    assertPrint("(x, a) ? b = 1 : c = 2", "(x,a)?b=1:c=2");
+
+    assertPrint("a ? (x, b) : c = 2", "a?(x,b):c=2");
+    assertPrint("a ? b = 1 : (x,c)", "a?b=1:(x,c)");
+
+    assertPrint("a ? b = 1 : c = 2 + x", "a?b=1:c=2+x");
+    assertPrint("(a ? b = 1 : c = 2) + x", "(a?b=1:c=2)+x");
+    assertPrint("a ? b = 1 : (c = 2) + x", "a?b=1:(c=2)+x");
+
+    assertPrint("a ? (b?1:2) : 3", "a?b?1:2:3");
+  }
+
   public void testPrintInOperatorInForLoop() {
     // Check for in expression in for's init expression.
     // Check alone, with + (higher precedence), with ?: (lower precedence),
@@ -305,6 +383,7 @@
   }
 
   private void assertPrint(String js, String expected) {
+    parse(expected); // validate the expected string is valid js
     assertEquals(expected,
         parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
   }
@@ -382,47 +461,270 @@
             CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
   }
 
-
   public void testPrettyPrinter() {
     // Ensure that the pretty printer inserts line breaks at appropriate
     // places.
-    assertPrettyPrint("(function(){})();","(function() {\n})()");
+    assertPrettyPrint("(function(){})();","(function() {\n})();\n");
     assertPrettyPrint("var a = (function() {});alert(a);",
-        "var a = function() {\n};\nalert(a)");
+        "var a = function() {\n};\nalert(a);\n");
+
+    // Check we correctly handle putting brackets around all if clauses so
+    // we can put breakpoints inside statements.
+    assertPrettyPrint("if (1) {}",
+        "if(1) {\n" +
+        "}\n");
+    assertPrettyPrint("if (1) {alert(\"\");}",
+        "if(1) {\n" +
+        "  alert(\"\")\n" +
+        "}\n");
+    assertPrettyPrint("if (1)alert(\"\");",
+        "if(1) {\n" +
+        "  alert(\"\")\n" +
+        "}\n");
+    assertPrettyPrint("if (1) {alert();alert();}",
+        "if(1) {\n" +
+        "  alert();\n" +
+        "  alert()\n" +
+        "}\n");
+
+    // Don't add blocks if they weren't there already.
+    assertPrettyPrint("label: alert();",
+        "label:alert();\n");
+
+    // But if statements and loops get blocks automagically.
+    assertPrettyPrint("if (1) alert();",
+        "if(1) {\n" +
+        "  alert()\n" +
+        "}\n");
+    assertPrettyPrint("for (;;) alert();",
+        "for(;;) {\n" +
+        "  alert()\n" +
+        "}\n");
+
+    assertPrettyPrint("while (1) alert();",
+        "while(1) {\n" +
+        "  alert()\n" +
+        "}\n");
+
+    // Do we put else clauses in blocks?
+    assertPrettyPrint("if (1) {} else {alert(a);}",
+        "if(1) {\n" +
+        "}else {\n  alert(a)\n}\n");
+
+    // Do we add blocks to else clauses?
+    assertPrettyPrint("if (1) alert(a); else alert(b);",
+        "if(1) {\n" +
+        "  alert(a)\n" +
+        "}else {\n" +
+        "  alert(b)\n" +
+        "}\n");
+
+    // Do we put for bodies in blocks?
+    assertPrettyPrint("for(;;) { alert();}",
+        "for(;;) {\n" +
+         "  alert()\n" +
+         "}\n");
+    assertPrettyPrint("for(;;) {}",
+        "for(;;) {\n" +
+        "}\n");
+    assertPrettyPrint("for(;;) { alert(); alert(); }",
+        "for(;;) {\n" +
+        "  alert();\n" +
+        "  alert()\n" +
+        "}\n");
+
+    // How about do loops?
+    assertPrettyPrint("do { alert(); } while(true);",
+        "do {\n" +
+        "  alert()\n" +
+        "}while(true);\n");
+
+    // label?
+    assertPrettyPrint("myLabel: { alert();}",
+        "myLabel: {\n" +
+        "  alert()\n" +
+        "}\n");
+
+    // Don't move the label on a loop, because then break {label} and
+    // continue {label} won't work.
+    assertPrettyPrint("myLabel: for(;;) continue myLabel;",
+        "myLabel:for(;;) {\n" +
+        "  continue myLabel\n" +
+        "}\n");
+
+    assertPrettyPrint("var a;", "var a;\n");
+  }
+
+  public void testPrettyPrinter2() {
+    assertPrettyPrint(
+        "if(true) f();",
+        "if(true) {\n" +
+        "  f()\n" +
+        "}\n");
+
+    assertPrettyPrint(
+        "if (true) { f() } else { g() }",
+        "if(true) {\n" +
+        "  f()\n" +
+        "}else {\n" +
+        "  g()\n" +
+        "}\n");
+
+    assertPrettyPrint(
+        "if(true) f(); for(;;) g();",
+        "if(true) {\n" +
+        "  f()\n" +
+        "}\n" +
+        "for(;;) {\n" +
+        "  g()\n" +
+        "}\n");
+  }
+
+  public void testPrettyPrinter3() {
+    assertPrettyPrint(
+        "try {} catch(e) {}if (1) {alert();alert();}",
+        "try {\n" +
+        "}catch(e) {\n" +
+        "}\n" +
+        "if(1) {\n" +
+        "  alert();\n" +
+        "  alert()\n" +
+        "}\n");
+
+    assertPrettyPrint(
+        "try {} finally {}if (1) {alert();alert();}",
+        "try {\n" +
+        "}finally {\n" +
+        "}\n" +
+        "if(1) {\n" +
+        "  alert();\n" +
+        "  alert()\n" +
+        "}\n");
+
+    assertPrettyPrint(
+        "try {} catch(e) {} finally {} if (1) {alert();alert();}",
+        "try {\n" +
+        "}catch(e) {\n" +
+        "}finally {\n" +
+        "}\n" +
+        "if(1) {\n" +
+        "  alert();\n" +
+        "  alert()\n" +
+        "}\n");
+  }
+
+  public void testPrettyPrinter4() {
+    assertPrettyPrint(
+        "function f() {}if (1) {alert();}",
+        "function f() {\n" +
+        "}\n" +
+        "if(1) {\n" +
+        "  alert()\n" +
+        "}\n");
+
+    assertPrettyPrint(
+        "var f = function() {};if (1) {alert();}",
+        "var f = function() {\n" +
+        "};\n" +
+        "if(1) {\n" +
+        "  alert()\n" +
+        "}\n");
+
+    assertPrettyPrint(
+        "(function() {})();if (1) {alert();}",
+        "(function() {\n" +
+        "})();\n" +
+        "if(1) {\n" +
+        "  alert()\n" +
+        "}\n");
+
+    assertPrettyPrint(
+        "(function() {alert();alert();})();if (1) {alert();}",
+        "(function() {\n" +
+        "  alert();\n" +
+        "  alert()\n" +
+        "})();\n" +
+        "if(1) {\n" +
+        "  alert()\n" +
+        "}\n");
   }
 
   public void testTypeAnnotations() {
-    assertTypeAnnotations("/** @constructor */ function Foo(){}",
-        "/**\n * @constructor\n */\nfunction Foo() {\n}\n");
+    assertTypeAnnotations(
+        "/** @constructor */ function Foo(){}",
+        "/**\n * @return {undefined}\n * @constructor\n */\n"
+        + "function Foo() {\n}\n");
+  }
+
+  public void testTypeAnnotationsTypeDef() {
+    // TODO(johnlenz): It would be nice if there were some way to preserve
+    // typedefs but currently they are resolved into the basic types in the
+    // type registry.
+    assertTypeAnnotations(
+        "/** @typedef {Array.<number>} */ goog.java.Long;\n"
+        + "/** @param {!goog.java.Long} a*/\n"
+        + "function f(a){};\n",
+        "goog.java.Long;\n"
+        + "/**\n"
+        + " * @param {(Array|null)} a\n"
+        + " * @return {undefined}\n"
+        + " */\n"
+        + "function f(a) {\n}\n");
   }
 
   public void testTypeAnnotationsAssign() {
     assertTypeAnnotations("/** @constructor */ var Foo = function(){}",
-        "/**\n * @constructor\n */\nvar Foo = function() {\n}");
+        "/**\n * @return {undefined}\n * @constructor\n */\n"
+        + "var Foo = function() {\n};\n");
   }
 
   public void testTypeAnnotationsNamespace() {
     assertTypeAnnotations("var a = {};"
         + "/** @constructor */ a.Foo = function(){}",
-        "var a = {};\n/**\n * @constructor\n */\na.Foo = function() {\n}");
+        "var a = {};\n"
+        + "/**\n * @return {undefined}\n * @constructor\n */\n"
+        + "a.Foo = function() {\n};\n");
   }
 
   public void testTypeAnnotationsMemberSubclass() {
     assertTypeAnnotations("var a = {};"
         + "/** @constructor */ a.Foo = function(){};"
         + "/** @constructor \n @extends {a.Foo} */ a.Bar = function(){}",
-        "var a = {};\n/**\n * @constructor\n */\na.Foo = function() {\n};\n"
-        + "/**\n * @extends {a.Foo}\n * @constructor\n */\n"
-        + "a.Bar = function() {\n}");
+        "var a = {};\n"
+        + "/**\n * @return {undefined}\n * @constructor\n */\n"
+        + "a.Foo = function() {\n};\n"
+        + "/**\n * @return {undefined}\n * @extends {a.Foo}\n"
+        + " * @constructor\n */\n"
+        + "a.Bar = function() {\n};\n");
   }
 
   public void testTypeAnnotationsInterface() {
     assertTypeAnnotations("var a = {};"
         + "/** @interface */ a.Foo = function(){};"
         + "/** @interface \n @extends {a.Foo} */ a.Bar = function(){}",
-        "var a = {};\n/**\n * @interface\n */\na.Foo = function() {\n};\n"
-        + "/**\n * @extends {a.Foo}\n * @interface\n */\n"
-        + "a.Bar = function() {\n}");
+        "var a = {};\n"
+        + "/**\n * @interface\n */\n"
+        + "a.Foo = function() {\n};\n"
+        + "/**\n * @extends {a.Foo}\n"
+        + " * @interface\n */\n"
+        + "a.Bar = function() {\n};\n");
+  }
+
+  public void testTypeAnnotationsMultipleInterface() {
+    assertTypeAnnotations("var a = {};"
+        + "/** @interface */ a.Foo1 = function(){};"
+        + "/** @interface */ a.Foo2 = function(){};"
+        + "/** @interface \n @extends {a.Foo1} \n @extends {a.Foo2} */"
+        + "a.Bar = function(){}",
+        "var a = {};\n"
+        + "/**\n * @interface\n */\n"
+        + "a.Foo1 = function() {\n};\n"
+        + "/**\n * @interface\n */\n"
+        + "a.Foo2 = function() {\n};\n"
+        + "/**\n * @extends {a.Foo1}\n"
+        + " * @extends {a.Foo2}\n"
+        + " * @interface\n */\n"
+        + "a.Bar = function() {\n};\n");
   }
 
   public void testTypeAnnotationsMember() {
@@ -430,18 +732,19 @@
         + "/** @constructor */ a.Foo = function(){}"
         + "/** @param {string} foo\n"
         + "  * @return {number} */\n"
-        + "a.Foo.prototype.foo = function(foo) {};"
+        + "a.Foo.prototype.foo = function(foo) { return 3; };"
         + "/** @type {string|undefined} */"
         + "a.Foo.prototype.bar = '';",
         "var a = {};\n"
-        + "/**\n * @constructor\n */\na.Foo = function() {\n};\n"
+        + "/**\n * @return {undefined}\n * @constructor\n */\n"
+        + "a.Foo = function() {\n};\n"
         + "/**\n"
         + " * @param {string} foo\n"
         + " * @return {number}\n"
         + " */\n"
-        + "a.Foo.prototype.foo = function(foo) {\n};\n"
-        + "/** @type {(string|undefined)} */\n"
-        + "a.Foo.prototype.bar = \"\"");
+        + "a.Foo.prototype.foo = function(foo) {\n  return 3\n};\n"
+        + "/** @type {string} */\n"
+        + "a.Foo.prototype.bar = \"\";\n");
   }
 
   public void testTypeAnnotationsImplements() {
@@ -453,12 +756,117 @@
         + " * @implements {a.I} \n @implements {a.I2}\n"
         + "*/ a.Bar = function(){}",
         "var a = {};\n"
-        + "/**\n * @constructor\n */\na.Foo = function() {\n};\n"
-        + "/**\n * @interface\n */\na.I = function() {\n};\n"
-        + "/**\n * @interface\n */\na.I2 = function() {\n};\n"
-        + "/**\n * @extends {a.Foo}\n * @implements {a.I}\n"
+        + "/**\n * @return {undefined}\n * @constructor\n */\n"
+        + "a.Foo = function() {\n};\n"
+        + "/**\n * @interface\n */\n"
+        + "a.I = function() {\n};\n"
+        + "/**\n * @interface\n */\n"
+        + "a.I2 = function() {\n};\n"
+        + "/**\n * @return {undefined}\n * @extends {a.Foo}\n"
+        + " * @implements {a.I}\n"
         + " * @implements {a.I2}\n * @constructor\n */\n"
-        + "a.Bar = function() {\n}");
+        + "a.Bar = function() {\n};\n");
+  }
+
+  public void testTypeAnnotationsDispatcher1() {
+    assertTypeAnnotations(
+        "var a = {};\n" +
+        "/** \n" +
+        " * @constructor \n" +
+        " * @javadispatch \n" +
+        " */\n" +
+        "a.Foo = function(){}",
+        "var a = {};\n" +
+        "/**\n" +
+        " * @return {undefined}\n" +
+        " * @constructor\n" +
+        " * @javadispatch\n" +
+        " */\n" +
+        "a.Foo = function() {\n" +
+        "};\n");
+  }
+
+  public void testTypeAnnotationsDispatcher2() {
+    assertTypeAnnotations(
+        "var a = {};\n" +
+        "/** \n" +
+        " * @constructor \n" +
+        " */\n" +
+        "a.Foo = function(){}\n" +
+        "/**\n" +
+        " * @javadispatch\n" +
+        " */\n" +
+        "a.Foo.prototype.foo = function() {};",
+
+        "var a = {};\n" +
+        "/**\n" +
+        " * @return {undefined}\n" +
+        " * @constructor\n" +
+        " */\n" +
+        "a.Foo = function() {\n" +
+        "};\n" +
+        "/**\n" +
+        " * @return {undefined}\n" +
+        " * @javadispatch\n" +
+        " */\n" +
+        "a.Foo.prototype.foo = function() {\n" +
+        "};\n");
+  }
+
+  public void testU2UFunctionTypeAnnotation() {
+    assertTypeAnnotations(
+        "/** @type {!Function} */ var x = function() {}",
+        "/**\n * @constructor\n */\nvar x = function() {\n};\n");
+  }
+
+  public void testEmitUnknownParamTypesAsAllType() {
+    assertTypeAnnotations(
+        "var a = function(x) {}",
+        "/**\n" +
+        " * @param {*} x\n" +
+        " * @return {undefined}\n" +
+        " */\n" +
+        "var a = function(x) {\n};\n");
+  }
+
+  public void testOptionalTypesAnnotation() {
+    assertTypeAnnotations(
+        "/**\n" +
+        " * @param {string=} x \n" +
+        " */\n" +
+        "var a = function(x) {}",
+        "/**\n" +
+        " * @param {string=} x\n" +
+        " * @return {undefined}\n" +
+        " */\n" +
+        "var a = function(x) {\n};\n");
+  }
+
+  public void testVariableArgumentsTypesAnnotation() {
+    assertTypeAnnotations(
+        "/**\n" +
+        " * @param {...string} x \n" +
+        " */\n" +
+        "var a = function(x) {}",
+        "/**\n" +
+        " * @param {...string} x\n" +
+        " * @return {undefined}\n" +
+        " */\n" +
+        "var a = function(x) {\n};\n");
+  }
+
+  public void testTempConstructor() {
+    assertTypeAnnotations(
+        "var x = function() {\n/**\n * @constructor\n */\nfunction t1() {}\n" +
+        " /**\n * @constructor\n */\nfunction t2() {}\n" +
+        " t1.prototype = t2.prototype}",
+        "/**\n * @return {undefined}\n */\nvar x = function() {\n" +
+        "  /**\n * @return {undefined}\n * @constructor\n */\n" +
+        "function t1() {\n  }\n" +
+        "  /**\n * @return {undefined}\n * @constructor\n */\n" +
+        "function t2() {\n  }\n" +
+        "  t1.prototype = t2.prototype\n};\n"
+    );
   }
 
   private void assertPrettyPrint(String js, String expected) {
@@ -473,16 +881,10 @@
             CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));
   }
 
-  /**
-   * This test case is more involved since we need to run a constant folding
-   * pass to get the -4 converted to a negative number, as opposed to a
-   * number node with a number 4 attached to the negation unary operator.
-   */
   public void testSubtraction() {
     Compiler compiler = new Compiler();
     Node n = compiler.parseTestCode("x - -4");
     assertEquals(0, compiler.getErrorCount());
-    NodeTraversal.traverse(compiler, n, new FoldConstants(compiler));
 
     assertEquals(
         "x- -4",
@@ -490,6 +892,21 @@
             CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD).build());
   }
 
+  public void testFunctionWithCall() {
+    assertPrint(
+        "var user = new function() {"
+        + "alert(\"foo\")}",
+        "var user=new function(){"
+        + "alert(\"foo\")}");
+    assertPrint(
+        "var user = new function() {"
+        + "this.name = \"foo\";"
+        + "this.local = function(){alert(this.name)};}",
+        "var user=new function(){"
+        + "this.name=\"foo\";"
+        + "this.local=function(){alert(this.name)}}");
+  }
+
   public void testLineLength() {
     // list
     assertLineLength("var aba,bcb,cdc",
@@ -535,85 +952,290 @@
   }
 
   public void testParsePrintParse() {
-    List<String> parsePrintParseTestCases = ImmutableList.of(
-        "3;",
-        "var a = b;",
-        "var x, y, z;",
-        "try { foo() } catch(e) { bar() }",
-        "try { foo() } catch(e) { bar() } finally { stuff() }",
-        "try { foo() } finally { stuff() }",
-        "throw 'me'",
-        "function foo(a) { return a + 4; }",
-        "function foo() { return; }",
-        "var a = function(a, b) { foo(); return a + b; }",
-        "b = [3, 4, 'paul', \"Buchhe it\",,5];",
-        "v = (5, 6, 7, 8)",
-        "d = 34.0; x = 0; y = .3; z = -22",
-        "d = -x; t = !x + ~y;",
-        "'hi'; /* just a test */ stuff(a,b) \n foo(); // and another \n bar();",
-        "a = b++ + ++c; a = b++-++c; a = - --b; a = - ++b;",
-        "a++; b= a++; b = ++a; b = a--; b = --a; a+=2; b-=5",
-        "a = (2 + 3) * 4;",
-        "a = 1 + (2 + 3) + 4;",
-        "x = a ? b : c; x = a ? (b,3,5) : (foo(),bar());",
-        "a = b | c || d ^ e && f & !g != h << i <= j < k >>> l > m * n % !o",
-        "a == b; a != b; a === b; a == b == a; (a == b) == a; a == (b == a);",
-        "if (a > b) a = b; if (b < 3) a = 3; else c = 4;",
-        "if (a == b) { a++; } if (a == 0) { a++; } else { a --; }",
-        "for (var i in a) b += i;",
-        "for (var i = 0; i < 10; i++){ b /= 2; if (b == 2)break;else continue;}",
-        "for (x = 0; x < 10; x++) a /= 2;",
-        "for (;;) a++;",
-        "while(true) { blah(); }while(true) blah();",
-        "do stuff(); while(a>b);",
-        "[0, null, , true, false, this];",
-        "s.replace(/absc/, 'X').replace(/ab/gi, 'Y');",
-        "new Foo; new Bar(a, b,c);",
-        "with(foo()) { x = z; y = t; } with(bar()) a = z;",
-        "delete foo['bar']; delete foo;",
-        "var x = { 'a':'paul', 1:'3', 2:(3,4) };",
-        "switch(a) { case 2: case 3: { stuff(); break; }" +
-        "case 4: morestuff(); break; default: done();}",
-        "x = foo['bar'] + foo['my stuff'] + foo[bar] + f.stuff;",
-        "a.v = b.v; x['foo'] = y['zoo'];",
-        "'test' in x; 3 in x; a in x;",
-        "'foo\"bar' + \"foo'c\" + 'stuff\\n and \\\\more'",
-        "x.__proto__;");
-
-    for (String testCase : parsePrintParseTestCases) {
-      Node parse1 = parse(testCase);
-      Node parse2 = parse(new CodePrinter.Builder(parse1).build());
-      assertTrue(testCase, parse1.checkTreeEqualsSilent(parse2));
-    }
+    testReparse("3;");
+    testReparse("var a = b;");
+    testReparse("var x, y, z;");
+    testReparse("try { foo() } catch(e) { bar() }");
+    testReparse("try { foo() } catch(e) { bar() } finally { stuff() }");
+    testReparse("try { foo() } finally { stuff() }");
+    testReparse("throw 'me'");
+    testReparse("function foo(a) { return a + 4; }");
+    testReparse("function foo() { return; }");
+    testReparse("var a = function(a, b) { foo(); return a + b; }");
+    testReparse("b = [3, 4, 'paul', \"Buchhe it\",,5];");
+    testReparse("v = (5, 6, 7, 8)");
+    testReparse("d = 34.0; x = 0; y = .3; z = -22");
+    testReparse("d = -x; t = !x + ~y;");
+    testReparse("'hi'; /* just a test */ stuff(a,b) \n" +
+            " foo(); // and another \n" +
+            " bar();");
+    testReparse("a = b++ + ++c; a = b++-++c; a = - --b; a = - ++b;");
+    testReparse("a++; b= a++; b = ++a; b = a--; b = --a; a+=2; b-=5");
+    testReparse("a = (2 + 3) * 4;");
+    testReparse("a = 1 + (2 + 3) + 4;");
+    testReparse("x = a ? b : c; x = a ? (b,3,5) : (foo(),bar());");
+    testReparse("a = b | c || d ^ e " +
+            "&& f & !g != h << i <= j < k >>> l > m * n % !o");
+    testReparse("a == b; a != b; a === b; a == b == a;" +
+            " (a == b) == a; a == (b == a);");
+    testReparse("if (a > b) a = b; if (b < 3) a = 3; else c = 4;");
+    testReparse("if (a == b) { a++; } if (a == 0) { a++; } else { a --; }");
+    testReparse("for (var i in a) b += i;");
+    testReparse("for (var i = 0; i < 10; i++){ b /= 2;" +
+            " if (b == 2)break;else continue;}");
+    testReparse("for (x = 0; x < 10; x++) a /= 2;");
+    testReparse("for (;;) a++;");
+    testReparse("while(true) { blah(); }while(true) blah();");
+    testReparse("do stuff(); while(a>b);");
+    testReparse("[0, null, , true, false, this];");
+    testReparse("s.replace(/absc/, 'X').replace(/ab/gi, 'Y');");
+    testReparse("new Foo; new Bar(a, b,c);");
+    testReparse("with(foo()) { x = z; y = t; } with(bar()) a = z;");
+    testReparse("delete foo['bar']; delete foo;");
+    testReparse("var x = { 'a':'paul', 1:'3', 2:(3,4) };");
+    testReparse("switch(a) { case 2: case 3: stuff(); break;" +
+        "case 4: morestuff(); break; default: done();}");
+    testReparse("x = foo['bar'] + foo['my stuff'] + foo[bar] + f.stuff;");
+    testReparse("a.v = b.v; x['foo'] = y['zoo'];");
+    testReparse("'test' in x; 3 in x; a in x;");
+    testReparse("'foo\"bar' + \"foo'c\" + 'stuff\\n and \\\\more'");
+    testReparse("x.__proto__;");
+  }
+
+  private void testReparse(String code) {
+    Compiler compiler = new Compiler();
+    Node parse1 = parse(code);
+    Node parse2 = parse(new CodePrinter.Builder(parse1).build());
+    String explanation = parse1.checkTreeEquals(parse2);
+    assertNull("\nExpected: " + compiler.toSource(parse1) +
+        "\nResult: " + compiler.toSource(parse2) +
+        "\n" + explanation, explanation);
   }
 
   public void testDoLoopIECompatiblity() {
     // Do loops within IFs cause syntax errors in IE6 and IE7.
-    assertPrint("function(){if(e1){do foo();while(e2)}else foo()}",
-        "function(){if(e1){do foo();while(e2)}else foo()}");
+    assertPrint("function f(){if(e1){do foo();while(e2)}else foo()}",
+        "function f(){if(e1){do foo();while(e2)}else foo()}");
 
-    assertPrint("function(){if(e1)do foo();while(e2)else foo()}",
-        "function(){if(e1){do foo();while(e2)}else foo()}");
+    assertPrint("function f(){if(e1)do foo();while(e2)else foo()}",
+        "function f(){if(e1){do foo();while(e2)}else foo()}");
 
     assertPrint("if(x){do{foo()}while(y)}else bar()",
         "if(x){do foo();while(y)}else bar()");
 
     assertPrint("if(x)do{foo()}while(y);else bar()",
         "if(x){do foo();while(y)}else bar()");
+
+    assertPrint("if(x){do{foo()}while(y)}",
+        "if(x){do foo();while(y)}");
+
+    assertPrint("if(x)do{foo()}while(y);",
+        "if(x){do foo();while(y)}");
+
+    assertPrint("if(x)A:do{foo()}while(y);",
+        "if(x){A:do foo();while(y)}");
+
+    assertPrint("var i = 0;a: do{b: do{i++;break b;} while(0);} while(0);",
+        "var i=0;a:do{b:do{i++;break b}while(0)}while(0)");
   }
 
   public void testFunctionSafariCompatiblity() {
-    // Do loops within IFs cause syntax errors in IE6 and IE7.
-    assertPrint("function(){if(e1){function goo(){return true}}else foo()}",
-        "function(){if(e1){function goo(){return true}}else foo()}");
+    // Functions within IFs cause syntax errors on Safari.
+    assertPrint("function f(){if(e1){function goo(){return true}}else foo()}",
+        "function f(){if(e1){function goo(){return true}}else foo()}");
 
-    assertPrint("function(){if(e1)function goo(){return true}else foo()}",
-        "function(){if(e1){function goo(){return true}}else foo()}");
+    assertPrint("function f(){if(e1)function goo(){return true}else foo()}",
+        "function f(){if(e1){function goo(){return true}}else foo()}");
 
     assertPrint("if(e1){function goo(){return true}}",
         "if(e1){function goo(){return true}}");
 
     assertPrint("if(e1)function goo(){return true}",
         "if(e1){function goo(){return true}}");
+
+    assertPrint("if(e1)A:function goo(){return true}",
+        "if(e1){A:function goo(){return true}}");
+  }
+
+  public void testExponents() {
+    assertPrintNumber("1", 1);
+    assertPrintNumber("10", 10);
+    assertPrintNumber("100", 100);
+    assertPrintNumber("1E3", 1000);
+    assertPrintNumber("1E4", 10000);
+    assertPrintNumber("1E5", 100000);
+    assertPrintNumber("-1", -1);
+    assertPrintNumber("-10", -10);
+    assertPrintNumber("-100", -100);
+    assertPrintNumber("-1E3", -1000);
+    assertPrintNumber("-12341234E4", -123412340000L);
+    assertPrintNumber("1E18", 1000000000000000000L);
+    assertPrintNumber("1E5", 100000.0);
+    assertPrintNumber("100000.1", 100000.1);
+
+    assertPrintNumber("1.0E-6", 0.000001);
+  }
+
+  // Make sure to test as both a String and a Node, because
+  // negative numbers do not parse consistently from strings.
+  private void assertPrintNumber(String expected, double number) {
+    assertPrint(String.valueOf(number), expected);
+    assertPrintNode(expected, Node.newNumber(number));
+  }
+
+  private void assertPrintNumber(String expected, int number) {
+    assertPrint(String.valueOf(number), expected);
+    assertPrintNode(expected, Node.newNumber(number));
+  }
+
+  public void testDirectEval() {
+    assertPrint("eval('1');", "eval(\"1\")");
+  }
+
+  public void testIndirectEval() {
+    Node n = parse("eval('1');");
+    assertPrintNode("eval(\"1\")", n);
+    n.getFirstChild().getFirstChild().getFirstChild().putBooleanProp(
+        Node.DIRECT_EVAL, false);
+    assertPrintNode("(0,eval)(\"1\")", n);
+  }
+
+  public void testFreeCall1() {
+    assertPrint("foo(a);", "foo(a)");
+    assertPrint("x.foo(a);", "x.foo(a)");
+  }
+
+  public void testFreeCall2() {
+    Node n = parse("foo(a);");
+    assertPrintNode("foo(a)", n);
+    Node call =  n.getFirstChild().getFirstChild();
+    assertTrue(call.getType() == Token.CALL);
+    call.putBooleanProp(Node.FREE_CALL, true);
+    assertPrintNode("foo(a)", n);
+  }
+
+  public void testFreeCall3() {
+    Node n = parse("x.foo(a);");
+    assertPrintNode("x.foo(a)", n);
+    Node call =  n.getFirstChild().getFirstChild();
+    assertTrue(call.getType() == Token.CALL);
+    call.putBooleanProp(Node.FREE_CALL, true);
+    assertPrintNode("(0,x.foo)(a)", n);
+  }
+
+  public void testPrintScript() {
+    // Verify that SCRIPT nodes not marked as synthetic are printed as
+    // blocks.
+    Node ast = new Node(Token.SCRIPT,
+        new Node(Token.EXPR_RESULT, Node.newString("f")),
+        new Node(Token.EXPR_RESULT, Node.newString("g")));
+    String result = new CodePrinter.Builder(ast).setPrettyPrint(true).build();
+    assertEquals("\"f\";\n\"g\";\n", result);
+  }
+
+  public void testObjectLit() {
+    assertPrint("({x:1})", "({x:1})");
+    assertPrint("var x=({x:1})", "var x={x:1}");
+    assertPrint("var x={'x':1}", "var x={\"x\":1}");
+    assertPrint("var x={1:1}", "var x={1:1}");
+  }
+
+  public void testObjectLit2() {
+    assertPrint("var x={1:1}", "var x={1:1}");
+    assertPrint("var x={'1':1}", "var x={1:1}");
+    assertPrint("var x={'1.0':1}", "var x={\"1.0\":1}");
+    assertPrint("var x={1.5:1}", "var x={\"1.5\":1}");
+
+  }
+
+  public void testObjectLit3() {
+    assertPrint("var x={3E9:1}",
+                "var x={3E9:1}");
+    assertPrint("var x={'3000000000':1}", // More than 31 bits
+                "var x={3E9:1}");
+    assertPrint("var x={'3000000001':1}",
+                "var x={3000000001:1}");
+    assertPrint("var x={'6000000001':1}",  // More than 32 bits
+                "var x={6000000001:1}");
+    assertPrint("var x={\"12345678901234567\":1}",  // More than 53 bits
+                "var x={\"12345678901234567\":1}");
+  }
+
+  public void testObjectLit4() {
+    // More than 128 bits.
+    assertPrint(
+        "var x={\"123456789012345671234567890123456712345678901234567\":1}",
+        "var x={\"123456789012345671234567890123456712345678901234567\":1}");
+  }
+
+  public void testGetter() {
+    assertPrint("var x = {}", "var x={}");
+    assertPrint("var x = {get a() {return 1}}", "var x={get a(){return 1}}");
+    assertPrint(
+      "var x = {get a() {}, get b(){}}",
+      "var x={get a(){},get b(){}}");
+
+    assertPrint(
+      "var x = {get 'a'() {return 1}}",
+      "var x={get \"a\"(){return 1}}");
+
+    assertPrint(
+      "var x = {get 1() {return 1}}",
+      "var x={get 1(){return 1}}");
+
+    assertPrint(
+      "var x = {get \"()\"() {return 1}}",
+      "var x={get \"()\"(){return 1}}");
+  }
+
+  public void testSetter() {
+    assertPrint("var x = {}", "var x={}");
+    assertPrint(
+       "var x = {set a(y) {return 1}}",
+       "var x={set a(y){return 1}}");
+
+    assertPrint(
+      "var x = {get 'a'() {return 1}}",
+      "var x={get \"a\"(){return 1}}");
+
+    assertPrint(
+      "var x = {set 1(y) {return 1}}",
+      "var x={set 1(y){return 1}}");
+
+    assertPrint(
+      "var x = {set \"(x)\"(y) {return 1}}",
+      "var x={set \"(x)\"(y){return 1}}");
+  }
+
+  public void testNegCollapse() {
+    // Collapse the negative symbol on numbers at generation time,
+    // to match the Rhino behavior.
+    assertPrint("var x = - - 2;", "var x=2");
+    assertPrint("var x = - (2);", "var x=-2");
+  }
+
+  public void testStrict() {
+    String result = parsePrint("var x", false, false, 0, false, true);
+    assertEquals("'use strict';var x", result);
+  }
+
+  public void testArrayLiteral() {
+    assertPrint("var x = [,];","var x=[,]");
+    assertPrint("var x = [,,];","var x=[,,]");
+    assertPrint("var x = [,s,,];","var x=[,s,,]");
+    assertPrint("var x = [,s];","var x=[,s]");
+    assertPrint("var x = [s,];","var x=[s]");
+  }
+
+  public void testZero() {
+    assertPrint("var x ='\\0';", "var x=\"\\0\"");
+    assertPrint("var x ='\\x00';", "var x=\"\\0\"");
+    assertPrint("var x ='\\u0000';", "var x=\"\\0\"");
+  }
+
+  public void testUnicode() {
+    assertPrint("var x ='\\x0f';", "var x=\"\\u000f\"");
+    assertPrint("var x ='\\x68';", "var x=\"h\"");
+    assertPrint("var x ='\\x7f';", "var x=\"\\u007f\"");
   }
 }
