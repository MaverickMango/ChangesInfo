diff -r -u inducing/src/main/java/org/apache/commons/math3/util/FastMath.java buggy/src/main/java/org/apache/commons/math3/util/FastMath.java
--- inducing/src/main/java/org/apache/commons/math3/util/FastMath.java	2023-06-12 11:40:42.118006129 +0800
+++ buggy/src/main/java/org/apache/commons/math3/util/FastMath.java	2023-06-12 11:40:41.750022510 +0800
@@ -14,14 +14,72 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.commons.math.util;
+package org.apache.commons.math3.util;
+
+import java.io.PrintStream;
 
 /**
- * Faster, more accurate, portable alternative to StrictMath.
- * @version $Revision$ $Date$
+ * Faster, more accurate, portable alternative to {@link Math} and
+ * {@link StrictMath} for large scale computation.
+ * <p>
+ * FastMath is a drop-in replacement for both Math and StrictMath. This
+ * means that for any method in Math (say {@code Math.sin(x)} or
+ * {@code Math.cbrt(y)}), user can directly change the class and use the
+ * methods as is (using {@code FastMath.sin(x)} or {@code FastMath.cbrt(y)}
+ * in the previous example).
+ * </p>
+ * <p>
+ * FastMath speed is achieved by relying heavily on optimizing compilers
+ * to native code present in many JVMs today and use of large tables.
+ * The larger tables are lazily initialised on first use, so that the setup
+ * time does not penalise methods that don't need them.
+ * </p>
+ * <p>
+ * Note that FastMath is
+ * extensively used inside Apache Commons Math, so by calling some algorithms,
+ * the overhead when the the tables need to be intialised will occur
+ * regardless of the end-user calling FastMath methods directly or not.
+ * Performance figures for a specific JVM and hardware can be evaluated by
+ * running the FastMathTestPerformance tests in the test directory of the source
+ * distribution.
+ * </p>
+ * <p>
+ * FastMath accuracy should be mostly independent of the JVM as it relies only
+ * on IEEE-754 basic operations and on embedded tables. Almost all operations
+ * are accurate to about 0.5 ulp throughout the domain range. This statement,
+ * of course is only a rough global observed behavior, it is <em>not</em> a
+ * guarantee for <em>every</em> double numbers input (see William Kahan's <a
+ * href="http://en.wikipedia.org/wiki/Rounding#The_table-maker.27s_dilemma">Table
+ * Maker's Dilemma</a>).
+ * </p>
+ * <p>
+ * FastMath additionally implements the following methods not found in Math/StrictMath:
+ * <ul>
+ * <li>{@link #asinh(double)}</li>
+ * <li>{@link #acosh(double)}</li>
+ * <li>{@link #atanh(double)}</li>
+ * </ul>
+ * The following methods are found in Math/StrictMath since 1.6 only, they are provided
+ * by FastMath even in 1.5 Java virtual machines
+ * <ul>
+ * <li>{@link #copySign(double, double)}</li>
+ * <li>{@link #getExponent(double)}</li>
+ * <li>{@link #nextAfter(double,double)}</li>
+ * <li>{@link #nextUp(double)}</li>
+ * <li>{@link #scalb(double, int)}</li>
+ * <li>{@link #copySign(float, float)}</li>
+ * <li>{@link #getExponent(float)}</li>
+ * <li>{@link #nextAfter(float,double)}</li>
+ * <li>{@link #nextUp(float)}</li>
+ * <li>{@link #scalb(float, int)}</li>
+ * </ul>
+ * </p>
+ * @version $Id$
  * @since 2.2
  */
 public class FastMath {
+    /** StrictMath.log(Double.MAX_VALUE): {@value} */
+    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);
 
     /** Archimede's constant PI, ratio of circle circumference to diameter. */
     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;
@@ -29,31 +87,23 @@
     /** Napier's constant e, base of the natural logarithm. */
     public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;
 
-    /** Exponential evaluated at integer values,
-     * exp(x) =  expIntTableA[x + 750] + expIntTableB[x+750].
-     */
-    private static final double EXP_INT_TABLE_A[] = new double[1500];
-
-    /** Exponential evaluated at integer values,
-     * exp(x) =  expIntTableA[x + 750] + expIntTableB[x+750]
-     */
-    private static final double EXP_INT_TABLE_B[] = new double[1500];
-
-    /** Exponential over the range of 0 - 1 in increments of 2^-10
-     * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].
-     */
-    private static final double EXP_FRAC_TABLE_A[] = new double[1025];
+    /** Index of exp(0) in the array of integer exponentials. */
+    static final int EXP_INT_TABLE_MAX_INDEX = 750;
+    /** Length of the array of integer exponentials. */
+    static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;
+    /** Logarithm table length. */
+    static final int LN_MANT_LEN = 1024;
+    /** Exponential fractions table length. */
+    static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024
 
-    /** Exponential over the range of 0 - 1 in increments of 2^-10
-     * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].
+    /** Indicator for tables initialization.
+     * <p>
+     * This compile-time constant should be set to true only if one explicitly
+     * wants to compute the tables at class loading time instead of using the
+     * already computed ones provided as literal arrays below.
+     * </p>
      */
-    private static final double EXP_FRAC_TABLE_B[] = new double[1025];
-
-    /** Factorial table, for Taylor series expansions. */
-    private static final double FACT[] = new double[20];
-
-    /** Extended precision logarithm table over the range 1 - 2 in increments of 2^-10. */
-    private static final double LN_MANT[][] = new double[1024][];
+    private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false;
 
     /** log(2) (high bits). */
     private static final double LN_2_A = 0.693147063255310059;
@@ -61,26 +111,6 @@
     /** log(2) (low bits). */
     private static final double LN_2_B = 1.17304635250823482e-7;
 
-    /** Coefficients for slowLog. */
-    private static final double LN_SPLIT_COEF[][] = {
-        {2.0, 0.0},
-        {0.6666666269302368, 3.9736429850260626E-8},
-        {0.3999999761581421, 2.3841857910019882E-8},
-        {0.2857142686843872, 1.7029898543501842E-8},
-        {0.2222222089767456, 1.3245471311735498E-8},
-        {0.1818181574344635, 2.4384203044354907E-8},
-        {0.1538461446762085, 9.140260083262505E-9},
-        {0.13333332538604736, 9.220590270857665E-9},
-        {0.11764700710773468, 1.2393345855018391E-8},
-        {0.10526403784751892, 8.251545029714408E-9},
-        {0.0952233225107193, 1.2675934823758863E-8},
-        {0.08713622391223907, 1.1430250008909141E-8},
-        {0.07842259109020233, 2.404307984052299E-9},
-        {0.08371849358081818, 1.176342548272881E-8},
-        {0.030589580535888672, 1.2958646899018938E-9},
-        {0.14982303977012634, 1.225743062930824E-8},
-    };
-
     /** Coefficients for log, when input 0.99 < x < 1.01. */
     private static final double LN_QUICK_COEF[][] = {
         {1.0, 5.669184079525E-24},
@@ -104,26 +134,126 @@
         {-0.16624879837036133, -2.6033824355191673E-8}
     };
 
+    /** Sine, Cosine, Tangent tables are for 0, 1/8, 2/8, ... 13/8 = PI/2 approx. */
+    private static final int SINE_TABLE_LEN = 14;
+
     /** Sine table (high bits). */
-    private static final double SINE_TABLE_A[] = new double[14];
+    private static final double SINE_TABLE_A[] =
+        {
+        +0.0d,
+        +0.1246747374534607d,
+        +0.24740394949913025d,
+        +0.366272509098053d,
+        +0.4794255495071411d,
+        +0.5850973129272461d,
+        +0.6816387176513672d,
+        +0.7675435543060303d,
+        +0.8414709568023682d,
+        +0.902267575263977d,
+        +0.9489846229553223d,
+        +0.9808930158615112d,
+        +0.9974949359893799d,
+        +0.9985313415527344d,
+    };
 
     /** Sine table (low bits). */
-    private static final double SINE_TABLE_B[] = new double[14];
+    private static final double SINE_TABLE_B[] =
+        {
+        +0.0d,
+        -4.068233003401932E-9d,
+        +9.755392680573412E-9d,
+        +1.9987994582857286E-8d,
+        -1.0902938113007961E-8d,
+        -3.9986783938944604E-8d,
+        +4.23719669792332E-8d,
+        -5.207000323380292E-8d,
+        +2.800552834259E-8d,
+        +1.883511811213715E-8d,
+        -3.5997360512765566E-9d,
+        +4.116164446561962E-8d,
+        +5.0614674548127384E-8d,
+        -1.0129027912496858E-9d,
+    };
 
     /** Cosine table (high bits). */
-    private static final double COSINE_TABLE_A[] = new double[14];
+    private static final double COSINE_TABLE_A[] =
+        {
+        +1.0d,
+        +0.9921976327896118d,
+        +0.9689123630523682d,
+        +0.9305076599121094d,
+        +0.8775825500488281d,
+        +0.8109631538391113d,
+        +0.7316888570785522d,
+        +0.6409968137741089d,
+        +0.5403022766113281d,
+        +0.4311765432357788d,
+        +0.3153223395347595d,
+        +0.19454771280288696d,
+        +0.07073719799518585d,
+        -0.05417713522911072d,
+    };
 
     /** Cosine table (low bits). */
-    private static final double COSINE_TABLE_B[] = new double[14];
+    private static final double COSINE_TABLE_B[] =
+        {
+        +0.0d,
+        +3.4439717236742845E-8d,
+        +5.865827662008209E-8d,
+        -3.7999795083850525E-8d,
+        +1.184154459111628E-8d,
+        -3.43338934259355E-8d,
+        +1.1795268640216787E-8d,
+        +4.438921624363781E-8d,
+        +2.925681159240093E-8d,
+        -2.6437112632041807E-8d,
+        +2.2860509143963117E-8d,
+        -4.813899778443457E-9d,
+        +3.6725170580355583E-9d,
+        +2.0217439756338078E-10d,
+    };
+
 
     /** Tangent table, used by atan() (high bits). */
-    private static final double TANGENT_TABLE_A[] = new double[14];
+    private static final double TANGENT_TABLE_A[] =
+        {
+        +0.0d,
+        +0.1256551444530487d,
+        +0.25534194707870483d,
+        +0.3936265707015991d,
+        +0.5463024377822876d,
+        +0.7214844226837158d,
+        +0.9315965175628662d,
+        +1.1974215507507324d,
+        +1.5574076175689697d,
+        +2.092571258544922d,
+        +3.0095696449279785d,
+        +5.041914939880371d,
+        +14.101419448852539d,
+        -18.430862426757812d,
+    };
 
     /** Tangent table, used by atan() (low bits). */
-    private static final double TANGENT_TABLE_B[] = new double[14];
+    private static final double TANGENT_TABLE_B[] =
+        {
+        +0.0d,
+        -7.877917738262007E-9d,
+        -2.5857668567479893E-8d,
+        +5.2240336371356666E-9d,
+        +5.206150291559893E-8d,
+        +1.8307188599677033E-8d,
+        -5.7618793749770706E-8d,
+        +7.848361555046424E-8d,
+        +1.0708593250394448E-7d,
+        +1.7827257129423813E-8d,
+        +2.893485277253286E-8d,
+        +3.1660099222737955E-7d,
+        +4.983191803254889E-7d,
+        -3.356118100840571E-7d,
+    };
 
     /** Bits of 1/(2*pi), need for reducePayneHanek(). */
-    private static long RECIP_2PI[] = new long[] {
+    private static final long RECIP_2PI[] = new long[] {
         (0x28be60dbL << 32) | 0x9391054aL,
         (0x7f09d5f4L << 32) | 0x7d4d3770L,
         (0x36d8a566L << 32) | 0x4f10e410L,
@@ -144,67 +274,102 @@
          0x9afed7ecL << 32  };
 
     /** Bits of pi/4, need for reducePayneHanek(). */
-    private static long PI_O_4_BITS[] = new long[] {
+    private static final long PI_O_4_BITS[] = new long[] {
         (0xc90fdaa2L << 32) | 0x2168c234L,
         (0xc4c6628bL << 32) | 0x80dc1cd1L };
 
-    /** Eighthes.
+    /** Eighths.
      * This is used by sinQ, because its faster to do a table lookup than
      * a multiply in this time-critical routine
      */
-    private static final double EIGHTHES[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625};
-
-    // Initialize tables
-    static {
-        int i;
-
-        // Generate an array of factorials
-        FACT[0] = 1.0;
-        for (i = 1; i < 20; i++) {
-            FACT[i] = FACT[i-1] * i;
-        }
-
-        double tmp[] = new double[2];
-        double recip[] = new double[2];
-
-        // Populate expIntTable
-        for (i = 0; i < 750; i++) {
-            expint(i, tmp);
-            EXP_INT_TABLE_A[i+750] = tmp[0];
-            EXP_INT_TABLE_B[i+750] = tmp[1];
+    private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625};
 
-            if (i != 0) {
-                // Negative integer powers
-                splitReciprocal(tmp, recip);
-                EXP_INT_TABLE_A[750-i] = recip[0];
-                EXP_INT_TABLE_B[750-i] = recip[1];
-            }
-        }
+    /** Table of 2^((n+2)/3) */
+    private static final double CBRTTWO[] = { 0.6299605249474366,
+                                            0.7937005259840998,
+                                            1.0,
+                                            1.2599210498948732,
+                                            1.5874010519681994 };
+
+    /*
+     *  There are 52 bits in the mantissa of a double.
+     *  For additional precision, the code splits double numbers into two parts,
+     *  by clearing the low order 30 bits if possible, and then performs the arithmetic
+     *  on each half separately.
+     */
 
-        // Populate expFracTable
-        for (i = 0; i < 1025; i++) {
-            slowexp(i/1024.0, tmp);
-            EXP_FRAC_TABLE_A[i] = tmp[0];
-            EXP_FRAC_TABLE_B[i] = tmp[1];
-        }
+    /**
+     * 0x40000000 - used to split a double into two parts, both with the low order bits cleared.
+     * Equivalent to 2^30.
+     */
+    private static final long HEX_40000000 = 0x40000000L; // 1073741824L
+
+    /** Mask used to clear low order 30 bits */
+    private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L;
+
+    /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */
+    private static final double TWO_POWER_52 = 4503599627370496.0;
+
+    /** Constant: {@value}. */
+    private static final double F_1_3 = 1d / 3d;
+    /** Constant: {@value}. */
+    private static final double F_1_5 = 1d / 5d;
+    /** Constant: {@value}. */
+    private static final double F_1_7 = 1d / 7d;
+    /** Constant: {@value}. */
+    private static final double F_1_9 = 1d / 9d;
+    /** Constant: {@value}. */
+    private static final double F_1_11 = 1d / 11d;
+    /** Constant: {@value}. */
+    private static final double F_1_13 = 1d / 13d;
+    /** Constant: {@value}. */
+    private static final double F_1_15 = 1d / 15d;
+    /** Constant: {@value}. */
+    private static final double F_1_17 = 1d / 17d;
+    /** Constant: {@value}. */
+    private static final double F_3_4 = 3d / 4d;
+    /** Constant: {@value}. */
+    private static final double F_15_16 = 15d / 16d;
+    /** Constant: {@value}. */
+    private static final double F_13_14 = 13d / 14d;
+    /** Constant: {@value}. */
+    private static final double F_11_12 = 11d / 12d;
+    /** Constant: {@value}. */
+    private static final double F_9_10 = 9d / 10d;
+    /** Constant: {@value}. */
+    private static final double F_7_8 = 7d / 8d;
+    /** Constant: {@value}. */
+    private static final double F_5_6 = 5d / 6d;
+    /** Constant: {@value}. */
+    private static final double F_1_2 = 1d / 2d;
+    /** Constant: {@value}. */
+    private static final double F_1_4 = 1d / 4d;
 
-        // Populate lnMant table
-        for (i = 0; i < 1024; i++) {
-            double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L );
-            LN_MANT[i] = slowLog(d);
-        }
+    /**
+     * Private Constructor
+     */
+    private FastMath() {}
 
-        // Build the sine and cosine tables
-        buildSinCosTables();
-    }
+    // Generic helper methods
 
     /**
-     * Private Constructor
+     * Get the high order bits from the mantissa.
+     * Equivalent to adding and subtracting HEX_40000 but also works for very large numbers
+     *
+     * @param d the value to split
+     * @return the high order part of the mantissa
      */
-    private FastMath() {
+    private static double doubleHighPart(double d) {
+        if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){
+            return d; // These are un-normalised - don't try to convert
+        }
+        long xl = Double.doubleToLongBits(d);
+        xl = xl & MASK_30BITS; // Drop low order bits
+        return Double.longBitsToDouble(xl);
     }
 
     /** Compute the square root of a number.
+     * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}
      * @param a number on which evaluation is done
      * @return square root of a
      */
@@ -212,77 +377,322 @@
         return Math.sqrt(a);
     }
 
-    /** Compute the cubic root of a number.
-     * @param a number on which evaluation is done
-     * @return cubic root of a
-     */
-    public static double cbrt(final double a) {
-        return Math.cbrt(a);
-    }
-
     /** Compute the hyperbolic cosine of a number.
-     * @param a number on which evaluation is done
-     * @return hyperbolic cosine of a
+     * @param x number on which evaluation is done
+     * @return hyperbolic cosine of x
      */
-    public static double cosh(final double a) {
-        return 0.5 * (FastMath.exp(a) + FastMath.exp(-a));
+    public static double cosh(double x) {
+      if (x != x) {
+          return x;
+      }
+
+      // cosh[z] = (exp(z) + exp(-z))/2
+
+      // for numbers with magnitude 20 or so,
+      // exp(-z) can be ignored in comparison with exp(z)
+
+      if (x > 20) {
+          if (x >= LOG_MAX_VALUE) {
+              // Avoid overflow (MATH-905).
+              final double t = exp(0.5 * x);
+              return (0.5 * t) * t;
+          } else {
+              return 0.5 * exp(x);
+          }
+      } else if (x < -20) {
+          if (x <= -LOG_MAX_VALUE) {
+              // Avoid overflow (MATH-905).
+              final double t = exp(-0.5 * x);
+              return (0.5 * t) * t;
+          } else {
+              return 0.5 * exp(-x);
+          }
+      }
+
+      final double hiPrec[] = new double[2];
+      if (x < 0.0) {
+          x = -x;
+      }
+      exp(x, 0.0, hiPrec);
+
+      double ya = hiPrec[0] + hiPrec[1];
+      double yb = -(ya - hiPrec[0] - hiPrec[1]);
+
+      double temp = ya * HEX_40000000;
+      double yaa = ya + temp - temp;
+      double yab = ya - yaa;
+
+      // recip = 1/y
+      double recip = 1.0/ya;
+      temp = recip * HEX_40000000;
+      double recipa = recip + temp - temp;
+      double recipb = recip - recipa;
+
+      // Correct for rounding in division
+      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;
+      // Account for yb
+      recipb += -yb * recip * recip;
+
+      // y = y + 1/y
+      temp = ya + recipa;
+      yb += -(temp - ya - recipa);
+      ya = temp;
+      temp = ya + recipb;
+      yb += -(temp - ya - recipb);
+      ya = temp;
+
+      double result = ya + yb;
+      result *= 0.5;
+      return result;
     }
 
     /** Compute the hyperbolic sine of a number.
-     * @param a number on which evaluation is done
-     * @return hyperbolic sine of a
+     * @param x number on which evaluation is done
+     * @return hyperbolic sine of x
      */
-    public static double sinh(double a) {
+    public static double sinh(double x) {
+      boolean negate = false;
+      if (x != x) {
+          return x;
+      }
 
-        boolean negative = false;
-        if (a < 0) {
-            negative = true;
-            a = -a;
-        }
+      // sinh[z] = (exp(z) - exp(-z) / 2
 
-        double absSinh;
-        if (a > 0.3) {
-            absSinh = 0.5 * (FastMath.exp(a) - FastMath.exp(-a));
-        } else {
-            final double a2 = a * a;
-            if (a > 0.05) {
-                absSinh = a * (1 + a2 * (1 + a2  * (1 + a2 * (1 + a2 * (1 + a2 / 110) / 72) / 42) / 20) / 6);
-            } else {
-                absSinh = a * (1 + a2 * (1 + a2  * (1 + a2 / 42) / 20) / 6);
-            }
-        }
+      // for values of z larger than about 20,
+      // exp(-z) can be ignored in comparison with exp(z)
+
+      if (x > 20) {
+          if (x >= LOG_MAX_VALUE) {
+              // Avoid overflow (MATH-905).
+              final double t = exp(0.5 * x);
+              return (0.5 * t) * t;
+          } else {
+              return 0.5 * exp(x);
+          }
+      } else if (x < -20) {
+          if (x <= -LOG_MAX_VALUE) {
+              // Avoid overflow (MATH-905).
+              final double t = exp(-0.5 * x);
+              return (-0.5 * t) * t;
+          } else {
+              return -0.5 * exp(-x);
+          }
+      }
+
+      if (x == 0) {
+          return x;
+      }
 
-        return negative ? -absSinh : absSinh;
+      if (x < 0.0) {
+          x = -x;
+          negate = true;
+      }
+
+      double result;
+
+      if (x > 0.25) {
+          double hiPrec[] = new double[2];
+          exp(x, 0.0, hiPrec);
+
+          double ya = hiPrec[0] + hiPrec[1];
+          double yb = -(ya - hiPrec[0] - hiPrec[1]);
+
+          double temp = ya * HEX_40000000;
+          double yaa = ya + temp - temp;
+          double yab = ya - yaa;
+
+          // recip = 1/y
+          double recip = 1.0/ya;
+          temp = recip * HEX_40000000;
+          double recipa = recip + temp - temp;
+          double recipb = recip - recipa;
+
+          // Correct for rounding in division
+          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;
+          // Account for yb
+          recipb += -yb * recip * recip;
+
+          recipa = -recipa;
+          recipb = -recipb;
+
+          // y = y + 1/y
+          temp = ya + recipa;
+          yb += -(temp - ya - recipa);
+          ya = temp;
+          temp = ya + recipb;
+          yb += -(temp - ya - recipb);
+          ya = temp;
+
+          result = ya + yb;
+          result *= 0.5;
+      }
+      else {
+          double hiPrec[] = new double[2];
+          expm1(x, hiPrec);
+
+          double ya = hiPrec[0] + hiPrec[1];
+          double yb = -(ya - hiPrec[0] - hiPrec[1]);
+
+          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
+          double denom = 1.0 + ya;
+          double denomr = 1.0 / denom;
+          double denomb = -(denom - 1.0 - ya) + yb;
+          double ratio = ya * denomr;
+          double temp = ratio * HEX_40000000;
+          double ra = ratio + temp - temp;
+          double rb = ratio - ra;
+
+          temp = denom * HEX_40000000;
+          double za = denom + temp - temp;
+          double zb = denom - za;
+
+          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;
+
+          // Adjust for yb
+          rb += yb*denomr;                        // numerator
+          rb += -ya * denomb * denomr * denomr;   // denominator
+
+          // y = y - 1/y
+          temp = ya + ra;
+          yb += -(temp - ya - ra);
+          ya = temp;
+          temp = ya + rb;
+          yb += -(temp - ya - rb);
+          ya = temp;
 
+          result = ya + yb;
+          result *= 0.5;
+      }
+
+      if (negate) {
+          result = -result;
+      }
+
+      return result;
     }
 
     /** Compute the hyperbolic tangent of a number.
-     * @param a number on which evaluation is done
-     * @return hyperbolic tangent of a
+     * @param x number on which evaluation is done
+     * @return hyperbolic tangent of x
      */
-    public static double tanh(double a) {
+    public static double tanh(double x) {
+      boolean negate = false;
 
-        boolean negative = false;
-        if (a < 0) {
-            negative = true;
-            a = -a;
-        }
+      if (x != x) {
+          return x;
+      }
 
-        double absTanh;
-        if (a > 0.074) {
-            final double twoA = 2 * a;
-            absTanh = FastMath.expm1(twoA) / (FastMath.exp(twoA) + 1);
-        } else {
-            final double a2 = a * a;
-            if (a > 0.016) {
-                absTanh = a * (1 - a2 * (1 - a2 * (2 - a2 * (17 - a2 * (62 - a2 * 1382 / 55 ) / 9) / 21) / 5) / 3);
-            } else {
-                absTanh = a * (1 - a2 * (1 - a2 * (2 - a2 * 17 / 21) / 5) / 3);
-            }
-        }
+      // tanh[z] = sinh[z] / cosh[z]
+      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))
+      // = (exp(2x) - 1) / (exp(2x) + 1)
+
+      // for magnitude > 20, sinh[z] == cosh[z] in double precision
+
+      if (x > 20.0) {
+          return 1.0;
+      }
+
+      if (x < -20) {
+          return -1.0;
+      }
 
-        return negative ? -absTanh : absTanh;
+      if (x == 0) {
+          return x;
+      }
+
+      if (x < 0.0) {
+          x = -x;
+          negate = true;
+      }
+
+      double result;
+      if (x >= 0.5) {
+          double hiPrec[] = new double[2];
+          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)
+          exp(x*2.0, 0.0, hiPrec);
+
+          double ya = hiPrec[0] + hiPrec[1];
+          double yb = -(ya - hiPrec[0] - hiPrec[1]);
+
+          /* Numerator */
+          double na = -1.0 + ya;
+          double nb = -(na + 1.0 - ya);
+          double temp = na + yb;
+          nb += -(temp - na - yb);
+          na = temp;
+
+          /* Denominator */
+          double da = 1.0 + ya;
+          double db = -(da - 1.0 - ya);
+          temp = da + yb;
+          db += -(temp - da - yb);
+          da = temp;
+
+          temp = da * HEX_40000000;
+          double daa = da + temp - temp;
+          double dab = da - daa;
+
+          // ratio = na/da
+          double ratio = na/da;
+          temp = ratio * HEX_40000000;
+          double ratioa = ratio + temp - temp;
+          double ratiob = ratio - ratioa;
+
+          // Correct for rounding in division
+          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;
+
+          // Account for nb
+          ratiob += nb / da;
+          // Account for db
+          ratiob += -db * na / da / da;
+
+          result = ratioa + ratiob;
+      }
+      else {
+          double hiPrec[] = new double[2];
+          // tanh(x) = expm1(2x) / (expm1(2x) + 2)
+          expm1(x*2.0, hiPrec);
+
+          double ya = hiPrec[0] + hiPrec[1];
+          double yb = -(ya - hiPrec[0] - hiPrec[1]);
+
+          /* Numerator */
+          double na = ya;
+          double nb = yb;
+
+          /* Denominator */
+          double da = 2.0 + ya;
+          double db = -(da - 2.0 - ya);
+          double temp = da + yb;
+          db += -(temp - da - yb);
+          da = temp;
+
+          temp = da * HEX_40000000;
+          double daa = da + temp - temp;
+          double dab = da - daa;
+
+          // ratio = na/da
+          double ratio = na/da;
+          temp = ratio * HEX_40000000;
+          double ratioa = ratio + temp - temp;
+          double ratiob = ratio - ratioa;
+
+          // Correct for rounding in division
+          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;
+
+          // Account for nb
+          ratiob += nb / da;
+          // Account for db
+          ratiob += -db * na / da / da;
+
+          result = ratioa + ratiob;
+      }
+
+      if (negate) {
+          result = -result;
+      }
 
+      return result;
     }
 
     /** Compute the inverse hyperbolic cosine of a number.
@@ -298,7 +708,6 @@
      * @return inverse hyperbolic sine of a
      */
     public static double asinh(double a) {
-
         boolean negative = false;
         if (a < 0) {
             negative = true;
@@ -311,18 +720,17 @@
         } else {
             final double a2 = a * a;
             if (a > 0.097) {
-                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0 - a2 * (1.0 / 15.0 - a2 * (1.0 / 17.0) * 15.0 / 16.0) * 13.0 / 14.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
+                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);
             } else if (a > 0.036) {
-                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
+                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);
             } else if (a > 0.0036) {
-                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
+                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);
             } else {
-                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0) * 3.0 / 4.0) / 2.0);
+                absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);
             }
         }
 
         return negative ? -absAsinh : absAsinh;
-
     }
 
     /** Compute the inverse hyperbolic tangent of a number.
@@ -330,7 +738,6 @@
      * @return inverse hyperbolic tangent of a
      */
     public static double atanh(double a) {
-
         boolean negative = false;
         if (a < 0) {
             negative = true;
@@ -343,27 +750,35 @@
         } else {
             final double a2 = a * a;
             if (a > 0.087) {
-                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0 + a2 * (1.0 / 15.0 + a2 * (1.0 / 17.0)))))))));
+                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));
             } else if (a > 0.031) {
-                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0)))))));
+                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));
             } else if (a > 0.003) {
-                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0)))));
+                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));
             } else {
-                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0)));
+                absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));
             }
         }
 
         return negative ? -absAtanh : absAtanh;
-
     }
 
     /** Compute the signum of a number.
      * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
      * @param a number on which evaluation is done
-     * @return -1, 0, +1 or NaN depending on sign of a
+     * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a
      */
     public static double signum(final double a) {
-        return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : (Double.isNaN(a) ? Double.NaN : 0.0));
+        return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a
+    }
+
+    /** Compute the signum of a number.
+     * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
+     * @param a number on which evaluation is done
+     * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a
+     */
+    public static float signum(final float a) {
+        return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a
     }
 
     /** Compute next number towards positive infinity.
@@ -374,7 +789,16 @@
         return nextAfter(a, Double.POSITIVE_INFINITY);
     }
 
+    /** Compute next number towards positive infinity.
+     * @param a number to which neighbor should be computed
+     * @return neighbor of a towards positive infinity
+     */
+    public static float nextUp(final float a) {
+        return nextAfter(a, Float.POSITIVE_INFINITY);
+    }
+
     /** Returns a pseudo-random number between 0.0 and 1.0.
+     * <p><b>Note:</b> this implementation currently delegates to {@link Math#random}
      * @return a random number between 0.0 and 1.0
      */
     public static double random() {
@@ -454,8 +878,8 @@
 
             intVal++;
 
-            intPartA = EXP_INT_TABLE_A[750-intVal];
-            intPartB = EXP_INT_TABLE_B[750-intVal];
+            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];
+            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];
 
             intVal = -intVal;
         } else {
@@ -469,8 +893,8 @@
                 return Double.POSITIVE_INFINITY;
             }
 
-            intPartA = EXP_INT_TABLE_A[750+intVal];
-            intPartB = EXP_INT_TABLE_B[750+intVal];
+            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];
+            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];
         }
 
         /* Get the fractional part of x, find the greatest multiple of 2^-10 less than
@@ -478,8 +902,8 @@
          * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.
          */
         final int intFrac = (int) ((x - intVal) * 1024.0);
-        final double fracPartA = EXP_FRAC_TABLE_A[intFrac];
-        final double fracPartB = EXP_FRAC_TABLE_B[intFrac];
+        final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];
+        final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];
 
         /* epsilon is the difference in x from the nearest multiple of 2^-10.  It
          * has a value in the range 0 <= epsilon < 2^-10.
@@ -534,6 +958,15 @@
      * @return exp(x) - 1
      */
     public static double expm1(double x) {
+      return expm1(x, null);
+    }
+
+    /** Internal helper method for expm1
+     * @param x number to compute shifted exponential
+     * @param hiPrecOut receive high precision result for -1.0 < x < 1.0
+     * @return exp(x) - 1
+     */
+    private static double expm1(double x, double hiPrecOut[]) {
         if (x != x || x == 0.0) { // NaN or zero
             return x;
         }
@@ -565,14 +998,14 @@
 
         {
             int intFrac = (int) (x * 1024.0);
-            double tempA = EXP_FRAC_TABLE_A[intFrac] - 1.0;
-            double tempB = EXP_FRAC_TABLE_B[intFrac];
+            double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0;
+            double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];
 
             double temp = tempA + tempB;
             tempB = -(temp - tempA - tempB);
             tempA = temp;
 
-            temp = tempA * 1073741824.0;
+            temp = tempA * HEX_40000000;
             baseA = tempA + temp - temp;
             baseB = tempB + (tempA - baseA);
 
@@ -593,7 +1026,7 @@
         zb = -(temp - za - zb);
         za = temp;
 
-        temp = za * 1073741824.0;
+        temp = za * HEX_40000000;
         temp = za + temp - temp;
         zb += za - temp;
         za = temp;
@@ -640,11 +1073,11 @@
             double denomr = 1.0 / denom;
             double denomb = -(denom - 1.0 - ya) + yb;
             double ratio = ya * denomr;
-            temp = ratio * 1073741824.0;
+            temp = ratio * HEX_40000000;
             final double ra = ratio + temp - temp;
             double rb = ratio - ra;
 
-            temp = denom * 1073741824.0;
+            temp = denom * HEX_40000000;
             za = denom + temp - temp;
             zb = denom - za;
 
@@ -667,254 +1100,14 @@
             yb = -rb;
         }
 
-        return ya + yb;
-    }
-
-    /**
-     *  For x between 0 and 1, returns exp(x), uses extended precision
-     *  @param x argument of exponential
-     *  @param result placeholder where to place exp(x) split in two terms
-     *  for extra precision (i.e. exp(x) = result[0] ° result[1]
-     *  @return exp(x)
-     */
-    private static double slowexp(final double x, final double result[]) {
-        final double xs[] = new double[2];
-        final double ys[] = new double[2];
-        final double facts[] = new double[2];
-        final double as[] = new double[2];
-        split(x, xs);
-        ys[0] = ys[1] = 0.0;
-
-        for (int i = 19; i >= 0; i--) {
-            splitMult(xs, ys, as);
-            ys[0] = as[0];
-            ys[1] = as[1];
-
-            split(FACT[i], as);
-            splitReciprocal(as, facts);
-
-            splitAdd(ys, facts, as);
-            ys[0] = as[0];
-            ys[1] = as[1];
-        }
-
-        if (result != null) {
-            result[0] = ys[0];
-            result[1] = ys[1];
-        }
-
-        return ys[0] + ys[1];
-    }
-
-    /** Compute split[0], split[1] such that their sum is equal to d,
-     * and split[0] has its 30 least significant bits as zero.
-     * @param d number to split
-     * @param split placeholder where to place the result
-     */
-    private static void split(final double d, final double split[]) {
-        if (d < 8e298 && d > -8e298) {
-            final double a = d * 1073741824.0;
-            split[0] = (d + a) - a;
-            split[1] = d - split[0];
-        } else {
-            final double a = d * 9.31322574615478515625E-10;
-            split[0] = (d + a - d) * 1073741824.0;
-            split[1] = d - split[0];
-        }
-    }
-
-    /** Recompute a split.
-     * @param a input/out array containing the split, changed
-     * on output
-     */
-    private static void resplit(final double a[]) {
-        final double c = a[0] + a[1];
-        final double d = -(c - a[0] - a[1]);
-
-        if (c < 8e298 && c > -8e298) {
-            double z = c * 1073741824.0;
-            a[0] = (c + z) - z;
-            a[1] = c - a[0] + d;
-        } else {
-            double z = c * 9.31322574615478515625E-10;
-            a[0] = (c + z - c) * 1073741824.0;
-            a[1] = c - a[0] + d;
-        }
-    }
-
-    /** Multiply two numbers in split form.
-     * @param a first term of multiplication
-     * @param b second term of multiplication
-     * @param ans placeholder where to put the result
-     */
-    private static void splitMult(double a[], double b[], double ans[]) {
-        ans[0] = a[0] * b[0];
-        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];
-
-        /* Resplit */
-        resplit(ans);
-    }
-
-    /** Add two numbers in split form.
-     * @param a first term of addition
-     * @param b second term of addition
-     * @param ans placeholder where to put the result
-     */
-    private static void splitAdd(final double a[], final double b[], final double ans[]) {
-        ans[0] = a[0] + b[0];
-        ans[1] = a[1] + b[1];
-
-        resplit(ans);
-    }
-
-    /** Compute the reciprocal of in.  Use the following algorithm.
-     *  in = c + d.
-     *  want to find x + y such that x+y = 1/(c+d) and x is much
-     *  larger than y and x has several zero bits on the right.
-     *
-     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.
-     *  Use following identity to compute (a+b)/(c+d)
-     *
-     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)
-     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)
-     *  This will be close to the right answer, but there will be
-     *  some rounding in the calculation of X.  So by carefully
-     *  computing 1 - (c+d)(x+y) we can compute an error and
-     *  add that back in.   This is done carefully so that terms
-     *  of similar size are subtracted first.
-     *  @param in initial number, in split form
-     *  @param result placeholder where to put the result
-     */
-    private static void splitReciprocal(final double in[], final double result[]) {
-        final double b = 1.0/4194304.0;
-        final double a = 1.0 - b;
-
-        if (in[0] == 0.0) {
-            in[0] = in[1];
-            in[1] = 0.0;
-        }
-
-        result[0] = a / in[0];
-        result[1] = (b*in[0]-a*in[1]) / (in[0]*in[0] + in[0]*in[1]);
-
-        if (result[1] != result[1]) { // can happen if result[1] is NAN
-            result[1] = 0.0;
-        }
-
-        /* Resplit */
-        resplit(result);
-
-        for (int i = 0; i < 2; i++) {
-            /* this may be overkill, probably once is enough */
-            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -
-            result[1] * in[0] - result[1] * in[1];
-            /*err = 1.0 - err; */
-            err = err * (result[0] + result[1]);
-            /*printf("err = %16e\n", err); */
-            result[1] += err;
-        }
-    }
-
-    /** Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.
-     * @param a first term of the multiplication
-     * @param b second term of the multiplication
-     * @param result placeholder where to put the result
-     */
-    private static void quadMult(final double a[], final double b[], final double result[]) {
-        final double xs[] = new double[2];
-        final double ys[] = new double[2];
-        final double zs[] = new double[2];
-
-        /* a[0] * b[0] */
-        split(a[0], xs);
-        split(b[0], ys);
-        splitMult(xs, ys, zs);
-
-        result[0] = zs[0];
-        result[1] = zs[1];
-
-        /* a[0] * b[1] */
-        split(b[1], ys);
-        splitMult(xs, ys, zs);
-
-        double tmp = result[0] + zs[0];
-        result[1] = result[1] - (tmp - result[0] - zs[0]);
-        result[0] = tmp;
-        tmp = result[0] + zs[1];
-        result[1] = result[1] - (tmp - result[0] - zs[1]);
-        result[0] = tmp;
-
-        /* a[1] * b[0] */
-        split(a[1], xs);
-        split(b[0], ys);
-        splitMult(xs, ys, zs);
-
-        tmp = result[0] + zs[0];
-        result[1] = result[1] - (tmp - result[0] - zs[0]);
-        result[0] = tmp;
-        tmp = result[0] + zs[1];
-        result[1] = result[1] - (tmp - result[0] - zs[1]);
-        result[0] = tmp;
-
-        /* a[1] * b[0] */
-        split(a[1], xs);
-        split(b[1], ys);
-        splitMult(xs, ys, zs);
-
-        tmp = result[0] + zs[0];
-        result[1] = result[1] - (tmp - result[0] - zs[0]);
-        result[0] = tmp;
-        tmp = result[0] + zs[1];
-        result[1] = result[1] - (tmp - result[0] - zs[1]);
-        result[0] = tmp;
-    }
-
-    /** Compute exp(p) for a integer p in extended precision.
-     * @param p integer whose exponential is requested
-     * @param result placeholder where to put the result in extended precision
-     * @return exp(p) in standard precision (equal to result[0] + result[1])
-     */
-    private static double expint(int p, final double result[]) {
-        //double x = M_E;
-        final double xs[] = new double[2];
-        final double as[] = new double[2];
-        final double ys[] = new double[2];
-        //split(x, xs);
-        //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);
-        //xs[0] = 2.71827697753906250000;
-        //xs[1] = 4.85091998273542816811e-06;
-        //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);
-        //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);
-
-        /* E */
-        xs[0] = 2.718281828459045;
-        xs[1] = 1.4456468917292502E-16;
-
-        split(1.0, ys);
-
-        while (p > 0) {
-            if ((p & 1) != 0) {
-                quadMult(ys, xs, as);
-                ys[0] = as[0]; ys[1] = as[1];
-            }
-
-            quadMult(xs, xs, as);
-            xs[0] = as[0]; xs[1] = as[1];
-
-            p >>= 1;
-        }
-
-        if (result != null) {
-            result[0] = ys[0];
-            result[1] = ys[1];
-
-            resplit(result);
+        if (hiPrecOut != null) {
+            hiPrecOut[0] = ya;
+            hiPrecOut[1] = yb;
         }
 
-        return ys[0] + ys[1];
+        return ya + yb;
     }
 
-
     /**
      * Natural logarithm.
      *
@@ -932,6 +1125,9 @@
      * @return log(x)
      */
     private static double log(final double x, final double[] hiPrec) {
+        if (x==0) { // Handle special case of +0/-0
+            return Double.NEGATIVE_INFINITY;
+        }
         long bits = Double.doubleToLongBits(x);
 
         /* Handle special cases of negative input, and NaN */
@@ -971,7 +1167,7 @@
             /* Normalize the subnormal number. */
             bits <<= 1;
             while ( (bits & 0x0010000000000000L) == 0) {
-                exp--;
+                --exp;
                 bits <<= 1;
             }
         }
@@ -985,29 +1181,31 @@
                /* Compute x - 1.0 and split it */
                 double xa = x - 1.0;
                 double xb = xa - x + 1.0;
-                double tmp = xa * 1073741824.0;
+                double tmp = xa * HEX_40000000;
                 double aa = xa + tmp - tmp;
                 double ab = xa - aa;
                 xa = aa;
                 xb = ab;
 
-                double ya = LN_QUICK_COEF[LN_QUICK_COEF.length-1][0];
-                double yb = LN_QUICK_COEF[LN_QUICK_COEF.length-1][1];
+                final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];
+                double ya = lnCoef_last[0];
+                double yb = lnCoef_last[1];
 
                 for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {
                     /* Multiply a = y * x */
                     aa = ya * xa;
                     ab = ya * xb + yb * xa + yb * xb;
                     /* split, so now y = a */
-                    tmp = aa * 1073741824.0;
+                    tmp = aa * HEX_40000000;
                     ya = aa + tmp - tmp;
                     yb = aa - ya + ab;
 
                     /* Add  a = y + lnQuickCoef */
-                    aa = ya + LN_QUICK_COEF[i][0];
-                    ab = yb + LN_QUICK_COEF[i][1];
+                    final double[] lnCoef_i = LN_QUICK_COEF[i];
+                    aa = ya + lnCoef_i[0];
+                    ab = yb + lnCoef_i[1];
                     /* Split y = a */
-                    tmp = aa * 1073741824.0;
+                    tmp = aa * HEX_40000000;
                     ya = aa + tmp - tmp;
                     yb = aa - ya + ab;
                 }
@@ -1016,21 +1214,16 @@
                 aa = ya * xa;
                 ab = ya * xb + yb * xa + yb * xb;
                 /* split, so now y = a */
-                tmp = aa * 1073741824.0;
+                tmp = aa * HEX_40000000;
                 ya = aa + tmp - tmp;
                 yb = aa - ya + ab;
 
-                if (hiPrec != null) {
-                    hiPrec[0] = ya;
-                    hiPrec[1] = yb;
-                }
-
                 return ya + yb;
             }
         }
 
         // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)
-        double lnm[] = LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];
+        final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];
 
         /*
     double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);
@@ -1041,43 +1234,45 @@
         // y is the most significant 10 bits of the mantissa
         //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);
         //double epsilon = (x - y) / y;
-        double epsilon = (double)(bits & 0x3ffffffffffL) / (4503599627370496.0 + (bits & 0x000ffc0000000000L));
+        final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));
 
         double lnza = 0.0;
         double lnzb = 0.0;
 
         if (hiPrec != null) {
             /* split epsilon -> x */
-            double tmp = epsilon * 1073741824.0;
+            double tmp = epsilon * HEX_40000000;
             double aa = epsilon + tmp - tmp;
             double ab = epsilon - aa;
             double xa = aa;
             double xb = ab;
 
             /* Need a more accurate epsilon, so adjust the division. */
-            double numer = (double)(bits & 0x3ffffffffffL);
-            double denom = 4503599627370496.0 + (bits & 0x000ffc0000000000L);
+            final double numer = bits & 0x3ffffffffffL;
+            final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);
             aa = numer - xa*denom - xb * denom;
             xb += aa / denom;
 
             /* Remez polynomial evaluation */
-            double ya = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][0];
-            double yb = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][1];
+            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];
+            double ya = lnCoef_last[0];
+            double yb = lnCoef_last[1];
 
             for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {
                 /* Multiply a = y * x */
                 aa = ya * xa;
                 ab = ya * xb + yb * xa + yb * xb;
                 /* split, so now y = a */
-                tmp = aa * 1073741824.0;
+                tmp = aa * HEX_40000000;
                 ya = aa + tmp - tmp;
                 yb = aa - ya + ab;
 
                 /* Add  a = y + lnHiPrecCoef */
-                aa = ya + LN_HI_PREC_COEF[i][0];
-                ab = yb + LN_HI_PREC_COEF[i][1];
+                final double[] lnCoef_i = LN_HI_PREC_COEF[i];
+                aa = ya + lnCoef_i[0];
+                ab = yb + lnCoef_i[1];
                 /* Split y = a */
-                tmp = aa * 1073741824.0;
+                tmp = aa * HEX_40000000;
                 ya = aa + tmp - tmp;
                 yb = aa - ya + ab;
             }
@@ -1155,43 +1350,42 @@
         return a + b;
     }
 
-    /** Compute log(1 + x).
-     * @param x a number
-     * @return log(1 + x)
+    /**
+     * Computes log(1 + x).
+     *
+     * @param x Number.
+     * @return {@code log(1 + x)}.
      */
     public static double log1p(final double x) {
-        double xpa = 1.0 + x;
-        double xpb = -(xpa - 1.0 - x);
-
         if (x == -1) {
-            return x/0.0;   // -Infinity
+            return Double.NEGATIVE_INFINITY;
         }
 
-        if (x > 0 && 1/x == 0) { // x = Infinity
-            return x;
+        if (x == Double.POSITIVE_INFINITY) {
+            return Double.POSITIVE_INFINITY;
         }
 
-        if (x>1e-6 || x<-1e-6) {
-            double hiPrec[] = new double[2];
-
-            log(xpa, hiPrec);
-
-            /* Do a taylor series expansion around xpa */
-            /* f(x+y) = f(x) + f'(x)*y + f''(x)/2 y^2 */
-            double fx1 = xpb/xpa;
-
-            double epsilon = 0.5 * fx1 + 1.0;
-            epsilon = epsilon * fx1;
-
-            return epsilon + hiPrec[1] + hiPrec[0];
+        if (x > 1e-6 ||
+            x < -1e-6) {
+            final double xpa = 1 + x;
+            final double xpb = -(xpa - 1 - x);
+
+            final double[] hiPrec = new double[2];
+            final double lores = log(xpa, hiPrec);
+            if (Double.isInfinite(lores)) { // Don't allow this to be converted to NaN
+                return lores;
+            }
+
+            // Do a taylor series expansion around xpa:
+            //   f(x+y) = f(x) + f'(x) y + f''(x)/2 y^2
+            final double fx1 = xpb / xpa;
+            final double epsilon = 0.5 * fx1 + 1;
+            return epsilon * fx1 + hiPrec[1] + hiPrec[0];
+        } else {
+            // Value is small |x| < 1e6, do a Taylor series centered on 1.
+            final double y = (x * F_1_3 - F_1_2) * x + 1;
+            return y * x;
         }
-
-        /* Value is small |x| < 1e6, do a Taylor series centered on 1.0 */
-        double y = x * 0.333333333333333 - 0.5;
-        y = y * x + 1.0;
-        y = y * x;
-
-        return y;
     }
 
     /** Compute the base 10 logarithm.
@@ -1201,9 +1395,12 @@
     public static double log10(final double x) {
         final double hiPrec[] = new double[2];
 
-        log(x, hiPrec);
+        final double lores = log(x, hiPrec);
+        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN
+            return lores;
+        }
 
-        final double tmp = hiPrec[0] * 1073741824.0;
+        final double tmp = hiPrec[0] * HEX_40000000;
         final double lna = hiPrec[0] + tmp - tmp;
         final double lnb = hiPrec[0] - lna + hiPrec[1];
 
@@ -1214,6 +1411,26 @@
     }
 
     /**
+     * Computes the <a href="http://mathworld.wolfram.com/Logarithm.html">
+     * logarithm</a> in a given base.
+     *
+     * Returns {@code NaN} if either argument is negative.
+     * If {@code base} is 0 and {@code x} is positive, 0 is returned.
+     * If {@code base} is positive and {@code x} is 0,
+     * {@code Double.NEGATIVE_INFINITY} is returned.
+     * If both arguments are 0, the result is {@code NaN}.
+     *
+     * @param base Base of the logarithm, must be greater than 0.
+     * @param x Argument, must be greater than 0.
+     * @return the value of the logarithm, i.e. the number {@code y} such that
+     * <code>base<sup>y</sup> = x</code>.
+     * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0)
+     */
+    public static double log(double base, double x) {
+        return log(x) / log(base);
+    }
+
+    /**
      * Power function.  Compute x^y.
      *
      * @param x   a double
@@ -1242,10 +1459,6 @@
                     return Double.NEGATIVE_INFINITY;
                 }
 
-                if (y < 0 && y == yi && (yi & 1) == 1) {
-                    return -0.0;
-                }
-
                 if (y > 0 && y == yi && (yi & 1) == 1) {
                     return -0.0;
                 }
@@ -1273,8 +1486,9 @@
         }
 
         if (y == Double.POSITIVE_INFINITY) {
-            if (x * x == 1.0)
-              return Double.NaN;
+            if (x * x == 1.0) {
+                return Double.NaN;
+            }
 
             if (x * x > 1.0) {
                 return Double.POSITIVE_INFINITY;
@@ -1323,7 +1537,7 @@
         /* Handle special case x<0 */
         if (x < 0) {
             // y is an even integer in this case
-            if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
+            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {
                 return pow(-x, y);
             }
 
@@ -1339,23 +1553,27 @@
         double ya;
         double yb;
         if (y < 8e298 && y > -8e298) {
-            double tmp1 = y * 1073741824.0;
+            double tmp1 = y * HEX_40000000;
             ya = y + tmp1 - tmp1;
             yb = y - ya;
         } else {
             double tmp1 = y * 9.31322574615478515625E-10;
             double tmp2 = tmp1 * 9.31322574615478515625E-10;
-            ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
+            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;
             yb = y - ya;
         }
 
         /* Compute ln(x) */
-        log(x, lns);
+        final double lores = log(x, lns);
+        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN
+            return lores;
+        }
+
         double lna = lns[0];
         double lnb = lns[1];
 
         /* resplit lns */
-        double tmp1 = lna * 1073741824.0;
+        double tmp1 = lna * HEX_40000000;
         double tmp2 = lna + tmp1 - tmp1;
         lnb += lna - tmp2;
         lna = tmp2;
@@ -1379,247 +1597,70 @@
         return result;
     }
 
-    /** xi in the range of [1, 2].
-     *                                3        5        7
-     *      x+1           /          x        x        x          \
-     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |
-     *      1-x           \          3        5        7          /
-     *
-     * So, compute a Remez approximation of the following function
-     *
-     *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x
-     *
-     * This will be an even function with only positive coefficents.
-     * x is in the range [0 - 1/3].
-     *
-     * Transform xi for input to the above function by setting
-     * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then
-     * the result is multiplied by x.
-     * @param xi number from which log is requested
-     * @return log(xi)
-     */
-    private static double[] slowLog(double xi) {
-        double x[] = new double[2];
-        double x2[] = new double[2];
-        double y[] = new double[2];
-        double a[] = new double[2];
-
-        split(xi, x);
-
-        /* Set X = (x-1)/(x+1) */
-        x[0] += 1.0;
-        resplit(x);
-        splitReciprocal(x, a);
-        x[0] -= 2.0;
-        resplit(x);
-        splitMult(x, a, y);
-        x[0] = y[0];
-        x[1] = y[1];
-
-        /* Square X -> X2*/
-        splitMult(x, x, x2);
-
-
-        //x[0] -= 1.0;
-        //resplit(x);
-
-        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];
-        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];
-
-        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {
-            splitMult(y, x2, a);
-            y[0] = a[0];
-            y[1] = a[1];
-            splitAdd(y, LN_SPLIT_COEF[i], a);
-            y[0] = a[0];
-            y[1] = a[1];
-        }
-
-        splitMult(y, x, a);
-        y[0] = a[0];
-        y[1] = a[1];
-
-        return y;
-    }
 
     /**
-     * For x between 0 and pi/4 compute sine.
-     * @param x number from which sine is requested
-     * @param result placeholder where to put the result in extended precision
-     * @return sin(x)
-     */
-    private static double slowSin(final double x, final double result[]) {
-        final double xs[] = new double[2];
-        final double ys[] = new double[2];
-        final double facts[] = new double[2];
-        final double as[] = new double[2];
-        split(x, xs);
-        ys[0] = ys[1] = 0.0;
-
-        for (int i = 19; i >= 0; i--) {
-            splitMult(xs, ys, as);
-            ys[0] = as[0]; ys[1] = as[1];
-
-            if ( (i & 1) == 0) {
-                continue;
-            }
-
-            split(FACT[i], as);
-            splitReciprocal(as, facts);
-
-            if ( (i & 2) != 0 ) {
-                facts[0] = -facts[0];
-                facts[1] = -facts[1];
-            }
-
-            splitAdd(ys, facts, as);
-            ys[0] = as[0]; ys[1] = as[1];
-        }
-
-        if (result != null) {
-            result[0] = ys[0];
-            result[1] = ys[1];
-        }
-
-        return ys[0] + ys[1];
-    }
-
-    /**
-     *  For x between 0 and pi/4 compute cosine
-     * @param x number from which cosine is requested
-     * @param result placeholder where to put the result in extended precision
-     * @return cos(x)
-     */
-    private static double slowCos(final double x, final double result[]) {
-
-        final double xs[] = new double[2];
-        final double ys[] = new double[2];
-        final double facts[] = new double[2];
-        final double as[] = new double[2];
-        split(x, xs);
-        ys[0] = ys[1] = 0.0;
-
-        for (int i = 19; i >= 0; i--) {
-            splitMult(xs, ys, as);
-            ys[0] = as[0]; ys[1] = as[1];
-
-            if ( (i & 1) != 0) {
-                continue;
-            }
-
-            split(FACT[i], as);
-            splitReciprocal(as, facts);
-
-            if ( (i & 2) != 0 ) {
-                facts[0] = -facts[0];
-                facts[1] = -facts[1];
-            }
-
-            splitAdd(ys, facts, as);
-            ys[0] = as[0]; ys[1] = as[1];
-        }
-
-        if (result != null) {
-            result[0] = ys[0];
-            result[1] = ys[1];
-        }
-
-        return ys[0] + ys[1];
-    }
-
-    /** Build the sine and cosine tables.
+     * Raise a double to an int power.
+     *
+     * @param d Number to raise.
+     * @param e Exponent.
+     * @return d<sup>e</sup>
      */
-    private static void buildSinCosTables() {
-        final double result[] = new double[2];
-
-        /* Use taylor series for 0 <= x <= 6/8 */
-        for (int i = 0; i < 7; i++) {
-            double x = i / 8.0;
-
-            slowSin(x, result);
-            SINE_TABLE_A[i] = result[0];
-            SINE_TABLE_B[i] = result[1];
-
-            slowCos(x, result);
-            COSINE_TABLE_A[i] = result[0];
-            COSINE_TABLE_B[i] = result[1];
-        }
+    public static double pow(double d, int e) {
 
-        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */
-        for (int i = 7; i < 14; i++) {
-            double xs[] = new double[2];
-            double ys[] = new double[2];
-            double as[] = new double[2];
-            double bs[] = new double[2];
-            double temps[] = new double[2];
-
-            if ( (i & 1) == 0) {
-                // Even, use double angle
-                xs[0] = SINE_TABLE_A[i/2];
-                xs[1] = SINE_TABLE_B[i/2];
-                ys[0] = COSINE_TABLE_A[i/2];
-                ys[1] = COSINE_TABLE_B[i/2];
+        if (e == 0) {
+            return 1.0;
+        } else if (e < 0) {
+            e = -e;
+            d = 1.0 / d;
+        }
+
+        // split d as two 26 bits numbers
+        // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties
+        final int splitFactor = 0x8000001;
+        final double cd       = splitFactor * d;
+        final double d1High   = cd - (cd - d);
+        final double d1Low    = d - d1High;
+
+        // prepare result
+        double resultHigh = 1;
+        double resultLow  = 0;
+
+        // d^(2p)
+        double d2p     = d;
+        double d2pHigh = d1High;
+        double d2pLow  = d1Low;
+
+        while (e != 0) {
+
+            if ((e & 0x1) != 0) {
+                // accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm
+                // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties
+                final double tmpHigh = resultHigh * d2p;
+                final double cRH     = splitFactor * resultHigh;
+                final double rHH     = cRH - (cRH - resultHigh);
+                final double rHL     = resultHigh - rHH;
+                final double tmpLow  = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow);
+                resultHigh = tmpHigh;
+                resultLow  = resultLow * d2p + tmpLow;
+            }
+
+            // accurate squaring d^(2(p+1)) = d^(2p) * d^(2p) using Veltkamp TwoProduct algorithm
+            // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties
+            final double tmpHigh = d2pHigh * d2p;
+            final double cD2pH   = splitFactor * d2pHigh;
+            final double d2pHH   = cD2pH - (cD2pH - d2pHigh);
+            final double d2pHL   = d2pHigh - d2pHH;
+            final double tmpLow  = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);
+            final double cTmpH   = splitFactor * tmpHigh;
+            d2pHigh = cTmpH - (cTmpH - tmpHigh);
+            d2pLow  = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);
+            d2p     = d2pHigh + d2pLow;
 
-                /* compute sine */
-                splitMult(xs, ys, result);
-                SINE_TABLE_A[i] = result[0] * 2.0;
-                SINE_TABLE_B[i] = result[1] * 2.0;
+            e = e >> 1;
 
-                /* Compute cosine */
-                splitMult(ys, ys, as);
-                splitMult(xs, xs, temps);
-                temps[0] = -temps[0];
-                temps[1] = -temps[1];
-                splitAdd(as, temps, result);
-                COSINE_TABLE_A[i] = result[0];
-                COSINE_TABLE_B[i] = result[1];
-            } else {
-                xs[0] = SINE_TABLE_A[i/2];
-                xs[1] = SINE_TABLE_B[i/2];
-                ys[0] = COSINE_TABLE_A[i/2];
-                ys[1] = COSINE_TABLE_B[i/2];
-                as[0] = SINE_TABLE_A[i/2+1];
-                as[1] = SINE_TABLE_B[i/2+1];
-                bs[0] = COSINE_TABLE_A[i/2+1];
-                bs[1] = COSINE_TABLE_B[i/2+1];
-
-                /* compute sine */
-                splitMult(xs, bs, temps);
-                splitMult(ys, as, result);
-                splitAdd(result, temps, result);
-                SINE_TABLE_A[i] = result[0];
-                SINE_TABLE_B[i] = result[1];
-
-                /* Compute cosine */
-                splitMult(ys, bs, result);
-                splitMult(xs, as, temps);
-                temps[0] = -temps[0];
-                temps[1] = -temps[1];
-                splitAdd(result, temps, result);
-                COSINE_TABLE_A[i] = result[0];
-                COSINE_TABLE_B[i] = result[1];
-            }
         }
 
-        /* Compute tangent = sine/cosine */
-        for (int i = 0; i < 14; i++) {
-            double xs[] = new double[2];
-            double ys[] = new double[2];
-            double as[] = new double[2];
-
-            as[0] = COSINE_TABLE_A[i];
-            as[1] = COSINE_TABLE_B[i];
-
-            splitReciprocal(as, ys);
-
-            xs[0] = SINE_TABLE_A[i];
-            xs[1] = SINE_TABLE_B[i];
-
-            splitMult(xs, ys, as);
-
-            TANGENT_TABLE_A[i] = as[0];
-            TANGENT_TABLE_B[i] = as[1];
-        }
+        return resultHigh + resultLow;
 
     }
 
@@ -1671,7 +1712,7 @@
      */
     private static double sinQ(double xa, double xb) {
         int idx = (int) ((xa * 8.0) + 0.5);
-        final double epsilon = xa - EIGHTHES[idx]; //idx*0.125;
+        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;
 
         // Table lookups
         final double sintA = SINE_TABLE_A[idx];
@@ -1686,7 +1727,7 @@
         final double cosEpsB = polyCosine(epsilon);
 
         // Split epsilon   xa + xb = x
-        final double temp = sinEpsA * 1073741824.0;
+        final double temp = sinEpsA * HEX_40000000;
         double temp2 = (sinEpsA + temp) - temp;
         sinEpsB +=  sinEpsA - temp2;
         sinEpsA = temp2;
@@ -1815,7 +1856,7 @@
     private static double tanQ(double xa, double xb, boolean cotanFlag) {
 
         int idx = (int) ((xa * 8.0) + 0.5);
-        final double epsilon = xa - EIGHTHES[idx]; //idx*0.125;
+        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;
 
         // Table lookups
         final double sintA = SINE_TABLE_A[idx];
@@ -1830,7 +1871,7 @@
         final double cosEpsB = polyCosine(epsilon);
 
         // Split epsilon   xa + xb = x
-        double temp = sinEpsA * 1073741824.0;
+        double temp = sinEpsA * HEX_40000000;
         double temp2 = (sinEpsA + temp) - temp;
         sinEpsB +=  sinEpsA - temp2;
         sinEpsA = temp2;
@@ -1922,11 +1963,11 @@
         double est = sina/cosa;
 
         /* Split the estimate to get more accurate read on division rounding */
-        temp = est * 1073741824.0;
+        temp = est * HEX_40000000;
         double esta = (est + temp) - temp;
         double estb =  est - esta;
 
-        temp = cosa * 1073741824.0;
+        temp = cosa * HEX_40000000;
         double cosaa = (cosa + temp) - temp;
         double cosab =  cosa - cosaa;
 
@@ -2160,8 +2201,8 @@
         }
 
         /* Convert to double */
-        double tmpA = (prod2A >>> 12) / 4503599627370496.0;  // High order 52 bits
-        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / 4503599627370496.0 / 4503599627370496.0; // Low bits
+        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits
+        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits
 
         double sumA = tmpA + tmpB;
         double sumB = -(sumA - tmpA - tmpB);
@@ -2173,9 +2214,10 @@
     }
 
     /**
-     *  Sine function.
-     *  @param x a number
-     *  @return sin(x)
+     * Sine function.
+     *
+     * @param x Argument.
+     * @return sin(x)
      */
     public static double sin(double x) {
         boolean negative = false;
@@ -2214,41 +2256,10 @@
             xa = reduceResults[1];
             xb = reduceResults[2];
         } else if (xa > 1.5707963267948966) {
-            /* Inline the Cody/Waite reduction for performance */
-
-            // Estimate k
-            //k = (int)(xa / 1.5707963267948966);
-            int k = (int)(xa * 0.6366197723675814);
-
-            // Compute remainder
-            double remA;
-            double remB;
-            while (true) {
-                double a = -k * 1.570796251296997;
-                remA = xa + a;
-                remB = -(remA - xa - a);
-
-                a = -k * 7.549789948768648E-8;
-                double b = remA;
-                remA = a + b;
-                remB += -(remA - b - a);
-
-                a = -k * 6.123233995736766E-17;
-                b = remA;
-                remA = a + b;
-                remB += -(remA - b - a);
-
-                if (remA > 0.0)
-                    break;
-
-                // Remainder is negative, so decrement k and try again.
-                // This should only happen if the input is very close
-                // to an even multiple of pi/2
-                k--;
-            }
-            quadrant = k & 3;
-            xa = remA;
-            xb = remB;
+            final CodyWaite cw = new CodyWaite(xa, xb);
+            quadrant = cw.getK() & 3;
+            xa = cw.getRemA();
+            xb = cw.getRemB();
         }
 
         if (negative) {
@@ -2270,9 +2281,10 @@
     }
 
     /**
-     *  Cosine function
-     *  @param x a number
-     *  @return cos(x)
+     * Cosine function.
+     *
+     * @param x Argument.
+     * @return cos(x)
      */
     public static double cos(double x) {
         int quadrant = 0;
@@ -2299,41 +2311,10 @@
             xa = reduceResults[1];
             xb = reduceResults[2];
         } else if (xa > 1.5707963267948966) {
-            /* Inline the Cody/Waite reduction for performance */
-
-            // Estimate k
-            //k = (int)(xa / 1.5707963267948966);
-            int k = (int)(xa * 0.6366197723675814);
-
-            // Compute remainder
-            double remA;
-            double remB;
-            while (true) {
-                double a = -k * 1.570796251296997;
-                remA = xa + a;
-                remB = -(remA - xa - a);
-
-                a = -k * 7.549789948768648E-8;
-                double b = remA;
-                remA = a + b;
-                remB += -(remA - b - a);
-
-                a = -k * 6.123233995736766E-17;
-                b = remA;
-                remA = a + b;
-                remB += -(remA - b - a);
-
-                if (remA > 0.0)
-                    break;
-
-                // Remainder is negative, so decrement k and try again.
-                // This should only happen if the input is very close
-                // to an even multiple of pi/2
-                k--;
-            }
-            quadrant = k & 3;
-            xa = remA;
-            xb = remB;
+            final CodyWaite cw = new CodyWaite(xa, xb);
+            quadrant = cw.getK() & 3;
+            xa = cw.getRemA();
+            xb = cw.getRemB();
         }
 
         //if (negative)
@@ -2354,9 +2335,10 @@
     }
 
     /**
-     *   Tangent function
-     *  @param x a number
-     *  @return tan(x)
+     * Tangent function.
+     *
+     * @param x Argument.
+     * @return tan(x)
      */
     public static double tan(double x) {
         boolean negative = false;
@@ -2394,45 +2376,14 @@
             xa = reduceResults[1];
             xb = reduceResults[2];
         } else if (xa > 1.5707963267948966) {
-            /* Inline the Cody/Waite reduction for performance */
-
-            // Estimate k
-            //k = (int)(xa / 1.5707963267948966);
-            int k = (int)(xa * 0.6366197723675814);
-
-            // Compute remainder
-            double remA;
-            double remB;
-            while (true) {
-                double a = -k * 1.570796251296997;
-                remA = xa + a;
-                remB = -(remA - xa - a);
-
-                a = -k * 7.549789948768648E-8;
-                double b = remA;
-                remA = a + b;
-                remB += -(remA - b - a);
-
-                a = -k * 6.123233995736766E-17;
-                b = remA;
-                remA = a + b;
-                remB += -(remA - b - a);
-
-                if (remA > 0.0)
-                    break;
-
-                // Remainder is negative, so decrement k and try again.
-                // This should only happen if the input is very close
-                // to an even multiple of pi/2
-                k--;
-            }
-            quadrant = k & 3;
-            xa = remA;
-            xb = remB;
+            final CodyWaite cw = new CodyWaite(xa, xb);
+            quadrant = cw.getK() & 3;
+            xa = cw.getRemA();
+            xb = cw.getRemB();
         }
 
         if (xa > 1.5) {
-            // Accurracy suffers between 1.5 and PI/2
+            // Accuracy suffers between 1.5 and PI/2
             final double pi2a = 1.5707963267948966;
             final double pi2b = 6.123233995736766E-17;
 
@@ -2473,12 +2424,16 @@
      * @param xa number from which arctangent is requested
      * @param xb extra bits for x (may be 0.0)
      * @param leftPlane if true, result angle must be put in the left half plane
-     * @return atan(xa + xb) (or angle shifted by &pi; if leftPlane is true)
+     * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)
      */
     private static double atan(double xa, double xb, boolean leftPlane) {
         boolean negate = false;
         int idx;
 
+        if (xa == 0.0) { // Matches +/- 0.0; return correct sign
+            return leftPlane ? copySign(Math.PI, xa) : xa;
+        }
+
         if (xa < 0) {
             // negative
             xa = -xa;
@@ -2487,15 +2442,15 @@
         }
 
         if (xa > 1.633123935319537E16) { // Very large input
-            return (negate ^ leftPlane) ? (-Math.PI/2.0) : (Math.PI/2.0);
+            return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);
         }
 
         /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */
-        if (xa < 1.0) {
+        if (xa < 1) {
             idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);
         } else {
-            double temp = 1.0/xa;
-            idx = (int) (-((-1.7168146928204136 * temp * temp + 8.0) * temp) + 13.07);
+            final double oneOverXa = 1 / xa;
+            idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07);
         }
         double epsA = xa - TANGENT_TABLE_A[idx];
         double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]);
@@ -2506,7 +2461,7 @@
         epsA = temp;
 
         /* Compute eps = eps / (1.0 + xa*tangent) */
-        temp = xa * 1073741824.0;
+        temp = xa * HEX_40000000;
         double ya = xa + temp - temp;
         double yb = xb + xa - ya;
         xa = ya;
@@ -2516,14 +2471,14 @@
         if (idx == 0) {
             /* If the slope of the arctan is gentle enough (< 0.45), this approximation will suffice */
             //double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);
-            double denom = 1.0 / (1.0 + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));
+            final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));
             //double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);
             ya = epsA * denom;
             yb = epsB * denom;
         } else {
             double temp2 = xa * TANGENT_TABLE_A[idx];
-            double za = 1.0 + temp2;
-            double zb = -(za - 1.0 - temp2);
+            double za = 1d + temp2;
+            double zb = -(za - 1d - temp2);
             temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];
             temp = za + temp2;
             zb += -(temp - za - temp2);
@@ -2532,11 +2487,11 @@
             zb += xb * TANGENT_TABLE_B[idx];
             ya = epsA / za;
 
-            temp = ya * 1073741824.0;
+            temp = ya * HEX_40000000;
             final double yaa = (ya + temp) - temp;
             final double yab = ya - yaa;
 
-            temp = za * 1073741824.0;
+            temp = za * HEX_40000000;
             final double zaa = (za + temp) - temp;
             final double zab = za - zaa;
 
@@ -2552,7 +2507,7 @@
         epsB = yb;
 
         /* Evaluate polynomial */
-        double epsA2 = epsA*epsA;
+        final double epsA2 = epsA * epsA;
 
         /*
     yb = -0.09001346640161823;
@@ -2579,25 +2534,22 @@
         ya = temp;
 
         /* Add in effect of epsB.   atan'(x) = 1/(1+x^2) */
-        yb += epsB / (1.0 + epsA * epsA);
-
-        double result;
-        double resultb;
+        yb += epsB / (1d + epsA * epsA);
 
         //result = yb + eighths[idx] + ya;
-        double za = EIGHTHES[idx] + ya;
-        double zb = -(za - EIGHTHES[idx] - ya);
+        double za = EIGHTHS[idx] + ya;
+        double zb = -(za - EIGHTHS[idx] - ya);
         temp = za + yb;
         zb += -(temp - za - yb);
         za = temp;
 
-        result = za + zb;
-        resultb = -(result - za - zb);
+        double result = za + zb;
+        double resultb = -(result - za - zb);
 
         if (leftPlane) {
             // Result is in the left plane
-            final double pia = 1.5707963267948966*2.0;
-            final double pib = 6.123233995736766E-17*2.0;
+            final double pia = 1.5707963267948966 * 2;
+            final double pib = 6.123233995736766E-17 * 2;
 
             za = pia - result;
             zb = -(za - pia + result);
@@ -2619,32 +2571,28 @@
      * Two arguments arctangent function
      * @param y ordinate
      * @param x abscissa
-     * @return phase angle of point (x,y) between -&pi; and &pi;
+     * @return phase angle of point (x,y) between {@code -PI} and {@code PI}
      */
     public static double atan2(double y, double x) {
-        if (x !=x || y != y) {
+        if (x != x || y != y) {
             return Double.NaN;
         }
 
-        if (y == 0.0) {
-            double result = x*y;
-            double invx = 1.0/x;
-            double invy = 1.0/y;
+        if (y == 0) {
+            final double result = x * y;
+            final double invx = 1d / x;
+            final double invy = 1d / y;
 
-            if (invx == 0.0) { // X is infinite
+            if (invx == 0) { // X is infinite
                 if (x > 0) {
-                    return 0.0;
+                    return y; // return +/- 0.0
                 } else {
-                    return Math.PI;
+                    return copySign(Math.PI, y);
                 }
             }
 
-            if (result != result) { // y must be infinite
-                return x/y;
-            }
-
-            if (x < 0.0 || invx < 0.0) {
-                if (y < 0.0 || invy < 0.0) {
+            if (x < 0 || invx < 0) {
+                if (y < 0 || invy < 0) {
                     return -Math.PI;
                 } else {
                     return Math.PI;
@@ -2654,85 +2602,90 @@
             }
         }
 
+        // y cannot now be zero
+
         if (y == Double.POSITIVE_INFINITY) {
             if (x == Double.POSITIVE_INFINITY) {
-                return Math.PI/4.0;
+                return Math.PI * F_1_4;
             }
 
             if (x == Double.NEGATIVE_INFINITY) {
-                return Math.PI*3.0/4.0;
+                return Math.PI * F_3_4;
             }
 
-            return Math.PI/2.0;
+            return Math.PI * F_1_2;
         }
 
         if (y == Double.NEGATIVE_INFINITY) {
             if (x == Double.POSITIVE_INFINITY) {
-                return -Math.PI/4.0;
+                return -Math.PI * F_1_4;
             }
 
             if (x == Double.NEGATIVE_INFINITY) {
-                return -Math.PI*3.0/4.0;
+                return -Math.PI * F_3_4;
             }
 
-            return -Math.PI/2.0;
+            return -Math.PI * F_1_2;
         }
 
         if (x == Double.POSITIVE_INFINITY) {
-            if (y > 0.0 || 1/y > 0.0) {
-                return 0.0;
+            if (y > 0 || 1 / y > 0) {
+                return 0d;
             }
 
-            if (y < 0.0 || 1/y < 0.0) {
-                return -0.0;
+            if (y < 0 || 1 / y < 0) {
+                return -0d;
             }
         }
 
         if (x == Double.NEGATIVE_INFINITY)
         {
-            if (y > 0.0 || 1/y > 0.0) {
+            if (y > 0.0 || 1 / y > 0.0) {
                 return Math.PI;
             }
 
-            if (y < 0.0 || 1/y < 0.0) {
+            if (y < 0 || 1 / y < 0) {
                 return -Math.PI;
             }
         }
 
+        // Neither y nor x can be infinite or NAN here
+
         if (x == 0) {
-            if (y > 0.0 || 1/y > 0.0) {
-                return Math.PI/2.0;
+            if (y > 0 || 1 / y > 0) {
+                return Math.PI * F_1_2;
             }
 
-            if (y < 0.0 || 1/y < 0.0) {
-                return -Math.PI/2.0;
+            if (y < 0 || 1 / y < 0) {
+                return -Math.PI * F_1_2;
             }
         }
 
-        if (x > 8e298 || x < -8e298) { // This would cause split of x to fail
-            x *= 9.31322574615478515625E-10;
-            y *= 9.31322574615478515625E-10;
+        // Compute ratio r = y/x
+        final double r = y / x;
+        if (Double.isInfinite(r)) { // bypass calculations that can create NaN
+            return atan(r, 0, x < 0);
         }
 
-        // Split y
-        double temp = x * 1073741824.0;
-        final double xa = x + temp - temp;
-        final double xb = x - xa;
-
-        // Compute ratio r = x/y
-        final double r = y/x;
-        temp = r * 1073741824.0;
-        double ra = r + temp - temp;
+        double ra = doubleHighPart(r);
         double rb = r - ra;
 
+        // Split x
+        final double xa = doubleHighPart(x);
+        final double xb = x - xa;
+
         rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
 
-        temp = ra + rb;
+        final double temp = ra + rb;
         rb = -(temp - ra - rb);
         ra = temp;
 
+        if (ra == 0) { // Fix up the sign so atan works correctly
+            ra = copySign(0d, y);
+        }
+
         // Call atan
-        double result = atan(ra, rb, x < 0);
+        final double result = atan(ra, rb, x < 0);
 
         return result;
     }
@@ -2758,10 +2711,14 @@
           return -Math.PI/2.0;
       }
 
+      if (x == 0.0) { // Matches +/- 0.0; return correct sign
+          return x;
+      }
+
       /* Compute asin(x) = atan(x/sqrt(1-x*x)) */
 
       /* Split x */
-      double temp = x * 1073741824.0;
+      double temp = x * HEX_40000000;
       final double xa = x + temp - temp;
       final double xb = x - xa;
 
@@ -2783,7 +2740,7 @@
       /* Square root */
       double y;
       y = sqrt(za);
-      temp = y * 1073741824.0;
+      temp = y * HEX_40000000;
       ya = y + temp - temp;
       yb = y - ya;
 
@@ -2795,7 +2752,7 @@
 
       // Compute ratio r = x/y
       double r = x/y;
-      temp = r * 1073741824.0;
+      temp = r * HEX_40000000;
       double ra = r + temp - temp;
       double rb = r - ra;
 
@@ -2837,7 +2794,7 @@
       /* Compute acos(x) = atan(sqrt(1-x*x)/x) */
 
       /* Split x */
-      double temp = x * 1073741824.0;
+      double temp = x * HEX_40000000;
       final double xa = x + temp - temp;
       final double xb = x - xa;
 
@@ -2858,7 +2815,7 @@
 
       /* Square root */
       double y = sqrt(za);
-      temp = y * 1073741824.0;
+      temp = y * HEX_40000000;
       ya = y + temp - temp;
       yb = y - ya;
 
@@ -2872,8 +2829,13 @@
 
       // Compute ratio r = y/x
       double r = y/x;
-      temp = r * 1073741824.0;
-      double ra = r + temp - temp;
+
+      // Did r overflow?
+      if (Double.isInfinite(r)) { // x is effectively zero
+          return Math.PI/2; // so return the appropriate value
+      }
+
+      double ra = doubleHighPart(r);
       double rb = r - ra;
 
       rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division
@@ -2886,6 +2848,90 @@
       return atan(ra, rb, x<0);
     }
 
+    /** Compute the cubic root of a number.
+     * @param x number on which evaluation is done
+     * @return cubic root of x
+     */
+    public static double cbrt(double x) {
+      /* Convert input double to bits */
+      long inbits = Double.doubleToLongBits(x);
+      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;
+      boolean subnormal = false;
+
+      if (exponent == -1023) {
+          if (x == 0) {
+              return x;
+          }
+
+          /* Subnormal, so normalize */
+          subnormal = true;
+          x *= 1.8014398509481984E16;  // 2^54
+          inbits = Double.doubleToLongBits(x);
+          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;
+      }
+
+      if (exponent == 1024) {
+          // Nan or infinity.  Don't care which.
+          return x;
+      }
+
+      /* Divide the exponent by 3 */
+      int exp3 = exponent / 3;
+
+      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */
+      double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) |
+                                          (long)(((exp3 + 1023) & 0x7ff)) << 52);
+
+      /* This will be a number between 1 and 2 */
+      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);
+
+      /* Estimate the cube root of mant by polynomial */
+      double est = -0.010714690733195933;
+      est = est * mant + 0.0875862700108075;
+      est = est * mant + -0.3058015757857271;
+      est = est * mant + 0.7249995199969751;
+      est = est * mant + 0.5039018405998233;
+
+      est *= CBRTTWO[exponent % 3 + 2];
+
+      // est should now be good to about 15 bits of precision.   Do 2 rounds of
+      // Newton's method to get closer,  this should get us full double precision
+      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.
+      final double xs = x / (p2*p2*p2);
+      est += (xs - est*est*est) / (3*est*est);
+      est += (xs - est*est*est) / (3*est*est);
+
+      // Do one round of Newton's method in extended precision to get the last bit right.
+      double temp = est * HEX_40000000;
+      double ya = est + temp - temp;
+      double yb = est - ya;
+
+      double za = ya * ya;
+      double zb = ya * yb * 2.0 + yb * yb;
+      temp = za * HEX_40000000;
+      double temp2 = za + temp - temp;
+      zb += za - temp2;
+      za = temp2;
+
+      zb = za * yb + ya * zb + zb * yb;
+      za = za * ya;
+
+      double na = xs - za;
+      double nb = -(na - xs + za);
+      nb -= zb;
+
+      est += (na+nb)/(3*est*est);
+
+      /* Scale by a power of two, so this is exact. */
+      est *= p2;
+
+      if (subnormal) {
+          est *= 3.814697265625E-6;  // 2^-18
+      }
+
+      return est;
+    }
+
     /**
      *  Convert degrees to radians, with error of less than 0.5 ULP
      *  @param x angle in degrees
@@ -2893,14 +2939,22 @@
      */
     public static double toRadians(double x)
     {
+        if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign
+            return x;
+        }
+
+        // These are PI/180 split into high and low order bits
         final double facta = 0.01745329052209854;
         final double factb = 1.997844754509471E-9;
 
-        double temp = x * 1073741824.0;
-        double xa = x + temp - temp;
+        double xa = doubleHighPart(x);
         double xb = x - xa;
 
-        return xb * factb + xb * facta + xa * factb + xa * facta;
+        double result = xb * factb + xb * facta + xa * factb + xa * facta;
+        if (result == 0) {
+            result = result * x; // ensure correct sign if calculation underflows
+        }
+        return result;
     }
 
     /**
@@ -2910,11 +2964,15 @@
      */
     public static double toDegrees(double x)
     {
+        if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign
+            return x;
+        }
+
+        // These are 180/PI split into high and low order bits
         final double facta = 57.2957763671875;
         final double factb = 3.145894820876798E-6;
 
-        double temp = x * 1073741824.0;
-        double xa = x + temp - temp;
+        double xa = doubleHighPart(x);
         double xb = x - xa;
 
         return xb * factb + xb * facta + xa * factb + xa * facta;
@@ -2944,7 +3002,7 @@
      * @return abs(x)
      */
     public static float abs(final float x) {
-        return (x < 0.0f) ? -x : x;
+        return (x < 0.0f) ? -x : (x == 0.0f) ? 0.0f : x; // -0.0 => +0.0
     }
 
     /**
@@ -2953,7 +3011,7 @@
      * @return abs(x)
      */
     public static double abs(double x) {
-        return (x < 0.0) ? -x : x;
+        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0
     }
 
     /**
@@ -2961,63 +3019,301 @@
      * @param x number from which ulp is requested
      * @return ulp(x)
      */
-
     public static double ulp(double x) {
+        if (Double.isInfinite(x)) {
+            return Double.POSITIVE_INFINITY;
+        }
         return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));
     }
 
     /**
+     * Compute least significant bit (Unit in Last Position) for a number.
+     * @param x number from which ulp is requested
+     * @return ulp(x)
+     */
+    public static float ulp(float x) {
+        if (Float.isInfinite(x)) {
+            return Float.POSITIVE_INFINITY;
+        }
+        return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));
+    }
+
+    /**
+     * Multiply a double number by a power of 2.
+     * @param d number to multiply
+     * @param n power of 2
+     * @return d &times; 2<sup>n</sup>
+     */
+    public static double scalb(final double d, final int n) {
+
+        // first simple and fast handling when 2^n can be represented using normal numbers
+        if ((n > -1023) && (n < 1024)) {
+            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);
+        }
+
+        // handle special cases
+        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {
+            return d;
+        }
+        if (n < -2098) {
+            return (d > 0) ? 0.0 : -0.0;
+        }
+        if (n > 2097) {
+            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;
+        }
+
+        // decompose d
+        final long bits = Double.doubleToLongBits(d);
+        final long sign = bits & 0x8000000000000000L;
+        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;
+        long mantissa   = bits & 0x000fffffffffffffL;
+
+        // compute scaled exponent
+        int scaledExponent = exponent + n;
+
+        if (n < 0) {
+            // we are really in the case n <= -1023
+            if (scaledExponent > 0) {
+                // both the input and the result are normal numbers, we only adjust the exponent
+                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);
+            } else if (scaledExponent > -53) {
+                // the input is a normal number and the result is a subnormal number
+
+                // recover the hidden mantissa bit
+                mantissa = mantissa | (1L << 52);
+
+                // scales down complete mantissa, hence losing least significant bits
+                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));
+                mantissa = mantissa >>> (1 - scaledExponent);
+                if (mostSignificantLostBit != 0) {
+                    // we need to add 1 bit to round up the result
+                    mantissa++;
+                }
+                return Double.longBitsToDouble(sign | mantissa);
+
+            } else {
+                // no need to compute the mantissa, the number scales down to 0
+                return (sign == 0L) ? 0.0 : -0.0;
+            }
+        } else {
+            // we are really in the case n >= 1024
+            if (exponent == 0) {
+
+                // the input number is subnormal, normalize it
+                while ((mantissa >>> 52) != 1) {
+                    mantissa = mantissa << 1;
+                    --scaledExponent;
+                }
+                ++scaledExponent;
+                mantissa = mantissa & 0x000fffffffffffffL;
+
+                if (scaledExponent < 2047) {
+                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);
+                } else {
+                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;
+                }
+
+            } else if (scaledExponent < 2047) {
+                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);
+            } else {
+                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;
+            }
+        }
+
+    }
+
+    /**
+     * Multiply a float number by a power of 2.
+     * @param f number to multiply
+     * @param n power of 2
+     * @return f &times; 2<sup>n</sup>
+     */
+    public static float scalb(final float f, final int n) {
+
+        // first simple and fast handling when 2^n can be represented using normal numbers
+        if ((n > -127) && (n < 128)) {
+            return f * Float.intBitsToFloat((n + 127) << 23);
+        }
+
+        // handle special cases
+        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {
+            return f;
+        }
+        if (n < -277) {
+            return (f > 0) ? 0.0f : -0.0f;
+        }
+        if (n > 276) {
+            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;
+        }
+
+        // decompose f
+        final int bits = Float.floatToIntBits(f);
+        final int sign = bits & 0x80000000;
+        int  exponent  = (bits >>> 23) & 0xff;
+        int mantissa   = bits & 0x007fffff;
+
+        // compute scaled exponent
+        int scaledExponent = exponent + n;
+
+        if (n < 0) {
+            // we are really in the case n <= -127
+            if (scaledExponent > 0) {
+                // both the input and the result are normal numbers, we only adjust the exponent
+                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);
+            } else if (scaledExponent > -24) {
+                // the input is a normal number and the result is a subnormal number
+
+                // recover the hidden mantissa bit
+                mantissa = mantissa | (1 << 23);
+
+                // scales down complete mantissa, hence losing least significant bits
+                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));
+                mantissa = mantissa >>> (1 - scaledExponent);
+                if (mostSignificantLostBit != 0) {
+                    // we need to add 1 bit to round up the result
+                    mantissa++;
+                }
+                return Float.intBitsToFloat(sign | mantissa);
+
+            } else {
+                // no need to compute the mantissa, the number scales down to 0
+                return (sign == 0) ? 0.0f : -0.0f;
+            }
+        } else {
+            // we are really in the case n >= 128
+            if (exponent == 0) {
+
+                // the input number is subnormal, normalize it
+                while ((mantissa >>> 23) != 1) {
+                    mantissa = mantissa << 1;
+                    --scaledExponent;
+                }
+                ++scaledExponent;
+                mantissa = mantissa & 0x007fffff;
+
+                if (scaledExponent < 255) {
+                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);
+                } else {
+                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;
+                }
+
+            } else if (scaledExponent < 255) {
+                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);
+            } else {
+                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;
+            }
+        }
+
+    }
+
+    /**
      * Get the next machine representable number after a number, moving
      * in the direction of another number.
      * <p>
-     * If <code>direction</code> is greater than or equal to<code>d</code>,
+     * The ordering is as follows (increasing):
+     * <ul>
+     * <li>-INFINITY</li>
+     * <li>-MAX_VALUE</li>
+     * <li>-MIN_VALUE</li>
+     * <li>-0.0</li>
+     * <li>+0.0</li>
+     * <li>+MIN_VALUE</li>
+     * <li>+MAX_VALUE</li>
+     * <li>+INFINITY</li>
+     * <li></li>
+     * <p>
+     * If arguments compare equal, then the second argument is returned.
+     * <p>
+     * If {@code direction} is greater than {@code d},
      * the smallest machine representable number strictly greater than
-     * <code>d</code> is returned; otherwise the largest representable number
-     * strictly less than <code>d</code> is returned.</p>
+     * {@code d} is returned; if less, then the largest representable number
+     * strictly less than {@code d} is returned.</p>
      * <p>
-     * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
+     * If {@code d} is infinite and direction does not
+     * bring it back to finite numbers, it is returned unchanged.</p>
      *
      * @param d base number
      * @param direction (the only important thing is whether
-     * direction is greater or smaller than d)
+     * {@code direction} is greater or smaller than {@code d})
      * @return the next machine representable number in the specified direction
      */
     public static double nextAfter(double d, double direction) {
 
         // handling of some important special cases
-        if (Double.isNaN(d) || Double.isInfinite(d)) {
-            return d;
+        if (Double.isNaN(d) || Double.isNaN(direction)) {
+            return Double.NaN;
+        } else if (d == direction) {
+            return direction;
+        } else if (Double.isInfinite(d)) {
+            return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;
         } else if (d == 0) {
             return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
         }
         // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
         // are handled just as normal numbers
 
-        // split the double in raw components
-        long bits     = Double.doubleToLongBits(d);
-        long sign     = bits & 0x8000000000000000L;
-        long exponent = bits & 0x7ff0000000000000L;
-        long mantissa = bits & 0x000fffffffffffffL;
-
-        if (d * (direction - d) >= 0) {
-            // we should increase the mantissa
-            if (mantissa == 0x000fffffffffffffL) {
-                return Double.longBitsToDouble(sign |
-                                               (exponent + 0x0010000000000000L));
-            } else {
-                return Double.longBitsToDouble(sign |
-                                               exponent | (mantissa + 1));
-            }
+        final long bits = Double.doubleToLongBits(d);
+        final long sign = bits & 0x8000000000000000L;
+        if ((direction < d) ^ (sign == 0L)) {
+            return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1));
         } else {
-            // we should decrease the mantissa
-            if (mantissa == 0L) {
-                return Double.longBitsToDouble(sign |
-                                               (exponent - 0x0010000000000000L) |
-                                               0x000fffffffffffffL);
-            } else {
-                return Double.longBitsToDouble(sign |
-                                               exponent | (mantissa - 1));
-            }
+            return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1));
+        }
+
+    }
+
+    /**
+     * Get the next machine representable number after a number, moving
+     * in the direction of another number.
+     * <p>
+     * The ordering is as follows (increasing):
+     * <ul>
+     * <li>-INFINITY</li>
+     * <li>-MAX_VALUE</li>
+     * <li>-MIN_VALUE</li>
+     * <li>-0.0</li>
+     * <li>+0.0</li>
+     * <li>+MIN_VALUE</li>
+     * <li>+MAX_VALUE</li>
+     * <li>+INFINITY</li>
+     * <li></li>
+     * <p>
+     * If arguments compare equal, then the second argument is returned.
+     * <p>
+     * If {@code direction} is greater than {@code f},
+     * the smallest machine representable number strictly greater than
+     * {@code f} is returned; if less, then the largest representable number
+     * strictly less than {@code f} is returned.</p>
+     * <p>
+     * If {@code f} is infinite and direction does not
+     * bring it back to finite numbers, it is returned unchanged.</p>
+     *
+     * @param f base number
+     * @param direction (the only important thing is whether
+     * {@code direction} is greater or smaller than {@code f})
+     * @return the next machine representable number in the specified direction
+     */
+    public static float nextAfter(final float f, final double direction) {
+
+        // handling of some important special cases
+        if (Double.isNaN(f) || Double.isNaN(direction)) {
+            return Float.NaN;
+        } else if (f == direction) {
+            return (float) direction;
+        } else if (Float.isInfinite(f)) {
+            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;
+        } else if (f == 0f) {
+            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;
+        }
+        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
+        // are handled just as normal numbers
+
+        final int bits = Float.floatToIntBits(f);
+        final int sign = bits & 0x80000000;
+        if ((direction < f) ^ (sign == 0)) {
+            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));
+        } else {
+            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1));
         }
 
     }
@@ -3033,7 +3329,7 @@
             return x;
         }
 
-        if (x >= 4503599627370496.0 || x <= -4503599627370496.0) {
+        if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {
             return x;
         }
 
@@ -3046,7 +3342,7 @@
             return x*y;
         }
 
-        return (double) y;
+        return y;
     }
 
     /** Get the smallest whole number larger than x.
@@ -3083,6 +3379,9 @@
         double d = x - y;
 
         if (d > 0.5) {
+            if (y == -1.0) {
+                return -0.0; // Preserve sign of operand
+            }
             return y+1.0;
         }
         if (d < 0.5) {
@@ -3107,7 +3406,7 @@
      * @return closest int to x
      */
     public static int round(final float x) {
-        return Math.round(x);
+        return (int) floor(x + 0.5f);
     }
 
     /** Compute the minimum of two values
@@ -3134,7 +3433,23 @@
      * @return a if a is lesser or equal to b, b otherwise
      */
     public static float min(final float a, final float b) {
-        return (a <= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);
+        if (a > b) {
+            return b;
+        }
+        if (a < b) {
+            return a;
+        }
+        /* if either arg is NaN, return NaN */
+        if (a != b) {
+            return Float.NaN;
+        }
+        /* min(+0.0,-0.0) == -0.0 */
+        /* 0x80000000 == Float.floatToRawIntBits(-0.0d) */
+        int bits = Float.floatToRawIntBits(a);
+        if (bits == 0x80000000) {
+            return a;
+        }
+        return b;
     }
 
     /** Compute the minimum of two values
@@ -3143,7 +3458,23 @@
      * @return a if a is lesser or equal to b, b otherwise
      */
     public static double min(final double a, final double b) {
-        return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b);
+        if (a > b) {
+            return b;
+        }
+        if (a < b) {
+            return a;
+        }
+        /* if either arg is NaN, return NaN */
+        if (a != b) {
+            return Double.NaN;
+        }
+        /* min(+0.0,-0.0) == -0.0 */
+        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */
+        long bits = Double.doubleToRawLongBits(a);
+        if (bits == 0x8000000000000000L) {
+            return a;
+        }
+        return b;
     }
 
     /** Compute the maximum of two values
@@ -3170,7 +3501,23 @@
      * @return b if a is lesser or equal to b, a otherwise
      */
     public static float max(final float a, final float b) {
-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
+        if (a > b) {
+            return a;
+        }
+        if (a < b) {
+            return b;
+        }
+        /* if either arg is NaN, return NaN */
+        if (a != b) {
+            return Float.NaN;
+        }
+        /* min(+0.0,-0.0) == -0.0 */
+        /* 0x80000000 == Float.floatToRawIntBits(-0.0d) */
+        int bits = Float.floatToRawIntBits(a);
+        if (bits == 0x80000000) {
+            return b;
+        }
+        return a;
     }
 
     /** Compute the maximum of two values
@@ -3179,7 +3526,339 @@
      * @return b if a is lesser or equal to b, a otherwise
      */
     public static double max(final double a, final double b) {
-        return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);
+        if (a > b) {
+            return a;
+        }
+        if (a < b) {
+            return b;
+        }
+        /* if either arg is NaN, return NaN */
+        if (a != b) {
+            return Double.NaN;
+        }
+        /* min(+0.0,-0.0) == -0.0 */
+        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */
+        long bits = Double.doubleToRawLongBits(a);
+        if (bits == 0x8000000000000000L) {
+            return b;
+        }
+        return a;
+    }
+
+    /**
+     * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}
+     * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<br/>
+     * avoiding intermediate overflow or underflow.
+     *
+     * <ul>
+     * <li> If either argument is infinite, then the result is positive infinity.</li>
+     * <li> else, if either argument is NaN then the result is NaN.</li>
+     * </ul>
+     *
+     * @param x a value
+     * @param y a value
+     * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)
+     */
+    public static double hypot(final double x, final double y) {
+        if (Double.isInfinite(x) || Double.isInfinite(y)) {
+            return Double.POSITIVE_INFINITY;
+        } else if (Double.isNaN(x) || Double.isNaN(y)) {
+            return Double.NaN;
+        } else {
+
+            final int expX = getExponent(x);
+            final int expY = getExponent(y);
+            if (expX > expY + 27) {
+                // y is neglectible with respect to x
+                return abs(x);
+            } else if (expY > expX + 27) {
+                // x is neglectible with respect to y
+                return abs(y);
+            } else {
+
+                // find an intermediate scale to avoid both overflow and underflow
+                final int middleExp = (expX + expY) / 2;
+
+                // scale parameters without losing precision
+                final double scaledX = scalb(x, -middleExp);
+                final double scaledY = scalb(y, -middleExp);
+
+                // compute scaled hypotenuse
+                final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);
+
+                // remove scaling
+                return scalb(scaledH, middleExp);
+
+            }
+
+        }
+    }
+
+    /**
+     * Computes the remainder as prescribed by the IEEE 754 standard.
+     * The remainder value is mathematically equal to {@code x - y*n}
+     * where {@code n} is the mathematical integer closest to the exact mathematical value
+     * of the quotient {@code x/y}.
+     * If two mathematical integers are equally close to {@code x/y} then
+     * {@code n} is the integer that is even.
+     * <p>
+     * <ul>
+     * <li>If either operand is NaN, the result is NaN.</li>
+     * <li>If the result is not NaN, the sign of the result equals the sign of the dividend.</li>
+     * <li>If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.</li>
+     * <li>If the dividend is finite and the divisor is an infinity, the result equals the dividend.</li>
+     * <li>If the dividend is a zero and the divisor is finite, the result equals the dividend.</li>
+     * </ul>
+     * <p><b>Note:</b> this implementation currently delegates to {@link StrictMath#IEEEremainder}
+     * @param dividend the number to be divided
+     * @param divisor the number by which to divide
+     * @return the remainder, rounded
+     */
+    public static double IEEEremainder(double dividend, double divisor) {
+        return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation
+    }
+
+    /**
+     * Returns the first argument with the sign of the second argument.
+     * A NaN {@code sign} argument is treated as positive.
+     *
+     * @param magnitude the value to return
+     * @param sign the sign for the returned value
+     * @return the magnitude with the same sign as the {@code sign} argument
+     */
+    public static double copySign(double magnitude, double sign){
+        long m = Double.doubleToLongBits(magnitude);
+        long s = Double.doubleToLongBits(sign);
+        if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK
+            return magnitude;
+        }
+        return -magnitude; // flip sign
+    }
+
+    /**
+     * Returns the first argument with the sign of the second argument.
+     * A NaN {@code sign} argument is treated as positive.
+     *
+     * @param magnitude the value to return
+     * @param sign the sign for the returned value
+     * @return the magnitude with the same sign as the {@code sign} argument
+     */
+    public static float copySign(float magnitude, float sign){
+        int m = Float.floatToIntBits(magnitude);
+        int s = Float.floatToIntBits(sign);
+        if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK
+            return magnitude;
+        }
+        return -magnitude; // flip sign
+    }
+
+    /**
+     * Return the exponent of a double number, removing the bias.
+     * <p>
+     * For double numbers of the form 2<sup>x</sup>, the unbiased
+     * exponent is exactly x.
+     * </p>
+     * @param d number from which exponent is requested
+     * @return exponent for d in IEEE754 representation, without bias
+     */
+    public static int getExponent(final double d) {
+        return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023;
+    }
+
+    /**
+     * Return the exponent of a float number, removing the bias.
+     * <p>
+     * For float numbers of the form 2<sup>x</sup>, the unbiased
+     * exponent is exactly x.
+     * </p>
+     * @param f number from which exponent is requested
+     * @return exponent for d in IEEE754 representation, without bias
+     */
+    public static int getExponent(final float f) {
+        return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127;
+    }
+
+    /**
+     * Print out contents of arrays, and check the length.
+     * <p>used to generate the preset arrays originally.</p>
+     * @param a unused
+     */
+    public static void main(String[] a) {
+        PrintStream out = System.out;
+        FastMathCalc.printarray(out, "EXP_INT_TABLE_A", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A);
+        FastMathCalc.printarray(out, "EXP_INT_TABLE_B", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);
+        FastMathCalc.printarray(out, "EXP_FRAC_TABLE_A", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);
+        FastMathCalc.printarray(out, "EXP_FRAC_TABLE_B", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B);
+        FastMathCalc.printarray(out, "LN_MANT",LN_MANT_LEN, lnMant.LN_MANT);
+        FastMathCalc.printarray(out, "SINE_TABLE_A", SINE_TABLE_LEN, SINE_TABLE_A);
+        FastMathCalc.printarray(out, "SINE_TABLE_B", SINE_TABLE_LEN, SINE_TABLE_B);
+        FastMathCalc.printarray(out, "COSINE_TABLE_A", SINE_TABLE_LEN, COSINE_TABLE_A);
+        FastMathCalc.printarray(out, "COSINE_TABLE_B", SINE_TABLE_LEN, COSINE_TABLE_B);
+        FastMathCalc.printarray(out, "TANGENT_TABLE_A", SINE_TABLE_LEN, TANGENT_TABLE_A);
+        FastMathCalc.printarray(out, "TANGENT_TABLE_B", SINE_TABLE_LEN, TANGENT_TABLE_B);
+    }
+
+    /** Enclose large data table in nested static class so it's only loaded on first access. */
+    private static class ExpIntTable {
+        /** Exponential evaluated at integer values,
+         * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX].
+         */
+        private static final double[] EXP_INT_TABLE_A;
+        /** Exponential evaluated at integer values,
+         * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX]
+         */
+        private static final double[] EXP_INT_TABLE_B;
+
+        static {
+            if (RECOMPUTE_TABLES_AT_RUNTIME) {
+                EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN];
+                EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN];
+
+                final double tmp[] = new double[2];
+                final double recip[] = new double[2];
+
+                // Populate expIntTable
+                for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) {
+                    FastMathCalc.expint(i, tmp);
+                    EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0];
+                    EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1];
+
+                    if (i != 0) {
+                        // Negative integer powers
+                        FastMathCalc.splitReciprocal(tmp, recip);
+                        EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0];
+                        EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1];
+                    }
+                }
+            } else {
+                EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA();
+                EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB();
+            }
+        }
+    }
+
+    /** Enclose large data table in nested static class so it's only loaded on first access. */
+    private static class ExpFracTable {
+        /** Exponential over the range of 0 - 1 in increments of 2^-10
+         * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].
+         * 1024 = 2^10
+         */
+        private static final double[] EXP_FRAC_TABLE_A;
+        /** Exponential over the range of 0 - 1 in increments of 2^-10
+         * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].
+         */
+        private static final double[] EXP_FRAC_TABLE_B;
+
+        static {
+            if (RECOMPUTE_TABLES_AT_RUNTIME) {
+                EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN];
+                EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN];
+
+                final double tmp[] = new double[2];
+
+                // Populate expFracTable
+                final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1);
+                for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) {
+                    FastMathCalc.slowexp(i * factor, tmp);
+                    EXP_FRAC_TABLE_A[i] = tmp[0];
+                    EXP_FRAC_TABLE_B[i] = tmp[1];
+                }
+            } else {
+                EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA();
+                EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB();
+            }
+        }
+    }
+
+    /** Enclose large data table in nested static class so it's only loaded on first access. */
+    private static class lnMant {
+        /** Extended precision logarithm table over the range 1 - 2 in increments of 2^-10. */
+        private static final double[][] LN_MANT;
+
+        static {
+            if (RECOMPUTE_TABLES_AT_RUNTIME) {
+                LN_MANT = new double[FastMath.LN_MANT_LEN][];
+
+                // Populate lnMant table
+                for (int i = 0; i < LN_MANT.length; i++) {
+                    final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L );
+                    LN_MANT[i] = FastMathCalc.slowLog(d);
+                }
+            } else {
+                LN_MANT = FastMathLiteralArrays.loadLnMant();
+            }
+        }
     }
 
+    /** Enclose the Cody/Waite reduction (used in "sin", "cos" and "tan"). */
+    private static class CodyWaite {
+        /** k */
+        private final int finalK;
+        /** remA */
+        private final double finalRemA;
+        /** remB */
+        private final double finalRemB;
+
+        /**
+         * @param xa Argument.
+         * @param xb Argument.
+         */
+        CodyWaite(double xa,
+                  double xb) {
+            // Estimate k.
+            //k = (int)(xa / 1.5707963267948966);
+            int k = (int)(xa * 0.6366197723675814);
+
+            // Compute remainder.
+            double remA;
+            double remB;
+            while (true) {
+                double a = -k * 1.570796251296997;
+                remA = xa + a;
+                remB = -(remA - xa - a);
+
+                a = -k * 7.549789948768648E-8;
+                double b = remA;
+                remA = a + b;
+                remB += -(remA - b - a);
+
+                a = -k * 6.123233995736766E-17;
+                b = remA;
+                remA = a + b;
+                remB += -(remA - b - a);
+
+                if (remA > 0) {
+                    break;
+                }
+
+                // Remainder is negative, so decrement k and try again.
+                // This should only happen if the input is very close
+                // to an even multiple of pi/2.
+                --k;
+            }
+
+            this.finalK = k;
+            this.finalRemA = remA;
+            this.finalRemB = remB;
+        }
+
+        /**
+         * @return k
+         */
+        int getK() {
+            return finalK;
+        }
+        /**
+         * @return remA
+         */
+        double getRemA() {
+            return finalRemA;
+        }
+        /**
+         * @return remB
+         */
+        double getRemB() {
+            return finalRemB;
+        }
+    }
 }
Only in buggy/src: test
