diff --git a/CHANGES b/CHANGES
index bffc3f4..d7804d0 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,5 +1,13 @@
 jsoup changelog
 
+*** Release 1.6.0 [PENDING]
+ * HTML5 conformant parser. Complete reimplemenation of HTML tokenisation and parsing, to implement the
+   http://whatwg.org/html spec. This ensures jsoup parses HTML identically to current modern browsers.
+
+ * When parsing files from disk, files are loaded via memory mapping, to increase parse speed.
+
+ * Reduced memory overhead and lowered garbage collector pressure with Attribute, Node and Entity model optimisations.
+
 *** Release 1.5.2 [2011-02-27]
  * Fixed issue with selector parser where some boolean AND + OR combined queries (e.g. "meta[http-equiv], meta[content]")
    were being parsed incorrectly as OR only queries (e.g. former as "meta, [http-equiv], meta[content]")
diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java
index 39ddb23..210837a 100644
--- a/src/main/java/org/jsoup/helper/DataUtil.java
+++ b/src/main/java/org/jsoup/helper/DataUtil.java
@@ -6,6 +6,8 @@
 
 import java.io.*;
 import java.nio.ByteBuffer;
+import java.nio.MappedByteBuffer;
+import java.nio.channels.FileChannel;
 import java.nio.charset.Charset;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -30,10 +32,11 @@
      * @throws IOException on IO error
      */
     public static Document load(File in, String charsetName, String baseUri) throws IOException {
-        InputStream inStream = null;
+        FileInputStream inStream = null;
         try {
             inStream = new FileInputStream(in);
-            return load(inStream, charsetName, baseUri);
+            MappedByteBuffer byteData = inStream.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, in.length());
+            return parseByteData(byteData, charsetName, baseUri);
         } finally {
             if (inStream != null)
                 inStream.close();
diff --git a/src/main/java/org/jsoup/helper/StringUtil.java b/src/main/java/org/jsoup/helper/StringUtil.java
index d946555..6bbf667 100644
--- a/src/main/java/org/jsoup/helper/StringUtil.java
+++ b/src/main/java/org/jsoup/helper/StringUtil.java
@@ -120,4 +120,12 @@
         }
         return modified ? sb.toString() : string;
     }
+
+    public static boolean in(String needle, String... haystack) {
+        for (String hay : haystack) {
+            if (hay.equals(needle))
+            return true;
+        }
+        return false;
+    }
 }
diff --git a/src/main/java/org/jsoup/helper/Validate.java b/src/main/java/org/jsoup/helper/Validate.java
index 1a2f9e7..090e92a 100644
--- a/src/main/java/org/jsoup/helper/Validate.java
+++ b/src/main/java/org/jsoup/helper/Validate.java
@@ -46,6 +46,25 @@
     }
 
     /**
+     * Validates that the value is false
+     * @param val object to test
+     */
+    public static void isFalse(boolean val) {
+        if (val)
+            throw new IllegalArgumentException("Must be false");
+    }
+
+    /**
+     * Validates that the value is false
+     * @param val object to test
+     * @param msg message to output if validation fails
+     */
+    public static void isFalse(boolean val, String msg) {
+        if (val)
+            throw new IllegalArgumentException(msg);
+    }
+
+    /**
      * Validates that the array contains no null elements
      * @param objects the array to test
      */
@@ -82,4 +101,12 @@
         if (string == null || string.length() == 0)
             throw new IllegalArgumentException(msg);
     }
+
+    /**
+     Cause a failure.
+     @param msg message to output.
+     */
+    public static void fail(String msg) {
+        throw new IllegalArgumentException(msg);
+    }
 }
diff --git a/src/main/java/org/jsoup/nodes/Attributes.java b/src/main/java/org/jsoup/nodes/Attributes.java
index 44b90ef..9436750 100644
--- a/src/main/java/org/jsoup/nodes/Attributes.java
+++ b/src/main/java/org/jsoup/nodes/Attributes.java
@@ -17,8 +17,9 @@
 public class Attributes implements Iterable<Attribute>, Cloneable {
     protected static final String dataPrefix = "data-";
     
-    private LinkedHashMap<String, Attribute> attributes = new LinkedHashMap<String, Attribute>(2);
+    private LinkedHashMap<String, Attribute> attributes = null;
     // linked hash map to preserve insertion order.
+    // null be default as so many elements have no attributes -- saves a good chunk of memory
 
     /**
      Get an attribute value by key.
@@ -28,7 +29,10 @@
      */
     public String get(String key) {
         Validate.notEmpty(key);
-        
+
+        if (attributes == null)
+            return "";
+
         Attribute attr = attributes.get(key.toLowerCase());
         return attr != null ? attr.getValue() : "";
     }
@@ -49,6 +53,8 @@
      */
     public void put(Attribute attribute) {
         Validate.notNull(attribute);
+        if (attributes == null)
+             attributes = new LinkedHashMap<String, Attribute>(2);
         attributes.put(attribute.getKey(), attribute);
     }
 
@@ -58,6 +64,8 @@
      */
     public void remove(String key) {
         Validate.notEmpty(key);
+        if (attributes == null)
+            return;
         attributes.remove(key.toLowerCase());
     }
 
@@ -67,7 +75,7 @@
      @return true if key exists, false otherwise
      */
     public boolean hasKey(String key) {
-        return attributes.containsKey(key.toLowerCase());
+        return attributes != null && attributes.containsKey(key.toLowerCase());
     }
 
     /**
@@ -75,6 +83,8 @@
      @return size
      */
     public int size() {
+        if (attributes == null)
+            return 0;
         return attributes.size();
     }
 
@@ -83,6 +93,10 @@
      @param incoming attributes to add to these attributes.
      */
     public void addAll(Attributes incoming) {
+        if (incoming.size() == 0)
+            return;
+        if (attributes == null)
+            attributes = new LinkedHashMap<String, Attribute>(incoming.size());
         attributes.putAll(incoming.attributes);
     }
     
@@ -96,6 +110,9 @@
      @return an view of the attributes as a List.
      */
     public List<Attribute> asList() {
+        if (attributes == null)
+            return Collections.emptyList();
+
         List<Attribute> list = new ArrayList<Attribute>(attributes.size());
         for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {
             list.add(entry.getValue());
@@ -123,6 +140,9 @@
     }
     
     void html(StringBuilder accum, Document.OutputSettings out) {
+        if (attributes == null)
+            return;
+        
         for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {
             Attribute attribute = entry.getValue();
             accum.append(" ");
@@ -153,6 +173,9 @@
 
     @Override
     public Attributes clone() {
+        if (attributes == null)
+            return new Attributes();
+
         Attributes clone;
         try {
             clone = (Attributes) super.clone();
@@ -167,6 +190,11 @@
 
     private class Dataset extends AbstractMap<String, String> {
 
+        private Dataset() {
+            if (attributes == null)
+                attributes = new LinkedHashMap<String, Attribute>(2);
+        }
+
         public Set<Entry<String, String>> entrySet() {
             return new EntrySet();
         }
diff --git a/src/main/java/org/jsoup/nodes/Document.java b/src/main/java/org/jsoup/nodes/Document.java
index 83141e7..bdfdf80 100644
--- a/src/main/java/org/jsoup/nodes/Document.java
+++ b/src/main/java/org/jsoup/nodes/Document.java
@@ -15,6 +15,7 @@
  @author Jonathan Hedley, jonathan@hedley.net */
 public class Document extends Element {
     private OutputSettings outputSettings = new OutputSettings();
+    private QuirksMode quirksMode = QuirksMode.noQuirks;
 
     /**
      Create a new, empty Document.
@@ -332,5 +333,18 @@
     public OutputSettings outputSettings() {
         return outputSettings;
     }
+
+    public enum QuirksMode {
+        noQuirks, quirks, limitedQuirks;
+    }
+
+    public QuirksMode quirksMode() {
+        return quirksMode;
+    }
+
+    public Document quirksMode(QuirksMode quirksMode) {
+        this.quirksMode = quirksMode;
+        return this;
+    }
 }
 
diff --git a/src/main/java/org/jsoup/nodes/DocumentType.java b/src/main/java/org/jsoup/nodes/DocumentType.java
new file mode 100644
index 0000000..27706a7
--- /dev/null
+++ b/src/main/java/org/jsoup/nodes/DocumentType.java
@@ -0,0 +1,39 @@
+package org.jsoup.nodes;
+
+import org.jsoup.helper.StringUtil;
+
+/**
+ * A {@code <!DOCTPYE>} node.
+ */
+public class DocumentType extends Node {
+    // todo: quirk mode from publicId and systemId
+
+    private DocumentType() {}
+
+    public DocumentType(String name, String publicId, String systemId, String baseUri) {
+        super(baseUri);
+
+        attr("name", name);
+        attr("publicId", publicId);
+        attr("systemId", systemId);
+    }
+
+    @Override
+    public String nodeName() {
+        return "#doctype";
+    }
+
+    @Override
+    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {
+        accum.append("<!DOCTYPE html");
+        if (!StringUtil.isBlank(attr("publicId")))
+            accum.append(" PUBLIC \"").append(attr("publicId")).append("\"");
+        if (!StringUtil.isBlank(attr("systemId")))
+            accum.append(' ').append(attr("systemId")).append("\"");
+        accum.append('>');
+    }
+
+    @Override
+    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {
+    }
+}
diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java
index 8043c55..441ebab 100644
--- a/src/main/java/org/jsoup/nodes/Element.java
+++ b/src/main/java/org/jsoup/nodes/Element.java
@@ -214,7 +214,7 @@
     }
     
     /**
-     * Add a node to the last child of this element.
+     * Add a node child node to this element.
      * 
      * @param child node to add. Must not already have a parent.
      * @return this element, so that you can add more child nodes or elements.
@@ -297,9 +297,9 @@
      */
     public Element append(String html) {
         Validate.notNull(html);
-        
-        Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body();
-        addChildren(fragment.childNodesAsArray());
+
+        List<Node> nodes = Parser.parseFragment(html, this, baseUri());
+        addChildren(nodes.toArray(new Node[nodes.size()]));
         return this;
     }
     
@@ -312,8 +312,8 @@
     public Element prepend(String html) {
         Validate.notNull(html);
         
-        Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body();
-        addChildren(0, fragment.childNodesAsArray());
+        List<Node> nodes = Parser.parseFragment(html, this, baseUri());
+        addChildren(0, nodes.toArray(new Node[nodes.size()]));
         return this;
     }
 
@@ -330,6 +330,17 @@
     }
 
     /**
+     * Insert the specified node into the DOM before this node (i.e. as a preceeding sibling).
+     * @param node to add before this element
+     * @return this Element, for chaining
+     * @see #after(Node)
+     */
+    @Override
+    public Element before(Node node) {
+        return (Element) super.before(node);
+    }
+
+    /**
      * Insert the specified HTML into the DOM after this element (i.e. as a following sibling).
      *
      * @param html HTML to add after this element
@@ -342,6 +353,17 @@
     }
 
     /**
+     * Insert the specified node into the DOM after this node (i.e. as a following sibling).
+     * @param node to add after this element
+     * @return this element, for chaining
+     * @see #before(Node)
+     */
+    @Override
+    public Element after(Node node) {
+        return (Element) super.after(node);
+    }
+
+    /**
      * Remove all of the element's child nodes. Any attributes are left as-is.
      * @return this element
      */
@@ -848,7 +870,7 @@
      * @return The literal class attribute, or <b>empty string</b> if no class attribute set.
      */
     public String className() {
-        return attributes.hasKey("class") ? attributes.get("class") : "";
+        return attr("class");
     }
 
     /**
@@ -1020,19 +1042,12 @@
 
     @Override
     public boolean equals(Object o) {
-        if (this == o) return true;
-        if (!(o instanceof Element)) return false;
-        if (!super.equals(o)) return false;
-
-        Element element = (Element) o;
-
-        if (tag != null ? !tag.equals(element.tag) : element.tag != null) return false;
-
-        return true;
+        return this == o;
     }
 
     @Override
     public int hashCode() {
+        // todo: fixup, not very useful
         int result = super.hashCode();
         result = 31 * result + (tag != null ? tag.hashCode() : 0);
         return result;
diff --git a/src/main/java/org/jsoup/nodes/Entities.java b/src/main/java/org/jsoup/nodes/Entities.java
index fc33a4c..b5f5b05 100644
--- a/src/main/java/org/jsoup/nodes/Entities.java
+++ b/src/main/java/org/jsoup/nodes/Entities.java
@@ -38,6 +38,26 @@
     private static final Pattern unescapePattern = Pattern.compile("&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\d*);?");
     private static final Pattern strictUnescapePattern = Pattern.compile("&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\d*);");
 
+    private Entities() {}
+
+    /**
+     * Check if the input is a known named entity
+     * @param name the possible entity name (e.g. "lt" or "amp"
+     * @return true if a known named entity
+     */
+    public static boolean isNamedEntity(String name) {
+        return full.containsKey(name);
+    }
+
+    /**
+     * Get the Character value of the named entity
+     * @param name named entity (e.g. "lt" or "amp")
+     * @return the Character value of the named entity (e.g. '<' or '&')
+     */
+    public static Character getCharacterByName(String name) {
+        return full.get(name);
+    }
+    
     static String escape(String string, Document.OutputSettings out) {
         return escape(string, out.encoder(), out.escapeMode());
     }
@@ -70,6 +90,7 @@
      * @return
      */
     static String unescape(String string, boolean strict) {
+        // todo: change this method to use Tokeniser.consumeCharacterReference
         if (!string.contains("&"))
             return string;
 
diff --git a/src/main/java/org/jsoup/nodes/Node.java b/src/main/java/org/jsoup/nodes/Node.java
index b3c8014..2154a15 100644
--- a/src/main/java/org/jsoup/nodes/Node.java
+++ b/src/main/java/org/jsoup/nodes/Node.java
@@ -3,7 +3,6 @@
 import org.jsoup.helper.StringUtil;
 import org.jsoup.helper.Validate;
 import org.jsoup.parser.Parser;
-import org.jsoup.select.Elements;
 import org.jsoup.select.NodeTraversor;
 import org.jsoup.select.NodeVisitor;
 
@@ -235,7 +234,7 @@
 
     /**
      * Insert the specified HTML into the DOM before this node (i.e. as a preceeding sibling).
-     * @param html HTML to add before this element
+     * @param html HTML to add before this node
      * @return this node, for chaining
      * @see #after(String)
      */
@@ -245,8 +244,22 @@
     }
 
     /**
+     * Insert the specified node into the DOM before this node (i.e. as a preceeding sibling).
+     * @param node to add before this node
+     * @return this node, for chaining
+     * @see #after(Node)
+     */
+    public Node before(Node node) {
+        Validate.notNull(node);
+        Validate.notNull(parentNode);
+
+        parentNode.addChildren(siblingIndex(), node);
+        return this;
+    }
+
+    /**
      * Insert the specified HTML into the DOM after this node (i.e. as a following sibling).
-     * @param html HTML to add after this element
+     * @param html HTML to add after this node
      * @return this node, for chaining
      * @see #before(String)
      */
@@ -255,12 +268,27 @@
         return this;
     }
 
+    /**
+     * Insert the specified node into the DOM after this node (i.e. as a following sibling).
+     * @param node to add after this node
+     * @return this node, for chaining
+     * @see #before(Node)
+     */
+    public Node after(Node node) {
+        Validate.notNull(node);
+        Validate.notNull(parentNode);
+
+        parentNode.addChildren(siblingIndex()+1, node);
+        return this;
+    }
+
     private void addSiblingHtml(int index, String html) {
         Validate.notNull(html);
         Validate.notNull(parentNode);
 
-        Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body();
-        parentNode.addChildren(index, fragment.childNodesAsArray());
+        Element context = parent() instanceof Element ? (Element) parent() : null;        
+        List<Node> nodes = Parser.parseFragment(html, context, baseUri());
+        parentNode.addChildren(index, nodes.toArray(new Node[nodes.size()]));
     }
 
     /**
@@ -271,20 +299,21 @@
     public Node wrap(String html) {
         Validate.notEmpty(html);
 
-        Element wrapBody = Parser.parseBodyFragmentRelaxed(html, baseUri).body();
-        Elements wrapChildren = wrapBody.children();
-        Element wrap = wrapChildren.first();
-        if (wrap == null) // nothing to wrap with; noop
+        Element context = parent() instanceof Element ? (Element) parent() : null;
+        List<Node> wrapChildren = Parser.parseFragment(html, context, baseUri());
+        Node wrapNode = wrapChildren.get(0);
+        if (wrapNode == null || !(wrapNode instanceof Element)) // nothing to wrap with; noop
             return null;
 
+        Element wrap = (Element) wrapNode;
         Element deepest = getDeepChild(wrap);
         parentNode.replaceChild(this, wrap);
         deepest.addChildren(this);
 
         // remainder (unbalanced wrap, like <div></div><p></p> -- The <p> is remainder
-        if (wrapChildren.size() > 1) {
-            for (int i = 1; i < wrapChildren.size(); i++) { // skip first
-                Element remainder = wrapChildren.get(i);
+        if (wrapChildren.size() > 0) {
+            for (int i = 0; i < wrapChildren.size(); i++) {
+                Node remainder = wrapChildren.get(i);
                 remainder.parentNode.removeChild(remainder);
                 wrap.appendChild(remainder);
             }
diff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java
new file mode 100644
index 0000000..632cc14
--- /dev/null
+++ b/src/main/java/org/jsoup/parser/CharacterReader.java
@@ -0,0 +1,196 @@
+package org.jsoup.parser;
+
+/**
+ CharacterReader cosumes tokens off a string. To replace the old TokenQueue.
+ */
+class CharacterReader {
+    static final char EOF = (char) -1;
+
+    private final String input;
+    private final int length;
+    private int pos = 0;
+    private int mark = 0;
+
+    CharacterReader(String input) {
+        this.input = input;
+        this.length = input.length();
+    }
+
+    int pos() {
+        return pos;
+    }
+
+    boolean isEmpty() {
+        return pos >= length;
+    }
+
+    char current() {
+        return isEmpty() ? EOF : input.charAt(pos);
+    }
+
+    char consume() {
+        return isEmpty() ? EOF : input.charAt(pos++);
+    }
+
+    void unconsume() {
+        pos--;
+    }
+
+    void advance() {
+        pos++;
+    }
+
+    void mark() {
+        mark = pos;
+    }
+
+    void rewindToMark() {
+        pos = mark;
+    }
+
+    String consumeAsString() {
+        return input.substring(pos, pos++);
+    }
+
+    String consumeTo(char c) {
+        int offset = input.indexOf(c, pos);
+        if (offset != -1) {
+            String consumed = input.substring(pos, offset);
+            pos += consumed.length();
+            return consumed;
+        } else {
+            return consumeToEnd();
+        }
+    }
+
+    String consumeTo(String seq) {
+        int offset = input.indexOf(seq, pos);
+        if (offset != -1) {
+            String consumed = input.substring(pos, offset);
+            pos += consumed.length();
+            return consumed;
+        } else {
+            return consumeToEnd();
+        }
+    }
+
+    String consumeToAny(char... seq) {
+        int start = pos;
+
+        OUTER: while (!isEmpty()) {
+            char c = input.charAt(pos);
+            for (char seek : seq) {
+                if (seek == c)
+                    break OUTER;
+            }
+            pos++;
+        }
+
+        return pos > start ? input.substring(start, pos) : "";
+    }
+
+    String consumeToEnd() {
+        String data = input.substring(pos, input.length() - 1);
+        pos = input.length();
+        return data;
+    }
+
+    String consumeLetterSequence() {
+        int start = pos;
+        while (!isEmpty()) {
+            char c = input.charAt(pos);
+            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
+                pos++;
+            else
+                break;
+        }
+
+        return input.substring(start, pos);
+    }
+
+    String consumeHexSequence() {
+        int start = pos;
+        while (!isEmpty()) {
+            char c = input.charAt(pos);
+            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))
+                pos++;
+            else
+                break;
+        }
+        return input.substring(start, pos);
+    }
+
+    String consumeDigitSequence() {
+        int start = pos;
+        while (!isEmpty()) {
+            char c = input.charAt(pos);
+            if (c >= '0' && c <= '9')
+                pos++;
+            else
+                break;
+        }
+        return input.substring(start, pos);
+    }
+
+    boolean matches(char c) {
+        return !isEmpty() && input.charAt(pos) == c;
+
+    }
+
+    boolean matches(String seq) {
+        return input.startsWith(seq, pos);
+    }
+
+    boolean matchesIgnoreCase(String seq) {
+        return input.regionMatches(true, pos, seq, 0, seq.length());
+    }
+
+    boolean matchesAny(char... seq) {
+        if (isEmpty())
+            return false;
+
+        char c = input.charAt(pos);
+        for (char seek : seq) {
+            if (seek == c)
+                return true;
+        }
+        return false;
+    }
+
+    boolean matchesLetter() {
+        if (isEmpty())
+            return false;
+        char c = input.charAt(pos);
+        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
+    }
+
+    boolean matchesDigit() {
+        if (isEmpty())
+            return false;
+        char c = input.charAt(pos);
+        return (c >= '0' && c <= '9');
+    }
+
+    boolean matchConsume(String seq) {
+        if (matches(seq)) {
+            pos += seq.length();
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    boolean matchConsumeIgnoreCase(String seq) {
+        if (matchesIgnoreCase(seq)) {
+            pos += seq.length();
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public String toString() {
+        return input.substring(pos);
+    }
+}
diff --git a/src/main/java/org/jsoup/parser/ParseError.java b/src/main/java/org/jsoup/parser/ParseError.java
new file mode 100644
index 0000000..01dec6e
--- /dev/null
+++ b/src/main/java/org/jsoup/parser/ParseError.java
@@ -0,0 +1,45 @@
+package org.jsoup.parser;
+
+/**
+ */
+public class ParseError {
+    private String errorMsg;
+    private int pos;
+    private char c;
+    private TokeniserState tokeniserState;
+    private TreeBuilderState treeBuilderState;
+    private Token token;
+
+    public ParseError(String errorMsg, char c, TokeniserState tokeniserState, int pos) {
+        this.errorMsg = errorMsg;
+        this.c = c;
+        this.tokeniserState = tokeniserState;
+        this.pos = pos;
+    }
+
+    public ParseError(String errorMsg, TokeniserState tokeniserState, int pos) {
+        this.errorMsg = errorMsg;
+        this.tokeniserState = tokeniserState;
+        this.pos = pos;
+    }
+
+    public ParseError(String errorMsg, int pos) {
+        this.errorMsg = errorMsg;
+        this.pos = pos;
+    }
+
+    public ParseError(String errorMsg, TreeBuilderState treeBuilderState, Token token, int pos) {
+        this.errorMsg = errorMsg;
+        this.treeBuilderState = treeBuilderState;
+        this.token = token;
+        this.pos = pos;
+    }
+
+    public String getErrorMsg() {
+        return errorMsg;
+    }
+
+    public int getPos() {
+        return pos;
+    }
+}
diff --git a/src/main/java/org/jsoup/parser/Parser.java b/src/main/java/org/jsoup/parser/Parser.java
index f9bc06c..8adc13d 100644
--- a/src/main/java/org/jsoup/parser/Parser.java
+++ b/src/main/java/org/jsoup/parser/Parser.java
@@ -1,318 +1,71 @@
 package org.jsoup.parser;
 
+import org.jsoup.nodes.Document;
+import org.jsoup.nodes.Element;
+import org.jsoup.nodes.Node;
 
-import org.jsoup.helper.Validate;
-import org.jsoup.nodes.*;
-
-import java.util.LinkedList;
+import java.util.List;
 
 /**
- Parses HTML into a {@link Document}. Generally best to use one of the  more convenient parse methods in {@link org.jsoup.Jsoup}.
-
- @author Jonathan Hedley, jonathan@hedley.net */
+ * Parses HTML into a {@link org.jsoup.nodes.Document}. Generally best to use one of the  more convenient parse methods
+ * in {@link org.jsoup.Jsoup}.
+ */
 public class Parser {
-    private static final String SQ = "'";
-    private static final String DQ = "\"";
-
-    private static final Tag htmlTag = Tag.valueOf("html");
-    private static final Tag headTag = Tag.valueOf("head");
-    private static final Tag bodyTag = Tag.valueOf("body");
-    private static final Tag titleTag = Tag.valueOf("title");
-    private static final Tag textareaTag = Tag.valueOf("textarea");
-
-    private final LinkedList<Element> stack;
-    private final TokenQueue tq;
-    private final Document doc;
-    private String baseUri;
-    private boolean relaxed = false;
-
-    private Parser(String html, String baseUri, boolean isBodyFragment) {
-        Validate.notNull(html);
-        Validate.notNull(baseUri);
-
-        stack = new LinkedList<Element>();
-        tq = new TokenQueue(html);
-        this.baseUri = baseUri;
-
-        if (isBodyFragment) {
-            doc = Document.createShell(baseUri);
-            stack.add(doc.body());
-        } else {
-            doc = new Document(baseUri);
-            stack.add(doc);
-        }
-    }
-
     /**
-     Parse HTML into a Document.
-     @param html HTML to parse
-     @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.
-     @return parsed Document
+     * Parse HTML into a Document.
+     *
+     * @param html HTML to parse
+     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.
+     *
+     * @return parsed Document
      */
     public static Document parse(String html, String baseUri) {
-        Parser parser = new Parser(html, baseUri, false);
-        return parser.parse();
+        TreeBuilder treeBuilder = new TreeBuilder();
+        return treeBuilder.parse(html, baseUri);
     }
 
     /**
-     Parse a fragment of HTML into the {@code body} of a Document.
-     @param bodyHtml fragment of HTML
-     @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.
-     @return Document, with empty head, and HTML parsed into body
+     * Parse a fragment of HTML into a list of nodes. The context element, if supplied, supplies parsing context.
+     *
+     * @param fragmentHtml the fragment of HTML to parse
+     * @param context (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This
+     * provides stack context (for implicit element creation).
+     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.
+     *
+     * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modifed.
+     */
+    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {
+        TreeBuilder treeBuilder = new TreeBuilder();
+        return treeBuilder.parseFragment(fragmentHtml, context, baseUri);
+    }
+
+    /**
+     * Parse a fragment of HTML into the {@code body} of a Document.
+     *
+     * @param bodyHtml fragment of HTML
+     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.
+     *
+     * @return Document, with empty head, and HTML parsed into body
      */
     public static Document parseBodyFragment(String bodyHtml, String baseUri) {
-        Parser parser = new Parser(bodyHtml, baseUri, true);
-        return parser.parse();
+        Document doc = Document.createShell(baseUri);
+        Element body = doc.body();
+        List<Node> nodeList = parseFragment(bodyHtml, body, baseUri);
+        Node[] nodes = nodeList.toArray(new Node[nodeList.size()]); // the node list gets modified when re-parented
+        for (Node node : nodes) {
+            body.appendChild(node);
+        }
+        return doc;
     }
 
     /**
-     Parse a fragment of HTML into the {@code body} of a Document, with relaxed parsing enabled. Relaxed, in this
-     context, means that implicit tags are not automatically created when missing.
-     @param bodyHtml fragment of HTML
-     @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.
-     @return Document, with empty head, and HTML parsed into body
+     * @param bodyHtml HTML to parse
+     * @param baseUri baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.
+     *
+     * @return parsed Document
+     * @deprecated Use {@link #parseBodyFragment} or {@link #parseFragment} instead.
      */
     public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) {
-        Parser parser = new Parser(bodyHtml, baseUri, true);
-        parser.relaxed = true;
-        return parser.parse();
-    }
-
-    private Document parse() {
-        while (!tq.isEmpty()) {
-            if (tq.matchesStartTag()) {
-                parseStartTag();
-            } else if (tq.matchesCS("</")) {
-                parseEndTag();
-            } else if (tq.matchesCS("<!--")) {
-                parseComment();
-            } else if (tq.matches("<![CDATA[")) {
-                parseCdata();
-            } else if (tq.matchesCS("<?") || tq.matchesCS("<!")) {
-                parseXmlDecl();
-            } else {
-                parseTextNode();
-            }
-        }
-        return doc.normalise();
-    }
-
-    private void parseComment() {
-        tq.consume("<!--");
-        String data = tq.chompTo("->");
-
-        if (data.endsWith("-")) // i.e. was -->
-            data = data.substring(0, data.length()-1);
-        Comment comment = new Comment(data, baseUri);
-        last().appendChild(comment);
-    }
-
-    private void parseXmlDecl() {
-        tq.consume("<");
-        Character firstChar = tq.consume(); // <? or <!, from initial match.
-        boolean procInstr = firstChar.toString().equals("!");
-        String data = tq.chompTo(">");
-
-        XmlDeclaration decl = new XmlDeclaration(data, baseUri, procInstr);
-        last().appendChild(decl);
-    }
-
-    private void parseEndTag() {
-        tq.consume("</");
-        String tagName = tq.consumeTagName();
-        tq.chompTo(">");
-
-        if (tagName.length() != 0) {
-            Tag tag = Tag.valueOf(tagName);
-            if (!last().tag().isIgnorableEndTag(tag)) // skips </tr> if in <table>
-                popStackToClose(tag);
-        }
-    }
-
-    private void parseStartTag() {
-        tq.consume("<");
-        String tagName = tq.consumeTagName();
-        Validate.notEmpty(tagName, "Unexpectedly empty tagname. (This should not occur, please report!)");
-        
-        tq.consumeWhitespace();
-        Attributes attributes = new Attributes();
-        while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) {
-            Attribute attribute = parseAttribute();
-            if (attribute != null)
-                attributes.put(attribute);
-        }
-
-        Tag tag = Tag.valueOf(tagName);
-        Element child = new Element(tag, baseUri, attributes);
-
-        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>
-        if (tq.matchChomp("/>")) { // close empty element or tag
-            isEmptyElement = true;
-            if (!tag.isKnownTag()) // if unknown and a self closed, allow it to be self closed on output. this doesn't force all instances to be empty
-                tag.setSelfClosing();
-        } else {
-            tq.matchChomp(">");
-        }
-        addChildToParent(child, isEmptyElement);
-
-        // pc data only tags (textarea, script): chomp to end tag, add content as text node
-        if (tag.isData()) {
-            String data = tq.chompToIgnoreCase("</" + tagName);
-            tq.chompTo(">");
-            popStackToClose(tag);
-            
-            Node dataNode;
-            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)
-                dataNode = TextNode.createFromEncoded(data, baseUri);
-            else
-                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for " in script)
-            child.appendChild(dataNode);   
-        }
-
-        // <base href>: update the base uri
-        if (child.tagName().equals("base")) {
-            String href = child.absUrl("href");
-            if (href.length() != 0) { // ignore <base target> etc
-                baseUri = href;
-                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base
-            }
-        }
-    }
-
-    private Attribute parseAttribute() {
-        tq.consumeWhitespace();
-        String key = tq.consumeAttributeKey();
-        String value = "";
-        tq.consumeWhitespace();
-        if (tq.matchChomp("=")) {
-            tq.consumeWhitespace();
-
-            if (tq.matchChomp(SQ)) {
-                value = tq.chompTo(SQ);
-            } else if (tq.matchChomp(DQ)) {
-                value = tq.chompTo(DQ);
-            } else {
-                StringBuilder valueAccum = new StringBuilder();
-                // no ' or " to look for, so scan to end tag or space (or end of stream)
-                while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) {
-                    valueAccum.append(tq.consume());
-                }
-                value = valueAccum.toString();
-            }
-            tq.consumeWhitespace();
-        }
-        if (key.length() != 0)
-            return Attribute.createFromEncoded(key, value);
-        else {
-            if (value.length() == 0) // no key, no val; unknown char, keep popping so not get stuck
-                tq.advance();
-                
-            return null;
-        }
-    }
-
-    private void parseTextNode() {
-        TextNode textNode;
-        // special case: handle string like "hello < there". first char will be "<", because of matchStartTag
-        if (tq.peek() == '<') {
-            tq.advance();
-            textNode = new TextNode("<", baseUri);
-        } else {
-            String text = tq.consumeTo("<");
-            textNode = TextNode.createFromEncoded(text, baseUri);
-        }
-        last().appendChild(textNode);
-    }
-
-    private void parseCdata() {
-        tq.consume("<![CDATA[");
-        String rawText = tq.chompTo("]]>");
-        TextNode textNode = new TextNode(rawText, baseUri); // constructor does not escape
-        last().appendChild(textNode);
-    }
-
-    private Element addChildToParent(Element child, boolean isEmptyElement) {
-        Element parent = popStackToSuitableContainer(child.tag());
-        Tag childTag = child.tag();
-        boolean validAncestor = stackHasValidParent(childTag);
-
-        if (!validAncestor && !relaxed) {
-            // create implicit parent around this child
-            Tag parentTag = childTag.getImplicitParent();
-            Element implicit = new Element(parentTag, baseUri);
-            // special case: make sure there's a head before putting in body
-            if (child.tag().equals(bodyTag)) {
-                Element head = new Element(headTag, baseUri);
-                implicit.appendChild(head);
-            }
-            implicit.appendChild(child);
-
-            // recurse to ensure somewhere to put parent
-            Element root = addChildToParent(implicit, false);
-            if (!isEmptyElement)
-                stack.addLast(child);
-            return root;
-        }
-
-        parent.appendChild(child);
-
-        if (!isEmptyElement)
-            stack.addLast(child);
-        return parent;
-    }
-
-    private boolean stackHasValidParent(Tag childTag) {
-        if (stack.size() == 1 && childTag.equals(htmlTag))
-            return true; // root is valid for html node
-
-        if (childTag.requiresSpecificParent())
-            return stack.getLast().tag().isValidParent(childTag);
-
-        // otherwise, look up the stack for valid ancestors
-        for (int i = stack.size() -1; i >= 0; i--) {
-            Element el = stack.get(i);
-            Tag parent2 = el.tag();
-            if (parent2.isValidAncestor(childTag)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private Element popStackToSuitableContainer(Tag tag) {
-        while (!stack.isEmpty()) {
-            if (last().tag().canContain(tag))
-                return last();
-            else
-                stack.removeLast();
-        }
-        return null;
-    }
-
-    private Element popStackToClose(Tag tag) {
-        // first check to see if stack contains this tag; if so pop to there, otherwise ignore
-        int counter = 0;
-        Element elToClose = null;
-        for (int i = stack.size() -1; i > 0; i--) {
-            counter++;
-            Element el = stack.get(i);
-            Tag elTag = el.tag();
-            if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { // once in body, don't close past body
-                break;
-            } else if (elTag.equals(tag)) {
-                elToClose = el;
-                break;
-            }
-        }
-        if (elToClose != null) {
-            for (int i = 0; i < counter; i++) {
-                stack.removeLast();
-            }
-        }
-        return elToClose;
-    }
-
-    private Element last() {
-        return stack.getLast();
+        return parse(bodyHtml, baseUri);
     }
 }
diff --git a/src/main/java/org/jsoup/parser/Tag.java b/src/main/java/org/jsoup/parser/Tag.java
index ddc664f..0ff2820 100644
--- a/src/main/java/org/jsoup/parser/Tag.java
+++ b/src/main/java/org/jsoup/parser/Tag.java
@@ -2,51 +2,46 @@
 
 import org.jsoup.helper.Validate;
 
-import java.util.*;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
- HTML Tag specifications. This is a very simplistic model without the full expressiveness as the DTD,
- but it should capture most of what we need to know to intelligently parse a doc.
-
- @author Jonathan Hedley, jonathan@hedley.net */
+ * HTML Tag capabilities.
+ *
+ * @author Jonathan Hedley, jonathan@hedley.net
+ */
 public class Tag {
-    private static final Map<String, Tag> tags = new HashMap<String, Tag>();
-    private static final Tag defaultAncestor;
-    static {
-        defaultAncestor = new Tag("BODY");
-        tags.put(defaultAncestor.tagName, defaultAncestor);
-    }
+    private static final Map<String, Tag> tags = new HashMap<String, Tag>(); // map of known tags
 
     private String tagName;
-    private boolean knownTag = false; // if pre-defined or auto-created
     private boolean isBlock = true; // block or inline
-    private boolean formatAsBlock = true;
+    private boolean formatAsBlock = true; // should be formatted as a block
     private boolean canContainBlock = true; // Can this tag hold block level tags?
     private boolean canContainInline = true; // only pcdata if not
-    private boolean optionalClosing = false; // If tag is open, and another seen, close previous tag
     private boolean empty = false; // can hold nothing; e.g. img
     private boolean selfClosing = false; // can self close (<foo />). used for unknown tags that self close, without forcing them as empty.
     private boolean preserveWhitespace = false; // for pre, textarea, script etc
-    private List<Tag> ancestors; // elements must be a descendant of one of these ancestors
-    private List<Tag> excludes = Collections.emptyList(); // cannot contain these tags
-    private List<Tag> ignoreEndTags = Collections.emptyList(); // ignore these end tags
-    private boolean directDescendant; // if true, must directly descend from one of the ancestors
-    private boolean limitChildren; // if true, only contain children that've registered parents
 
     private Tag(String tagName) {
         this.tagName = tagName.toLowerCase();
     }
 
+    /**
+     * Get this tag's name.
+     *
+     * @return the tag's name
+     */
     public String getName() {
         return tagName;
     }
 
     /**
-     Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.
-     <p>
-     Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().
-     @param tagName Name of tag, e.g. "p". Case insensitive.
-     @return The tag, either defined or new generic.
+     * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.
+     * <p/>
+     * Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().
+     *
+     * @param tagName Name of tag, e.g. "p". Case insensitive.
+     * @return The tag, either defined or new generic.
      */
     public static Tag valueOf(String tagName) {
         Validate.notNull(tagName);
@@ -58,8 +53,6 @@
             if (tag == null) {
                 // not defined: create default; go anywhere, do anything! (incl be inside a <p>)
                 tag = new Tag(tagName);
-                tag.setAncestor(defaultAncestor.tagName);
-                tag.setExcludes();
                 tag.isBlock = false;
                 tag.canContainBlock = true;
             }
@@ -68,52 +61,9 @@
     }
 
     /**
-     Test if this tag, the prospective parent, can accept the proposed child.
-     @param child potential child tag.
-     @return true if this can contain child.
-     */
-    boolean canContain(Tag child) {
-        Validate.notNull(child);
-
-        if (child.isBlock && !this.canContainBlock)
-            return false;
-
-        if (!child.isBlock && !this.canContainInline) // not block == inline
-            return false;
-
-        if (this.optionalClosing && this.equals(child))
-            return false;
-
-        if (this.empty || this.isData())
-            return false;
-        
-        // don't allow children to contain their parent (directly)
-        if (this.requiresSpecificParent() && this.getImplicitParent().equals(child))
-            return false;
-
-        // confirm limited children
-        if (limitChildren) {
-            for (Tag childParent : child.ancestors) {
-                if (childParent.equals(this))
-                    return true;
-            }
-            return false;
-        }
-        
-        // exclude children
-        if (!excludes.isEmpty()) {
-            for (Tag excluded: excludes) {
-                if (child.equals(excluded))
-                    return false;
-            }
-        }
-        
-        return true;
-    }
-
-    /**
-     Gets if this is a block tag.
-     @return if block tag
+     * Gets if this is a block tag.
+     *
+     * @return if block tag
      */
     public boolean isBlock() {
         return isBlock;
@@ -121,6 +71,7 @@
 
     /**
      * Gets if this tag should be formatted as a block (or as inline)
+     *
      * @return if should be formatted as block or inline
      */
     public boolean formatAsBlock() {
@@ -128,112 +79,112 @@
     }
 
     /**
-     Gets if this tag can contain block tags.
-     @return if tag can contain block tags
+     * Gets if this tag can contain block tags.
+     *
+     * @return if tag can contain block tags
      */
     public boolean canContainBlock() {
         return canContainBlock;
     }
 
     /**
-     Gets if this tag is an inline tag.
-     @return if this tag is an inline tag.
+     * Gets if this tag is an inline tag.
+     *
+     * @return if this tag is an inline tag.
      */
     public boolean isInline() {
         return !isBlock;
     }
 
     /**
-     Gets if this tag is a data only tag.
-     @return if this tag is a data only tag
+     * Gets if this tag is a data only tag.
+     *
+     * @return if this tag is a data only tag
      */
     public boolean isData() {
         return !canContainInline && !isEmpty();
     }
 
     /**
-     Get if this is an empty tag
-     @return if this is an emtpy tag
+     * Get if this is an empty tag
+     *
+     * @return if this is an emtpy tag
      */
     public boolean isEmpty() {
         return empty;
     }
-    
+
     /**
      * Get if this tag is self closing.
+     *
      * @return if this tag should be output as self closing.
      */
     public boolean isSelfClosing() {
         return empty || selfClosing;
     }
-    
+
     /**
      * Get if this is a pre-defined tag, or was auto created on parsing.
+     *
      * @return if a known tag
      */
     public boolean isKnownTag() {
-        return knownTag;
+        return tags.containsKey(tagName);
     }
 
     /**
-     Get if this tag should preserve whitespace within child text nodes.
-     @return if preserve whitepace
+     * Check if this tagname is a known tag.
+     *
+     * @param tagName name of tag
+     * @return if known HTML tag
+     */
+    public static boolean isKnownTag(String tagName) {
+        return tags.containsKey(tagName);
+    }
+
+    /**
+     * Get if this tag should preserve whitespace within child text nodes.
+     *
+     * @return if preserve whitepace
      */
     public boolean preserveWhitespace() {
         return preserveWhitespace;
     }
 
-    Tag getImplicitParent() {
-        return (!ancestors.isEmpty()) ? ancestors.get(0) : null;
-    }
-
-    boolean requiresSpecificParent() {
-        return directDescendant;
-    }
-
-    boolean isValidParent(Tag child) {
-        return isValidAncestor(child);
-    }
-
-    boolean isValidAncestor(Tag child) {
-        if (child.ancestors.isEmpty())
-            return true; // HTML tag
-
-        for (int i = 0; i < child.ancestors.size(); i++)
-            if (this.equals(child.ancestors.get(i)))
-                return true;
-        
-        return false;
-    }
-
-    boolean isIgnorableEndTag(Tag child) {
-        for (Tag endTag : ignoreEndTags) {
-            if (child.equals(endTag))
-                return true;
-        }
-        return false;        
+    Tag setSelfClosing() {
+        selfClosing = true;
+        return this;
     }
 
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
+        if (!(o instanceof Tag)) return false;
 
         Tag tag = (Tag) o;
 
-        if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false;
+        if (canContainBlock != tag.canContainBlock) return false;
+        if (canContainInline != tag.canContainInline) return false;
+        if (empty != tag.empty) return false;
+        if (formatAsBlock != tag.formatAsBlock) return false;
+        if (isBlock != tag.isBlock) return false;
+        if (preserveWhitespace != tag.preserveWhitespace) return false;
+        if (selfClosing != tag.selfClosing) return false;
+        if (!tagName.equals(tag.tagName)) return false;
 
         return true;
     }
 
     @Override
     public int hashCode() {
-        int result = tagName != null ? tagName.hashCode() : 0;
+        int result = tagName.hashCode();
         result = 31 * result + (isBlock ? 1 : 0);
+        result = 31 * result + (formatAsBlock ? 1 : 0);
         result = 31 * result + (canContainBlock ? 1 : 0);
         result = 31 * result + (canContainInline ? 1 : 0);
-        result = 31 * result + (optionalClosing ? 1 : 0);
         result = 31 * result + (empty ? 1 : 0);
+        result = 31 * result + (selfClosing ? 1 : 0);
+        result = 31 * result + (preserveWhitespace ? 1 : 0);
         return result;
     }
 
@@ -242,280 +193,70 @@
     }
 
     // internal static initialisers:
+    // prepped from http://www.w3.org/TR/REC-html40/sgml/dtd.html and other sources
+    private static final String[] blockTags = {
+            "html", "head", "body", "frameset", "script", "noscript", "style", "meta", "link", "title", "frame",
+            "noframes", "section", "nav", "aside", "hgroup", "header", "footer", "p", "h1", "h2", "h3", "h4", "h5", "h6",
+            "ul", "ol", "pre", "div", "blockquote", "hr", "address", "figure", "figcaption", "form", "fieldset", "ins",
+            "del", "dl", "dt", "dd", "li", "table", "caption", "thead", "tfoot", "tbody", "colgroup", "col", "tr", "th",
+            "td", "video", "audio", "canvas", "details", "menu", "plaintext"
+    };
+    private static final String[] inlineTags = {
+            "object", "base", "font", "tt", "i", "b", "u", "big", "small", "em", "strong", "dfn", "code", "samp", "kbd",
+            "var", "cite", "abbr", "time", "acronym", "mark", "ruby", "rt", "rp", "a", "img", "br", "wbr", "map", "q",
+            "sub", "sup", "bdo", "iframe", "embed", "span", "input", "select", "textarea", "label", "button", "optgroup",
+            "option", "legend", "datalist", "keygen", "output", "progress", "meter", "area", "param", "source", "track",
+            "summary", "command", "device"
+    };
+    private static final String[] emptyTags = {
+            "meta", "link", "base", "frame", "img", "br", "wbr", "embed", "hr", "input", "keygen", "col", "command",
+            "device"
+    };
+    private static final String[] formatAsInlineTags = {
+            "title", "a", "p", "h1", "h2", "h3", "h4", "h5", "h6", "pre", "address", "li", "th", "td"
+    };
+    private static final String[] preserveWhitespaceTags = {"pre", "plaintext", "title"};
 
     static {
-        // prepped from http://www.w3.org/TR/REC-html40/sgml/dtd.html#inline
-        // tags are set here in uppercase for legibility, but internally held as lowercase.
-        // TODO[must]: incorporate html 5 as appropriate
+        // creates
+        for (String tagName : blockTags) {
+            Tag tag = new Tag(tagName);
+            register(tag);
+        }
+        for (String tagName : inlineTags) {
+            Tag tag = new Tag(tagName);
+            tag.isBlock = false;
+            tag.canContainBlock = false;
+            tag.formatAsBlock = false;
+            register(tag);
+        }
 
-        // document
-        createBlock("HTML").setAncestor(); // specific includes not impl
-        createBlock("HEAD").setParent("HTML").setLimitChildren();
-        createBlock("BODY").setAncestor("HTML"); // specific includes not impl
-        createBlock("FRAMESET").setAncestor("HTML");
+        // mods:
+        for (String tagName : emptyTags) {
+            Tag tag = tags.get(tagName);
+            Validate.notNull(tag);
+            tag.canContainBlock = false;
+            tag.canContainInline = false;
+            tag.empty = true;
+        }
 
-        // head
-        // all ancestors set to (head, body): so implicitly create head, but allow in body
-        createBlock("SCRIPT").setAncestor("HEAD", "BODY").setContainDataOnly();
-        createBlock("NOSCRIPT").setAncestor("HEAD", "BODY");
-        createBlock("STYLE").setAncestor("HEAD", "BODY").setContainDataOnly();
-        createBlock("META").setAncestor("HEAD", "BODY").setEmpty();
-        createBlock("LINK").setAncestor("HEAD", "BODY").setEmpty(); // only within head
-        createInline("OBJECT").setAncestor("HEAD", "BODY"); // flow (block/inline) or param
-        createBlock("TITLE").setAncestor("HEAD", "BODY").setContainDataOnly().setFormatAsInline();
-        createInline("BASE").setAncestor("HEAD", "BODY").setEmpty();
+        for (String tagName : formatAsInlineTags) {
+            Tag tag = tags.get(tagName);
+            Validate.notNull(tag);
+            tag.formatAsBlock = false;
+        }
 
-        createBlock("FRAME").setParent("FRAMESET").setEmpty();
-        createBlock("NOFRAMES").setParent("FRAMESET").setContainDataOnly();
-
-        // html5 sections
-        createBlock("SECTION");
-        createBlock("NAV");
-        createBlock("ASIDE");
-        createBlock("HGROUP").setLimitChildren(); // limited to h1 - h6
-        createBlock("HEADER").setExcludes("HEADER", "FOOTER");
-        createBlock("FOOTER").setExcludes("HEADER", "FOOTER");
-
-        // fontstyle
-        createInline("FONT").setOptionalClosing().setCanContainBlock().setFormatAsInline();
-        createInline("TT");
-        createInline("I");
-        createInline("B");
-        createInline("U");
-        createInline("BIG");
-        createInline("SMALL");
-
-        // phrase
-        createInline("EM");
-        createInline("STRONG");
-        createInline("DFN").setOptionalClosing();
-        createInline("CODE");
-        createInline("SAMP");
-        createInline("KBD");
-        createInline("VAR");
-        createInline("CITE");
-        createInline("ABBR");
-        createInline("TIME").setOptionalClosing();
-        createInline("ACRONYM");
-        createInline("MARK");
-        
-        // ruby
-        createInline("RUBY");
-        createInline("RT").setParent("RUBY").setExcludes("RT", "RP");
-        createInline("RP").setParent("RUBY").setExcludes("RT", "RP");
-
-        // special
-        createInline("A").setOptionalClosing().setCanContainBlock().setFormatAsInline(); // cannot contain self
-        createInline("IMG").setEmpty().setAncestor("BODY", "NOSCRIPT"); // noscript so an image can be in html->head->noscript
-        createInline("BR").setEmpty();
-        createInline("WBR").setEmpty();
-        createInline("MAP"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD.
-        createInline("Q");
-        createInline("SUB");
-        createInline("SUP");
-        createInline("BDO");
-        createInline("IFRAME").setOptionalClosing();
-        createInline("EMBED").setEmpty();
-
-        // things past this point aren't really blocks or inline. I'm using them because they can hold block or inline,
-        // but per the spec, only specific elements can hold this. if this becomes a real-world parsing problem,
-        // will need to have another non block/inline type, and explicit include & exclude rules. should be right though
-
-        // block
-        createInline("SPAN").setCanContainBlock().setFormatAsInline(); // spec is phrasing only, practise is block
-        createBlock("P").setContainInlineOnly(); // emasculated block?
-        createBlock("H1").setAncestor("BODY", "HGROUP").setExcludes("HGROUP", "H1", "H2", "H3", "H4", "H5", "H6").setFormatAsInline();
-        createBlock("H2").setAncestor("BODY", "HGROUP").setExcludes("HGROUP", "H1", "H2", "H3", "H4", "H5", "H6").setFormatAsInline();
-        createBlock("H3").setAncestor("BODY", "HGROUP").setExcludes("HGROUP", "H1", "H2", "H3", "H4", "H5", "H6").setFormatAsInline();
-        createBlock("H4").setAncestor("BODY", "HGROUP").setExcludes("HGROUP", "H1", "H2", "H3", "H4", "H5", "H6").setFormatAsInline();
-        createBlock("H5").setAncestor("BODY", "HGROUP").setExcludes("HGROUP", "H1", "H2", "H3", "H4", "H5", "H6").setFormatAsInline();
-        createBlock("H6").setAncestor("BODY", "HGROUP").setExcludes("HGROUP", "H1", "H2", "H3", "H4", "H5", "H6").setFormatAsInline();
-        createBlock("UL");
-        createBlock("OL");
-        createBlock("PRE").setContainInlineOnly().setPreserveWhitespace();
-        createBlock("DIV");
-        createBlock("BLOCKQUOTE");
-        createBlock("HR").setEmpty();
-        createBlock("ADDRESS").setContainInlineOnly();
-        createBlock("FIGURE");
-        createBlock("FIGCAPTION").setAncestor("FIGURE");
-
-        // formctrl
-        createBlock("FORM").setOptionalClosing(); // can't contain self
-        createInline("INPUT").setAncestor("FORM").setEmpty();
-        createInline("SELECT").setAncestor("FORM"); // just contain optgroup or option
-        createInline("TEXTAREA").setAncestor("FORM").setContainDataOnly();
-        createInline("LABEL").setAncestor("FORM").setOptionalClosing(); // not self
-        createInline("BUTTON").setAncestor("FORM"); // bunch of excludes not defined
-        createInline("OPTGROUP").setParent("SELECT"); //  only contain option
-        createInline("OPTION").setParent("SELECT", "OPTGROUP", "DATALIST").setOptionalClosing();
-        createBlock("FIELDSET").setAncestor("FORM");
-        createInline("LEGEND").setAncestor("FIELDSET");
-        
-        // html5 form ctrl, not specced to have to be in forms
-        createInline("DATALIST");
-        createInline("KEYGEN").setEmpty();
-        createInline("OUTPUT");
-        createInline("PROGRESS").setOptionalClosing();
-        createInline("METER").setOptionalClosing();
-
-        // other
-        createInline("AREA").setAncestor("MAP").setEmpty(); // not an inline per-se
-        createInline("PARAM").setParent("OBJECT").setEmpty();
-        createBlock("INS"); // only within body
-        createBlock("DEL"); // only within body
-
-        // definition lists. per spec, dt and dd are inline and must directly descend from dl. However in practise
-        // these are all used as blocks and dl need only be an ancestor
-        createBlock("DL").setOptionalClosing(); // can't nest
-        createBlock("DT").setAncestor("DL").setExcludes("DL", "DD").setOptionalClosing(); // only within DL.
-        createBlock("DD").setAncestor("DL").setExcludes("DL", "DT").setOptionalClosing(); // only within DL.
-
-        createBlock("LI").setAncestor("UL", "OL").setOptionalClosing().setFormatAsInline(); // only within OL or UL.
-
-        // tables
-        createBlock("TABLE").setOptionalClosing().setIgnoreEnd("BODY", "CAPTION", "COL", "COLGROUP", "HTML", "TBODY", "TD", "TFOO", "TH", "THEAD", "TR"); // specific list of only includes (tr, td, thead etc) not implemented
-        createBlock("CAPTION").setParent("TABLE").setExcludes("THEAD", "TFOOT", "TBODY", "COLGROUP", "COL", "TR", "TH", "TD").setOptionalClosing().setIgnoreEnd("BODY", "COL", "COLGROUP", "HTML", "TBODY", "TD", "TFOOT", "TH", "THEAD", "TR");
-        createBlock("THEAD").setParent("TABLE").setLimitChildren().setOptionalClosing().setIgnoreEnd("BODY", "CAPTION", "COL", "COLGROUP", "HTML", "TD", "TH", "TR"); // just TR
-        createBlock("TFOOT").setParent("TABLE").setLimitChildren().setOptionalClosing().setIgnoreEnd("BODY", "CAPTION", "COL", "COLGROUP", "HTML", "TD", "TH", "TR"); // just TR
-        createBlock("TBODY").setParent("TABLE").setLimitChildren().setOptionalClosing().setIgnoreEnd("BODY", "CAPTION", "COL", "COLGROUP", "HTML", "TD", "TH", "TR"); // optional / implicit open too. just TR
-        createBlock("COLGROUP").setParent("TABLE").setLimitChildren().setOptionalClosing().setIgnoreEnd("COL"); // just COL
-        createBlock("COL").setParent("COLGROUP").setEmpty();
-        createBlock("TR").setParent("TBODY", "THEAD", "TFOOT", "TABLE").setLimitChildren().setOptionalClosing().setIgnoreEnd("BODY", "CAPTION", "COL", "COLGROUP", "HTML", "TD", "TH"); // just TH, TD
-        createBlock("TH").setParent("TR").setExcludes("THEAD", "TFOOT", "TBODY", "COLGROUP", "COL", "TR", "TH", "TD").setOptionalClosing().setIgnoreEnd("BODY", "CAPTION", "COL", "COLGROUP", "HTML").setFormatAsInline();
-        createBlock("TD").setParent("TR").setExcludes("THEAD", "TFOOT", "TBODY", "COLGROUP", "COL", "TR", "TH", "TD").setOptionalClosing().setIgnoreEnd("BODY", "CAPTION", "COL", "COLGROUP", "HTML").setFormatAsInline();
-        
-        // html5 media
-        createBlock("VIDEO").setExcludes("VIDEO", "AUDIO");
-        createBlock("AUDIO").setExcludes("VIDEO", "AUDIO");
-        createInline("SOURCE").setParent("VIDEO", "AUDIO").setEmpty();
-        createInline("TRACK").setParent("VIDEO", "AUDIO").setEmpty();
-        createBlock("CANVAS");
-        
-        // html5 interactive
-        createBlock("DETAILS");
-        createInline("SUMMARY").setParent("DETAILS");
-        createInline("COMMAND").setEmpty();
-        createBlock("MENU");
-        createInline("DEVICE").setEmpty();
-    }
-
-    private static Tag createBlock(String tagName) {
-        return register(new Tag(tagName));
-    }
-
-    private static Tag createInline(String tagName) {
-        Tag inline = new Tag(tagName);
-        inline.isBlock = false;
-        inline.canContainBlock = false;
-        inline.formatAsBlock = false;
-        return register(inline);
+        for (String tagName : preserveWhitespaceTags) {
+            Tag tag = tags.get(tagName);
+            Validate.notNull(tag);
+            tag.preserveWhitespace = true;
+        }
     }
 
     private static Tag register(Tag tag) {
-        tag.setAncestor(defaultAncestor.tagName);
-        tag.setKnownTag();
         synchronized (tags) {
             tags.put(tag.tagName, tag);
         }
         return tag;
     }
-
-    private Tag setCanContainBlock() {
-        canContainBlock = true;
-        return this;
-    }
-
-    private Tag setContainInlineOnly() {
-        canContainBlock = false;
-        canContainInline = true;
-        formatAsBlock = false;
-        return this;
-    }
-
-    private Tag setFormatAsInline() {
-        formatAsBlock = false;
-        return this;
-    }
-
-    private Tag setContainDataOnly() {
-        canContainBlock = false;
-        canContainInline = false;
-        preserveWhitespace = true;
-        return this;
-    }
-
-    private Tag setEmpty() {
-        canContainBlock = false;
-        canContainInline = false;
-        empty = true;
-        return this;
-    }
-
-    private Tag setOptionalClosing() {
-        optionalClosing = true;
-        return this;
-    }
-
-    private Tag setPreserveWhitespace() {
-        preserveWhitespace = true;
-        return this;
-    }
-
-    private Tag setAncestor(String... tagNames) {
-        if (tagNames == null || tagNames.length == 0) {
-            ancestors = Collections.emptyList();
-        } else {
-            ancestors = new ArrayList<Tag>(tagNames.length);
-            for (String name : tagNames) {
-                ancestors.add(Tag.valueOf(name));
-            }
-        }
-        return this;
-    }
-    
-    private Tag setExcludes(String... tagNames) {
-        if (tagNames == null || tagNames.length == 0) {
-            excludes = Collections.emptyList();
-        } else {
-            excludes = new ArrayList<Tag>(tagNames.length);
-            for (String name : tagNames) {
-                excludes.add(Tag.valueOf(name));
-            }
-        }
-        return this;
-    }
-
-    private Tag setIgnoreEnd(String... tagNames) {
-        if (tagNames == null || tagNames.length == 0) {
-            ignoreEndTags = Collections.emptyList();
-        } else {
-            ignoreEndTags = new ArrayList<Tag>(tagNames.length);
-            for (String name : tagNames) {
-                ignoreEndTags.add(Tag.valueOf(name));
-            }
-        }
-        return this;
-    }
-
-    private Tag setParent(String... tagNames) {
-        directDescendant = true;
-        setAncestor(tagNames);
-        return this;
-    }
-    
-    private Tag setLimitChildren() {
-        limitChildren = true;
-        return this;
-    }
-    
-    Tag setSelfClosing() {
-        selfClosing = true;
-        return this;
-    }
-    
-    private Tag setKnownTag() {
-        knownTag = true;
-        return this;
-    }
 }
diff --git a/src/main/java/org/jsoup/parser/Token.java b/src/main/java/org/jsoup/parser/Token.java
new file mode 100644
index 0000000..f38a0f6
--- /dev/null
+++ b/src/main/java/org/jsoup/parser/Token.java
@@ -0,0 +1,248 @@
+package org.jsoup.parser;
+
+import org.jsoup.helper.Validate;
+import org.jsoup.nodes.Attribute;
+import org.jsoup.nodes.Attributes;
+
+/**
+ * Parse tokens for the Tokeniser.
+ */
+abstract class Token {
+    TokenType type;
+
+    private Token() {
+    }
+
+    static class Doctype extends Token {
+        final StringBuilder name = new StringBuilder();
+        final StringBuilder publicIdentifier = new StringBuilder();
+        final StringBuilder systemIdentifier = new StringBuilder();
+        boolean forceQuirks = false;
+
+        Doctype() {
+            type = TokenType.Doctype;
+        }
+
+        String getName() {
+            return name.toString();
+        }
+
+        String getPublicIdentifier() {
+            return publicIdentifier.toString();
+        }
+
+        public String getSystemIdentifier() {
+            return systemIdentifier.toString();
+        }
+
+        public boolean isForceQuirks() {
+            return forceQuirks;
+        }
+    }
+
+    static abstract class Tag extends Token {
+        protected String tagName;
+        private String pendingAttributeName;
+        private String pendingAttributeValue;
+
+        boolean selfClosing = false;
+        Attributes attributes = new Attributes(); // todo: allow nodes to not have attributes
+
+        void newAttribute() {
+            if (pendingAttributeName != null) {
+                if (pendingAttributeValue == null)
+                    pendingAttributeValue = "";
+                Attribute attribute = new Attribute(pendingAttributeName, pendingAttributeValue);
+                attributes.put(attribute);
+            }
+            pendingAttributeName = null;
+            pendingAttributeValue = null;
+        }
+
+        void finaliseTag() {
+            // finalises for emit
+            if (pendingAttributeName != null) {
+                // todo: check if attribute name exists; if so, drop and error
+                newAttribute();
+            }
+        }
+
+        String name() {
+            Validate.isFalse(tagName.isEmpty());
+            return tagName;
+        }
+
+        Tag name(String name) {
+            tagName = name;
+            return this;
+        }
+
+        boolean isSelfClosing() {
+            return selfClosing;
+        }
+
+        @SuppressWarnings({"TypeMayBeWeakened"})
+        Attributes getAttributes() {
+            return attributes;
+        }
+
+        // these appenders are rarely hit in not null state-- caused by null chars.
+        void appendTagName(String append) {
+            tagName = tagName == null ? append : tagName.concat(append);
+        }
+
+        void appendTagName(char append) {
+            appendTagName(String.valueOf(append));
+        }
+
+        void appendAttributeName(String append) {
+            pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);
+        }
+
+        void appendAttributeName(char append) {
+            appendAttributeName(String.valueOf(append));
+        }
+
+        void appendAttributeValue(String append) {
+            pendingAttributeValue = pendingAttributeValue == null ? append : pendingAttributeValue.concat(append);
+        }
+
+        void appendAttributeValue(char append) {
+            appendAttributeValue(String.valueOf(append));
+        }
+    }
+
+    static class StartTag extends Tag {
+        StartTag() {
+            super();
+            type = TokenType.StartTag;
+        }
+
+        StartTag(String name) {
+            this();
+            this.tagName = name;
+        }
+
+        StartTag(String name, Attributes attributes) {
+            this();
+            this.tagName = name;
+            this.attributes = attributes;
+        }
+
+        @Override
+        public String toString() {
+            return "<" + name() + " " + attributes.toString() + ">";
+        }
+    }
+
+    static class EndTag extends Tag{
+        EndTag() {
+            super();
+            type = TokenType.EndTag;
+        }
+
+        EndTag(String name) {
+            this();
+            this.tagName = name;
+        }
+
+        @Override
+        public String toString() {
+            return "</" + name() + " " + attributes.toString() + ">";
+        }
+    }
+
+    static class Comment extends Token {
+        final StringBuilder data = new StringBuilder();
+
+        Comment() {
+            type = TokenType.Comment;
+        }
+
+        String getData() {
+            return data.toString();
+        }
+
+        @Override
+        public String toString() {
+            return "<!--" + getData() + "-->";
+        }
+    }
+
+    static class Character extends Token {
+        private final String data;
+
+        Character(String data) {
+            type = TokenType.Character;
+            this.data = data;
+        }
+
+        String getData() {
+            return data;
+        }
+
+        @Override
+        public String toString() {
+            return getData();
+        }
+    }
+
+    static class EOF extends Token {
+        EOF() {
+            type = Token.TokenType.EOF;
+        }
+    }
+
+    boolean isDoctype() {
+        return type == TokenType.Doctype;
+    }
+
+    Doctype asDoctype() {
+        return (Doctype) this;
+    }
+
+    boolean isStartTag() {
+        return type == TokenType.StartTag;
+    }
+
+    StartTag asStartTag() {
+        return (StartTag) this;
+    }
+
+    boolean isEndTag() {
+        return type == TokenType.EndTag;
+    }
+
+    EndTag asEndTag() {
+        return (EndTag) this;
+    }
+
+    boolean isComment() {
+        return type == TokenType.Comment;
+    }
+
+    Comment asComment() {
+        return (Comment) this;
+    }
+
+    boolean isCharacter() {
+        return type == TokenType.Character;
+    }
+
+    Character asCharacter() {
+        return (Character) this;
+    }
+
+    boolean isEOF() {
+        return type == TokenType.EOF;
+    }
+
+    enum TokenType {
+        Doctype,
+        StartTag,
+        EndTag,
+        Comment,
+        Character,
+        EOF
+    }
+}
diff --git a/src/main/java/org/jsoup/parser/Tokeniser.java b/src/main/java/org/jsoup/parser/Tokeniser.java
new file mode 100644
index 0000000..c012a73
--- /dev/null
+++ b/src/main/java/org/jsoup/parser/Tokeniser.java
@@ -0,0 +1,231 @@
+package org.jsoup.parser;
+
+import org.jsoup.helper.Validate;
+import org.jsoup.nodes.Entities;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Readers the input stream into tokens.
+ */
+class Tokeniser {
+    static final char replacementChar = '\uFFFD'; // replaces null character
+
+    private CharacterReader reader; // html input
+    private boolean trackErrors = true;
+    private List<ParseError> errors = new ArrayList<ParseError>(); // errors found while tokenising
+
+    private TokeniserState state = TokeniserState.Data; // current tokenisation state
+    private Token emitPending; // the token we are about to emit on next read
+    private boolean isEmitPending = false;
+    private StringBuilder charBuffer = new StringBuilder(); // buffers characters to output as one token
+    StringBuilder dataBuffer; // buffers data looking for </script>
+
+    Token.Tag tagPending; // tag we are building up
+    Token.Doctype doctypePending; // doctype building up
+    Token.Comment commentPending; // comment building up
+    private Token.StartTag lastStartTag; // the last start tag emitted, to test appropriate end tag
+    private boolean selfClosingFlagAcknowledged = true;
+
+    Tokeniser(CharacterReader reader) {
+        this.reader = reader;
+    }
+
+    Token read() {
+        if (!selfClosingFlagAcknowledged) {
+            error("Self closing flag not acknowledged");
+            selfClosingFlagAcknowledged = true;
+        }
+
+        while (!isEmitPending)
+            state.read(this, reader);
+
+        // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:
+        if (charBuffer.length() > 0) {
+            String str = charBuffer.toString();
+            charBuffer.delete(0, charBuffer.length());
+            return new Token.Character(str);
+        } else {
+            isEmitPending = false;
+            return emitPending;
+        }
+    }
+
+    void emit(Token token) {
+        Validate.isFalse(isEmitPending, "There is an unread token pending!");
+
+        emitPending = token;
+        isEmitPending = true;
+
+        if (token.type == Token.TokenType.StartTag) {
+            Token.StartTag startTag = (Token.StartTag) token;
+            lastStartTag = startTag;
+            if (startTag.selfClosing)
+                selfClosingFlagAcknowledged = false;
+        } else if (token.type == Token.TokenType.EndTag) {
+            Token.EndTag endTag = (Token.EndTag) token;
+            if (endTag.attributes.size() > 0)
+                error("Attributes incorrectly present on end tag");
+        }
+    }
+
+    void emit(String str) {
+        // buffer strings up until last string token found, to emit only one token for a run of character refs etc.
+        // does not set isEmitPending; read checks that
+        charBuffer.append(str);
+    }
+
+    void emit(char c) {
+        charBuffer.append(c);
+    }
+
+    TokeniserState getState() {
+        return state;
+    }
+
+    void transition(TokeniserState state) {
+        this.state = state;
+    }
+
+    void advanceTransition(TokeniserState state) {
+        reader.advance();
+        this.state = state;
+    }
+
+    void acknowledgeSelfClosingFlag() {
+        selfClosingFlagAcknowledged = true;
+    }
+
+    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
+        if (reader.isEmpty())
+            return null;
+        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
+            return null;
+        if (reader.matchesAny('\t', '\n', '\f', '<', '&'))
+            return null;
+
+        reader.mark();
+        if (reader.matchConsume("#")) { // numbered
+            boolean isHexMode = reader.matchConsumeIgnoreCase("X");
+            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
+            if (numRef.length() == 0) { // didn't match anything
+                characterReferenceError();
+                reader.rewindToMark();
+                return null;
+            }
+            if (!reader.matchConsume(";"))
+                characterReferenceError(); // missing semi
+            int charval = -1;
+            try {
+                int base = isHexMode ? 16 : 10;
+                charval = Integer.valueOf(numRef, base);
+            } catch (NumberFormatException e) {
+            } // skip
+            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
+                characterReferenceError();
+                return replacementChar;
+            } else {
+                // todo: implement number replacement table
+                // todo: check for extra illegal unicode points as parse errors
+                return (char) charval;
+            }
+        } else { // named
+            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
+            String nameRef = reader.consumeLetterSequence();
+            boolean looksLegit = reader.matches(';');
+            boolean found = false;
+            while (nameRef.length() > 0 && !found) {
+                if (Entities.isNamedEntity(nameRef))
+                    found = true;
+                else {
+                    nameRef = nameRef.substring(0, nameRef.length()-1);
+                    reader.unconsume();
+                }
+            }
+            if (!found) {
+                if (looksLegit) // named with semicolon
+                    characterReferenceError();
+                reader.rewindToMark();
+                return null;
+            }
+            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {
+                // don't want that to match
+                reader.rewindToMark();
+                return null;
+            }
+            if (!reader.matchConsume(";"))
+                characterReferenceError(); // missing semi
+            return Entities.getCharacterByName(nameRef);
+        }
+    }
+
+    Token.Tag createTagPending(boolean start) {
+        tagPending = start ? new Token.StartTag() : new Token.EndTag();
+        return tagPending;
+    }
+
+    void emitTagPending() {
+        tagPending.finaliseTag();
+        emit(tagPending);
+    }
+
+    void createCommentPending() {
+        commentPending = new Token.Comment();
+    }
+
+    void emitCommentPending() {
+        emit(commentPending);
+    }
+
+    void createDoctypePending() {
+        doctypePending = new Token.Doctype();
+    }
+
+    void emitDoctypePending() {
+        emit(doctypePending);
+    }
+
+    void createTempBuffer() {
+        dataBuffer = new StringBuilder();
+    }
+
+    boolean isAppropriateEndTagToken() {
+        return tagPending.tagName.equals(lastStartTag.tagName);
+    }
+
+    boolean isTrackErrors() {
+        return trackErrors;
+    }
+
+    void setTrackErrors(boolean trackErrors) {
+        this.trackErrors = trackErrors;
+    }
+
+    void error(TokeniserState state) {
+        if (trackErrors)
+            errors.add(new ParseError("Unexpected character in input", reader.current(), state, reader.pos()));
+    }
+
+    void eofError(TokeniserState state) {
+        if (trackErrors)
+            errors.add(new ParseError("Unexpectedly reached end of file (EOF)", state, reader.pos()));
+    }
+
+    private void characterReferenceError() {
+        if (trackErrors)
+            errors.add(new ParseError("Invalid character reference", reader.pos()));
+    }
+
+    private void error(String errorMsg) {
+        if (trackErrors)
+            errors.add(new ParseError(errorMsg, reader.pos()));
+    }
+
+    boolean currentNodeInHtmlNS() {
+        // todo: implememnt namespaces correctly
+        return true;
+        // Element currentNode = currentNode();
+        // return currentNode != null && currentNode.namespace().equals("HTML");
+    }
+}
diff --git a/src/main/java/org/jsoup/parser/TokeniserState.java b/src/main/java/org/jsoup/parser/TokeniserState.java
new file mode 100644
index 0000000..a26e238
--- /dev/null
+++ b/src/main/java/org/jsoup/parser/TokeniserState.java
@@ -0,0 +1,1779 @@
+package org.jsoup.parser;
+
+/**
+ * States and transition activations for the Tokeniser.
+ */
+enum TokeniserState {
+    Data {
+        // in data state, gather characters until a character reference or tag is found
+        void read(Tokeniser t, CharacterReader r) {
+            switch (r.current()) {
+                case '&':
+                    t.advanceTransition(CharacterReferenceInData);
+                    break;
+                case '<':
+                    t.advanceTransition(TagOpen);
+                    break;
+                case nullChar:
+                    t.error(this); // NOT replacement character (oddly?)
+                    t.emit(r.consume());
+                    break;
+                case eof:
+                    t.emit(new Token.EOF());
+                    break;
+                default:
+                    String data = r.consumeToAny('&', '<', nullChar);
+                    t.emit(data);
+                    break;
+            }
+        }
+    },
+    CharacterReferenceInData {
+        // from & in data
+        void read(Tokeniser t, CharacterReader r) {
+            Character c = t.consumeCharacterReference(null, false);
+            if (c == null)
+                t.emit('&');
+            else
+                t.emit(c);
+            t.transition(Data);
+        }
+    },
+    Rcdata {
+        /// handles data in title, textarea etc
+        void read(Tokeniser t, CharacterReader r) {
+            switch (r.current()) {
+                case '&':
+                    t.advanceTransition(CharacterReferenceInRcdata);
+                    break;
+                case '<':
+                    t.advanceTransition(RcdataLessthanSign);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    r.advance();
+                    t.emit(replacementChar);
+                    break;
+                case eof:
+                    t.emit(new Token.EOF());
+                    break;
+                default:
+                    String data = r.consumeToAny('&', '<', nullChar);
+                    t.emit(data);
+                    break;
+            }
+        }
+    },
+    CharacterReferenceInRcdata {
+        void read(Tokeniser t, CharacterReader r) {
+            Character c = t.consumeCharacterReference(null, false);
+            if (c == null)
+                t.emit('&');
+            else
+                t.emit(c);
+            t.transition(Rcdata);
+        }
+    },
+    Rawtext {
+        void read(Tokeniser t, CharacterReader r) {
+            switch (r.current()) {
+                case '<':
+                    t.advanceTransition(RawtextLessthanSign);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    r.advance();
+                    t.emit(replacementChar);
+                    break;
+                case eof:
+                    t.emit(new Token.EOF());
+                    break;
+                default:
+                    String data = r.consumeToAny('<', nullChar);
+                    t.emit(data);
+                    break;
+            }
+        }
+    },
+    ScriptData {
+        void read(Tokeniser t, CharacterReader r) {
+            switch (r.current()) {
+                case '<':
+                    t.advanceTransition(ScriptDataLessthanSign);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    r.advance();
+                    t.emit(replacementChar);
+                    break;
+                case eof:
+                    t.emit(new Token.EOF());
+                    break;
+                default:
+                    String data = r.consumeToAny('<', nullChar);
+                    t.emit(data);
+                    break;
+            }
+        }
+    },
+    PLAINTEXT {
+        void read(Tokeniser t, CharacterReader r) {
+            switch (r.current()) {
+                case nullChar:
+                    t.error(this);
+                    r.advance();
+                    t.emit(replacementChar);
+                    break;
+                case eof:
+                    t.emit(new Token.EOF());
+                    break;
+                default:
+                    String data = r.consumeTo(nullChar);
+                    t.emit(data);
+                    break;
+            }
+        }
+    },
+    TagOpen {
+        // from < in data
+        void read(Tokeniser t, CharacterReader r) {
+            switch (r.current()) {
+                case '!':
+                    t.advanceTransition(MarkupDeclarationOpen);
+                    break;
+                case '/':
+                    t.advanceTransition(EndTagOpen);
+                    break;
+                case '?':
+                    t.advanceTransition(BogusComment);
+                    break;
+                default:
+                    if (r.matchesLetter()) {
+                        t.createTagPending(true);
+                        t.transition(TagName);
+                    } else {
+                        t.error(this);
+                        t.emit('<'); // char that got us here
+                        t.transition(Data);
+                    }
+                    break;
+            }
+        }
+    },
+    EndTagOpen {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.isEmpty()) {
+                t.eofError(this);
+                t.emit("</");
+                t.transition(Data);
+            } else if (r.matchesLetter()) {
+                t.createTagPending(false);
+                t.transition(TagName);
+            } else if (r.matches('>')) {
+                t.error(this);
+                t.advanceTransition(Data);
+            } else {
+                t.error(this);
+                t.advanceTransition(BogusComment);
+            }
+        }
+    },
+    TagName {
+        // from < or </ in data, will have start or end tag pending
+        void read(Tokeniser t, CharacterReader r) {
+            // previous TagOpen state did NOT consume, will have a letter char in current
+            String tagName = r.consumeToAny('\t', '\n', '\f', ' ', '/', '>', nullChar).toLowerCase();
+            t.tagPending.appendTagName(tagName);
+
+            switch (r.consume()) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    t.transition(BeforeAttributeName);
+                    break;
+                case '/':
+                    t.transition(SelfClosingStartTag);
+                    break;
+                case '>':
+                    t.emitTagPending();
+                    t.transition(Data);
+                    break;
+                case nullChar: // replacement
+                    t.tagPending.appendTagName(replacementStr);
+                    break;
+                case eof: // should emit pending tag?
+                    t.eofError(this);
+                    t.transition(Data);
+                // no default, as covered with above consumeToAny
+            }
+        }
+    },
+    RcdataLessthanSign {
+        // from < in rcdata
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matches('/')) {
+                t.createTempBuffer();
+                t.advanceTransition(RCDATAEndTagOpen);
+            } else {
+                t.emit("<");
+                t.transition(Rcdata);
+            }
+        }
+    },
+    RCDATAEndTagOpen {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matchesLetter()) {
+                t.createTagPending(false);
+                t.tagPending.appendTagName(Character.toLowerCase(r.current()));
+                t.dataBuffer.append(Character.toLowerCase(r.current()));
+                t.advanceTransition(RCDATAEndTagName);
+            } else {
+                t.emit("</");
+                t.transition(Rcdata);
+            }
+        }
+    },
+    RCDATAEndTagName {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matchesLetter()) {
+                String name = r.consumeLetterSequence();
+                t.tagPending.appendTagName(name.toLowerCase());
+                t.dataBuffer.append(name);
+                return;
+            }
+
+            char c = r.consume();
+            boolean handled = true;
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    if (t.isAppropriateEndTagToken())
+                        t.transition(BeforeAttributeName);
+                    else
+                        handled = false;
+                    break;
+                case '/':
+                    if (t.isAppropriateEndTagToken())
+                        t.transition(SelfClosingStartTag);
+                    else
+                        handled = false;
+                    break;
+                case '>':
+                    if (t.isAppropriateEndTagToken()) {
+                        t.emitTagPending();
+                        t.transition(Data);
+                    }
+                    else
+                        handled = false;
+                    break;
+            }
+            if (!handled) {
+                t.emit("</" + t.dataBuffer.toString());
+                r.unconsume();
+                t.transition(Rcdata);
+            }
+        }
+    },
+    RawtextLessthanSign {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matches('/')) {
+                t.createTempBuffer();
+                t.advanceTransition(RawtextEndTagOpen);
+            } else {
+                t.emit('<');
+                t.transition(Rawtext);
+            }
+        }
+    },
+    RawtextEndTagOpen {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matchesLetter()) {
+                t.createTagPending(false);
+                t.transition(RawtextEndTagName);
+            } else {
+                t.emit("</");
+                t.transition(Rawtext);
+            }
+        }
+    },
+    RawtextEndTagName {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matchesLetter()) {
+                String name = r.consumeLetterSequence();
+                t.tagPending.appendTagName(name.toLowerCase());
+                t.dataBuffer.append(name);
+                return;
+            }
+
+            char c = r.consume();
+            boolean handled = true;
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    if (t.isAppropriateEndTagToken())
+                        t.transition(BeforeAttributeName);
+                    else
+                        handled = false;
+                    break;
+                case '/':
+                    if (t.isAppropriateEndTagToken())
+                        t.transition(SelfClosingStartTag);
+                    else
+                        handled = false;
+                    break;
+                case '>':
+                    if (t.isAppropriateEndTagToken()) {
+                        t.emitTagPending();
+                        t.transition(Data);
+                    }
+                    else
+                        handled = false;
+                    break;
+            }
+            if (!handled) {
+                t.emit("</" + t.dataBuffer.toString());
+                r.unconsume();
+                t.transition(Rawtext);
+            }
+        }
+    },
+    ScriptDataLessthanSign {
+        void read(Tokeniser t, CharacterReader r) {
+            switch (r.consume()) {
+                case '/':
+                    t.createTempBuffer();
+                    t.transition(ScriptDataEndTagOpen);
+                    break;
+                case '!':
+                    t.emit("<!");
+                    t.transition(ScriptDataEscapeStart);
+                    break;
+                default:
+                    t.emit("<");
+                    r.unconsume();
+                    t.transition(ScriptData);
+            }
+        }
+    },
+    ScriptDataEndTagOpen {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matchesLetter()) {
+                t.createTagPending(false);
+                t.transition(ScriptDataEndTagName);
+            } else {
+                t.emit("</");
+                t.transition(ScriptData);
+            }
+
+        }
+    },
+    ScriptDataEndTagName {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matchesLetter()) {
+                String name = r.consumeLetterSequence();
+                t.tagPending.appendTagName(name.toLowerCase());
+                t.dataBuffer.append(name);
+                return;
+            }
+
+            char c = r.consume();
+            boolean handled = true;
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    if (t.isAppropriateEndTagToken())
+                        t.transition(BeforeAttributeName);
+                    else
+                        handled = false;
+                    break;
+                case '/':
+                    if (t.isAppropriateEndTagToken())
+                        t.transition(SelfClosingStartTag);
+                    else
+                        handled = false;
+                    break;
+                case '>':
+                    if (t.isAppropriateEndTagToken()) {
+                        t.emitTagPending();
+                        t.transition(Data);
+                    }
+                    else
+                        handled = false;
+                    break;
+            }
+            if (!handled) {
+                t.emit("</" + t.dataBuffer.toString());
+                r.unconsume();
+                t.transition(ScriptData);
+            }
+        }
+    },
+    ScriptDataEscapeStart {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matches('-')) {
+                t.emit('-');
+                t.advanceTransition(ScriptDataEscapeStartDash);
+            } else {
+                t.transition(ScriptData);
+            }
+        }
+    },
+    ScriptDataEscapeStartDash {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matches('-')) {
+                t.emit('-');
+                t.advanceTransition(ScriptDataEscapedDashDash);
+            } else {
+                t.transition(ScriptData);
+            }
+        }
+    },
+    ScriptDataEscaped {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.isEmpty()) {
+                t.eofError(this);
+                t.transition(Data);
+                return;
+            }
+
+            switch (r.current()) {
+                case '-':
+                    t.emit('-');
+                    t.advanceTransition(ScriptDataEscapedDash);
+                    break;
+                case '<':
+                    t.advanceTransition(ScriptDataEscapedLessthanSign);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    r.advance();
+                    t.emit(replacementChar);
+                    break;
+                default:
+                    String data = r.consumeToAny('-', '<', nullChar);
+                    t.emit(data);
+            }
+        }
+    },
+    ScriptDataEscapedDash {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.isEmpty()) {
+                t.eofError(this);
+                t.transition(Data);
+                return;
+            }
+
+            char c = r.consume();
+            switch (c) {
+                case '-':
+                    t.emit(c);
+                    t.transition(ScriptDataEscapedDashDash);
+                    break;
+                case '<':
+                    t.transition(ScriptDataEscapedLessthanSign);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.emit(replacementChar);
+                    t.transition(ScriptDataEscaped);
+                    break;
+                default:
+                    t.emit(c);
+                    t.transition(ScriptDataEscaped);
+            }
+        }
+    },
+    ScriptDataEscapedDashDash {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.isEmpty()) {
+                t.eofError(this);
+                t.transition(Data);
+                return;
+            }
+
+            char c = r.consume();
+            switch (c) {
+                case '-':
+                    t.emit(c);
+                    break;
+                case '<':
+                    t.transition(ScriptDataEscapedLessthanSign);
+                    break;
+                case '>':
+                    t.emit(c);
+                    t.transition(ScriptData);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.emit(replacementChar);
+                    t.transition(ScriptDataEscaped);
+                    break;
+                default:
+                    t.emit(c);
+                    t.transition(ScriptDataEscaped);
+            }
+        }
+    },
+    ScriptDataEscapedLessthanSign {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matchesLetter()) {
+                t.createTempBuffer();
+                t.dataBuffer.append(Character.toLowerCase(r.current()));
+                t.emit("<" + r.current());
+                t.advanceTransition(ScriptDataDoubleEscapeStart);
+            } else if (r.matches('/')) {
+                t.createTempBuffer();
+                t.advanceTransition(ScriptDataEscapedEndTagOpen);
+            } else {
+                t.emit('<');
+                t.transition(ScriptDataEscaped);
+            }
+        }
+    },
+    ScriptDataEscapedEndTagOpen {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matchesLetter()) {
+                t.createTagPending(false);
+                t.tagPending.appendTagName(Character.toLowerCase(r.current()));
+                t.dataBuffer.append(r.current());
+                t.advanceTransition(ScriptDataEscapedEndTagName);
+            } else {
+                t.emit("</");
+                t.transition(ScriptDataEscaped);
+            }
+        }
+    },
+    ScriptDataEscapedEndTagName {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matchesLetter()) {
+                String name = r.consumeLetterSequence();
+                t.tagPending.appendTagName(name.toLowerCase());
+                t.dataBuffer.append(name);
+                r.advance();
+                return;
+            }
+
+            char c = r.consume();
+            boolean handled = true;
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    if (t.isAppropriateEndTagToken())
+                        t.transition(BeforeAttributeName);
+                    else
+                        handled = false;
+                    break;
+                case '/':
+                    if (t.isAppropriateEndTagToken())
+                        t.transition(SelfClosingStartTag);
+                    else
+                        handled = false;
+                    break;
+                case '>':
+                    if (t.isAppropriateEndTagToken()) {
+                        t.emitTagPending();
+                        t.transition(Data);
+                    }
+                    else
+                        handled = false;
+                    break;
+            }
+            if (!handled) {
+                t.emit("</" + t.dataBuffer.toString());
+                r.unconsume();
+                t.transition(ScriptDataEscaped);
+            }
+        }
+    },
+    ScriptDataDoubleEscapeStart {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matchesLetter()) {
+                String name = r.consumeLetterSequence();
+                t.dataBuffer.append(name.toLowerCase());
+                t.emit(name);
+                return;
+            }
+
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                case '/':
+                case '>':
+                    if (t.dataBuffer.toString().equals("script"))
+                        t.transition(ScriptDataDoubleEscaped);
+                    else
+                        t.transition(ScriptDataEscaped);
+                    t.emit(c);
+                    break;
+                default:
+                    r.unconsume();
+                    t.transition(ScriptDataEscaped);
+            }
+        }
+    },
+    ScriptDataDoubleEscaped {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.current();
+            switch (c) {
+                case '-':
+                    t.emit(c);
+                    t.advanceTransition(ScriptDataDoubleEscapedDash);
+                    break;
+                case '<':
+                    t.emit(c);
+                    t.advanceTransition(ScriptDataDoubleEscapedLessthanSign);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    r.advance();
+                    t.emit(replacementChar);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.transition(Data);
+                    break;
+                default:
+                    String data = r.consumeToAny('-', '<', nullChar);
+                    t.emit(data);
+            }
+        }
+    },
+    ScriptDataDoubleEscapedDash {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '-':
+                    t.emit(c);
+                    t.transition(ScriptDataDoubleEscapedDashDash);
+                    break;
+                case '<':
+                    t.emit(c);
+                    t.transition(ScriptDataDoubleEscapedLessthanSign);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.emit(replacementChar);
+                    t.transition(ScriptDataDoubleEscaped);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.transition(Data);
+                    break;
+                default:
+                    t.emit(c);
+                    t.transition(ScriptDataDoubleEscaped);
+            }
+        }
+    },
+    ScriptDataDoubleEscapedDashDash {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '-':
+                    t.emit(c);
+                    break;
+                case '<':
+                    t.emit(c);
+                    t.transition(ScriptDataDoubleEscapedLessthanSign);
+                    break;
+                case '>':
+                    t.emit(c);
+                    t.transition(ScriptData);
+                case nullChar:
+                    t.error(this);
+                    t.emit(replacementChar);
+                    t.transition(ScriptDataDoubleEscaped);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.transition(Data);
+                    break;
+                default:
+                    t.emit(c);
+                    t.transition(ScriptDataDoubleEscaped);
+            }
+        }
+    },
+    ScriptDataDoubleEscapedLessthanSign {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matches('/')) {
+                t.emit('/');
+                t.createTempBuffer();
+                t.advanceTransition(ScriptDataDoubleEscapeEnd);
+            } else {
+                t.transition(ScriptDataDoubleEscaped);
+            }
+        }
+    },
+    ScriptDataDoubleEscapeEnd {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matchesLetter()) {
+                String name = r.consumeLetterSequence();
+                t.dataBuffer.append(name.toLowerCase());
+                t.emit(name);
+                return;
+            }
+
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                case '/':
+                case '>':
+                    if (t.dataBuffer.toString().equals("script"))
+                        t.transition(ScriptDataEscaped);
+                    else
+                        t.transition(ScriptDataDoubleEscaped);
+                    t.emit(c);
+                    break;
+                default:
+                    r.unconsume();
+                    t.transition(ScriptDataDoubleEscaped);
+            }
+        }
+    },
+    BeforeAttributeName {
+        // from tagname <xxx
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    break; // ignore whitespace
+                case '/':
+                    t.transition(SelfClosingStartTag);
+                    break;
+                case '>':
+                    t.emitTagPending();
+                    t.transition(Data);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.tagPending.newAttribute();
+                    r.unconsume();
+                    t.transition(AttributeName);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.transition(Data);
+                    break;
+                case '"':
+                case '\'':
+                case '<':
+                case '=':
+                    t.error(this);
+                    t.tagPending.newAttribute();
+                    t.tagPending.appendAttributeName(c);
+                    t.transition(AttributeName);
+                    break;
+                default: // A-Z, anything else
+                    t.tagPending.newAttribute();
+                    r.unconsume();
+                    t.transition(AttributeName);
+            }
+        }
+    },
+    AttributeName {
+        // from before attribute name
+        void read(Tokeniser t, CharacterReader r) {
+            String name = r.consumeToAny('\t', '\n', '\f', ' ', '/', '=', '>', nullChar, '"', '\'', '<');
+            t.tagPending.appendAttributeName(name.toLowerCase());
+
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    t.transition(AfterAttributeName);
+                    break;
+                case '/':
+                    t.transition(SelfClosingStartTag);
+                    break;
+                case '=':
+                    t.transition(BeforeAttributeValue);
+                    break;
+                case '>':
+                    t.emitTagPending();
+                    t.transition(Data);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.tagPending.appendAttributeName(replacementChar);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.transition(Data);
+                    break;
+                case '"':
+                case '\'':
+                case '<':
+                    t.error(this);
+                    t.tagPending.appendAttributeName(c);
+                // no default, as covered in consumeToAny
+            }
+        }
+    },
+    AfterAttributeName {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    // ignore
+                    break;
+                case '/':
+                    t.transition(SelfClosingStartTag);
+                    break;
+                case '=':
+                    t.transition(BeforeAttributeValue);
+                    break;
+                case '>':
+                    t.emitTagPending();
+                    t.transition(Data);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.tagPending.appendAttributeName(replacementChar);
+                    t.transition(AttributeName);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.transition(Data);
+                    break;
+                case '"':
+                case '\'':
+                case '<':
+                    t.error(this);
+                    t.tagPending.newAttribute();
+                    t.tagPending.appendAttributeName(c);
+                    t.transition(AttributeName);
+                    break;
+                default: // A-Z, anything else
+                    t.tagPending.newAttribute();
+                    r.unconsume();
+                    t.transition(AttributeName);
+            }
+        }
+    },
+    BeforeAttributeValue {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    // ignore
+                    break;
+                case '"':
+                    t.transition(AttributeValue_doubleQuoted);
+                    break;
+                case '&':
+                    r.unconsume();
+                    t.transition(AttributeValue_unquoted);
+                    break;
+                case '\'':
+                    t.transition(AttributeValue_singleQuoted);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.tagPending.appendAttributeValue(replacementChar);
+                    t.transition(AttributeValue_unquoted);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.transition(Data);
+                    break;
+                case '>':
+                    t.error(this);
+                    t.emitTagPending();
+                    t.transition(Data);
+                    break;
+                case '<':
+                case '=':
+                case '`':
+                    t.error(this);
+                    t.tagPending.appendAttributeValue(c);
+                    t.transition(AttributeValue_unquoted);
+                    break;
+                default:
+                    r.unconsume();
+                    t.transition(AttributeValue_unquoted);
+            }
+        }
+    },
+    AttributeValue_doubleQuoted {
+        void read(Tokeniser t, CharacterReader r) {
+            String value = r.consumeToAny('"', '&', nullChar);
+            if (value.length() > 0)
+                t.tagPending.appendAttributeValue(value);
+
+            char c = r.consume();
+            switch (c) {
+                case '"':
+                    t.transition(AfterAttributeValue_quoted);
+                    break;
+                case '&':
+                    Character ref = t.consumeCharacterReference('"', true);
+                    if (ref != null)
+                        t.tagPending.appendAttributeValue(ref);
+                    else
+                        t.tagPending.appendAttributeValue('&');
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.tagPending.appendAttributeValue(replacementChar);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.transition(Data);
+                    break;
+                // no default, handled in consume to any above
+            }
+        }
+    },
+    AttributeValue_singleQuoted {
+        void read(Tokeniser t, CharacterReader r) {
+            String value = r.consumeToAny('\'', '&', nullChar);
+            if (value.length() > 0)
+                t.tagPending.appendAttributeValue(value);
+
+            char c = r.consume();
+            switch (c) {
+                case '\'':
+                    t.transition(AfterAttributeValue_quoted);
+                    break;
+                case '&':
+                    Character ref = t.consumeCharacterReference('\'', true);
+                    if (ref != null)
+                        t.tagPending.appendAttributeValue(ref);
+                    else
+                        t.tagPending.appendAttributeValue('&');
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.tagPending.appendAttributeValue(replacementChar);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.transition(Data);
+                    break;
+                // no default, handled in consume to any above
+            }
+        }
+    },
+    AttributeValue_unquoted {
+        void read(Tokeniser t, CharacterReader r) {
+            String value = r.consumeToAny('\t', '\n', '\f', ' ', '&', '>', nullChar, '"', '\'', '<', '=', '`');
+            if (value.length() > 0)
+                t.tagPending.appendAttributeValue(value);
+
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    t.transition(BeforeAttributeName);
+                    break;
+                case '&':
+                    Character ref = t.consumeCharacterReference('>', true);
+                    if (ref != null)
+                        t.tagPending.appendAttributeValue(ref);
+                    else
+                        t.tagPending.appendAttributeValue('&');
+                    break;
+                case '>':
+                    t.emitTagPending();
+                    t.transition(Data);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.tagPending.appendAttributeValue(replacementChar);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.transition(Data);
+                    break;
+                case '"':
+                case '\'':
+                case '<':
+                case '=':
+                case '`':
+                    t.error(this);
+                    t.tagPending.appendAttributeValue(c);
+                    break;
+                // no default, handled in consume to any above
+            }
+
+        }
+    },
+    // CharacterReferenceInAttributeValue state handled inline
+    AfterAttributeValue_quoted {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    t.transition(BeforeAttributeName);
+                    break;
+                case '/':
+                    t.transition(SelfClosingStartTag);
+                    break;
+                case '>':
+                    t.emitTagPending();
+                    t.transition(Data);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.transition(Data);
+                    break;
+                default:
+                    t.error(this);
+                    r.unconsume();
+                    t.transition(BeforeAttributeName);
+            }
+
+        }
+    },
+    SelfClosingStartTag {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '>':
+                    t.tagPending.selfClosing = true;
+                    t.emitTagPending();
+                    t.transition(Data);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.transition(Data);
+                    break;
+                default:
+                    t.error(this);
+                    t.transition(BeforeAttributeName);
+            }
+        }
+    },
+    BogusComment {
+        void read(Tokeniser t, CharacterReader r) {
+            // todo: handle bogus comment starting from eof. when does that trigger?
+            // rewind to capture character that lead us here
+            r.unconsume();
+            Token.Comment comment = new Token.Comment();
+            comment.data.append(r.consumeTo('>'));
+            // todo: replace nullChar with replaceChar
+            t.emit(comment);
+            t.advanceTransition(Data);
+        }
+    },
+    MarkupDeclarationOpen {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matchConsume("--")) {
+                t.createCommentPending();
+                t.transition(CommentStart);
+            } else if (r.matchConsumeIgnoreCase("DOCTYPE")) {
+                t.transition(Doctype);
+            } else if (r.matchConsume("[CDATA[")) {
+                // todo: should actually check current namepspace, and only non-html allows cdata. until namespace
+                // is implemented properly, keep handling as cdata
+                //} else if (!t.currentNodeInHtmlNS() && r.matchConsume("[CDATA[")) {
+                t.transition(CdataSection);
+            } else {
+                t.error(this);
+                t.advanceTransition(BogusComment); // advance so this character gets in bogus comment data's rewind
+            }
+        }
+    },
+    CommentStart {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '-':
+                    t.transition(CommentStartDash);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.commentPending.data.append(replacementChar);
+                    t.transition(Comment);
+                    break;
+                case '>':
+                    t.error(this);
+                    t.emitCommentPending();
+                    t.transition(Data);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.emitCommentPending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.commentPending.data.append(c);
+                    t.transition(Comment);
+            }
+        }
+    },
+    CommentStartDash {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '-':
+                    t.transition(CommentStartDash);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.commentPending.data.append(replacementChar);
+                    t.transition(Comment);
+                    break;
+                case '>':
+                    t.error(this);
+                    t.emitCommentPending();
+                    t.transition(Data);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.emitCommentPending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.commentPending.data.append(c);
+                    t.transition(Comment);
+            }
+        }
+    },
+    Comment {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.current();
+            switch (c) {
+                case '-':
+                    t.advanceTransition(CommentEndDash);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.commentPending.data.append(replacementChar);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.emitCommentPending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.commentPending.data.append(r.consumeToAny('-', nullChar));
+            }
+        }
+    },
+    CommentEndDash {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '-':
+                    t.transition(CommentEnd);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.commentPending.data.append('-').append(replacementChar);
+                    t.transition(Comment);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.emitCommentPending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.commentPending.data.append('-').append(c);
+                    t.transition(Comment);
+            }
+        }
+    },
+    CommentEnd {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '>':
+                    t.emitCommentPending();
+                    t.transition(Data);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.commentPending.data.append("--").append(replacementChar);
+                    t.transition(Comment);
+                    break;
+                case '!':
+                    t.error(this);
+                    t.transition(CommentEndBang);
+                    break;
+                case '-':
+                    t.error(this);
+                    t.commentPending.data.append('-');
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.emitCommentPending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.error(this);
+                    t.commentPending.data.append("--").append(c);
+                    t.transition(Comment);
+            }
+        }
+    },
+    CommentEndBang {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '-':
+                    t.commentPending.data.append("--!");
+                    t.transition(CommentEndDash);
+                    break;
+                case '>':
+                    t.emitCommentPending();
+                    t.transition(Data);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.commentPending.data.append("--!").append(replacementChar);
+                    t.transition(Comment);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.emitCommentPending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.commentPending.data.append("--!").append(c);
+                    t.transition(Comment);
+            }
+        }
+    },
+    Doctype {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    t.transition(BeforeDoctypeName);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.createDoctypePending();
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.error(this);
+                    t.transition(BeforeDoctypeName);
+            }
+        }
+    },
+    BeforeDoctypeName {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matchesLetter()) {
+                t.createDoctypePending();
+                t.transition(DoctypeName);
+                return;
+            }
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    break; // ignore whitespace
+                case nullChar:
+                    t.error(this);
+                    t.doctypePending.name.append(replacementChar);
+                    t.transition(DoctypeName);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.createDoctypePending();
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.createDoctypePending();
+                    t.doctypePending.name.append(c);
+                    t.transition(DoctypeName);
+            }
+        }
+    },
+    DoctypeName {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.matchesLetter()) {
+                String name = r.consumeLetterSequence();
+                t.doctypePending.name.append(name.toLowerCase());
+                return;
+            }
+            char c = r.consume();
+            switch (c) {
+                case '>':
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    t.transition(AfterDoctypeName);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.doctypePending.name.append(replacementChar);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.doctypePending.name.append(c);
+            }
+        }
+    },
+    AfterDoctypeName {
+        void read(Tokeniser t, CharacterReader r) {
+            if (r.isEmpty()) {
+                t.eofError(this);
+                t.doctypePending.forceQuirks = true;
+                t.emitDoctypePending();
+                t.transition(Data);
+                return;
+            }
+            if (r.matches('>')) {
+                t.emitDoctypePending();
+                t.advanceTransition(Data);
+            } else if (r.matchConsumeIgnoreCase("PUBLIC")) {
+                t.transition(AfterDoctypePublicKeyword);
+            } else if (r.matchConsumeIgnoreCase("SYSTEM")) {
+                t.transition(AfterDoctypeSystemKeyword);
+            } else {
+                t.error(this);
+                t.doctypePending.forceQuirks = true;
+                t.advanceTransition(BogusDoctype);
+            }
+
+        }
+    },
+    AfterDoctypePublicKeyword {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    t.transition(BeforeDoctypePublicIdentifier);
+                    break;
+                case '"':
+                    t.error(this);
+                    // set public id to empty string
+                    t.transition(DoctypePublicIdentifier_doubleQuoted);
+                    break;
+                case '\'':
+                    t.error(this);
+                    // set public id to empty string
+                    t.transition(DoctypePublicIdentifier_singleQuoted);
+                    break;
+                case '>':
+                    t.error(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.error(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.transition(BogusDoctype);
+            }
+        }
+    },
+    BeforeDoctypePublicIdentifier {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    break;
+                case '"':
+                    // set public id to empty string
+                    t.transition(DoctypePublicIdentifier_doubleQuoted);
+                    break;
+                case '\'':
+                    // set public id to empty string
+                    t.transition(DoctypePublicIdentifier_singleQuoted);
+                    break;
+                case '>':
+                    t.error(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.error(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.transition(BogusDoctype);
+            }
+        }
+    },
+    DoctypePublicIdentifier_doubleQuoted {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '"':
+                    t.transition(AfterDoctypePublicIdentifier);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.doctypePending.publicIdentifier.append(replacementChar);
+                    break;
+                case '>':
+                    t.error(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.doctypePending.publicIdentifier.append(c);
+            }
+        }
+    },
+    DoctypePublicIdentifier_singleQuoted {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '\'':
+                    t.transition(AfterDoctypePublicIdentifier);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.doctypePending.publicIdentifier.append(replacementChar);
+                    break;
+                case '>':
+                    t.error(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.doctypePending.publicIdentifier.append(c);
+            }
+        }
+    },
+    AfterDoctypePublicIdentifier {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    t.transition(BetweenDoctypePublicAndSystemIdentifiers);
+                    break;
+                case '>':
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                case '"':
+                    t.error(this);
+                    // system id empty
+                    t.transition(DoctypeSystemIdentifier_doubleQuoted);
+                    break;
+                case '\'':
+                    t.error(this);
+                    // system id empty
+                    t.transition(DoctypeSystemIdentifier_singleQuoted);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.error(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.transition(BogusDoctype);
+            }
+        }
+    },
+    BetweenDoctypePublicAndSystemIdentifiers {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    break;
+                case '>':
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                case '"':
+                    t.error(this);
+                    // system id empty
+                    t.transition(DoctypeSystemIdentifier_doubleQuoted);
+                    break;
+                case '\'':
+                    t.error(this);
+                    // system id empty
+                    t.transition(DoctypeSystemIdentifier_singleQuoted);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.error(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.transition(BogusDoctype);
+            }
+        }
+    },
+    AfterDoctypeSystemKeyword {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    t.transition(BeforeDoctypeSystemIdentifier);
+                    break;
+                case '>':
+                    t.error(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                case '"':
+                    t.error(this);
+                    // system id empty
+                    t.transition(DoctypeSystemIdentifier_doubleQuoted);
+                    break;
+                case '\'':
+                    t.error(this);
+                    // system id empty
+                    t.transition(DoctypeSystemIdentifier_singleQuoted);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.error(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+            }
+        }
+    },
+    BeforeDoctypeSystemIdentifier {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    break;
+                case '"':
+                    // set system id to empty string
+                    t.transition(DoctypeSystemIdentifier_doubleQuoted);
+                    break;
+                case '\'':
+                    // set public id to empty string
+                    t.transition(DoctypeSystemIdentifier_singleQuoted);
+                    break;
+                case '>':
+                    t.error(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.error(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.transition(BogusDoctype);
+            }
+        }
+    },
+    DoctypeSystemIdentifier_doubleQuoted {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '"':
+                    t.transition(AfterDoctypeSystemIdentifier);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.doctypePending.systemIdentifier.append(replacementChar);
+                    break;
+                case '>':
+                    t.error(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.doctypePending.systemIdentifier.append(c);
+            }
+        }
+    },
+    DoctypeSystemIdentifier_singleQuoted {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '\'':
+                    t.transition(AfterDoctypeSystemIdentifier);
+                    break;
+                case nullChar:
+                    t.error(this);
+                    t.doctypePending.systemIdentifier.append(replacementChar);
+                    break;
+                case '>':
+                    t.error(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.doctypePending.systemIdentifier.append(c);
+            }
+        }
+    },
+    AfterDoctypeSystemIdentifier {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '\t':
+                case '\n':
+                case '\f':
+                case ' ':
+                    break;
+                case '>':
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                case eof:
+                    t.eofError(this);
+                    t.doctypePending.forceQuirks = true;
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                default:
+                    t.error(this);
+                    t.transition(BogusDoctype);
+                    // NOT force quirks
+            }
+        }
+    },
+    BogusDoctype {
+        void read(Tokeniser t, CharacterReader r) {
+            char c = r.consume();
+            switch (c) {
+                case '>':
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                case eof:
+                    t.emitDoctypePending();
+                    t.transition(Data);
+                    break;
+                default:
+                    // ignore char
+                    break;
+            }
+        }
+    },
+    CdataSection {
+        void read(Tokeniser t, CharacterReader r) {
+            String data = r.consumeTo("]]>");
+            t.emit(data);
+            r.matchConsume("]]>");
+            t.transition(Data);
+        }
+    };
+
+
+    abstract void read(Tokeniser t, CharacterReader r);
+
+    private static final char nullChar = '\u0000';
+    private static final char replacementChar = Tokeniser.replacementChar;
+    private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);
+    private static final char eof = CharacterReader.EOF;
+}
diff --git a/src/main/java/org/jsoup/parser/TreeBuilder.java b/src/main/java/org/jsoup/parser/TreeBuilder.java
new file mode 100644
index 0000000..941d596
--- /dev/null
+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java
@@ -0,0 +1,695 @@
+package org.jsoup.parser;
+
+import org.jsoup.helper.StringUtil;
+import org.jsoup.helper.Validate;
+import org.jsoup.nodes.*;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * HTML Tree Builder; creates a DOM from Tokens.
+ */
+class TreeBuilder {
+    CharacterReader reader;
+    Tokeniser tokeniser;
+
+    private TreeBuilderState state; // the current state
+    private TreeBuilderState originalState; // original / marked state
+    private Document doc; // current doc we are building into
+    private LinkedList<Element> stack; // the stack of open elements
+
+    private String baseUri; // current base uri, for creating new elements
+    private Token currentToken; // currentToken is used only for error tracking.
+    private Element headElement; // the current head element
+    private Element formElement; // the current form element
+    private Element contextElement; // fragment parse context -- could be null even if fragment parsing
+    private LinkedList<Element> formattingElements = new LinkedList<Element>(); // active (open) formatting elements
+    private List<Token.Character> pendingTableCharacters = new ArrayList<Token.Character>(); // chars in table to be shifted out
+
+    private boolean framesetOk = true; // if ok to go into frameset
+    private boolean fosterInserts = false; // if next inserts should be fostered
+    private boolean fragmentParsing = false; // if parsing a fragment of html
+
+    private boolean trackErrors = false;
+    private List<ParseError> errors = new ArrayList<ParseError>();
+
+    TreeBuilder() {}
+
+    private void initialiseParse(String input, String baseUri) {
+        doc = new Document(baseUri);
+        reader = new CharacterReader(input);
+        tokeniser = new Tokeniser(reader);
+        stack = new LinkedList<Element>();
+        this.baseUri = baseUri;
+    }
+
+    Document parse(String input, String baseUri) {
+        state = TreeBuilderState.Initial;
+        initialiseParse(input, baseUri);
+        runParser();
+        return doc;
+    }
+
+    List<Node> parseFragment(String inputFragment, Element context, String baseUri) {
+        // context may be null
+        initialiseParse(inputFragment, baseUri);
+        contextElement = context;
+        fragmentParsing = true;
+        Element root = null;
+
+        if (context != null) {
+            if (context.ownerDocument() != null) // quirks setup:
+                doc.quirksMode(context.ownerDocument().quirksMode());
+
+            // initialise the tokeniser state:
+            String contextTag = context.tagName();
+            if (StringUtil.in(contextTag, "title", "textarea"))
+                tokeniser.transition(TokeniserState.Rcdata);
+            else if (StringUtil.in(contextTag, "iframe", "noembed", "noframes", "style", "xmp"))
+                tokeniser.transition(TokeniserState.Rawtext);
+            else if (contextTag.equals("script"))
+                tokeniser.transition(TokeniserState.ScriptData);
+            else if (contextTag.equals(("noscript")))
+                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext
+            else if (contextTag.equals("plaintext"))
+                tokeniser.transition(TokeniserState.Data);
+            else
+                tokeniser.transition(TokeniserState.Data); // default
+
+            root = new Element(Tag.valueOf("html"), baseUri);
+            doc.appendChild(root);
+            stack.push(root);
+            resetInsertionMode();
+            // todo: setup form element to nearest form on context (up ancestor chain)
+        }
+
+        runParser();
+        if (context != null)
+            return root.childNodes();
+        else
+            return doc.childNodes();
+    }
+
+    private void runParser() {
+        while (true) {
+            // todo: handle foreign content checks
+
+            Token token = tokeniser.read();
+            process(token);
+
+            if (token.type == Token.TokenType.EOF)
+                break;
+        }
+    }
+
+    boolean process(Token token) {
+        currentToken = token;
+        return this.state.process(token, this);
+    }
+
+    boolean process(Token token, TreeBuilderState state) {
+        currentToken = token;
+        return state.process(token, this);
+    }
+
+    void transition(TreeBuilderState state) {
+        this.state = state;
+    }
+
+    TreeBuilderState state() {
+        return state;
+    }
+
+    void markInsertionMode() {
+        originalState = state;
+    }
+
+    TreeBuilderState originalState() {
+        return originalState;
+    }
+
+    void framesetOk(boolean framesetOk) {
+        this.framesetOk = framesetOk;
+    }
+
+    boolean framesetOk() {
+        return framesetOk;
+    }
+
+    Element currentElement() {
+        return stack.getLast();
+    }
+
+    Document getDocument() {
+        return doc;
+    }
+
+    String getBaseUri() {
+        return baseUri;
+    }
+
+    void setBaseUri(Element base) {
+        String href = base.absUrl("href");
+        if (href.length() != 0) { // ignore <base target> etc
+            baseUri = href;
+            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base
+        }
+    }
+
+    boolean isFragmentParsing() {
+        return fragmentParsing;
+    }
+
+    void error(TreeBuilderState state) {
+        if (trackErrors)
+            errors.add(new ParseError("Unexpected token", state, currentToken, reader.pos()));
+    }
+
+    Element insert(Token.StartTag startTag) {
+        // handle empty unknown tags
+        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate fake end tag.
+        if (startTag.isSelfClosing() && !Tag.isKnownTag(startTag.name())) {
+            Element el =  insertEmpty(startTag);
+            process(new Token.EndTag(el.tagName())); // ensure we get out of whatever state we are in
+            return el;
+        }
+        
+        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);
+        insert(el);
+        return el;
+    }
+
+    Element insert(String startTagName) {
+        Element el = new Element(Tag.valueOf(startTagName), baseUri);
+        insert(el);
+        return el;
+    }
+
+    void insert(Element el) {
+        insertNode(el);
+        stack.add(el);
+    }
+
+    Element insertEmpty(Token.StartTag startTag) {
+        Tag tag = Tag.valueOf(startTag.name());
+        Element el = new Element(tag, baseUri, startTag.attributes);
+        insertNode(el);
+        if (startTag.isSelfClosing()) {
+            tokeniser.acknowledgeSelfClosingFlag();
+            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output
+                tag.setSelfClosing();
+        }
+        return el;
+    }
+
+    void insert(Token.Comment commentToken) {
+        Comment comment = new Comment(commentToken.getData(), baseUri);
+        insertNode(comment);
+    }
+
+    void insert(Token.Character characterToken) {
+        Node node;
+        // characters in script and style go in as datanodes, not text nodes
+        if (StringUtil.in(currentElement().tagName(), "script", "style"))
+            node = new DataNode(characterToken.getData(), baseUri);
+        else
+            node = new TextNode(characterToken.getData(), baseUri);
+        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.
+    }
+
+    private void insertNode(Node node) {
+        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc
+        if (stack.size() == 0)
+            doc.appendChild(node);
+        else if (isFosterInserts())
+            insertInFosterParent(node);
+        else
+            currentElement().appendChild(node);
+    }
+
+    Element pop() {
+        // todo - dev, remove validation check
+        if (stack.peekLast().nodeName().equals("td") && !state.name().equals("InCell"))
+            Validate.isFalse(true, "pop td not in cell");
+        if (stack.peekLast().nodeName().equals("html"))
+            Validate.isFalse(true, "popping html!");
+        return stack.pollLast();
+    }
+
+    void push(Element element) {
+        stack.add(element);
+    }
+
+    LinkedList<Element> getStack() {
+        return stack;
+    }
+
+    boolean onStack(Element el) {
+        return isElementInQueue(stack, el);
+    }
+
+    private boolean isElementInQueue(LinkedList<Element> queue, Element element) {
+        Iterator<Element> it = queue.descendingIterator();
+        while (it.hasNext()) {
+            Element next = it.next();
+            if (next == element) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    Element getFromStack(String elName) {
+        Iterator<Element> it = stack.descendingIterator();
+        while (it.hasNext()) {
+            Element next = it.next();
+            if (next.nodeName().equals(elName)) {
+                return next;
+            }
+        }
+        return null;
+    }
+
+    boolean removeFromStack(Element el) {
+        Iterator<Element> it = stack.descendingIterator();
+        while (it.hasNext()) {
+            Element next = it.next();
+            if (next == el) {
+                it.remove();
+                return true;
+            }
+        }
+        return false;
+    }
+
+    void popStackToClose(String elName) {
+        Iterator<Element> it = stack.descendingIterator();
+        while (it.hasNext()) {
+            Element next = it.next();
+            if (next.nodeName().equals(elName)) {
+                it.remove();
+                break;
+            } else {
+                it.remove();
+            }
+        }
+    }
+
+    void popStackToClose(String... elNames) {
+        Iterator<Element> it = stack.descendingIterator();
+        while (it.hasNext()) {
+            Element next = it.next();
+            if (StringUtil.in(next.nodeName(), elNames)) {
+                it.remove();
+                break;
+            } else {
+                it.remove();
+            }
+        }
+    }
+
+    void popStackToBefore(String elName) {
+        Iterator<Element> it = stack.descendingIterator();
+        while (it.hasNext()) {
+            Element next = it.next();
+            if (next.nodeName().equals(elName)) {
+                break;
+            } else {
+                it.remove();
+            }
+        }
+    }
+
+    void clearStackToTableContext() {
+        clearStackToContext("table");
+    }
+
+    void clearStackToTableBodyContext() {
+        clearStackToContext("tbody", "tfoot", "thead");
+    }
+
+    void clearStackToTableRowContext() {
+        clearStackToContext("tr");
+    }
+
+    private void clearStackToContext(String... nodeNames) {
+        Iterator<Element> it = stack.descendingIterator();
+        while (it.hasNext()) {
+            Element next = it.next();
+            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals("html"))
+                break;
+            else
+                it.remove();
+        }
+    }
+
+    Element aboveOnStack(Element el) {
+        assert onStack(el);
+        Iterator<Element> it = stack.descendingIterator();
+        while (it.hasNext()) {
+            Element next = it.next();
+            if (next == el) {
+                return it.next();
+            }
+        }
+        return null;
+    }
+
+    void insertOnStackAfter(Element after, Element in) {
+        int i = stack.lastIndexOf(after);
+        Validate.isTrue(i != -1);
+        stack.add(i+1, in);
+    }
+
+    void replaceOnStack(Element out, Element in) {
+        replaceInQueue(stack, out, in);
+    }
+
+    private void replaceInQueue(LinkedList<Element> queue, Element out, Element in) {
+        int i = queue.lastIndexOf(out);
+        Validate.isTrue(i != -1);
+        queue.remove(i);
+        queue.add(i, in);
+    }
+
+    void resetInsertionMode() {
+        boolean last = false;
+        Iterator<Element> it = stack.descendingIterator();
+        while (it.hasNext()) {
+            Element node = it.next();
+            if (!it.hasNext()) {
+                last = true;
+                node = contextElement;
+            }
+            String name = node.nodeName();
+            if ("select".equals(name)) {
+                transition(TreeBuilderState.InSelect);
+                break; // frag
+            } else if (("td".equals(name) || "td".equals(name) && !last)) {
+                transition(TreeBuilderState.InCell);
+                break;
+            } else if ("tr".equals(name)) {
+                transition(TreeBuilderState.InRow);
+                break;
+            } else if ("tbody".equals(name) || "thead".equals(name) || "tfoot".equals(name)) {
+                transition(TreeBuilderState.InTableBody);
+                break;
+            } else if ("caption".equals(name)) {
+                transition(TreeBuilderState.InCaption);
+                break;
+            } else if ("colgroup".equals(name)) {
+                transition(TreeBuilderState.InColumnGroup);
+                break; // frag
+            } else if ("table".equals(name)) {
+                transition(TreeBuilderState.InTable);
+                break;
+            } else if ("head".equals(name)) {
+                transition(TreeBuilderState.InBody);
+                break; // frag
+            } else if ("body".equals(name)) {
+                transition(TreeBuilderState.InBody);
+                break;
+            } else if ("frameset".equals(name)) {
+                transition(TreeBuilderState.InFrameset);
+                break; // frag
+            } else if ("html".equals(name)) {
+                transition(TreeBuilderState.BeforeHead);
+                break; // frag
+            } else if (last) {
+                transition(TreeBuilderState.InBody);
+                break; // frag
+            }
+        }
+    }
+
+    // todo: tidy up in specific scope methods
+    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {
+        return inSpecificScope(new String[]{targetName}, baseTypes, extraTypes);
+    }
+
+    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {
+        Iterator<Element> it = stack.descendingIterator();
+        while (it.hasNext()) {
+            Element el = it.next();
+            String elName = el.nodeName();
+            if (StringUtil.in(elName, targetNames))
+                return true;
+            if (StringUtil.in(elName, baseTypes))
+                return false;
+            if (extraTypes != null && StringUtil.in(elName, extraTypes))
+                return false;
+        }
+        Validate.fail("Should not be reachable");
+        return false;
+    }
+
+    boolean inScope(String[] targetNames) {
+        return inSpecificScope(targetNames, new String[]{"applet", "caption", "html", "table", "td", "th", "marquee", "object"}, null);
+    }
+
+    boolean inScope(String targetName) {
+        return inScope(targetName, null);
+    }
+
+    boolean inScope(String targetName, String[] extras) {
+        return inSpecificScope(targetName, new String[]{"applet", "caption", "html", "table", "td", "th", "marquee", "object"}, extras);
+        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml
+        // todo: in svg namespace: forignOjbect, desc, title
+    }
+
+    boolean inListItemScope(String targetName) {
+        return inScope(targetName, new String[]{"ol", "ul"});
+    }
+
+    boolean inButtonScope(String targetName) {
+        return inScope(targetName, new String[]{"button"});
+    }
+
+    boolean inTableScope(String targetName) {
+        return inSpecificScope(targetName, new String[]{"html", "table"}, null);
+    }
+
+    boolean inSelectScope(String targetName) {
+        Iterator<Element> it = stack.descendingIterator();
+        while (it.hasNext()) {
+            Element el = it.next();
+            String elName = el.nodeName();
+            if (elName.equals(targetName))
+                return true;
+            if (!StringUtil.in(elName, "optgroup", "option")) // all elements except
+                return false;
+        }
+        Validate.fail("Should not be reachable");
+        return false;
+    }
+
+    void setHeadElement(Element headElement) {
+        this.headElement = headElement;
+    }
+
+    Element getHeadElement() {
+        return headElement;
+    }
+
+    boolean isFosterInserts() {
+        return fosterInserts;
+    }
+
+    void setFosterInserts(boolean fosterInserts) {
+        this.fosterInserts = fosterInserts;
+    }
+
+    Element getFormElement() {
+        return formElement;
+    }
+
+    void setFormElement(Element formElement) {
+        this.formElement = formElement;
+    }
+
+    void newPendingTableCharacters() {
+        pendingTableCharacters = new ArrayList<Token.Character>();
+    }
+
+    List<Token.Character> getPendingTableCharacters() {
+        return pendingTableCharacters;
+    }
+
+    void setPendingTableCharacters(List<Token.Character> pendingTableCharacters) {
+        this.pendingTableCharacters = pendingTableCharacters;
+    }
+
+    /**
+     11.2.5.2 Closing elements that have implied end tags<p/>
+     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a
+     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,
+     the UA must pop the current node off the stack of open elements.
+
+     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the
+     process, then the UA must perform the above steps as if that element was not in the above list.
+     */
+    void generateImpliedEndTags(String excludeTag) {
+        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&
+                StringUtil.in(currentElement().nodeName(), "dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"))
+            pop();
+    }
+
+    void generateImpliedEndTags() {
+        generateImpliedEndTags(null);
+    }
+
+    boolean isSpecial(Element el) {
+        // todo: mathml's mi, mo, mn
+        // todo: svg's foreigObject, desc, title
+        String name = el.nodeName();
+        return StringUtil.in(name, "address", "applet", "area", "article", "aside", "base", "basefont", "bgsound",
+                "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "command", "dd",
+                "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form",
+                "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html",
+                "iframe", "img", "input", "isindex", "li", "link", "listing", "marquee", "menu", "meta", "nav",
+                "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script",
+                "section", "select", "style", "summary", "table", "tbody", "td", "textarea", "tfoot", "th", "thead",
+                "title", "tr", "ul", "wbr", "xmp");
+    }
+
+    // active formatting elements
+    void pushActiveFormattingElements(Element in) {
+        int numSeen = 0;
+        Iterator<Element> iter = formattingElements.descendingIterator();
+        while (iter.hasNext()) {
+            Element el =  iter.next();
+            if (el == null) // marker
+                break;
+
+            if (isSameFormattingElement(in, el))
+                numSeen++;
+
+            if (numSeen == 3) {
+                iter.remove();
+                break;
+            }
+        }
+        formattingElements.add(in);
+    }
+
+    private boolean isSameFormattingElement(Element a, Element b) {
+        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children
+        return a.nodeName().equals(b.nodeName()) &&
+                // a.namespace().equals(b.namespace()) &&
+                a.attributes().equals(b.attributes());
+        // todo: namespaces
+    }
+
+    void reconstructFormattingElements() {
+        int size = formattingElements.size();
+        if (size == 0 || formattingElements.getLast() == null || onStack(formattingElements.getLast()))
+            return;
+
+        Element entry = formattingElements.getLast();
+        int pos = size - 1;
+        boolean skip = false;
+        while (true) {
+            if (pos == 0) { // step 4. if none before, skip to 8
+                skip = true;
+                break;
+            }
+            entry = formattingElements.get(--pos); // step 5. one earlier than entry
+            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack
+                break; // jump to 8, else continue back to 4
+        }
+        while(true) {
+            if (!skip) // step 7: on later than entry
+                entry = formattingElements.get(++pos);
+
+            // 8. create new element from element, 9 insert into current node, onto stack
+            skip = false; // can only skip increment from 4.
+            Element newEl = insert(entry.nodeName()); // todo: avoid fostering here?
+            // newEl.namespace(entry.namespace()); // todo: namespaces
+            newEl.attributes().addAll(entry.attributes());
+
+            // 10. replace entry with new entry
+            formattingElements.add(pos, newEl);
+            formattingElements.remove(pos + 1);
+
+            // 11
+            if (pos == size-1) // if not last entry in list, jump to 7
+                break;
+        }
+    }
+
+    void clearFormattingElementsToLastMarker() {
+        while (!formattingElements.isEmpty()) {
+            Element el = formattingElements.peekLast();
+            formattingElements.removeLast();
+            if (el == null)
+                break;
+        }
+    }
+
+    void removeFromActiveFormattingElements(Element el) {
+        Iterator<Element> it = formattingElements.descendingIterator();
+        while (it.hasNext()) {
+            Element next = it.next();
+            if (next == el) {
+                it.remove();
+                break;
+            }
+        }
+    }
+
+    boolean isInActiveFormattingElements(Element el) {
+        return isElementInQueue(formattingElements, el);
+    }
+
+    Element getActiveFormattingElement(String nodeName) {
+        Iterator<Element> it = formattingElements.descendingIterator();
+        while (it.hasNext()) {
+            Element next = it.next();
+            if (next == null) // scope marker
+                break;
+            else if (next.nodeName().equals(nodeName))
+                return next;
+        }
+        return null;
+    }
+
+    void replaceActiveFormattingElement(Element out, Element in) {
+        replaceInQueue(formattingElements, out, in);
+    }
+
+    void insertMarkerToFormattingElements() {
+        formattingElements.add(null);
+    }
+
+    void insertInFosterParent(Node in) {
+        Element fosterParent = null;
+        Element lastTable = getFromStack("table");
+        boolean isLastTableParent = false;
+        if (lastTable != null) {
+            if (lastTable.parent() != null) {
+                fosterParent = lastTable.parent();
+                isLastTableParent = true;
+            } else
+                fosterParent = aboveOnStack(lastTable);
+        } else { // no table == frag
+            fosterParent = stack.get(0);
+        }
+
+        if (isLastTableParent)
+            lastTable.before(in);
+        else
+            fosterParent.appendChild(in);
+    }
+
+    @Override
+    public String toString() {
+        return "TreeBuilder{" +
+                "currentToken=" + currentToken +
+                ", state=" + state +
+                ", currentElement=" + currentElement() +
+                '}';
+    }
+}
diff --git a/src/main/java/org/jsoup/parser/TreeBuilderState.java b/src/main/java/org/jsoup/parser/TreeBuilderState.java
new file mode 100644
index 0000000..0b36067
--- /dev/null
+++ b/src/main/java/org/jsoup/parser/TreeBuilderState.java
@@ -0,0 +1,1482 @@
+package org.jsoup.parser;
+
+import org.jsoup.helper.StringUtil;
+import org.jsoup.helper.Validate;
+import org.jsoup.nodes.*;
+
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.LinkedList;
+
+/**
+ */
+public enum TreeBuilderState {
+    Initial {
+        boolean process(Token t, TreeBuilder tb) {
+            if (isWhitespace(t)) {
+                return true; // ignore whitespace
+            } else if (t.isComment()) {
+                tb.insert(t.asComment());
+            } else if (t.isDoctype()) {
+                // todo: parse error check on expected doctypes
+                // todo: quirk state check on doctype ids
+                Token.Doctype d = t.asDoctype();
+                DocumentType doctype = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());
+                tb.getDocument().appendChild(doctype);
+                if (d.isForceQuirks())
+                    tb.getDocument().quirksMode(Document.QuirksMode.quirks);
+                tb.transition(BeforeHtml);
+            } else {
+                // todo: check not iframe srcdoc
+                tb.transition(BeforeHtml);
+                return tb.process(t); // re-process token
+            }
+            return true;
+        }
+    },
+    BeforeHtml {
+        boolean process(Token t, TreeBuilder tb) {
+            if (t.isDoctype()) {
+                tb.error(this);
+                return false;
+            } else if (t.isComment()) {
+                tb.insert(t.asComment());
+            } else if (isWhitespace(t)) {
+                return true; // ignore whitespace
+            } else if (t.isStartTag() && t.asStartTag().name().equals("html")) {
+                tb.insert(t.asStartTag());
+                tb.transition(BeforeHead);
+            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), "head", "body", "html", "br"))) {
+                return anythingElse(t, tb);
+            } else if (t.isEndTag()) {
+                tb.error(this);
+                return false;
+            } else {
+                return anythingElse(t, tb);
+            }
+            return true;
+        }
+
+        private boolean anythingElse(Token t, TreeBuilder tb) {
+            tb.insert("html");
+            tb.transition(BeforeHead);
+            return tb.process(t);
+        }
+    },
+    BeforeHead {
+        boolean process(Token t, TreeBuilder tb) {
+            if (isWhitespace(t)) {
+                return true;
+            } else if (t.isComment()) {
+                tb.insert(t.asComment());
+            } else if (t.isDoctype()) {
+                tb.error(this);
+                return false;
+            } else if (t.isStartTag() && t.asStartTag().name().equals("html")) {
+                return InBody.process(t, tb); // does not transition
+            } else if (t.isStartTag() && t.asStartTag().name().equals("head")) {
+                Element head = tb.insert(t.asStartTag());
+                tb.setHeadElement(head);
+                tb.transition(InHead);
+            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), "head", "body", "html", "br"))) {
+                tb.process(new Token.StartTag("head"));
+                return tb.process(t);
+            } else if (t.isEndTag()) {
+                tb.error(this);
+                return false;
+            } else {
+                tb.process(new Token.StartTag("head"));
+                return tb.process(t);
+            }
+            return true;
+        }
+    },
+    InHead {
+        boolean process(Token t, TreeBuilder tb) {
+            if (isWhitespace(t)) {
+                tb.insert(t.asCharacter());
+                return true;
+            }
+            switch (t.type) {
+                case Comment:
+                    tb.insert(t.asComment());
+                    break;
+                case Doctype:
+                    tb.error(this);
+                    return false;
+                case StartTag:
+                    Token.StartTag start = t.asStartTag();
+                    String name = start.name();
+                    if (name.equals("html")) {
+                        return InBody.process(t, tb);
+                    } else if (StringUtil.in(name, "base", "basefont", "bgsound", "command", "link")) {
+                        Element el = tb.insertEmpty(start);
+                        // jsoup special: update base as it is seen. todo: flip to current browser behaviour of one shot
+                        if (name.equals("base") && el.hasAttr("href"))
+                            tb.setBaseUri(el);
+                    } else if (name.equals("meta")) {
+                        Element meta = tb.insertEmpty(start);
+                        // todo: charset switches
+                    } else if (name.equals("title")) {
+                        handleRcData(start, tb);
+                    } else if (StringUtil.in(name, "noframes", "style")) {
+                        handleRawtext(start, tb);
+                    } else if (name.equals("noscript")) {
+                        // else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)
+                        tb.insert(start);
+                        tb.transition(InHeadNoscript);
+                    } else if (name.equals("script")) {
+                        // skips some script rules as won't execute them
+                        tb.insert(start);
+                        tb.tokeniser.transition(TokeniserState.ScriptData);
+                        tb.markInsertionMode();
+                        tb.transition(Text);
+                    } else if (name.equals("head")) {
+                        tb.error(this);
+                        return false;
+                    } else {
+                        return anythingElse(t, tb);
+                    }
+                    break;
+                case EndTag:
+                    Token.EndTag end = t.asEndTag();
+                    name = end.name();
+                    if (name.equals("head")) {
+                        tb.pop();
+                        tb.transition(AfterHead);
+                    } else if (StringUtil.in(name, "body", "html", "br")) {
+                        return anythingElse(t, tb);
+                    } else {
+                        tb.error(this);
+                        return false;
+                    }
+                    break;
+                default:
+                    return anythingElse(t, tb);
+            }
+            return true;
+        }
+
+        private boolean anythingElse(Token t, TreeBuilder tb) {
+            tb.process(new Token.EndTag("head"));
+            return tb.process(t);
+        }
+    },
+    InHeadNoscript {
+        boolean process(Token t, TreeBuilder tb) {
+            if (t.isDoctype()) {
+                tb.error(this);
+            } else if (t.isStartTag() && t.asStartTag().name().equals("html")) {
+                return tb.process(t, InBody);
+            } else if (t.isEndTag() && t.asEndTag().name().equals("noscript")) {
+                tb.pop();
+                tb.transition(InHead);
+            } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().name(),
+                    "basefont", "bgsound", "link", "meta", "noframes", "style"))) {
+                return tb.process(t, InHead);
+            } else if (t.isEndTag() && t.asEndTag().name().equals("br")) {
+                return anythingElse(t, tb);
+            } else if ((t.isStartTag() && StringUtil.in(t.asStartTag().name(), "head", "noscript")) || t.isEndTag()) {
+                tb.error(this);
+                return false;
+            } else {
+                return anythingElse(t, tb);
+            }
+            return true;
+        }
+
+        private boolean anythingElse(Token t, TreeBuilder tb) {
+            tb.error(this);
+            tb.process(new Token.EndTag("noscript"));
+            return tb.process(t);
+        }
+    },
+    AfterHead {
+        boolean process(Token t, TreeBuilder tb) {
+            if (isWhitespace(t)) {
+                tb.insert(t.asCharacter());
+            } else if (t.isComment()) {
+                tb.insert(t.asComment());
+            } else if (t.isDoctype()) {
+                tb.error(this);
+            } else if (t.isStartTag()) {
+                Token.StartTag startTag = t.asStartTag();
+                String name = startTag.name();
+                if (name.equals("html")) {
+                    return tb.process(t, InBody);
+                } else if (name.equals("body")) {
+                    tb.insert(startTag);
+                    tb.framesetOk(false);
+                    tb.transition(InBody);
+                } else if (name.equals("frameset")) {
+                    tb.insert(startTag);
+                    tb.transition(InFrameset);
+                } else if (StringUtil.in(name, "base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "title")) {
+                    tb.error(this);
+                    Element head = tb.getHeadElement();
+                    tb.push(head);
+                    tb.process(t, InHead);
+                    tb.removeFromStack(head);
+                } else if (name.equals("head")) {
+                    tb.error(this);
+                    return false;
+                } else {
+                    anythingElse(t, tb);
+                }
+            } else if (t.isEndTag()) {
+                if (StringUtil.in(t.asEndTag().name(), "body", "html")) {
+                    anythingElse(t, tb);
+                } else {
+                    tb.error(this);
+                    return false;
+                }
+            } else {
+                anythingElse(t, tb);
+            }
+            return true;
+        }
+
+        private boolean anythingElse(Token t, TreeBuilder tb) {
+            tb.process(new Token.StartTag("body"));
+            tb.framesetOk(true);
+            return tb.process(t);
+        }
+    },
+    InBody {
+        boolean process(Token t, TreeBuilder tb) {
+            switch (t.type) {
+                case Character: {
+                    Token.Character c = t.asCharacter();
+                    if (c.getData().equals(nullString)) {
+                        // todo confirm that check
+                        tb.error(this);
+                        return false;
+                    } else if (isWhitespace(c)) {
+                        tb.reconstructFormattingElements();
+                        tb.insert(c);
+                    } else {
+                        tb.reconstructFormattingElements();
+                        tb.insert(c);
+                        tb.framesetOk(false);
+                    }
+                    break;
+                }
+                case Comment: {
+                    tb.insert(t.asComment());
+                    break;
+                }
+                case Doctype: {
+                    tb.error(this);
+                    return false;
+                }
+                case StartTag:
+                    Token.StartTag startTag = t.asStartTag();
+                    String name = startTag.name();
+                    if (name.equals("html")) {
+                        tb.error(this);
+                        // merge attributes onto real html
+                        Element html = tb.getStack().getFirst();
+                        for (Attribute attribute : startTag.getAttributes()) {
+                            if (!html.hasAttr(attribute.getKey()))
+                                html.attributes().put(attribute);
+                        }
+                    } else if (StringUtil.in(name, "base", "basefont", "bgsound", "command", "link", "meta", "noframes", "style", "title")) {
+                        return tb.process(t, InHead);
+                    } else if (name.equals("body")) {
+                        tb.error(this);
+                        LinkedList<Element> stack = tb.getStack();
+                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body"))) {
+                            // only in fragment case
+                            return false; // ignore
+                        } else {
+                            tb.framesetOk(false);
+                            Element body = stack.get(1);
+                            for (Attribute attribute : startTag.getAttributes()) {
+                                if (!body.hasAttr(attribute.getKey()))
+                                    body.attributes().put(attribute);
+                            }
+                        }
+                    } else if (name.equals("frameset")) {
+                        tb.error(this);
+                        LinkedList<Element> stack = tb.getStack();
+                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body"))) {
+                            // only in fragment case
+                            return false; // ignore
+                        } else if (!tb.framesetOk()) {
+                            return false; // ignore frameset
+                        } else {
+                            Element second = stack.get(1);
+                            if (second.parent() != null)
+                                second.remove();
+                            // pop up to html element
+                            while (stack.size() > 1)
+                                stack.removeLast();
+                            tb.insert(startTag);
+                            tb.transition(InFrameset);
+                        }
+                    } else if (StringUtil.in(name,
+                            "address", "article", "aside", "blockquote", "center", "details", "dir", "div", "dl",
+                            "fieldset", "figcaption", "figure", "footer", "header", "hgroup", "menu", "nav", "ol",
+                            "p", "section", "summary", "ul")) {
+                        if (tb.inButtonScope("p")) {
+                            tb.process(new Token.EndTag("p"));
+                        }
+                        tb.insert(startTag);
+                    } else if (StringUtil.in(name, "h1", "h2", "h3", "h4", "h5", "h6")) {
+                        if (tb.inButtonScope("p")) {
+                            tb.process(new Token.EndTag("p"));
+                        }
+                        if (StringUtil.in(tb.currentElement().nodeName(), "h1", "h2", "h3", "h4", "h5", "h6")) {
+                            tb.error(this);
+                            tb.pop();
+                        }
+                        tb.insert(startTag);
+                    } else if (StringUtil.in(name, "pre", "listing")) {
+                        if (tb.inButtonScope("p")) {
+                            tb.process(new Token.EndTag("p"));
+                        }
+                        tb.insert(startTag);
+                        // todo: ignore LF if next token
+                        tb.framesetOk(false);
+                    } else if (name.equals("form")) {
+                        if (tb.getFormElement() != null) {
+                            tb.error(this);
+                            return false;
+                        }
+                        if (tb.inButtonScope("p")) {
+                            tb.process(new Token.EndTag("p"));
+                        }
+                        Element form = tb.insert(startTag);
+                        tb.setFormElement(form);
+                    } else if (name.equals("li")) {
+                        tb.framesetOk(false);
+                        LinkedList<Element> stack = tb.getStack();
+                        for (int i = stack.size() - 1; i > 0; i--) {
+                            Element el = stack.get(i);
+                            if (el.nodeName().equals("li")) {
+                                tb.process(new Token.EndTag("li"));
+                                break;
+                            }
+                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), "address", "div", "p"))
+                                break;
+                        }
+                        if (tb.inButtonScope("p")) {
+                            tb.process(new Token.EndTag("p"));
+                        }
+                        tb.insert(startTag);
+                    } else if (StringUtil.in(name, "dd", "dt")) {
+                        tb.framesetOk(false);
+                        LinkedList<Element> stack = tb.getStack();
+                        for (int i = stack.size() - 1; i > 0; i--) {
+                            Element el = stack.get(i);
+                            if (StringUtil.in(el.nodeName(), "dd", "dt")) {
+                                tb.process(new Token.EndTag(el.nodeName()));
+                                break;
+                            }
+                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), "address", "div", "p"))
+                                break;
+                        }
+                        if (tb.inButtonScope("p")) {
+                            tb.process(new Token.EndTag("p"));
+                        }
+                        tb.insert(startTag);
+                    } else if (name.equals("plaintext")) {
+                        if (tb.inButtonScope("p")) {
+                            tb.process(new Token.EndTag("p"));
+                        }
+                        tb.insert(startTag);
+                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out
+                    } else if (name.equals("button")) {
+                        if (tb.inButtonScope("button")) {
+                            // close and reprocess
+                            tb.error(this);
+                            tb.process(new Token.EndTag("button"));
+                            tb.process(startTag);
+                        } else {
+                            tb.reconstructFormattingElements();
+                            tb.insert(startTag);
+                            tb.framesetOk(false);
+                        }
+                    } else if (name.equals("a")) {
+                        if (tb.getActiveFormattingElement("a") != null) {
+                            tb.error(this);
+                            tb.process(new Token.EndTag("a"));
+
+                            // still on stack?
+                            Element remainingA = tb.getFromStack("a");
+                            if (remainingA != null) {
+                                tb.removeFromActiveFormattingElements(remainingA);
+                                tb.removeFromStack(remainingA);
+                            }
+                        }
+                        tb.reconstructFormattingElements();
+                        Element a = tb.insert(startTag);
+                        tb.pushActiveFormattingElements(a);
+                    } else if (StringUtil.in(name,
+                            "b", "big", "code", "em", "font", "i", "s", "small", "strike", "strong", "tt", "u")) {
+                        tb.reconstructFormattingElements();
+                        Element el = tb.insert(startTag);
+                        tb.pushActiveFormattingElements(el);
+                    } else if (name.equals("nobr")) {
+                        tb.reconstructFormattingElements();
+                        if (tb.inScope("nobr")) {
+                            tb.error(this);
+                            tb.process(new Token.EndTag("nobr"));
+                            tb.reconstructFormattingElements();
+                        }
+                        Element el = tb.insert(startTag);
+                        tb.pushActiveFormattingElements(el);
+                    } else if (StringUtil.in(name, "applet", "marquee", "object")) {
+                        tb.reconstructFormattingElements();
+                        tb.insert(startTag);
+                        tb.insertMarkerToFormattingElements();
+                        tb.framesetOk(false);
+                    } else if (name.equals("table")) {
+                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope("p")) {
+                            tb.process(new Token.EndTag("p"));
+                        }
+                        tb.insert(startTag);
+                        tb.framesetOk(false);
+                        tb.transition(InTable);
+                    } else if (StringUtil.in(name, "area", "br", "embed", "img", "keygen", "wbr")) {
+                        tb.reconstructFormattingElements();
+                        tb.insertEmpty(startTag);
+                        tb.framesetOk(false);
+                    } else if (name.equals("input")) {
+                        tb.reconstructFormattingElements();
+                        Element el = tb.insertEmpty(startTag);
+                        if (!el.attr("type").equalsIgnoreCase("hidden"))
+                            tb.framesetOk(false);
+                    } else if (StringUtil.in(name, "param", "source", "track")) {
+                        tb.insertEmpty(startTag);
+                    } else if (name.equals("hr")) {
+                        if (tb.inButtonScope("p")) {
+                            tb.process(new Token.EndTag("p"));
+                        }
+                        tb.insertEmpty(startTag);
+                        tb.framesetOk(false);
+                    } else if (name.equals("image")) {
+                        // we're not supposed to ask.
+                        startTag.name("img");
+                        return tb.process(startTag);
+                    } else if (name.equals("isindex")) {
+                        // how much do we care about the early 90s?
+                        tb.error(this);
+                        if (tb.getFormElement() != null)
+                            return false;
+
+                        tb.tokeniser.acknowledgeSelfClosingFlag();
+                        tb.process(new Token.StartTag("form"));
+                        if (startTag.attributes.hasKey("action")) {
+                            Element form = tb.getFormElement();
+                            form.attr("action", startTag.attributes.get("action"));
+                        }
+                        tb.process(new Token.StartTag("hr"));
+                        tb.process(new Token.StartTag("label"));
+                        // hope you like english.
+                        String prompt = startTag.attributes.hasKey("prompt") ?
+                                startTag.attributes.get("prompt") :
+                                "This is a searchable index. Enter search keywords: ";
+
+                        tb.process(new Token.Character(prompt));
+
+                        // input
+                        Attributes inputAttribs = new Attributes();
+                        for (Attribute attr : startTag.attributes) {
+                            if (!StringUtil.in(attr.getKey(), "name", "action", "prompt"))
+                                inputAttribs.put(attr);
+                        }
+                        inputAttribs.put("name", "isindex");
+                        tb.process(new Token.StartTag("input", inputAttribs));
+                        tb.process(new Token.EndTag("label"));
+                        tb.process(new Token.StartTag("hr"));
+                        tb.process(new Token.EndTag("form"));
+                    } else if (name.equals("textarea")) {
+                        tb.insert(startTag);
+                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
+                        tb.tokeniser.transition(TokeniserState.Rcdata);
+                        tb.markInsertionMode();
+                        tb.framesetOk(false);
+                        tb.transition(Text);
+                    } else if (name.equals("xmp")) {
+                        if (tb.inButtonScope("p")) {
+                            tb.process(new Token.EndTag("p"));
+                        }
+                        tb.reconstructFormattingElements();
+                        tb.framesetOk(false);
+                        handleRawtext(startTag, tb);
+                    } else if (name.equals("iframe")) {
+                        tb.framesetOk(false);
+                        handleRawtext(startTag, tb);
+                    } else if (name.equals("noembed")) {
+                        // also handle noscript if script enabled
+                        handleRawtext(startTag, tb);
+                    } else if (name.equals("select")) {
+                        tb.reconstructFormattingElements();
+                        tb.insert(startTag);
+                        tb.framesetOk(false);
+
+                        TreeBuilderState state = tb.state();
+                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))
+                            tb.transition(InSelectInTable);
+                        else
+                            tb.transition(InSelect);
+                    } else if (StringUtil.in("optgroup", "option")) {
+                        if (tb.currentElement().nodeName().equals("option"))
+                            tb.process(new Token.EndTag("option"));
+                        tb.reconstructFormattingElements();
+                        tb.insert(startTag);
+                    } else if (StringUtil.in("rp", "rt")) {
+                        if (tb.inScope("ruby")) {
+                            tb.generateImpliedEndTags();
+                            if (!tb.currentElement().nodeName().equals("ruby")) {
+                                tb.error(this);
+                                tb.popStackToBefore("ruby"); // i.e. close up to but not include name
+                            }
+                            tb.insert(startTag);
+                        }
+                    } else if (name.equals("math")) {
+                        tb.reconstructFormattingElements();
+                        // todo: handle A start tag whose tag name is "math" (i.e. foreign, mathml)
+                        tb.insert(startTag);
+                        tb.tokeniser.acknowledgeSelfClosingFlag();
+                    } else if (name.equals("svg")) {
+                        tb.reconstructFormattingElements();
+                        // todo: handle A start tag whose tag name is "svg" (xlink, svg)
+                        tb.insert(startTag);
+                        tb.tokeniser.acknowledgeSelfClosingFlag();
+                    } else if (StringUtil.in(name,
+                            "caption", "col", "colgroup", "frame", "head", "tbody", "td", "tfoot", "th", "thead", "tr")) {
+                        tb.error(this);
+                        return false;
+                    } else {
+                        tb.reconstructFormattingElements();
+                        tb.insert(startTag);
+                    }
+                    break;
+
+                case EndTag:
+                    Token.EndTag endTag = t.asEndTag();
+                    name = endTag.name();
+                    if (name.equals("body")) {
+                        if (!tb.inScope("body")) {
+                            tb.error(this);
+                            return false;
+                        } else {
+                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html
+                            tb.transition(AfterBody);
+                        }
+                    } else if (name.equals("html")) {
+                        boolean notIgnored = tb.process(new Token.EndTag("body"));
+                        if (notIgnored)
+                            return tb.process(endTag);
+                    } else if (StringUtil.in(name,
+                            "address", "article", "aside", "blockquote", "button", "center", "details", "dir", "div",
+                            "dl", "fieldset", "figcaption", "figure", "footer", "header", "hgroup", "listing", "menu",
+                            "nav", "ol", "pre", "section", "summary", "ul")) {
+                        // todo: refactor these lookups
+                        if (!tb.inScope(name)) {
+                            // nothing to close
+                            tb.error(this);
+                            return false;
+                        } else {
+                            tb.generateImpliedEndTags();
+                            if (!tb.currentElement().nodeName().equals(name))
+                                tb.error(this);
+                            tb.popStackToClose(name);
+                        }
+                    } else if (name.equals("form")) {
+                        Element currentForm = tb.getFormElement();
+                        tb.setFormElement(null);
+                        if (currentForm == null || !tb.inScope(name)) {
+                            tb.error(this);
+                            return false;
+                        } else {
+                            tb.generateImpliedEndTags();
+                            if (!tb.currentElement().nodeName().equals(name))
+                                tb.error(this);
+                            // remove currentForm from stack. will shift anything under up.
+                            tb.removeFromStack(currentForm);
+                        }
+                    } else if (name.equals("p")) {
+                        if (!tb.inButtonScope(name)) {
+                            tb.error(this);
+                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>
+                            return tb.process(endTag);
+                        } else {
+                            tb.generateImpliedEndTags(name);
+                            if (!tb.currentElement().nodeName().equals(name))
+                                tb.error(this);
+                            tb.popStackToClose(name);
+                        }
+                    } else if (name.equals("li")) {
+                        if (!tb.inListItemScope(name)) {
+                            tb.error(this);
+                            return false;
+                        } else {
+                            tb.generateImpliedEndTags(name);
+                            if (!tb.currentElement().nodeName().equals(name))
+                                tb.error(this);
+                            tb.popStackToClose(name);
+                        }
+                    } else if (StringUtil.in(name, "dd", "dt")) {
+                        if (!tb.inScope(name)) {
+                            tb.error(this);
+                            return false;
+                        } else {
+                            tb.generateImpliedEndTags(name);
+                            if (!tb.currentElement().nodeName().equals(name))
+                                tb.error(this);
+                            tb.popStackToClose(name);
+                        }
+                    } else if (StringUtil.in(name, "h1", "h2", "h3", "h4", "h5", "h6")) {
+                        if (!tb.inScope(new String[]{"h1", "h2", "h3", "h4", "h5", "h6"})) {
+                            tb.error(this);
+                            return false;
+                        } else {
+                            tb.generateImpliedEndTags(name);
+                            if (!tb.currentElement().nodeName().equals(name))
+                                tb.error(this);
+                            tb.popStackToClose("h1", "h2", "h3", "h4", "h5", "h6");
+                        }
+                    } else if (name.equals("sarcasm")) {
+                        // *sigh*
+                        return anyOtherEndTag(t, tb);
+                    } else if (StringUtil.in(name,
+                            "a", "b", "big", "code", "em", "font", "i", "nobr", "s", "small", "strike", "strong", "tt", "u")) {
+                        // Adoption Agency Algorithm.
+                        OUTER:
+                        for (int i = 0; i < 8; i++) {
+                            Element formatEl = tb.getActiveFormattingElement(name);
+                            if (formatEl == null)
+                                return anyOtherEndTag(t, tb);
+                            else if (!tb.onStack(formatEl)) {
+                                tb.error(this);
+                                tb.removeFromActiveFormattingElements(formatEl);
+                                return true;
+                            } else if (!tb.inScope(formatEl.nodeName())) {
+                                tb.error(this);
+                                return false;
+                            } else if (tb.currentElement() != formatEl)
+                                tb.error(this);
+
+                            Element furthestBlock = null;
+                            Element commonAncestor = null;
+                            boolean seenFormattingElement = false;
+                            LinkedList<Element> stack = tb.getStack();
+                            for (int si = 0; si < stack.size(); si++) {
+                                Element el = stack.get(si);
+                                if (el == formatEl) {
+                                    commonAncestor = stack.get(si - 1);
+                                    seenFormattingElement = true;
+                                } else if (seenFormattingElement && tb.isSpecial(el)) {
+                                    furthestBlock = el;
+                                    break;
+                                }
+                            }
+                            if (furthestBlock == null) {
+                                tb.popStackToClose(formatEl.nodeName());
+                                tb.removeFromActiveFormattingElements(formatEl);
+                                return true;
+                            }
+
+                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.
+                            // does that mean: int pos of format el in list?
+                            Element node = furthestBlock;
+                            Element lastNode = furthestBlock;
+                            INNER:
+                            for (int j = 0; j < 3; j++) {
+                                if (tb.onStack(node))
+                                    node = tb.aboveOnStack(node);
+                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check
+                                    tb.removeFromStack(node);
+                                    continue INNER;
+                                } else if (node == formatEl)
+                                    break INNER;
+
+                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());
+                                tb.replaceActiveFormattingElement(node, replacement);
+                                tb.replaceOnStack(node, replacement);
+                                node = replacement;
+
+                                if (lastNode == furthestBlock) {
+                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.
+                                    // not getting how this bookmark both straddles the element above, but is inbetween here...
+                                }
+                                if (lastNode.parent() != null)
+                                    lastNode.remove();
+                                node.appendChild(lastNode);
+
+                                lastNode = node;
+                            }
+
+                            if (StringUtil.in(commonAncestor.nodeName(), "table", "tbody", "tfoot", "thead", "tr")) {
+                                if (lastNode.parent() != null)
+                                    lastNode.remove();
+                                tb.insertInFosterParent(lastNode);
+                            } else {
+                                if (lastNode.parent() != null)
+                                    lastNode.remove();
+                                commonAncestor.appendChild(lastNode);
+                            }
+
+                            Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());
+                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);
+                            for (Node childNode : childNodes) {
+                                adopter.appendChild(childNode); // append will reparent. thus the clone to avvoid concurrent mod.
+                            }
+                            furthestBlock.appendChild(adopter);
+                            tb.removeFromActiveFormattingElements(formatEl);
+                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.
+                            tb.removeFromStack(formatEl);
+                            tb.insertOnStackAfter(furthestBlock, adopter);
+                        }
+                    } else if (StringUtil.in(name, "applet", "marquee", "object")) {
+                        if (!tb.inScope("name")) {
+                            if (!tb.inScope(name)) {
+                                tb.error(this);
+                                return false;
+                            }
+                            tb.generateImpliedEndTags();
+                            if (!tb.currentElement().nodeName().equals(name))
+                                tb.error(this);
+                            tb.popStackToClose(name);
+                            tb.clearFormattingElementsToLastMarker();
+                        }
+                    } else if (name.equals("br")) {
+                        tb.error(this);
+                        tb.process(new Token.StartTag("br"));
+                        return false;
+                    } else {
+                        return anyOtherEndTag(t, tb);
+                    }
+
+                    break;
+                case EOF:
+                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html
+                    // stop parsing
+                    break;
+            }
+            return true;
+        }
+
+        boolean anyOtherEndTag(Token t, TreeBuilder tb) {
+            String name = t.asEndTag().name();
+            LinkedList<Element> stack = tb.getStack();
+            Iterator<Element> it = stack.descendingIterator();
+            while (it.hasNext()) {
+                Element node = it.next();
+                if (node.nodeName().equals(name)) {
+                    tb.generateImpliedEndTags(name);
+                    if (!name.equals(tb.currentElement().nodeName()))
+                        tb.error(this);
+                    tb.popStackToClose(name);
+                    break;
+                } else {
+                    if (tb.isSpecial(node)) {
+                        tb.error(this);
+                        return false;
+                    }
+                }
+            }
+            return true;
+        }
+    },
+    Text {
+        // in script, style etc. normally treated as data tags
+        boolean process(Token t, TreeBuilder tb) {
+            if (t.isCharacter()) {
+                tb.insert(t.asCharacter());
+            } else if (t.isEOF()) {
+                tb.error(this);
+                // if current node is script: already started
+                tb.pop();
+                tb.transition(tb.originalState());
+                return tb.process(t);
+            } else if (t.isEndTag()) {
+                // if: An end tag whose tag name is "script" -- scripting nesting level, if evaluating scripts
+                tb.pop();
+                tb.transition(tb.originalState());
+            }
+            return true;
+        }
+    },
+    InTable {
+        boolean process(Token t, TreeBuilder tb) {
+            if (t.isCharacter()) {
+                tb.newPendingTableCharacters();
+                tb.markInsertionMode();
+                tb.transition(InTableText);
+                return tb.process(t);
+            } else if (t.isComment()) {
+                tb.insert(t.asComment());
+            } else if (t.isDoctype()) {
+                tb.error(this);
+                return false;
+            } else if (t.isStartTag()) {
+                Token.StartTag startTag = t.asStartTag();
+                String name = startTag.name();
+                if (name.equals("caption")) {
+                    tb.clearStackToTableContext();
+                    tb.insertMarkerToFormattingElements();
+                    tb.insert(startTag);
+                    tb.transition(InCaption);
+                } else if (name.equals("colgroup")) {
+                    tb.clearStackToTableContext();
+                    tb.insert(startTag);
+                    tb.transition(InColumnGroup);
+                } else if (name.equals("col")) {
+                    tb.process(new Token.StartTag("colgroup"));
+                    return tb.process(t);
+                } else if (StringUtil.in(name, "tbody", "tfoot", "thead")) {
+                    tb.clearStackToTableContext();
+                    tb.insert(startTag);
+                    tb.transition(InTableBody);
+                } else if (StringUtil.in(name, "td", "th", "tr")) {
+                    tb.process(new Token.StartTag("tbody"));
+                    return tb.process(t);
+                } else if (name.equals("table")) {
+                    tb.error(this);
+                    boolean processed = tb.process(new Token.EndTag("table"));
+                    if (processed) // only ignored if in fragment
+                        return tb.process(t);
+                } else if (StringUtil.in(name, "style", "script")) {
+                    return tb.process(t, InHead);
+                } else if (name.equals("input")) {
+                    if (!startTag.attributes.get("type").equalsIgnoreCase("hidden")) {
+                        return anythingElse(t, tb);
+                    } else {
+                        tb.insertEmpty(startTag);
+                    }
+                } else if (name.equals("form")) {
+                    tb.error(this);
+                    if (tb.getFormElement() != null)
+                        return false;
+                    else {
+                        Element form = tb.insertEmpty(startTag);
+                        tb.setFormElement(form);
+                    }
+                } else {
+                    return anythingElse(t, tb);
+                }
+            } else if (t.isEndTag()) {
+                Token.EndTag endTag = t.asEndTag();
+                String name = endTag.name();
+
+                if (name.equals("table")) {
+                    if (!tb.inTableScope(name)) {
+                        tb.error(this);
+                        return false;
+                    } else {
+                        tb.popStackToClose("table");
+                    }
+                    tb.resetInsertionMode();
+                } else if (StringUtil.in(name,
+                        "body", "caption", "col", "colgroup", "html", "tbody", "td", "tfoot", "th", "thead", "tr")) {
+                    tb.error(this);
+                    return false;
+                } else {
+                    return anythingElse(t, tb);
+                }
+            } else if (t.isEOF()) {
+                if (tb.currentElement().nodeName().equals("html"))
+                    tb.error(this);
+                return true; // stops parsing
+            }
+            return anythingElse(t, tb);
+        }
+
+        boolean anythingElse(Token t, TreeBuilder tb) {
+            tb.error(this);
+            boolean processed = true;
+            if (StringUtil.in(tb.currentElement().nodeName(), "table", "tbody", "tfoot", "thead", "tr")) {
+                tb.setFosterInserts(true);
+                processed = tb.process(t, InBody);
+                tb.setFosterInserts(false);
+            } else {
+                processed = tb.process(t, InBody);
+            }
+            return processed;
+        }
+    },
+    InTableText {
+        boolean process(Token t, TreeBuilder tb) {
+            switch (t.type) {
+                case Character:
+                    Token.Character c = t.asCharacter();
+                    if (c.getData().equals(nullString)) {
+                        tb.error(this);
+                        return false;
+                    } else {
+                        tb.getPendingTableCharacters().add(c);
+                    }
+                    break;
+                default:
+                    if (tb.getPendingTableCharacters().size() > 0) {
+                        for (Token.Character character : tb.getPendingTableCharacters()) {
+                            if (!isWhitespace(character)) {
+                                // InTable anything else section:
+                                tb.error(this);
+                                if (StringUtil.in(tb.currentElement().nodeName(), "table", "tbody", "tfoot", "thead", "tr")) {
+                                    tb.setFosterInserts(true);
+                                    tb.process(character, InBody);
+                                    tb.setFosterInserts(false);
+                                } else {
+                                    tb.process(character, InBody);
+                                }
+                            } else
+                                tb.insert(character);
+                        }
+                        tb.newPendingTableCharacters();
+                    }
+                    tb.transition(tb.originalState());
+                    return tb.process(t);
+            }
+            return true;
+        }
+    },
+    InCaption {
+        boolean process(Token t, TreeBuilder tb) {
+            if (t.isEndTag() && t.asEndTag().name().equals("caption")) {
+                Token.EndTag endTag = t.asEndTag();
+                String name = endTag.name();
+                if (!tb.inTableScope(name)) {
+                    tb.error(this);
+                    return false;
+                } else {
+                    tb.generateImpliedEndTags();
+                    if (!tb.currentElement().nodeName().equals("caption"))
+                        tb.error(this);
+                    tb.popStackToClose("caption");
+                    tb.clearFormattingElementsToLastMarker();
+                    tb.transition(InTable);
+                }
+            } else if ((
+                    t.isStartTag() && StringUtil.in(t.asStartTag().name(),
+                            "caption", "col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr") ||
+                            t.isEndTag() && t.asEndTag().name().equals("table"))
+                    ) {
+                tb.error(this);
+                boolean processed = tb.process(new Token.EndTag("caption"));
+                if (processed)
+                    return tb.process(t);
+            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(),
+                    "body", "col", "colgroup", "html", "tbody", "td", "tfoot", "th", "thead", "tr")) {
+                tb.error(this);
+                return false;
+            } else {
+                return tb.process(t, InBody);
+            }
+            return true;
+        }
+    },
+    InColumnGroup {
+        boolean process(Token t, TreeBuilder tb) {
+            if (isWhitespace(t)) {
+                tb.insert(t.asCharacter());
+                return true;
+            }
+            switch (t.type) {
+                case Comment:
+                    tb.insert(t.asComment());
+                    break;
+                case Doctype:
+                    tb.error(this);
+                    break;
+                case StartTag:
+                    Token.StartTag startTag = t.asStartTag();
+                    String name = startTag.name();
+                    if (name.equals("html"))
+                        return tb.process(t, InBody);
+                    else if (name.equals("col"))
+                        tb.insertEmpty(startTag);
+                    else
+                        return anythingElse(t, tb);
+                    break;
+                case EndTag:
+                    Token.EndTag endTag = t.asEndTag();
+                    name = endTag.name();
+                    if (name.equals("colgroup")) {
+                        if (tb.currentElement().nodeName().equals("html")) { // frag case
+                            tb.error(this);
+                            return false;
+                        } else {
+                            tb.pop();
+                            tb.transition(InTable);
+                        }
+                    } else
+                        return anythingElse(t, tb);
+                    break;
+                case EOF:
+                    if (tb.currentElement().nodeName().equals("html"))
+                        return true; // stop parsing; frag case
+                    else
+                        return anythingElse(t, tb);
+                default:
+                    return anythingElse(t, tb);
+            }
+            return true;
+        }
+
+        private boolean anythingElse(Token t, TreeBuilder tb) {
+            boolean processed = tb.process(new Token.EndTag("colgroup"));
+            if (processed) // only ignored in frag case
+                return tb.process(t);
+            return true;
+        }
+    },
+    InTableBody {
+        boolean process(Token t, TreeBuilder tb) {
+            switch (t.type) {
+                case StartTag:
+                    Token.StartTag startTag = t.asStartTag();
+                    String name = startTag.name();
+                    if (name.equals("tr")) {
+                        tb.clearStackToTableBodyContext();
+                        tb.insert(startTag);
+                        tb.transition(InRow);
+                    } else if (StringUtil.in(name, "th", "td")) {
+                        tb.error(this);
+                        tb.process(new Token.StartTag("tr"));
+                        return tb.process(startTag);
+                    } else if (StringUtil.in(name, "caption", "col", "colgroup", "tbody", "tfoot", "thead")) {
+                        return exitTableBody(t, tb);
+                    } else
+                        return anythingElse(t, tb);
+                    break;
+                case EndTag:
+                    Token.EndTag endTag = t.asEndTag();
+                    name = endTag.name();
+                    if (StringUtil.in(name, "tbody", "tfoot", "thead")) {
+                        if (!tb.inTableScope(name)) {
+                            tb.error(this);
+                            return false;
+                        } else {
+                            tb.clearStackToTableBodyContext();
+                            tb.pop();
+                            tb.transition(InTable);
+                        }
+                    } else if (name.equals("table")) {
+                        return exitTableBody(t, tb);
+                    } else if (StringUtil.in(name, "body", "caption", "col", "colgroup", "html", "td", "th", "tr")) {
+                        tb.error(this);
+                        return false;
+                    } else
+                        return anythingElse(t, tb);
+                    break;
+                default:
+                    return anythingElse(t, tb);
+            }
+            return true;
+        }
+
+        private boolean exitTableBody(Token t, TreeBuilder tb) {
+            if (!(tb.inTableScope("tbody") || tb.inTableScope("thead") || tb.inScope("tfoot"))) {
+                // frag case
+                tb.error(this);
+                return false;
+            }
+            tb.clearStackToTableBodyContext();
+            tb.process(new Token.EndTag(tb.currentElement().nodeName())); // tbody, tfoot, thead
+            return tb.process(t);
+        }
+
+        private boolean anythingElse(Token t, TreeBuilder tb) {
+            return tb.process(t, InTable);
+        }
+    },
+    InRow {
+        boolean process(Token t, TreeBuilder tb) {
+            if (t.isStartTag()) {
+                Token.StartTag startTag = t.asStartTag();
+                String name = startTag.name();
+
+                if (StringUtil.in(name, "th", "td")) {
+                    tb.clearStackToTableRowContext();
+                    tb.insert(startTag);
+                    tb.transition(InCell);
+                    tb.insertMarkerToFormattingElements();
+                } else if (StringUtil.in(name, "caption", "col", "colgroup", "tbody", "tfoot", "thead", "tr")) {
+                    return handleMissingTr(t, tb);
+                } else {
+                    return anythingElse(t, tb);
+                }
+            } else if (t.isEndTag()) {
+                Token.EndTag endTag = t.asEndTag();
+                String name = endTag.name();
+
+                if (name.equals("tr")) {
+                    if (!tb.inTableScope(name)) {
+                        tb.error(this); // frag
+                        return false;
+                    }
+                    tb.clearStackToTableRowContext();
+                    tb.pop(); // tr
+                    tb.transition(InTableBody);
+                } else if (name.equals("table")) {
+                    return handleMissingTr(t, tb);
+                } else if (StringUtil.in(name, "tbody", "tfoot", "thead")) {
+                    if (!tb.inTableScope(name)) {
+                        tb.error(this);
+                        return false;
+                    }
+                    tb.process(new Token.EndTag("tr"));
+                    return tb.process(t);
+                } else if (StringUtil.in(name, "body", "caption", "col", "colgroup", "html", "td", "th")) {
+                    tb.error(this);
+                    return false;
+                } else {
+                    return anythingElse(t, tb);
+                }
+            } else {
+                return anythingElse(t, tb);
+            }
+            return true;
+        }
+
+        private boolean anythingElse(Token t, TreeBuilder tb) {
+            return tb.process(t, InTable);
+        }
+
+        private boolean handleMissingTr(Token t, TreeBuilder tb) {
+            boolean processed = tb.process(new Token.EndTag("tr"));
+            if (processed)
+                return tb.process(t);
+            else
+                return false;
+        }
+    },
+    InCell {
+        boolean process(Token t, TreeBuilder tb) {
+            if (t.isEndTag()) {
+                Token.EndTag endTag = t.asEndTag();
+                String name = endTag.name();
+
+                if (StringUtil.in(name, "td", "th")) {
+                    if (!tb.inTableScope(name)) {
+                        tb.error(this);
+                        tb.transition(InRow); // might not be in scope if empty: <td /> and processing fake end tag
+                        return false;
+                    }
+                    tb.generateImpliedEndTags();
+                    if (!tb.currentElement().nodeName().equals(name))
+                        tb.error(this);
+                    tb.popStackToClose(name);
+                    tb.clearFormattingElementsToLastMarker();
+                    tb.transition(InRow);
+                } else if (StringUtil.in(name, "body", "caption", "col", "colgroup", "html")) {
+                    tb.error(this);
+                    return false;
+                } else if (StringUtil.in(name, "table", "tbody", "tfoot", "thead", "tr")) {
+                    if (!tb.inTableScope(name)) {
+                        tb.error(this);
+                        return false;
+                    }
+                    closeCell(tb);
+                    return tb.process(t);
+                } else {
+                    return anythingElse(t, tb);
+                }
+            } else if (t.isStartTag() &&
+                    StringUtil.in(t.asStartTag().name(),
+                            "caption", "col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr")) {
+                if (!(tb.inTableScope("td") || tb.inTableScope("th"))) {
+                    tb.error(this);
+                    return false;
+                }
+                closeCell(tb);
+                return tb.process(t);
+            } else {
+                return anythingElse(t, tb);
+            }
+            return true;
+        }
+
+        private boolean anythingElse(Token t, TreeBuilder tb) {
+            return tb.process(t, InBody);
+        }
+
+        private void closeCell(TreeBuilder tb) {
+            if (tb.inTableScope("td"))
+                tb.process(new Token.EndTag("td"));
+            else
+                tb.process(new Token.EndTag("th")); // only here if th or td in scope
+        }
+    },
+    InSelect {
+        boolean process(Token t, TreeBuilder tb) {
+            switch (t.type) {
+                case Character:
+                    Token.Character c = t.asCharacter();
+                    if (c.getData().equals(nullString)) {
+                        tb.error(this);
+                        return false;
+                    } else {
+                        tb.insert(c);
+                    }
+                    break;
+                case Comment:
+                    tb.insert(t.asComment());
+                    break;
+                case Doctype:
+                    tb.error(this);
+                    return false;
+                case StartTag:
+                    Token.StartTag start = t.asStartTag();
+                    String name = start.name();
+                    if (name.equals("html"))
+                        return tb.process(start, InBody);
+                    else if (name.equals("option")) {
+                        tb.process(new Token.EndTag("option"));
+                        tb.insert(start);
+                    } else if (name.equals("optgroup")) {
+                        if (tb.currentElement().nodeName().equals("option"))
+                            tb.process(new Token.EndTag("option"));
+                        else if (tb.currentElement().nodeName().equals("optgroup"))
+                            tb.process(new Token.EndTag("optgroup"));
+                        tb.insert(start);
+                    } else if (name.equals("select")) {
+                        tb.error(this);
+                        return tb.process(new Token.EndTag("select"));
+                    } else if (StringUtil.in(name, "input", "keygen", "textarea")) {
+                        tb.error(this);
+                        if (!tb.inSelectScope("select"))
+                            return false; // frag
+                        tb.process(new Token.EndTag("select"));
+                        return tb.process(start);
+                    } else if (name.equals("script")) {
+                        return tb.process(t, InHead);
+                    } else {
+                        return anythingElse(t, tb);
+                    }
+                    break;
+                case EndTag:
+                    Token.EndTag end = t.asEndTag();
+                    name = end.name();
+                    if (name.equals("optgroup")) {
+                        if (tb.currentElement().nodeName().equals("option") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals("optgroup"))
+                            tb.process(new Token.EndTag("option"));
+                        if (tb.currentElement().nodeName().equals("optgroup"))
+                            tb.pop();
+                        else
+                            tb.error(this);
+                    } else if (name.equals("option")) {
+                        if (tb.currentElement().nodeName().equals("option"))
+                            tb.pop();
+                        else
+                            tb.error(this);
+                    } else if (name.equals("select")) {
+                        if (!tb.inSelectScope(name)) {
+                            tb.error(this);
+                            return false;
+                        } else {
+                            tb.popStackToClose(name);
+                            tb.resetInsertionMode();
+                        }
+                    } else
+                        return anythingElse(t, tb);
+                    break;
+                case EOF:
+                    if (!tb.currentElement().nodeName().equals("html"))
+                        tb.error(this);
+                    break;
+                default:
+                    return anythingElse(t, tb);
+            }
+            return true;
+        }
+
+        private boolean anythingElse(Token t, TreeBuilder tb) {
+            tb.error(this);
+            return false;
+        }
+    },
+    InSelectInTable {
+        boolean process(Token t, TreeBuilder tb) {
+            if (t.isStartTag() && StringUtil.in(t.asStartTag().name(), "caption", "table", "tbody", "tfoot", "thead", "tr", "td", "th")) {
+                tb.error(this);
+                tb.process(new Token.EndTag("select"));
+                return tb.process(t);
+            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(), "caption", "table", "tbody", "tfoot", "thead", "tr", "td", "th")) {
+                tb.error(this);
+                if (tb.inTableScope(t.asEndTag().name())) {
+                    tb.process(new Token.EndTag("select"));
+                    return (tb.process(t));
+                } else
+                    return false;
+            } else {
+                return tb.process(t, InSelect);
+            }
+        }
+    },
+    AfterBody {
+        boolean process(Token t, TreeBuilder tb) {
+            if (isWhitespace(t)) {
+                return tb.process(t, InBody);
+            } else if (t.isComment()) {
+                tb.insert(t.asComment()); // into html node
+            } else if (t.isDoctype()) {
+                tb.error(this);
+                return false;
+            } else if (t.isStartTag() && t.asStartTag().name().equals("html")) {
+                return tb.process(t, InBody);
+            } else if (t.isEndTag() && t.asEndTag().name().equals("html")) {
+                if (tb.isFragmentParsing()) {
+                    tb.error(this);
+                    return false;
+                } else {
+                    tb.transition(AfterAfterBody);
+                }
+            } else if (t.isEOF()) {
+                // chillax! we're done
+            } else {
+                tb.error(this);
+                tb.transition(InBody);
+                return tb.process(t);
+            }
+            return true;
+        }
+    },
+    InFrameset {
+        boolean process(Token t, TreeBuilder tb) {
+            if (isWhitespace(t)) {
+                tb.insert(t.asCharacter());
+            } else if (t.isComment()) {
+                tb.insert(t.asComment());
+            } else if (t.isDoctype()) {
+                tb.error(this);
+                return false;
+            } else if (t.isStartTag()) {
+                Token.StartTag start = t.asStartTag();
+                String name = start.name();
+                if (name.equals("html")) {
+                    return tb.process(start, InBody);
+                } else if (name.equals("frameset")) {
+                    tb.insert(start);
+                } else if (name.equals("frame")) {
+                    tb.insertEmpty(start);
+                } else if (name.equals("noframes")) {
+                    return tb.process(start, InHead);
+                } else {
+                    tb.error(this);
+                    return false;
+                }
+            } else if (t.isEndTag() && t.asEndTag().name().equals("frameset")) {
+                if (tb.currentElement().nodeName().equals("html")) { // frag
+                    tb.error(this);
+                    return false;
+                } else {
+                    tb.pop();
+                    if (!tb.isFragmentParsing() && !tb.currentElement().nodeName().equals("frameset")) {
+                        tb.transition(AfterFrameset);
+                    }
+                }
+            } else if (t.isEOF()) {
+                if (!tb.currentElement().nodeName().equals("html")) {
+                    tb.error(this);
+                    return true;
+                }
+            } else {
+                tb.error(this);
+                return false;
+            }
+            return true;
+        }
+    },
+    AfterFrameset {
+        boolean process(Token t, TreeBuilder tb) {
+            if (isWhitespace(t)) {
+                tb.insert(t.asCharacter());
+            } else if (t.isComment()) {
+                tb.insert(t.asComment());
+            } else if (t.isDoctype()) {
+                tb.error(this);
+                return false;
+            } else if (t.isStartTag() && t.asStartTag().name().equals("html")) {
+                return tb.process(t, InBody);
+            } else if (t.isEndTag() && t.asEndTag().name().equals("html")) {
+                tb.transition(AfterAfterFrameset);
+            } else if (t.isStartTag() && t.asStartTag().name().equals("noframes")) {
+                return tb.process(t, InHead);
+            } else if (t.isEOF()) {
+                // cool your heels, we're complete
+            } else {
+                tb.error(this);
+                return false;
+            }
+            return true;
+        }
+    },
+    AfterAfterBody {
+        boolean process(Token t, TreeBuilder tb) {
+            if (t.isComment()) {
+                tb.insert(t.asComment());
+            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().name().equals("html"))) {
+                return tb.process(t, InBody);
+            } else if (t.isEOF()) {
+                // nice work chuck
+            } else {
+                tb.error(this);
+                tb.transition(InBody);
+                return tb.process(t);
+            }
+            return true;
+        }
+    },
+    AfterAfterFrameset {
+        boolean process(Token t, TreeBuilder tb) {
+            if (t.isComment()) {
+                tb.insert(t.asComment());
+            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().name().equals("html"))) {
+                return tb.process(t, InBody);
+            } else if (t.isEOF()) {
+                // nice work chuck
+            } else if (t.isStartTag() && t.asStartTag().name().equals("nofrmes")) {
+                return tb.process(t, InHead);
+            } else {
+                tb.error(this);
+                tb.transition(InBody);
+                return tb.process(t);
+            }
+            return true;
+        }
+    },
+    ForeignContent {
+        boolean process(Token t, TreeBuilder tb) {
+            return true;
+            // todo: implement. Also; how do we get here?
+        }
+    };
+
+    private static String nullString = String.valueOf(0x0000);
+
+    abstract boolean process(Token t, TreeBuilder tb);
+
+    private static boolean isWhitespace(Token t) {
+        if (t.isCharacter()) {
+            String data = t.asCharacter().getData();
+            // todo: this checks more than spec - "\t", "\n", "\f", "\r", " "
+            for (int i = 0; i < data.length(); i++) {
+                char c = data.charAt(i);
+                if (!Character.isWhitespace(c))
+                    return false;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    private static void handleRcData(Token.StartTag startTag, TreeBuilder tb) {
+        tb.insert(startTag);
+        tb.tokeniser.transition(TokeniserState.Rcdata);
+        tb.markInsertionMode();
+        tb.transition(Text);
+    }
+
+    private static void handleRawtext(Token.StartTag startTag, TreeBuilder tb) {
+        tb.insert(startTag);
+        tb.tokeniser.transition(TokeniserState.Rawtext);
+        tb.markInsertionMode();
+        tb.transition(Text);
+    }
+}
diff --git a/src/test/java/org/jsoup/nodes/DocumentTest.java b/src/test/java/org/jsoup/nodes/DocumentTest.java
index 1f62d59..3a2fa1c 100644
--- a/src/test/java/org/jsoup/nodes/DocumentTest.java
+++ b/src/test/java/org/jsoup/nodes/DocumentTest.java
@@ -55,8 +55,8 @@
     }
 
     @Test public void testNormalisesStructure() {
-        Document doc = Jsoup.parse("<html><head><script>one</script><noscript><p>two</p></noscript></head><body><p>three</p></body></html>");
-        assertEquals("<html><head><script>one</script><noscript></noscript></head><body><p>two</p><p>three</p></body></html>", TextUtil.stripNewlines(doc.html()));
+        Document doc = Jsoup.parse("<html><head><script>one</script><noscript><p>two</p></noscript></head><body><p>three</p></body><p>four</p></html>");
+        assertEquals("<html><head><script>one</script><noscript></noscript></head><body><p>two</p><p>three</p><p>four</p></body></html>", TextUtil.stripNewlines(doc.html()));
     }
 
     @Test public void testClone() {
diff --git a/src/test/java/org/jsoup/nodes/ElementTest.java b/src/test/java/org/jsoup/nodes/ElementTest.java
index 7cada58..1bc63ed 100644
--- a/src/test/java/org/jsoup/nodes/ElementTest.java
+++ b/src/test/java/org/jsoup/nodes/ElementTest.java
@@ -276,18 +276,18 @@
 
     @Test public void testAppendRowToTable() {
         Document doc = Jsoup.parse("<table><tr><td>1</td></tr></table>");
-        Element table = doc.select("table").first();
+        Element table = doc.select("tbody").first();
         table.append("<tr><td>2</td></tr>");
 
-        assertEquals("<table><tr><td>1</td></tr><tr><td>2</td></tr></table>", TextUtil.stripNewlines(doc.body().html()));
+        assertEquals("<table><tbody><tr><td>1</td></tr><tr><td>2</td></tr></tbody></table>", TextUtil.stripNewlines(doc.body().html()));
     }
 
         @Test public void testPrependRowToTable() {
         Document doc = Jsoup.parse("<table><tr><td>1</td></tr></table>");
-        Element table = doc.select("table").first();
+        Element table = doc.select("tbody").first();
         table.prepend("<tr><td>2</td></tr>");
 
-        assertEquals("<table><tr><td>2</td></tr><tr><td>1</td></tr></table>", TextUtil.stripNewlines(doc.body().html()));
+        assertEquals("<table><tbody><tr><td>2</td></tr><tr><td>1</td></tr></tbody></table>", TextUtil.stripNewlines(doc.body().html()));
 
         // check sibling index (reindexChildren):
         Elements ps = doc.select("tr");
diff --git a/src/test/java/org/jsoup/nodes/NodeTest.java b/src/test/java/org/jsoup/nodes/NodeTest.java
index 274ebcb..24f818d 100644
--- a/src/test/java/org/jsoup/nodes/NodeTest.java
+++ b/src/test/java/org/jsoup/nodes/NodeTest.java
@@ -84,4 +84,28 @@
         assertTrue(doc.ownerDocument() == doc);
         assertNull(doc.parent());
     }
+
+    @Test public void before() {
+        Document doc = Jsoup.parse("<p>One <b>two</b> three</p>");
+        Element newNode = new Element(Tag.valueOf("em"), "");
+        newNode.appendText("four");
+
+        doc.select("b").first().before(newNode);
+        assertEquals("<p>One <em>four</em><b>two</b> three</p>", doc.body().html());
+
+        doc.select("b").first().before("<i>five</i>");
+        assertEquals("<p>One <em>four</em><i>five</i><b>two</b> three</p>", doc.body().html());
+    }
+
+    @Test public void after() {
+        Document doc = Jsoup.parse("<p>One <b>two</b> three</p>");
+        Element newNode = new Element(Tag.valueOf("em"), "");
+        newNode.appendText("four");
+
+        doc.select("b").first().after(newNode);
+        assertEquals("<p>One <b>two</b><em>four</em> three</p>", doc.body().html());
+
+        doc.select("b").first().after("<i>five</i>");
+        assertEquals("<p>One <b>two</b><i>five</i><em>four</em> three</p>", doc.body().html());
+    }
 }
diff --git a/src/test/java/org/jsoup/parser/AttributeParseTest.java b/src/test/java/org/jsoup/parser/AttributeParseTest.java
index 59521dc..86fd019 100644
--- a/src/test/java/org/jsoup/parser/AttributeParseTest.java
+++ b/src/test/java/org/jsoup/parser/AttributeParseTest.java
@@ -37,17 +37,19 @@
         assertEquals(0, attr.size());
     }
 
-    @Test public void emptyOnNoKey() {
+    @Test public void canStartWithEq() {
         String html = "<a =empty />";
         Element el = Jsoup.parse(html).getElementsByTag("a").get(0);
         Attributes attr = el.attributes();
-        assertEquals(0, attr.size());
+        assertEquals(1, attr.size());
+        assertTrue(attr.hasKey("=empty"));
+        assertEquals("", attr.get("=empty"));
     }
 
     @Test public void strictAttributeUnescapes() {
         String html = "<a id=1 href='?foo=bar&mid&lt=true'>One</a> <a id=2 href='?foo=bar&lt;qux&lg=1'>Two</a>";
         Elements els = Jsoup.parse(html).select("a");
-        assertEquals("?foo=bar&mid&lt=true", els.first().attr("href"));
+        assertEquals("?foo=bar∣&lt=true", els.first().attr("href")); // &mid gets to ∣ because not tailed by =; lt is so not unescaped
         assertEquals("?foo=bar<qux&lg=1", els.last().attr("href"));
     }
 }
diff --git a/src/test/java/org/jsoup/parser/ParserTest.java b/src/test/java/org/jsoup/parser/ParserTest.java
index 7684ba1..f6795b0 100644
--- a/src/test/java/org/jsoup/parser/ParserTest.java
+++ b/src/test/java/org/jsoup/parser/ParserTest.java
@@ -11,7 +11,8 @@
 
 import java.util.List;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  Tests for the Parser
@@ -39,23 +40,22 @@
         assertEquals("p", p.tagName());
         assertEquals("foo > bar", p.attr("class"));
     }
-    
+
     @Test public void parsesQuiteRoughAttributes() {
-        String html = "<p =a>One<a =a";
+        String html = "<p =a>One<a <p>Something</p>Else";
+        // this gets a <p> with attr '=a' and an <a tag with an attribue named '<p'; and then auto-recreated
         Document doc = Jsoup.parse(html);
-        assertEquals("<p>One<a></a></p>", doc.body().html());
-        
-        doc = Jsoup.parse("<p .....");
-        assertEquals("<p></p>", doc.body().html());
-        
-        doc = Jsoup.parse("<p .....<p!!");
-        assertEquals("<p></p>\n<p></p>", doc.body().html());
+        assertEquals("<p =a=\"\">One<a <p=\"\">Something</a></p>\n" +
+                "<a <p=\"\">Else</a>", doc.body().html());
+
+        doc = Jsoup.parse("<p .....>");
+        assertEquals("<p .....=\"\"></p>", doc.body().html());
     }
 
     @Test public void parsesComments() {
         String html = "<html><head></head><body><img src=foo><!-- <table><tr><td></table> --><p>Hello</p></body></html>";
         Document doc = Jsoup.parse(html);
-        
+
         Element body = doc.body();
         Comment comment = (Comment) body.childNode(1); // comment should not be sub of img, as it's an empty tag
         assertEquals(" <table><tr><td></table> ", comment.getData());
@@ -75,41 +75,40 @@
         assertEquals(" <tr><td>", comment.getData());
     }
 
-    @Test public void parsesUnterminatedTag() {
+    @Test public void dropsUnterminatedTag() {
+        // jsoup used to parse this to <p>, but whatwg, webkit will drop.
         String h1 = "<p";
         Document doc = Jsoup.parse(h1);
-        assertEquals(1, doc.getElementsByTag("p").size());
+        assertEquals(0, doc.getElementsByTag("p").size());
+        assertEquals("", doc.text());
 
         String h2 = "<div id=1<p id='2'";
         doc = Jsoup.parse(h2);
-        Element d = doc.getElementById("1");
-        assertEquals(1, d.children().size());
-        Element p = doc.getElementById("2");
-        assertNotNull(p);
+        assertEquals("", doc.text());
     }
 
-    @Test public void parsesUnterminatedAttribute() {
+    @Test public void dropsUnterminatedAttribute() {
+        // jsoup used to parse this to <p id="foo">, but whatwg, webkit will drop.
         String h1 = "<p id=\"foo";
         Document doc = Jsoup.parse(h1);
-        Element p = doc.getElementById("foo");
-        assertNotNull(p);
-        assertEquals("p", p.tagName());
+        assertEquals("", doc.text());
     }
-    
+
     @Test public void parsesUnterminatedTextarea() {
         Document doc = Jsoup.parse("<body><p><textarea>one<p>two");
         Element t = doc.select("textarea").first();
         assertEquals("one<p>two", t.text());
     }
-    
+
     @Test public void parsesUnterminatedOption() {
+        // bit weird this -- browsers and spec get stuck in select until there's a </select>
         Document doc = Jsoup.parse("<body><p><select><option>One<option>Two</p><p>Three</p>");
         Elements options = doc.select("option");
         assertEquals(2, options.size());
         assertEquals("One", options.first().text());
-        assertEquals("Two", options.last().text());
+        assertEquals("TwoThree", options.last().text());
     }
-    
+
     @Test public void testSpaceAfterTag() {
         Document doc = Jsoup.parse("<div > <a name=\"top\"></a ><p id=1 >Hello</p></div>");
         assertEquals("<div> <a name=\"top\"></a><p id=\"1\">Hello</p></div>", TextUtil.stripNewlines(doc.body().html()));
@@ -138,7 +137,7 @@
         // needs to move into the start of the body
         String html = "foo <b>bar</b> baz";
         Document doc = Jsoup.parse(html);
-        assertEquals ("foo bar baz", doc.text());
+        assertEquals("foo bar baz", doc.text());
 
     }
 
@@ -168,7 +167,7 @@
         Document doc = Jsoup.parse(h);
         assertEquals("<html><head></head><body>pre <script>inner</script> aft</body></html>", TextUtil.stripNewlines(doc.html()));
     }
-    
+
     @Test public void handlesTextArea() {
         Document doc = Jsoup.parse("<textarea>Hello</textarea>");
         Elements els = doc.select("textarea");
@@ -176,12 +175,15 @@
         assertEquals("Hello", els.val());
     }
 
-    @Test public void createsImplicitLists() {
+    @Test public void doesNotCreateImplicitLists() {
+        // old jsoup used to wrap this in <ul>, but that's not to spec
         String h = "<li>Point one<li>Point two";
         Document doc = Jsoup.parse(h);
-        Elements ol = doc.select("ul"); // should have created a default ul.
-        assertEquals(1, ol.size());
-        assertEquals(2, ol.get(0).children().size());
+        Elements ol = doc.select("ul"); // should NOT have created a default ul.
+        assertEquals(0, ol.size());
+        Elements lis = doc.select("li");
+        assertEquals(2, lis.size());
+        assertEquals("body", lis.first().parent().tagName());
 
         // no fiddling with non-implicit lists
         String h2 = "<ol><li><p>Point the first<li><p>Point the second";
@@ -194,47 +196,50 @@
         assertEquals(1, doc2.select("ol li").get(0).children().size()); // one p in first li
     }
 
-    @Test public void createsImplicitTable() {
+    @Test public void discardsNakedTds() {
+        // jsoup used to make this into an implicit table; but browsers make it into a text run
         String h = "<td>Hello<td><p>There<p>now";
         Document doc = Jsoup.parse(h);
-        assertEquals("<table><tbody><tr><td>Hello</td><td><p>There</p><p>now</p></td></tr></tbody></table>", TextUtil.stripNewlines(doc.body().html()));
+        assertEquals("Hello<p>There</p><p>now</p>", TextUtil.stripNewlines(doc.body().html()));
         // <tbody> is introduced if no implicitly creating table, but allows tr to be directly under table
     }
 
-     @Test public void handlesNestedImplicitTable() {
+    @Test public void handlesNestedImplicitTable() {
         Document doc = Jsoup.parse("<table><td>1</td></tr> <td>2</td></tr> <td> <table><td>3</td> <td>4</td></table> <tr><td>5</table>");
-        assertEquals("<table><tr><td>1</td></tr> <tr><td>2</td></tr> <tr><td> <table><tr><td>3</td> <td>4</td></tr></table> </td></tr><tr><td>5</td></tr></table>", TextUtil.stripNewlines(doc.body().html()));
+        assertEquals("<table><tbody><tr><td>1</td></tr> <tr><td>2</td></tr> <tr><td> <table><tbody><tr><td>3</td> <td>4</td></tr></tbody></table> </td></tr><tr><td>5</td></tr></tbody></table>", TextUtil.stripNewlines(doc.body().html()));
     }
-    
+
     @Test public void handlesWhatWgExpensesTableExample() {
         // http://www.whatwg.org/specs/web-apps/current-work/multipage/tabular-data.html#examples-0
         Document doc = Jsoup.parse("<table> <colgroup> <col> <colgroup> <col> <col> <col> <thead> <tr> <th> <th>2008 <th>2007 <th>2006 <tbody> <tr> <th scope=rowgroup> Research and development <td> $ 1,109 <td> $ 782 <td> $ 712 <tr> <th scope=row> Percentage of net sales <td> 3.4% <td> 3.3% <td> 3.7% <tbody> <tr> <th scope=rowgroup> Selling, general, and administrative <td> $ 3,761 <td> $ 2,963 <td> $ 2,433 <tr> <th scope=row> Percentage of net sales <td> 11.6% <td> 12.3% <td> 12.6% </table>");
         assertEquals("<table> <colgroup> <col /> </colgroup><colgroup> <col /> <col /> <col /> </colgroup><thead> <tr> <th> </th><th>2008 </th><th>2007 </th><th>2006 </th></tr></thead><tbody> <tr> <th scope=\"rowgroup\"> Research and development </th><td> $ 1,109 </td><td> $ 782 </td><td> $ 712 </td></tr><tr> <th scope=\"row\"> Percentage of net sales </th><td> 3.4% </td><td> 3.3% </td><td> 3.7% </td></tr></tbody><tbody> <tr> <th scope=\"rowgroup\"> Selling, general, and administrative </th><td> $ 3,761 </td><td> $ 2,963 </td><td> $ 2,433 </td></tr><tr> <th scope=\"row\"> Percentage of net sales </th><td> 11.6% </td><td> 12.3% </td><td> 12.6% </td></tr></tbody></table>", TextUtil.stripNewlines(doc.body().html()));
     }
-    
+
     @Test public void handlesTbodyTable() {
         Document doc = Jsoup.parse("<html><head></head><body><table><tbody><tr><td>aaa</td><td>bbb</td></tr></tbody></table></body></html>");
         assertEquals("<table><tbody><tr><td>aaa</td><td>bbb</td></tr></tbody></table>", TextUtil.stripNewlines(doc.body().html()));
     }
-    
+
     @Test public void handlesImplicitCaptionClose() {
         Document doc = Jsoup.parse("<table><caption>A caption<td>One<td>Two");
-        assertEquals("<table><caption>A caption</caption><tr><td>One</td><td>Two</td></tr></table>", TextUtil.stripNewlines(doc.body().html()));
+        assertEquals("<table><caption>A caption</caption><tbody><tr><td>One</td><td>Two</td></tr></tbody></table>", TextUtil.stripNewlines(doc.body().html()));
     }
 
     @Test public void noTableDirectInTable() {
         Document doc = Jsoup.parse("<table> <td>One <td><table><td>Two</table> <table><td>Three");
-        assertEquals("<table> <tr><td>One </td><td><table><tr><td>Two</td></tr></table> <table><tr><td>Three</td></tr></table></td></tr></table>", 
-            TextUtil.stripNewlines(doc.body().html()));
+        assertEquals("<table> <tbody><tr><td>One </td><td><table><tbody><tr><td>Two</td></tr></tbody></table> <table><tbody><tr><td>Three</td></tr></tbody></table></td></tr></tbody></table>",
+                TextUtil.stripNewlines(doc.body().html()));
     }
 
     @Test public void ignoresDupeEndTrTag() {
         Document doc = Jsoup.parse("<table><tr><td>One</td><td><table><tr><td>Two</td></tr></tr></table></td><td>Three</td></tr></table>"); // two </tr></tr>, must ignore or will close table
-        assertEquals("<table><tr><td>One</td><td><table><tr><td>Two</td></tr></table></td><td>Three</td></tr></table>",
-            TextUtil.stripNewlines(doc.body().html()));
+        assertEquals("<table><tbody><tr><td>One</td><td><table><tbody><tr><td>Two</td></tr></tbody></table></td><td>Three</td></tr></tbody></table>",
+                TextUtil.stripNewlines(doc.body().html()));
     }
 
     @Test public void handlesBaseTags() {
+        // todo -- don't handle base tags like this -- spec and browsers don't (any more -- v. old ones do).
+        // instead, just maintain one baseUri in the doc
         String h = "<a href=1>#</a><base href='/2/'><a href='3'>#</a><base href='http://bar'><a href=4>#</a>";
         Document doc = Jsoup.parse(h, "http://foo/");
         assertEquals("http://bar", doc.baseUri()); // gets updated as base changes, so doc.createElement has latest.
@@ -252,7 +257,8 @@
     }
 
     @Test public void handlesCdata() {
-        String h = "<div id=1><![CData[<html>\n<foo><&amp;]]></div>"; // "cdata" insensitive. the &amp; in there should remain literal
+        // todo: as this is html namespace, should actually treat as bogus comment, not cdata. keep as cdata for now
+        String h = "<div id=1><![CDATA[<html>\n<foo><&amp;]]></div>"; // the &amp; in there should remain literal
         Document doc = Jsoup.parse(h);
         Element div = doc.getElementById("1");
         assertEquals("<html> <foo><&amp;", div.text());
@@ -265,7 +271,7 @@
         Document doc = Jsoup.parse(h);
         assertEquals("Hello < There <&>", doc.select("div").first().text());
     }
-    
+
     @Test public void handlesUnknownTags() {
         String h = "<div><foo title=bar>Hello<foo title=qux>there</foo></div>";
         Document doc = Jsoup.parse(h);
@@ -282,32 +288,53 @@
         String out = doc.body().html();
         assertEquals(h, TextUtil.stripNewlines(out));
     }
-    
+
+    @Test public void parsesBodyFragment() {
+        String h = "<!-- comment --><p><a href='foo'>One</a></p>";
+        Document doc = Jsoup.parseBodyFragment(h, "http://example.com");
+        assertEquals("<body><!-- comment --><p><a href=\"foo\">One</a></p></body>", TextUtil.stripNewlines(doc.body().outerHtml()));
+        assertEquals("http://example.com/foo", doc.select("a").first().absUrl("href"));
+    }
+
     @Test public void handlesUnknownNamespaceTags() {
-        String h = "<foo:bar id=1/><abc:def id=2>Foo<p>Hello</abc:def><foo:bar>There</foo:bar>";
+        // note that the first foo:bar should not really be allowed to be self closing, if parsed in html mode.
+        String h = "<foo:bar id='1' /><abc:def id=2>Foo<p>Hello</p></abc:def><foo:bar>There</foo:bar>";
         Document doc = Jsoup.parse(h);
         assertEquals("<foo:bar id=\"1\" /><abc:def id=\"2\">Foo<p>Hello</p></abc:def><foo:bar>There</foo:bar>", TextUtil.stripNewlines(doc.body().html()));
     }
-    
-    @Test public void handlesEmptyBlocks() {
-        String h = "<div id=1/><div id=2><img /></div> <hr /> hr text";
+
+    @Test public void handlesKnownEmptyBlocks() {
+        // if known tag, must be defined as self closing to allow as self closing. unkown tags can be self closing.
+        String h = "<div id='1' /><div id=2><img /><img></div> <hr /> hr text <hr> hr text two";
         Document doc = Jsoup.parse(h);
         Element div1 = doc.getElementById("1");
-        assertTrue(div1.children().isEmpty());
+        assertTrue(!div1.children().isEmpty()); // <div /> is treated as <div>...
         assertTrue(doc.select("hr").first().children().isEmpty());
+        assertTrue(doc.select("hr").last().children().isEmpty());
+        assertTrue(doc.select("img").first().children().isEmpty());
+        assertTrue(doc.select("img").last().children().isEmpty());
     }
-    
+
+    @Test public void handlesSolidusAtAttributeEnd() {
+        // this test makes sure [<a href=/>link</a>] is parsed as [<a href="/">link</a>], not [<a href="" /><a>link</a>]
+        String h = "<a href=/>link</a>";
+        Document doc = Jsoup.parse(h);
+        assertEquals("<a href=\"/\">link</a>", doc.body().html());
+    }
+
     @Test public void handlesMultiClosingBody() {
         String h = "<body><p>Hello</body><p>there</p></body></body></html><p>now";
         Document doc = Jsoup.parse(h);
         assertEquals(3, doc.select("p").size());
         assertEquals(3, doc.body().children().size());
     }
-    
+
     @Test public void handlesUnclosedDefinitionLists() {
+        // jsoup used to create a <dl>, but that's not to spec
         String h = "<dt>Foo<dd>Bar<dt>Qux<dd>Zug";
         Document doc = Jsoup.parse(h);
-        assertEquals(4, doc.body().getElementsByTag("dl").first().children().size());
+        assertEquals(0, doc.select("dl").size()); // no auto dl
+        assertEquals(4, doc.select("dt, dd").size());
         Elements dts = doc.select("dt");
         assertEquals(2, dts.size());
         assertEquals("Zug", dts.get(1).nextElementSibling().text());
@@ -325,8 +352,9 @@
     @Test public void handlesFrames() {
         String h = "<html><head><script></script><noscript></noscript></head><frameset><frame src=foo></frame><frame src=foo></frameset></html>";
         Document doc = Jsoup.parse(h);
-        assertEquals("<html><head><script></script><noscript></noscript></head><frameset><frame src=\"foo\" /><frame src=\"foo\" /></frameset><body></body></html>",
+        assertEquals("<html><head><script></script><noscript></noscript></head><frameset><frame src=\"foo\" /><frame src=\"foo\" /></frameset></html>",
                 TextUtil.stripNewlines(doc.html()));
+        // no body auto vivification
     }
 
     @Test public void handlesJavadocFont() {
@@ -349,13 +377,13 @@
     @Test public void normalisesDocument() {
         String h = "<!doctype html>One<html>Two<head>Three<link></head>Four<body>Five </body>Six </html>Seven ";
         Document doc = Jsoup.parse(h);
-        assertEquals("<!doctype html><html><head><link /></head><body>One Two Four Three Five Six Seven </body></html>",
-                TextUtil.stripNewlines(doc.html())); // is spaced OK if not newline & space stripped
+        assertEquals("<!DOCTYPE html><html><head></head><body>OneTwoThree<link />FourFive Six Seven </body></html>",
+                TextUtil.stripNewlines(doc.html()));
     }
 
     @Test public void normalisesEmptyDocument() {
         Document doc = Jsoup.parse("");
-        assertEquals("<html><head></head><body></body></html>",TextUtil.stripNewlines(doc.html()));
+        assertEquals("<html><head></head><body></body></html>", TextUtil.stripNewlines(doc.html()));
     }
 
     @Test public void normalisesHeadlessBody() {
@@ -363,19 +391,20 @@
         assertEquals("<html><head></head><body><span class=\"foo\">bar</span></body></html>",
                 TextUtil.stripNewlines(doc.html()));
     }
-    
+
     @Test public void findsCharsetInMalformedMeta() {
         String h = "<meta http-equiv=Content-Type content=text/html; charset=gb2312>";
         // example cited for reason of html5's <meta charset> element
         Document doc = Jsoup.parse(h);
         assertEquals("gb2312", doc.select("meta").attr("charset"));
     }
-    
+
     @Test public void testHgroup() {
+        // jsoup used to not allow hroup in h{n}, but that's not in spec, and browsers are OK
         Document doc = Jsoup.parse("<h1>Hello <h2>There <hgroup><h1>Another<h2>headline</hgroup> <hgroup><h1>More</h1><p>stuff</p></hgroup>");
-        assertEquals("<h1>Hello </h1><h2>There </h2><hgroup><h1>Another</h1><h2>headline</h2></hgroup> <hgroup><h1>More</h1></hgroup><p>stuff</p>", TextUtil.stripNewlines(doc.body().html()));
+        assertEquals("<h1>Hello </h1><h2>There <hgroup><h1>Another</h1><h2>headline</h2></hgroup> <hgroup><h1>More</h1><p>stuff</p></hgroup></h2>", TextUtil.stripNewlines(doc.body().html()));
     }
-    
+
     @Test public void testRelaxedTags() {
         Document doc = Jsoup.parse("<abc_def id=1>Hello</abc_def> <abc-def>There</abc-def>");
         assertEquals("<abc_def id=\"1\">Hello</abc_def> <abc-def>There</abc-def>", TextUtil.stripNewlines(doc.body().html()));
@@ -394,10 +423,10 @@
         assertEquals("<span>Hello <div>there</div> <span>now</span></span>", TextUtil.stripNewlines(doc.body().html()));
     }
 
-    @Test public void testAllowsImageInNoScriptInHead() {
-        // some sites use this pattern as an analytics mechanism
+    @Test public void testNoImagesInNoScriptInHead() {
+        // jsoup used to allow, but against spec if parsing with noscript
         Document doc = Jsoup.parse("<html><head><noscript><img src='foo'></noscript></head><body><p>Hello</p></body></html>");
-        assertEquals("<html><head><noscript><img src=\"foo\" /></noscript></head><body><p>Hello</p></body></html>", TextUtil.stripNewlines(doc.html()));
+        assertEquals("<html><head><noscript></noscript></head><body><img src=\"foo\" /><p>Hello</p></body></html>", TextUtil.stripNewlines(doc.html()));
     }
 
     @Test public void testAFlowContents() {
@@ -406,9 +435,90 @@
         assertEquals("<a>Hello <div>there</div> <span>now</span></a>", TextUtil.stripNewlines(doc.body().html()));
     }
 
-     @Test public void testFontFlowContents() {
+    @Test public void testFontFlowContents() {
         // html5 has no definition of <font>; often used as flow
         Document doc = Jsoup.parse("<font>Hello <div>there</div> <span>now</span></font>");
         assertEquals("<font>Hello <div>there</div> <span>now</span></font>", TextUtil.stripNewlines(doc.body().html()));
     }
+
+    @Test public void handlesMisnestedTagsBI() {
+        // whatwg: <b><i></b></i>
+        String h = "<p>1<b>2<i>3</b>4</i>5</p>";
+        Document doc = Jsoup.parse(h);
+        assertEquals("<p>1<b>2<i>3</i></b><i>4</i>5</p>", doc.body().html());
+        // adoption agency on </b>, reconstruction of formatters on 4.
+    }
+
+    @Test public void handlesMisnestedTagsBP() {
+        //  whatwg: <b><p></b></p>
+        String h = "<b>1<p>2</b>3</p>";
+        Document doc = Jsoup.parse(h);
+        assertEquals("<b>1</b>\n<p><b>2</b>3</p>", doc.body().html());
+    }
+
+    @Test public void handlesUnexpectedMarkupInTables() {
+        // whatwg - tests markers in active formatting (if they didn't work, would get in in table)
+        // also tests foster parenting
+        String h = "<table><b><tr><td>aaa</td></tr>bbb</table>ccc";
+        Document doc = Jsoup.parse(h);
+        assertEquals("<b></b><b>bbb</b><table><tbody><tr><td>aaa</td></tr></tbody></table><b>ccc</b>", TextUtil.stripNewlines(doc.body().html()));
+    }
+
+    @Test public void handlesUnclosedFormattingElements() {
+        // whatwg: formatting elements get collected and applied, but excess elements are thrown away
+        String h = "<!DOCTYPE html>\n" +
+                "<p><b class=x><b class=x><b><b class=x><b class=x><b>X\n" +
+                "<p>X\n" +
+                "<p><b><b class=x><b>X\n" +
+                "<p></b></b></b></b></b></b>X";
+        Document doc = Jsoup.parse(h);
+        doc.outputSettings().indentAmount(0);
+        String want = "<!DOCTYPE html>\n" +
+                "<html>\n" +
+                "<head></head>\n" +
+                "<body>\n" +
+                "<p><b class=\"x\"><b class=\"x\"><b><b class=\"x\"><b class=\"x\"><b>X </b></b></b></b></b></b></p>\n" +
+                "<p><b class=\"x\"><b><b class=\"x\"><b class=\"x\"><b>X </b></b></b></b></b></p>\n" +
+                "<p><b class=\"x\"><b><b class=\"x\"><b class=\"x\"><b><b><b class=\"x\"><b>X </b></b></b></b></b></b></b></b></p>\n" +
+                "<p>X</p>\n" +
+                "</body>\n" +
+                "</html>";
+        assertEquals(want, doc.html());
+    }
+
+    @Test public void reconstructFormattingElements() {
+        // tests attributes and multi b
+        String h = "<p><b class=one>One <i>Two <b>Three</p><p>Hello</p>";
+        Document doc = Jsoup.parse(h);
+        assertEquals("<p><b class=\"one\">One <i>Two <b>Three</b></i></b></p>\n<p><b class=\"one\"><i><b>Hello</b></i></b></p>", doc.body().html());
+    }
+
+    @Test public void reconstructFormattingElementsInTable() {
+        // tests that tables get formatting markers -- the <b> applies outside the table and does not leak in,
+        // and the <i> inside the table and does not leak out.
+        String h = "<p><b>One</p> <table><tr><td><p><i>Three<p>Four</i></td></tr></table> <p>Five</p>";
+        Document doc = Jsoup.parse(h);
+        String want = "<p><b>One</b></p>\n" +
+                "<b> \n" +
+                " <table>\n" +
+                "  <tbody>\n" +
+                "   <tr>\n" +
+                "    <td><p><i>Three</i></p><p><i>Four</i></p></td>\n" +
+                "   </tr>\n" +
+                "  </tbody>\n" +
+                " </table> <p>Five</p></b>";
+        assertEquals(want, doc.body().html());
+    }
+
+    @Test public void commentBeforeHtml() {
+        String h = "<!-- comment --><!-- comment 2 --><p>One</p>";
+        Document doc = Jsoup.parse(h);
+        assertEquals("<!-- comment --><!-- comment 2 --><html><head></head><body><p>One</p></body></html>", TextUtil.stripNewlines(doc.html()));
+    }
+
+    @Test public void emptyTdTag() {
+        String h = "<table><tr><td>One</td><td id='2' /></tr></table>";
+        Document doc = Jsoup.parse(h);
+        assertEquals("<td>One</td>\n<td id=\"2\"></td>", doc.select("tr").first().html());
+    }
 }
diff --git a/src/test/java/org/jsoup/parser/TagTest.java b/src/test/java/org/jsoup/parser/TagTest.java
index beac7eb..bee6400 100644
--- a/src/test/java/org/jsoup/parser/TagTest.java
+++ b/src/test/java/org/jsoup/parser/TagTest.java
@@ -29,51 +29,32 @@
 
     @Test public void divSemantics() {
         Tag div = Tag.valueOf("div");
-        Tag p = Tag.valueOf("p");
 
-        assertTrue(div.canContain(div));
-        assertTrue(div.canContain(p));
+        assertTrue(div.isBlock());
+        assertTrue(div.formatAsBlock());
     }
 
     @Test public void pSemantics() {
-        Tag div = Tag.valueOf("div");
         Tag p = Tag.valueOf("p");
-        Tag img = Tag.valueOf("img");
-        Tag span = Tag.valueOf("span");
 
-        assertTrue(p.canContain(img));
-        assertTrue(p.canContain(span));
-        assertFalse(p.canContain(div));
-        assertFalse(p.canContain(p));
-    }
-
-    @Test public void spanSemantics() {
-        Tag span = Tag.valueOf("span");
-        Tag p = Tag.valueOf("p");
-        Tag div = Tag.valueOf("div");
-
-        assertTrue(span.canContain(span));
-        assertTrue(span.canContain(p));
-        assertTrue(span.canContain(div));
+        assertTrue(p.isBlock());
+        assertFalse(p.formatAsBlock());
     }
 
     @Test public void imgSemantics() {
         Tag img = Tag.valueOf("img");
-        Tag p = Tag.valueOf("p");
-
-        assertFalse(img.canContain(img));
-        assertFalse(img.canContain(p));
+        assertTrue(img.isInline());
+        assertTrue(img.isSelfClosing());
+        assertFalse(img.isBlock());
     }
 
     @Test public void defaultSemantics() {
         Tag foo = Tag.valueOf("foo"); // not defined
         Tag foo2 = Tag.valueOf("FOO");
-        Tag div = Tag.valueOf("div");
 
         assertEquals(foo, foo2);
-        assertTrue(foo.canContain(foo));
-        assertTrue(foo.canContain(div));
-        assertTrue(div.canContain(foo));
+        assertTrue(foo.isInline());
+        assertTrue(foo.formatAsBlock());
     }
 
     @Test(expected = IllegalArgumentException.class) public void valueOfChecksNotNull() {
diff --git a/src/test/java/org/jsoup/safety/CleanerTest.java b/src/test/java/org/jsoup/safety/CleanerTest.java
index 3c8836d..d249b90 100644
--- a/src/test/java/org/jsoup/safety/CleanerTest.java
+++ b/src/test/java/org/jsoup/safety/CleanerTest.java
@@ -26,7 +26,7 @@
     }
 
     @Test public void basicBehaviourTest() {
-        String h = "<div><p><a href='javascript:sendAllMoney()'>Dodgy</a> <A HREF='HTTP://nice.com'>Nice</p><blockquote>Hello</blockquote>";
+        String h = "<div><p><a href='javascript:sendAllMoney()'>Dodgy</a> <A HREF='HTTP://nice.com'>Nice</a></p><blockquote>Hello</blockquote>";
         String cleanHtml = Jsoup.clean(h, Whitelist.basic());
 
         assertEquals("<p><a rel=\"nofollow\">Dodgy</a> <a href=\"http://nice.com\" rel=\"nofollow\">Nice</a></p><blockquote>Hello</blockquote>",
@@ -40,7 +40,7 @@
     }
     
     @Test public void testRelaxed() {
-        String h = "<h1>Head</h1><td>One<td>Two</td>";
+        String h = "<h1>Head</h1><table><tr><td>One<td>Two</td></tr></table>";
         String cleanHtml = Jsoup.clean(h, Whitelist.relaxed());
         assertEquals("<h1>Head</h1><table><tbody><tr><td>One</td><td>Two</td></tr></tbody></table>", TextUtil.stripNewlines(cleanHtml));
     }
diff --git a/src/test/java/org/jsoup/select/ElementsTest.java b/src/test/java/org/jsoup/select/ElementsTest.java
index 4d13a7c..c0af17a 100644
--- a/src/test/java/org/jsoup/select/ElementsTest.java
+++ b/src/test/java/org/jsoup/select/ElementsTest.java
@@ -104,7 +104,7 @@
     
     @Test public void val() {
         Document doc = Jsoup.parse("<input value='one' /><textarea>two</textarea>");
-        Elements els = doc.select("form > *");
+        Elements els = doc.select("input, textarea");
         assertEquals(2, els.size());
         assertEquals("one", els.val());
         assertEquals("two", els.last().val());
