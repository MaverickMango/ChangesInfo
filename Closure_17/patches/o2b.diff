diff -r -u original/src/com/google/javascript/jscomp/TypedScopeCreator.java buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java
--- original/src/com/google/javascript/jscomp/TypedScopeCreator.java	2023-06-13 15:31:38.151075253 +0800
+++ buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java	2023-06-12 11:40:18.207099071 +0800
@@ -16,7 +16,6 @@
 
 package com.google.javascript.jscomp;
 
-import static com.google.javascript.jscomp.TypeCheck.ENUM_DUP;
 import static com.google.javascript.jscomp.TypeCheck.ENUM_NOT_CONSTANT;
 import static com.google.javascript.jscomp.TypeCheck.MULTIPLE_VAR_DEF;
 import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_FUNCTION_TYPE;
@@ -26,6 +25,7 @@
 import static com.google.javascript.rhino.jstype.JSTypeNative.ERROR_FUNCTION_TYPE;
 import static com.google.javascript.rhino.jstype.JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
 import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE;
+import static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS;
 import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE;
 import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;
 import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;
@@ -48,14 +48,19 @@
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.javascript.jscomp.CodingConvention.DelegateRelationship;
 import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast;
 import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;
 import com.google.javascript.jscomp.CodingConvention.SubclassType;
+import com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents;
+import com.google.javascript.jscomp.NodeTraversal.AbstractScopedCallback;
 import com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback;
 import com.google.javascript.jscomp.Scope.Var;
 import com.google.javascript.rhino.ErrorReporter;
+import com.google.javascript.rhino.InputId;
 import com.google.javascript.rhino.JSDocInfo;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
@@ -69,6 +74,7 @@
 
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 
 import javax.annotation.Nullable;
 
@@ -83,6 +89,8 @@
  *
  * When building scope information, also declares relevant information
  * about types in the type registry.
+ *
+ * @author nicksantos@google.com (Nick Santos)
  */
 final class TypedScopeCreator implements ScopeCreator {
   /**
@@ -91,8 +99,6 @@
   static final String DELEGATE_PROXY_SUFFIX =
       ObjectType.createDelegateSuffix("Proxy");
 
-  private static final String LEGACY_TYPEDEF = "goog.typedef";
-
   static final DiagnosticType MALFORMED_TYPEDEF =
       DiagnosticType.warning(
           "JSC_MALFORMED_TYPEDEF",
@@ -134,6 +140,12 @@
   private final CodingConvention codingConvention;
   private final JSTypeRegistry typeRegistry;
   private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();
+  private final Map<String, String> delegateCallingConventions =
+      Maps.newHashMap();
+
+  // Simple properties inferred about functions.
+  private final Map<Node, AstFunctionContents> functionAnalysisResults =
+      Maps.newHashMap();
 
   /**
    * Defer attachment of types to nodes until all type names
@@ -176,6 +188,7 @@
    * Creates a scope with all types declared. Declares newly discovered types
    * and type properties in the type registry.
    */
+  @Override
   public Scope createScope(Node root, Scope parent) {
     // Constructing the global scope is very different than constructing
     // inner scopes, because only global scopes can contain named classes that
@@ -183,6 +196,10 @@
     Scope newScope = null;
     AbstractScopeBuilder scopeBuilder = null;
     if (parent == null) {
+      // Run a first-order analysis over the syntax tree.
+      (new FirstOrderFunctionAnalyzer(compiler, functionAnalysisResults))
+          .process(root.getFirstChild(), root.getLastChild());
+
       // Find all the classes in the global scope.
       newScope = createInitialScope(root);
 
@@ -204,8 +221,8 @@
     // build properties on.
     for (Node functionNode : scopeBuilder.nonExternFunctions) {
       JSType type = functionNode.getJSType();
-      if (type != null && type instanceof FunctionType) {
-        FunctionType fnType = (FunctionType) type;
+      if (type != null && type.isFunctionType()) {
+        FunctionType fnType = type.toMaybeFunctionType();
         ObjectType fnThisType = fnType.getTypeOfThis();
         if (!fnThisType.isUnknownType()) {
           NodeTraversal.traverse(compiler, functionNode.getLastChild(),
@@ -216,12 +233,61 @@
 
     if (parent == null) {
       codingConvention.defineDelegateProxyPrototypeProperties(
-          typeRegistry, newScope, delegateProxyPrototypes);
+          typeRegistry, newScope, delegateProxyPrototypes,
+          delegateCallingConventions);
     }
     return newScope;
   }
 
   /**
+   * Patches a given global scope by removing variables previously declared in
+   * a script and re-traversing a new version of that script.
+   *
+   * @param globalScope The global scope generated by {@code createScope}.
+   * @param scriptRoot The script that is modified.
+   */
+  void patchGlobalScope(Scope globalScope, Node scriptRoot) {
+    // Preconditions: This is supposed to be called only on (named) SCRIPT nodes
+    // and a global typed scope should have been generated already.
+    Preconditions.checkState(scriptRoot.isScript());
+    Preconditions.checkNotNull(globalScope);
+    Preconditions.checkState(globalScope.isGlobal());
+
+    String scriptName = NodeUtil.getSourceName(scriptRoot);
+    Preconditions.checkNotNull(scriptName);
+    for (Node node : ImmutableList.copyOf(functionAnalysisResults.keySet())) {
+      if (scriptName.equals(NodeUtil.getSourceName(node))) {
+        functionAnalysisResults.remove(node);
+      }
+    }
+
+    (new FirstOrderFunctionAnalyzer(
+        compiler, functionAnalysisResults)).process(null, scriptRoot);
+
+    // TODO(bashir): Variable declaration is not the only side effect of last
+    // global scope generation but here we only wipe that part off!
+
+    // Remove all variables that were previously declared in this scripts.
+    // First find all vars to remove then remove them because of iterator!
+    Iterator<Var> varIter = globalScope.getVars();
+    List<Var> varsToRemove = Lists.newArrayList();
+    while (varIter.hasNext()) {
+      Var oldVar = varIter.next();
+      if (scriptName.equals(oldVar.getInputName())) {
+        varsToRemove.add(oldVar);
+      }
+    }
+    for (Var var : varsToRemove) {
+      globalScope.undeclare(var);
+      globalScope.getTypeOfThis().removeProperty(var.getName());
+    }
+
+    // Now re-traverse the given script.
+    GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(globalScope);
+    NodeTraversal.traverse(compiler, scriptRoot, scopeBuilder);
+  }
+
+  /**
    * Create the outermost scope. This scope contains native binding such as
    * {@code Object}, {@code Date}, etc.
    */
@@ -249,12 +315,7 @@
     declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE);
     declareNativeValueType(s, "undefined", VOID_TYPE);
 
-    // The typedef construct needs the any type, so that it can be assigned
-    // to anything. This is kind of a hack, and an artifact of the typedef
-    // syntax we've chosen.
-    declareNativeValueType(s, LEGACY_TYPEDEF, NO_TYPE);
-
-    // ActiveXObject is unqiuely special, because it can be used to construct
+    // ActiveXObject is uniquely special, because it can be used to construct
     // any type (the type that it creates is related to the arguments you
     // pass to it).
     declareNativeValueType(s, "ActiveXObject", NO_OBJECT_TYPE);
@@ -295,12 +356,12 @@
                child != null; child = child.getNext()) {
             identifyNameNode(
                 child, child.getFirstChild(),
-                NodeUtil.getInfoForNameNode(child));
+                NodeUtil.getBestJSDocInfo(child));
           }
           break;
         case Token.EXPR_RESULT:
           Node firstChild = node.getFirstChild();
-          if (firstChild.getType() == Token.ASSIGN) {
+          if (firstChild.isAssign()) {
             identifyNameNode(
                 firstChild.getFirstChild(), firstChild.getLastChild(),
                 firstChild.getJSDocInfo());
@@ -322,34 +383,10 @@
             registry.identifyNonNullableName(nameNode.getQualifiedName());
           }
         }
-
-        if (valueNode != null &&
-            LEGACY_TYPEDEF.equals(valueNode.getQualifiedName())) {
-          registry.identifyNonNullableName(nameNode.getQualifiedName());
-        }
       }
     }
   }
 
-  /**
-   * Given a node, determines whether that node names a prototype
-   * property, and if so, returns the qualified name node representing
-   * the owner of that property. Otherwise, returns null.
-   */
-  private static Node getPrototypePropertyOwner(Node n) {
-    if (n.getType() == Token.GETPROP) {
-      Node firstChild = n.getFirstChild();
-      if (firstChild.getType() == Token.GETPROP &&
-          firstChild.getLastChild().getString().equals("prototype")) {
-        Node maybeOwner = firstChild.getFirstChild();
-        if (maybeOwner.isQualifiedName()) {
-          return maybeOwner;
-        }
-      }
-    }
-    return null;
-  }
-
   private JSType getNativeType(JSTypeNative nativeType) {
     return typeRegistry.getNativeType(nativeType);
   }
@@ -358,7 +395,7 @@
       implements NodeTraversal.Callback {
 
     /**
-     * The scope that we're builidng.
+     * The scope that we're building.
      */
     final Scope scope;
 
@@ -371,6 +408,18 @@
     private final List<Node> nonExternFunctions = Lists.newArrayList();
 
     /**
+     * Object literals with a @lends annotation aren't analyzed until we
+     * reach the root of the statement they're defined in.
+     *
+     * This ensures that if there are any @lends annotations on the object
+     * literals, the type on the @lends annotation resolves correctly.
+     *
+     * For more information, see
+     * http://code.google.com/p/closure-compiler/issues/detail?id=314
+     */
+    private List<Node> lentObjectLiterals = null;
+
+    /**
      * Type-less stubs.
      *
      * If at the end of traversal, we still don't have types for these
@@ -384,6 +433,11 @@
      */
     private String sourceName = null;
 
+    /**
+     * The InputId of the current node.
+     */
+    private InputId inputId;
+
     private AbstractScopeBuilder(Scope scope) {
       this.scope = scope;
     }
@@ -410,26 +464,46 @@
     }
 
     @Override
-    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,
+    public final boolean shouldTraverse(NodeTraversal t, Node n,
         Node parent) {
-      if (n.getType() == Token.FUNCTION ||
-          n.getType() == Token.SCRIPT) {
-        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
+      inputId = t.getInputId();
+      if (n.isFunction() ||
+          n.isScript()) {
+        Preconditions.checkNotNull(inputId);
+        sourceName = NodeUtil.getSourceName(n);
       }
 
       // We do want to traverse the name of a named function, but we don't
       // want to traverse the arguments or body.
-      return parent == null || parent.getType() != Token.FUNCTION ||
+      boolean descend = parent == null || !parent.isFunction() ||
           n == parent.getFirstChild() || parent == scope.getRootNode();
+
+      if (descend) {
+        // Handle hoisted functions on pre-order traversal, so that they
+        // get hit before other things in the scope.
+        if (NodeUtil.isStatementParent(n)) {
+          for (Node child = n.getFirstChild();
+               child != null;
+               child = child.getNext()) {
+            if (NodeUtil.isHoistedFunctionDeclaration(child)) {
+              defineFunctionLiteral(child, n);
+            }
+          }
+        }
+      }
+
+      return descend;
     }
 
     @Override
     public void visit(NodeTraversal t, Node n, Node parent) {
+      inputId = t.getInputId();
       attachLiteralTypes(t, n);
 
       switch (n.getType()) {
         case Token.CALL:
           checkForClassDefiningCalls(t, n, parent);
+          checkForCallingConventionDefiningCalls(n, delegateCallingConventions);
           break;
 
         case Token.FUNCTION:
@@ -437,13 +511,16 @@
             nonExternFunctions.add(n);
           }
 
-          defineFunctionLiteral(n, parent);
+          // Hoisted functions are handled during pre-traversal.
+          if (!NodeUtil.isHoistedFunctionDeclaration(n)) {
+            defineFunctionLiteral(n, parent);
+          }
           break;
 
         case Token.ASSIGN:
           // Handle initialization of properties.
           Node firstChild = n.getFirstChild();
-          if (firstChild.getType() == Token.GETPROP &&
+          if (firstChild.isGetProp() &&
               firstChild.isQualifiedName()) {
             maybeDeclareQualifiedName(t, n.getJSDocInfo(),
                 firstChild, n, firstChild.getNext());
@@ -460,12 +537,21 @@
 
         case Token.GETPROP:
           // Handle stubbed properties.
-          if (parent.getType() == Token.EXPR_RESULT &&
+          if (parent.isExprResult() &&
               n.isQualifiedName()) {
             maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
           }
           break;
       }
+
+      // Analyze any @lends object literals in this statement.
+      if (n.getParent() != null && NodeUtil.isStatement(n) &&
+          lentObjectLiterals != null) {
+        for (Node objLit : lentObjectLiterals) {
+          defineObjectLiteral(objLit);
+        }
+        lentObjectLiterals.clear();
+      }
     }
 
     private void attachLiteralTypes(NodeTraversal t, Node n) {
@@ -479,17 +565,11 @@
           break;
 
         case Token.STRING:
-          // Defer keys to the Token.OBJECTLIT case
-          if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
-            n.setJSType(getNativeType(STRING_TYPE));
-          }
+          n.setJSType(getNativeType(STRING_TYPE));
           break;
 
         case Token.NUMBER:
-          // Defer keys to the Token.OBJECTLIT case
-          if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
-            n.setJSType(getNativeType(NUMBER_TYPE));
-          }
+          n.setJSType(getNativeType(NUMBER_TYPE));
           break;
 
         case Token.TRUE:
@@ -501,12 +581,17 @@
           n.setJSType(getNativeType(REGEXP_TYPE));
           break;
 
-        case Token.REF_SPECIAL:
-          n.setJSType(getNativeType(UNKNOWN_TYPE));
-          break;
-
         case Token.OBJECTLIT:
-          defineObjectLiteral(t, n);
+          JSDocInfo info = n.getJSDocInfo();
+          if (info != null &&
+              info.getLendsName() != null) {
+            if (lentObjectLiterals == null) {
+              lentObjectLiterals = Lists.newArrayList();
+            }
+            lentObjectLiterals.add(n);
+          } else {
+            defineObjectLiteral(n);
+          }
           break;
 
           // NOTE(nicksantos): If we ever support Array tuples,
@@ -514,7 +599,7 @@
       }
     }
 
-    private void defineObjectLiteral(NodeTraversal t, Node objectLit) {
+    private void defineObjectLiteral(Node objectLit) {
       // Handle the @lends annotation.
       JSType type = null;
       JSDocInfo info = objectLit.getJSDocInfo();
@@ -541,11 +626,13 @@
         }
       }
 
-      info = getBestJSDocInfo(objectLit);
-      Node lValue = getBestLValue(objectLit);
-      String lValueName = getBestLValueName(lValue);
+      info = NodeUtil.getBestJSDocInfo(objectLit);
+      Node lValue = NodeUtil.getBestLValue(objectLit);
+      String lValueName = NodeUtil.getBestLValueName(lValue);
+      boolean createdEnumType = false;
       if (info != null && info.hasEnumParameterType()) {
         type = createEnumTypeFromNodes(objectLit, lValueName, info, lValue);
+        createdEnumType = true;
       }
 
       if (type == null) {
@@ -554,8 +641,9 @@
 
       setDeferredType(objectLit, type);
 
+      // If this is an enum, the properties were already taken care of above.
       processObjectLitProperties(
-          t, objectLit, ObjectType.cast(objectLit.getJSType()));
+          objectLit, ObjectType.cast(objectLit.getJSType()), !createdEnumType);
     }
 
     /**
@@ -563,34 +651,37 @@
      * @param objLit The OBJECTLIT node.
      * @param objLitType The type of the OBJECTLIT node. This might be a named
      *     type, because of the lends annotation.
+     * @param declareOnOwner If true, declare properties on the objLitType as
+     *     well. If false, the caller should take care of this.
      */
     void processObjectLitProperties(
-        NodeTraversal t, Node objLit, ObjectType objLitType) {
+        Node objLit, ObjectType objLitType,
+        boolean declareOnOwner) {
       for (Node keyNode = objLit.getFirstChild(); keyNode != null;
            keyNode = keyNode.getNext()) {
         Node value = keyNode.getFirstChild();
         String memberName = NodeUtil.getObjectLitKeyName(keyNode);
         JSDocInfo info = keyNode.getJSDocInfo();
-        JSType valueType = getDeclaredType(
-            t.getSourceName(), info, keyNode, value);
-        JSType keyType = NodeUtil.getObjectLitKeyTypeFromValueType(
-            keyNode, valueType);
-        if (keyType != null) {
-          // Try to declare this property in the current scope if it
-          // has an authoritative name.
-          String qualifiedName = getBestLValueName(keyNode);
-          if (qualifiedName != null) {
-            defineSlot(keyNode, objLit, qualifiedName, keyType, false);
-          } else {
-            setDeferredType(keyNode, keyType);
-          }
-
-          if (objLitType != null) {
-            // Declare this property on its object literal.
-            boolean isExtern = t.getInput() != null && t.getInput().isExtern();
-            objLitType.defineDeclaredProperty(
-                memberName, keyType, isExtern, keyNode);
-          }
+        JSType valueType =
+            getDeclaredType(keyNode.getSourceFileName(), info, keyNode, value);
+        JSType keyType =  objLitType.isEnumType() ?
+            objLitType.toMaybeEnumType().getElementsType() :
+            NodeUtil.getObjectLitKeyTypeFromValueType(keyNode, valueType);
+
+        // Try to declare this property in the current scope if it
+        // has an authoritative name.
+        String qualifiedName = NodeUtil.getBestLValueName(keyNode);
+        if (qualifiedName != null) {
+          boolean inferred = keyType == null;
+          defineSlot(keyNode, objLit, qualifiedName, keyType, inferred);
+        } else if (keyType != null) {
+          setDeferredType(keyNode, keyType);
+        }
+
+        if (keyType != null && objLitType != null && declareOnOwner) {
+          // Declare this property on its object literal.
+          boolean isExtern = keyNode.isFromExterns();
+          objLitType.defineDeclaredProperty(memberName, keyType, keyNode);
         }
       }
     }
@@ -605,7 +696,7 @@
         Node node, JSDocInfo info) {
       JSType jsType = null;
       Node objNode =
-          node.getType() == Token.GETPROP ? node.getFirstChild() :
+          node.isGetProp() ? node.getFirstChild() :
           NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() :
           null;
       if (info != null) {
@@ -621,7 +712,7 @@
     }
 
     /**
-     * Asserts that it's ok to define this node's name.
+     * Asserts that it's OK to define this node's name.
      * The node should have a source name and be of the specified type.
      */
     void assertDefinitionNode(Node n, int type) {
@@ -665,11 +756,11 @@
     void defineFunctionLiteral(Node n, Node parent) {
       assertDefinitionNode(n, Token.FUNCTION);
 
-      // Determine the name and JSDocInfo and lvalue for the function.
+      // Determine the name and JSDocInfo and l-value for the function.
       // Any of these may be null.
-      Node lValue = getBestLValue(n);
-      JSDocInfo info = getBestJSDocInfo(n);
-      String functionName = getBestLValueName(lValue);
+      Node lValue = NodeUtil.getBestLValue(n);
+      JSDocInfo info = NodeUtil.getBestJSDocInfo(n);
+      String functionName = NodeUtil.getBestLValueName(lValue);
       FunctionType functionType =
           createFunctionTypeFromNodes(n, functionName, info, lValue);
 
@@ -700,9 +791,7 @@
       JSType type = getDeclaredType(sourceName, info, name, value);
       if (type == null) {
         // The variable's type will be inferred.
-        CompilerInput input = compiler.getInput(sourceName);
-        Preconditions.checkNotNull(input, sourceName);
-        type = input.isExtern() ?
+        type = name.isFromExterns() ?
             getNativeType(UNKNOWN_TYPE) : null;
       }
       defineSlot(name, var, type);
@@ -733,7 +822,7 @@
      * This handles two cases that are semantically very different, but
      * are not mutually exclusive:
      * - A function literal that needs a type attached to it.
-     * - An assignment expression with function-type info in the jsdoc.
+     * - An assignment expression with function-type info in the JsDoc.
      *
      * All parameters are optional, and we will do the best we can to create
      * a function type.
@@ -760,8 +849,9 @@
       // Global ctor aliases should be registered with the type registry.
       if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {
         Var var = scope.getVar(rValue.getQualifiedName());
-        if (var != null && var.getType() instanceof FunctionType) {
-          FunctionType aliasedType  = (FunctionType) var.getType();
+        if (var != null && var.getType() != null &&
+            var.getType().isFunctionType()) {
+          FunctionType aliasedType  = var.getType().toMaybeFunctionType();
           if ((aliasedType.isConstructor() || aliasedType.isInterface()) &&
               !aliasedType.isNativeObjectType()) {
             functionType = aliasedType;
@@ -776,7 +866,7 @@
       if (functionType == null) {
         Node errorRoot = rValue == null ? lvalueNode : rValue;
         boolean isFnLiteral =
-            rValue != null && rValue.getType() == Token.FUNCTION;
+            rValue != null && rValue.isFunction();
         Node fnRoot = isFnLiteral ? rValue : null;
         Node parametersNode = isFnLiteral ?
             rValue.getFirstChild().getNext() : null;
@@ -788,60 +878,69 @@
           // Known to be not null since we have the FUNCTION token there.
           type = type.restrictByNotNullOrUndefined();
           if (type.isFunctionType()) {
-            functionType = (FunctionType) type;
+            functionType = type.toMaybeFunctionType();
             functionType.setJSDocInfo(info);
           }
         }
 
         if (functionType == null) {
           // Find the type of any overridden function.
-          FunctionType overriddenPropType = null;
-          if (lvalueNode != null &&
-              lvalueNode.getType() == Token.GETPROP &&
-              lvalueNode.isQualifiedName()) {
-            Var var = scope.getVar(
-                lvalueNode.getFirstChild().getQualifiedName());
-            if (var != null) {
-              ObjectType ownerType = ObjectType.cast(var.getType());
-              if (ownerType != null) {
-                String propName = lvalueNode.getLastChild().getString();
-                overriddenPropType =
-                    findOverriddenFunction(ownerType, propName);
-              }
+          Node ownerNode = NodeUtil.getBestLValueOwner(lvalueNode);
+          String ownerName = NodeUtil.getBestLValueName(ownerNode);
+          Var ownerVar = null;
+          String propName = null;
+          ObjectType ownerType = null;
+          if (ownerName != null) {
+            ownerVar = scope.getVar(ownerName);
+            if (ownerVar != null) {
+              ownerType = ObjectType.cast(ownerVar.getType());
+            }
+            if (name != null) {
+              propName = name.substring(ownerName.length() + 1);
             }
           }
 
+          FunctionType overriddenPropType = null;
+          if (ownerType != null && propName != null) {
+            overriddenPropType =
+                findOverriddenFunction(ownerType, propName);
+          }
+
           FunctionTypeBuilder builder =
               new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,
                   scope)
-              .setSourceNode(fnRoot)
+              .setContents(getFunctionAnalysisResults(fnRoot))
               .inferFromOverriddenFunction(overriddenPropType, parametersNode)
               .inferTemplateTypeName(info)
               .inferReturnType(info)
               .inferInheritance(info);
 
+
           // Infer the context type.
           boolean searchedForThisType = false;
-          if (lvalueNode != null &&
-              lvalueNode.getType() == Token.GETPROP) {
-            Node objNode = lvalueNode.getFirstChild();
-            if (objNode.getType() == Token.GETPROP &&
-                objNode.getLastChild().getString().equals("prototype")) {
-              builder.inferThisType(info, objNode.getFirstChild());
-              searchedForThisType = true;
-            } else if (objNode.getType() == Token.THIS) {
-              builder.inferThisType(info, objNode.getJSType());
-              searchedForThisType = true;
-            }
+          if (ownerType != null && ownerType.isFunctionPrototypeType()) {
+            builder.inferThisType(
+                info, ownerType.getOwnerFunction().getInstanceType());
+            searchedForThisType = true;
+          } else if (ownerNode != null && ownerNode.isThis()) {
+            // If 'this' has a type, use that instead.
+            // This is a hack, necessary because CollectProperties (below)
+            // doesn't run with the scope that it's building,
+            // so scope.getTypeOfThis() will be wrong.
+            JSType injectedThisType = ownerNode.getJSType();
+            builder.inferThisType(
+                info,
+                injectedThisType == null ?
+                scope.getTypeOfThis() : injectedThisType);
+            searchedForThisType = true;
           }
 
           if (!searchedForThisType) {
-            builder.inferThisType(info, (Node) null);
+            builder.inferThisType(info);
           }
 
           functionType = builder
               .inferParameterTypes(parametersNode, info)
-              .inferReturnStatementsAsLastResort(fnBlock)
               .buildAndRegister();
         }
       }
@@ -858,16 +957,16 @@
       // First, check to see if the property is implemented
       // on a superclass.
       JSType propType = ownerType.getPropertyType(propName);
-      if (propType instanceof FunctionType) {
-        return (FunctionType) propType;
+      if (propType != null && propType.isFunctionType()) {
+        return propType.toMaybeFunctionType();
       } else {
         // If it's not, then check to see if it's implemented
         // on an implemented interface.
         for (ObjectType iface :
                  ownerType.getCtorImplementedInterfaces()) {
           propType = iface.getPropertyType(propName);
-          if (propType instanceof FunctionType) {
-            return (FunctionType) propType;
+          if (propType != null && propType.isFunctionType()) {
+            return propType.toMaybeFunctionType();
           }
         }
       }
@@ -881,7 +980,7 @@
      * This handles two cases that are semantically very different, but
      * are not mutually exclusive:
      * - An object literal that needs an enum type attached to it.
-     * - An assignment expression with an enum tag in the jsdoc.
+     * - An assignment expression with an enum tag in the JsDoc.
      *
      * This function will always create an enum type, so only call it if
      * you're sure that's what you want.
@@ -889,7 +988,7 @@
      * @param rValue The node of the enum.
      * @param name The enum's name
      * @param info The {@link JSDocInfo} attached to the enum definition.
-     * @param lvalueNode The node where this function is being
+     * @param lValueNode The node where this function is being
      *     assigned.
      */
     private EnumType createEnumTypeFromNodes(Node rValue, String name,
@@ -909,9 +1008,9 @@
       if (enumType == null) {
         JSType elementsType =
             info.getEnumParameterType().evaluate(scope, typeRegistry);
-        enumType = typeRegistry.createEnumType(name, elementsType);
+        enumType = typeRegistry.createEnumType(name, rValue, elementsType);
 
-        if (rValue != null && rValue.getType() == Token.OBJECTLIT) {
+        if (rValue != null && rValue.isObjectLit()) {
           // collect enum elements
           Node key = rValue.getFirstChild();
           while (key != null) {
@@ -920,8 +1019,6 @@
               // GET and SET don't have a String value;
               compiler.report(
                   JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));
-            } else if (enumType.hasOwnProperty(keyName)) {
-              compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));
             } else if (!codingConvention.isValidEnumKey(keyName)) {
               compiler.report(
                   JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));
@@ -967,19 +1064,19 @@
     void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
       Preconditions.checkArgument(inferred || type != null);
 
-      // Only allow declarations of NAMEs and qualfied names.
+      // Only allow declarations of NAMEs and qualified names.
       // Object literal keys will have to compute their names themselves.
-      if (n.getType() == Token.NAME) {
+      if (n.isName()) {
         Preconditions.checkArgument(
-            parent.getType() == Token.FUNCTION ||
-            parent.getType() == Token.VAR ||
-            parent.getType() == Token.LP ||
-            parent.getType() == Token.CATCH);
+            parent.isFunction() ||
+            parent.isVar() ||
+            parent.isParamList() ||
+            parent.isCatch());
       } else {
         Preconditions.checkArgument(
-            n.getType() == Token.GETPROP &&
-            (parent.getType() == Token.ASSIGN ||
-             parent.getType() == Token.EXPR_RESULT));
+            n.isGetProp() &&
+            (parent.isAssign() ||
+             parent.isExprResult()));
       }
       defineSlot(n, parent, n.getQualifiedName(), type, inferred);
     }
@@ -990,7 +1087,7 @@
      *
      * @param n the defining NAME or GETPROP or object literal key node.
      * @param parent the {@code n}'s parent.
-     * @param name The name that this should be known by.
+     * @param variableName The name that this should be known by.
      * @param type the variable's type. It may be {@code null} if
      *     {@code inferred} is {@code true}.
      * @param inferred Whether the type is inferred or declared.
@@ -999,16 +1096,17 @@
         JSType type, boolean inferred) {
       Preconditions.checkArgument(!variableName.isEmpty());
 
+      boolean isGlobalVar = n.isName() && scope.isGlobal();
       boolean shouldDeclareOnGlobalThis =
-          n.getType() == Token.NAME && scope.isGlobal() &&
-          (parent.getType() == Token.VAR ||
-           parent.getType() == Token.FUNCTION);
+          isGlobalVar &&
+          (parent.isVar() ||
+           parent.isFunction());
 
       // If n is a property, then we should really declare it in the
       // scope where the root object appears. This helps out people
       // who declare "global" names in an anonymous namespace.
       Scope scopeToDeclareIn = scope;
-      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&
+      if (n.isGetProp() && !scope.isGlobal() &&
           isQnameRootedInGlobalScope(n)) {
         Scope globalScope = scope.getGlobalScope();
 
@@ -1019,95 +1117,142 @@
         }
       }
 
+      // The input may be null if we are working with a AST snippet. So read
+      // the extern info from the node.
+      boolean isExtern = n.isFromExterns();
+      Var newVar = null;
+
       // declared in closest scope?
+      CompilerInput input = compiler.getInput(inputId);
       if (scopeToDeclareIn.isDeclared(variableName, false)) {
         Var oldVar = scopeToDeclareIn.getVar(variableName);
-        validator.expectUndeclaredVariable(
-            sourceName, n, parent, oldVar, variableName, type);
+        newVar = validator.expectUndeclaredVariable(
+            sourceName, input, n, parent, oldVar, variableName, type);
       } else {
         if (!inferred) {
           setDeferredType(n, type);
         }
-        CompilerInput input = compiler.getInput(sourceName);
-        boolean isExtern = input.isExtern();
-        Var newVar =
-            scopeToDeclareIn.declare(variableName, n, type, input, inferred);
-
-        if (shouldDeclareOnGlobalThis) {
-          ObjectType globalThis =
-              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
-          if (inferred) {
-            globalThis.defineInferredProperty(variableName,
-                type == null ?
-                    getNativeType(JSTypeNative.NO_TYPE) :
-                    type,
-                isExtern, n);
-          } else {
-            globalThis.defineDeclaredProperty(variableName, type, isExtern, n);
-          }
-        }
+
+        newVar =
+          scopeToDeclareIn.declare(variableName, n, type, input, inferred);
 
         if (type instanceof EnumType) {
           Node initialValue = newVar.getInitialValue();
           boolean isValidValue = initialValue != null &&
-              (initialValue.getType() == Token.OBJECTLIT ||
+              (initialValue.isObjectLit() ||
                initialValue.isQualifiedName());
           if (!isValidValue) {
             compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER));
           }
         }
+      }
 
-        // We need to do some additional work for constructors and interfaces.
-        if (type instanceof FunctionType &&
-            // We don't want to look at empty function types.
-            !type.isEmptyType()) {
-          FunctionType fnType = (FunctionType) type;
-          if ((fnType.isConstructor() || fnType.isInterface()) &&
-              !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {
-            // Declare var.prototype in the scope chain.
-            FunctionType superClassCtor = fnType.getSuperClassConstructor();
-            scopeToDeclareIn.declare(variableName + ".prototype", n,
-                fnType.getPrototype(), input,
-                /* declared iff there's an explicit supertype */
-                superClassCtor == null ||
-                superClassCtor.getInstanceType().equals(
-                    getNativeType(OBJECT_TYPE)));
-
-            // Make sure the variable is initialized to something if
-            // it constructs itself.
-            if (newVar.getInitialValue() == null &&
-                !isExtern &&
-                // We want to make sure that when we declare a new instance
-                // type (with @constructor) that there's actually a ctor for it.
-                // This doesn't apply to structural constructors
-                // (like function(new:Array). Checking the constructed
-                // type against the variable name is a sufficient check for
-                // this.
-                variableName.equals(
-                    fnType.getInstanceType().getReferenceName())) {
-              compiler.report(
-                  JSError.make(sourceName, n,
-                      fnType.isConstructor() ?
-                          CTOR_INITIALIZER : IFACE_INITIALIZER,
-                      variableName));
-            }
+      // We need to do some additional work for constructors and interfaces.
+      FunctionType fnType = JSType.toMaybeFunctionType(type);
+      if (fnType != null &&
+          // We don't want to look at empty function types.
+          !type.isEmptyType()) {
+        if ((fnType.isConstructor() || fnType.isInterface()) &&
+            !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {
+          // Declare var.prototype in the scope chain.
+          FunctionType superClassCtor = fnType.getSuperClassConstructor();
+          ObjectType.Property prototypeSlot = fnType.getSlot("prototype");
+
+          // When we declare the function prototype implicitly, we
+          // want to make sure that the function and its prototype
+          // are declared at the same node. We also want to make sure
+          // that the if a symbol has both a Var and a JSType, they have
+          // the same node.
+          //
+          // This consistency is helpful to users of SymbolTable,
+          // because everything gets declared at the same place.
+          prototypeSlot.setNode(n);
+
+          String prototypeName = variableName + ".prototype";
+
+          // There are some rare cases where the prototype will already
+          // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.
+          // Fortunately, other warnings will complain if this happens.
+          Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);
+          if (prototypeVar != null && prototypeVar.scope == scopeToDeclareIn) {
+            scopeToDeclareIn.undeclare(prototypeVar);
+          }
+
+          scopeToDeclareIn.declare(prototypeName,
+              n, prototypeSlot.getType(), input,
+              /* declared iff there's an explicit supertype */
+              superClassCtor == null ||
+              superClassCtor.getInstanceType().equals(
+                  getNativeType(OBJECT_TYPE)));
+
+          // Make sure the variable is initialized to something if
+          // it constructs itself.
+          if (newVar.getInitialValue() == null &&
+              !isExtern &&
+              // We want to make sure that when we declare a new instance
+              // type (with @constructor) that there's actually a ctor for it.
+              // This doesn't apply to structural constructors
+              // (like function(new:Array). Checking the constructed
+              // type against the variable name is a sufficient check for
+              // this.
+              variableName.equals(
+                  fnType.getInstanceType().getReferenceName())) {
+            compiler.report(
+                JSError.make(sourceName, n,
+                    fnType.isConstructor() ?
+                    CTOR_INITIALIZER : IFACE_INITIALIZER,
+                    variableName));
           }
         }
       }
+
+      if (shouldDeclareOnGlobalThis) {
+        ObjectType globalThis =
+            typeRegistry.getNativeObjectType(GLOBAL_THIS);
+        if (inferred) {
+          globalThis.defineInferredProperty(variableName,
+              type == null ?
+              getNativeType(JSTypeNative.NO_TYPE) :
+              type,
+              n);
+        } else {
+          globalThis.defineDeclaredProperty(variableName, type, n);
+        }
+      }
+
+      if (isGlobalVar && "Window".equals(variableName)
+          && type != null
+          && type.isFunctionType()
+          && type.isConstructor()) {
+        FunctionType globalThisCtor =
+            typeRegistry.getNativeObjectType(GLOBAL_THIS).getConstructor();
+        globalThisCtor.getInstanceType().clearCachedValues();
+        globalThisCtor.getPrototype().clearCachedValues();
+        globalThisCtor
+            .setPrototypeBasedOn((type.toMaybeFunctionType()).getInstanceType());
+      }
     }
 
     /**
      * Check if the given node is a property of a name in the global scope.
      */
     private boolean isQnameRootedInGlobalScope(Node n) {
+      Scope scope = getQnameRootScope(n);
+      return scope != null && scope.isGlobal();
+    }
+
+    /**
+     * Return the scope for the name of the given node.
+     */
+    private Scope getQnameRootScope(Node n) {
       Node root = NodeUtil.getRootOfQualifiedName(n);
-      if (root.getType() == Token.NAME) {
+      if (root.isName()) {
         Var var = scope.getVar(root.getString());
         if (var != null) {
-          return var.isGlobal();
+          return var.getScope();
         }
       }
-      return false;
+      return null;
     }
 
     /**
@@ -1123,24 +1268,65 @@
         Node lValue, @Nullable Node rValue) {
       if (info != null && info.hasType()) {
         return getDeclaredTypeInAnnotation(sourceName, lValue, info);
-      } else if (rValue != null && rValue.getType() == Token.FUNCTION &&
+      } else if (rValue != null && rValue.isFunction() &&
           shouldUseFunctionLiteralType(
-              (FunctionType) rValue.getJSType(), info, lValue)) {
+              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
         return rValue.getJSType();
-      } else if (info != null && info.hasEnumParameterType()) {
-        if (rValue != null && rValue.getType() == Token.OBJECTLIT) {
-          return rValue.getJSType();
-        } else {
-          return createEnumTypeFromNodes(
+      } else if (info != null) {
+        if (info.hasEnumParameterType()) {
+          if (rValue != null && rValue.isObjectLit()) {
+            return rValue.getJSType();
+          } else {
+            return createEnumTypeFromNodes(
+                rValue, lValue.getQualifiedName(), info, lValue);
+          }
+        } else if (info.isConstructor() || info.isInterface()) {
+          return createFunctionTypeFromNodes(
               rValue, lValue.getQualifiedName(), info, lValue);
+        } else {
+          // Check if this is constant, and if it has a known type.
+          if (info.isConstant()) {
+            JSType knownType = null;
+            if (rValue != null) {
+              if (rValue.getJSType() != null
+                  && !rValue.getJSType().isUnknownType()) {
+                return rValue.getJSType();
+              } else if (rValue.isOr()) {
+                // Check for a very specific JS idiom:
+                // var x = x || TYPE;
+                // This is used by Closure's base namespace for esoteric
+                // reasons.
+                Node firstClause = rValue.getFirstChild();
+                Node secondClause = firstClause.getNext();
+                boolean namesMatch = firstClause.isName()
+                    && lValue.isName()
+                    && firstClause.getString().equals(lValue.getString());
+                if (namesMatch && secondClause.getJSType() != null
+                    && !secondClause.getJSType().isUnknownType()) {
+                  return secondClause.getJSType();
+                }
+              }
+            }
+          }
         }
-      } else if (info != null &&
-                 (info.isConstructor() || info.isInterface())) {
-        return createFunctionTypeFromNodes(
-            rValue, lValue.getQualifiedName(), info, lValue);
-      } else {
-        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
       }
+
+      return getDeclaredTypeInAnnotation(sourceName, lValue, info);
+    }
+
+    private FunctionType getFunctionType(@Nullable Var v) {
+      JSType t = v == null ? null : v.getType();
+      ObjectType o = t == null ? null : t.dereference();
+      return JSType.toMaybeFunctionType(o);
+    }
+
+    /**
+     * Look for calls that set a delegate method's calling convention.
+     */
+    private void checkForCallingConventionDefiningCalls(
+        Node n, Map<String, String> delegateCallingConventions) {
+      codingConvention.checkForCallingConventionDefiningCalls(n,
+          delegateCallingConventions);
     }
 
     /**
@@ -1153,15 +1339,23 @@
       SubclassRelationship relationship =
           codingConvention.getClassesDefinedByCall(n);
       if (relationship != null) {
-        ObjectType superClass = ObjectType.cast(
-            typeRegistry.getType(relationship.superclassName));
-        ObjectType subClass = ObjectType.cast(
-            typeRegistry.getType(relationship.subclassName));
-        if (superClass != null && subClass != null) {
-          FunctionType superCtor = superClass.getConstructor();
-          FunctionType subCtor = subClass.getConstructor();
+        FunctionType superCtor = getFunctionType(
+            scope.getVar(relationship.superclassName));
+        FunctionType subCtor = getFunctionType(
+            scope.getVar(relationship.subclassName));
+        if (superCtor != null && superCtor.isConstructor() &&
+            subCtor != null && subCtor.isConstructor()) {
+          ObjectType superClass = superCtor.getInstanceType();
+          ObjectType subClass = subCtor.getInstanceType();
+
+          // superCtor and subCtor might be structural constructors
+          // (like {function(new:Object)}) so we need to resolve them back
+          // to the original ctor objects.
+          superCtor = superClass.getConstructor();
+          subCtor = subClass.getConstructor();
 
-          if (relationship.type == SubclassType.INHERITS) {
+          if (relationship.type == SubclassType.INHERITS &&
+              !superClass.isEmptyType() && !subClass.isEmptyType()) {
             validator.expectSuperType(t, n, superClass, subClass);
           }
 
@@ -1196,15 +1390,20 @@
       }
 
       ObjectLiteralCast objectLiteralCast =
-          codingConvention.getObjectLiteralCast(t, n);
+          codingConvention.getObjectLiteralCast(n);
       if (objectLiteralCast != null) {
-        ObjectType type = ObjectType.cast(
-            typeRegistry.getType(objectLiteralCast.typeName));
-        if (type != null && type.getConstructor() != null) {
-          setDeferredType(objectLiteralCast.objectNode, type);
+        if (objectLiteralCast.diagnosticType == null) {
+          ObjectType type = ObjectType.cast(
+              typeRegistry.getType(objectLiteralCast.typeName));
+          if (type != null && type.getConstructor() != null) {
+            setDeferredType(objectLiteralCast.objectNode, type);
+          } else {
+            compiler.report(JSError.make(t.getSourceName(), n,
+                    CONSTRUCTOR_EXPECTED));
+          }
         } else {
           compiler.report(JSError.make(t.getSourceName(), n,
-                  CONSTRUCTOR_EXPECTED));
+                  objectLiteralCast.diagnosticType));
         }
       }
     }
@@ -1268,6 +1467,26 @@
       String propName = n.getLastChild().getString();
       Preconditions.checkArgument(qName != null && ownerName != null);
 
+      // Precedence of type information on GETPROPs:
+      // 1) @type annotation / @enum annotation
+      // 2) ASSIGN to FUNCTION literal
+      // 3) @param/@return annotation (with no function literal)
+      // 4) ASSIGN to something marked @const
+      // 5) ASSIGN to anything else
+      //
+      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
+      // the function has JsDoc or has not been declared before.
+      //
+      // FUNCTION literals are special because TypedScopeCreator is very smart
+      // about getting as much type information as possible for them.
+
+      // Determining type for #1 + #2 + #3 + #4
+      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
+      if (valueType == null && rhsValue != null) {
+        // Determining type for #5
+        valueType = rhsValue.getJSType();
+      }
+
       // Function prototypes are special.
       // It's a common JS idiom to do:
       // F.prototype = { ... };
@@ -1276,8 +1495,23 @@
       if ("prototype".equals(propName)) {
         Var qVar = scope.getVar(qName);
         if (qVar != null) {
-          if (!qVar.isTypeInferred()) {
-            // Just ignore assigns to declared prototypes.
+          // If the programmer has declared that F inherits from Super,
+          // and they assign F.prototype to an object literal,
+          // then they are responsible for making sure that the object literal's
+          // implicit prototype is set up appropriately. We just obey
+          // the @extends tag.
+          ObjectType qVarType = ObjectType.cast(qVar.getType());
+          if (qVarType != null &&
+              rhsValue != null &&
+              rhsValue.isObjectLit()) {
+            typeRegistry.resetImplicitPrototype(
+                rhsValue.getJSType(), qVarType.getImplicitPrototype());
+          } else if (!qVar.isTypeInferred()) {
+            // If the programmer has declared that F inherits from Super,
+            // and they assign F.prototype to some arbitrary expression,
+            // there's not much we can do. We just ignore the expression,
+            // and hope they've annotated their code in a way to tell us
+            // what props are going to be on that prototype.
             return;
           }
           if (qVar.getScope() == scope) {
@@ -1286,27 +1520,8 @@
         }
       }
 
-      // Precedence of type information on GETPROPs:
-      // 1) @type annnotation / @enum annotation
-      // 2) ASSIGN to FUNCTION literal
-      // 3) @param/@return annotation (with no function literal)
-      // 4) ASSIGN to anything else
-      //
-      // 1 and 3 are declarations, 4 is inferred, and 2 is a declaration iff
-      // the function has not been declared before.
-      //
-      // FUNCTION literals are special because TypedScopeCreator is very smart
-      // about getting as much type information as possible for them.
-
-      // Determining type for #1 + #2 + #3
-      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
-      if (valueType == null && rhsValue != null) {
-        // Determining type for #4
-        valueType = rhsValue.getJSType();
-      }
-
       if (valueType == null) {
-        if (parent.getType() == Token.EXPR_RESULT) {
+        if (parent.isExprResult()) {
           stubDeclarations.add(new StubDeclaration(
               n,
               t.getInput() != null && t.getInput().isExtern(),
@@ -1316,20 +1531,8 @@
         return;
       }
 
-      boolean inferred = true;
-      if (info != null) {
-        // Determining declaration for #1 + #3
-        inferred = !(info.hasType() || info.hasEnumParameterType() ||
-            FunctionTypeBuilder.isFunctionTypeDeclaration(info));
-      }
-
-      if (inferred) {
-        // Determining declaration for #2
-        inferred = !(rhsValue != null &&
-            rhsValue.getType() == Token.FUNCTION &&
-            !scope.isDeclared(qName, false));
-      }
-
+      boolean inferred = isQualifiedNameInferred(
+          qName, n, info, rhsValue, valueType);
       if (!inferred) {
         ObjectType ownerType = getObjectSlot(ownerName);
         if (ownerType != null) {
@@ -1341,29 +1544,100 @@
               ((isExtern && !ownerType.isNativeObjectType()) ||
                !ownerType.isInstanceType())) {
             // If the property is undeclared or inferred, declare it now.
-            ownerType.defineDeclaredProperty(propName, valueType, isExtern, n);
+            ownerType.defineDeclaredProperty(propName, valueType, n);
           }
         }
 
         // If the property is already declared, the error will be
         // caught when we try to declare it in the current scope.
         defineSlot(n, parent, valueType, inferred);
-      } else if (rhsValue != null &&
-          rhsValue.getType() == Token.TRUE) {
+      } else if (rhsValue != null && rhsValue.isTrue()) {
         // We declare these for delegate proxy method properties.
-        ObjectType ownerType = getObjectSlot(ownerName);
-        if (ownerType instanceof FunctionType) {
-          JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis();
+        FunctionType ownerType =
+            JSType.toMaybeFunctionType(getObjectSlot(ownerName));
+        if (ownerType != null) {
+          JSType ownerTypeOfThis = ownerType.getTypeOfThis();
           String delegateName = codingConvention.getDelegateSuperclassName();
           JSType delegateType = delegateName == null ?
               null : typeRegistry.getType(delegateName);
           if (delegateType != null &&
               ownerTypeOfThis.isSubtype(delegateType)) {
-            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE),
-                true);
+            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
+          }
+        }
+      }
+    }
+
+    /**
+     * Determines whether a qualified name is inferred.
+     * NOTE(nicksantos): Determining whether a property is declared or not
+     * is really really obnoxious.
+     *
+     * The problem is that there are two (equally valid) coding styles:
+     *
+     * (function() {
+     *   /* The authoritative definition of goog.bar. /
+     *   goog.bar = function() {};
+     * })();
+     *
+     * function f() {
+     *   goog.bar();
+     *   /* Reset goog.bar to a no-op. /
+     *   goog.bar = function() {};
+     * }
+     *
+     * In a dynamic language with first-class functions, it's very difficult
+     * to know which one the user intended without looking at lots of
+     * contextual information (the second example demonstrates a small case
+     * of this, but there are some really pathological cases as well).
+     *
+     * The current algorithm checks if either the declaration has
+     * JsDoc type information, or @const with a known type,
+     * or a function literal with a name we haven't seen before.
+     */
+    private boolean isQualifiedNameInferred(
+        String qName, Node n, JSDocInfo info,
+        Node rhsValue, JSType valueType) {
+      if (valueType == null) {
+        return true;
+      }
+
+      boolean inferred = true;
+      if (info != null) {
+        inferred = !(info.hasType()
+            || info.hasEnumParameterType()
+            || (info.isConstant() && valueType != null
+                && !valueType.isUnknownType())
+            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
+      }
+
+      if (inferred && rhsValue != null && rhsValue.isFunction()) {
+        if (info != null) {
+          return false;
+        } else if (!scope.isDeclared(qName, false) &&
+            n.isUnscopedQualifiedName()) {
+
+          // Check if this is in a conditional block.
+          // Functions assigned in conditional blocks are inferred.
+          for (Node current = n.getParent();
+               !(current.isScript() || current.isFunction());
+               current = current.getParent()) {
+            if (NodeUtil.isControlStructure(current)) {
+              return true;
+            }
+          }
+
+          // Check if this is assigned in an inner scope.
+          // Functions assigned in inner scopes are inferred.
+          AstFunctionContents contents =
+              getFunctionAnalysisResults(scope.getRootNode());
+          if (contents == null ||
+              !contents.getEscapedQualifiedNames().contains(qName)) {
+            return false;
           }
         }
       }
+      return inferred;
     }
 
     /**
@@ -1382,7 +1656,7 @@
     }
 
     /**
-     * Resolve any stub delcarations to unknown types if we could not
+     * Resolve any stub declarations to unknown types if we could not
      * find types for them during traversal.
      */
     void resolveStubDeclarations() {
@@ -1409,7 +1683,7 @@
           // If this is a stub for a prototype, just declare it
           // as an unknown type. These are seen often in externs.
           ownerType.defineInferredProperty(
-              propName, unknownType, isExtern, n);
+              propName, unknownType, n);
         } else {
           typeRegistry.registerPropertyOnType(
               propName, ownerType == null ? unknownType : ownerType);
@@ -1429,8 +1703,9 @@
         this.thisType = thisType;
       }
 
+      @Override
       public void visit(NodeTraversal t, Node n, Node parent) {
-        if (n.getType() == Token.EXPR_RESULT) {
+        if (n.isExprResult()) {
           Node child = n.getFirstChild();
           switch (child.getType()) {
             case Token.ASSIGN:
@@ -1452,8 +1727,8 @@
         // if the node is not a member expression, or
         // if the member expression is not of the form: this.someProperty.
         if (info == null ||
-            member.getType() != Token.GETPROP ||
-            member.getFirstChild().getType() != Token.THIS) {
+            !member.isGetProp() ||
+            !member.getFirstChild().isThis()) {
           return;
         }
 
@@ -1461,11 +1736,10 @@
         JSType jsType = getDeclaredType(t.getSourceName(), info, member, value);
         Node name = member.getLastChild();
         if (jsType != null &&
-            (name.getType() == Token.NAME || name.getType() == Token.STRING)) {
+            (name.isName() || name.isString())) {
           thisType.defineDeclaredProperty(
               name.getString(),
               jsType,
-              false /* functions with implementations are not in externs */,
               member);
         }
       }
@@ -1510,15 +1784,9 @@
 
       switch (n.getType()) {
 
-        case Token.ASSIGN:
-          // Handle typedefs.
-          checkForOldStyleTypedef(t, n);
-          break;
-
         case Token.VAR:
           // Handle typedefs.
           if (n.hasOneChild()) {
-            checkForOldStyleTypedef(t, n);
             checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());
           }
           break;
@@ -1551,7 +1819,7 @@
       }
 
       // TODO(nicksantos|user): This is a terrible, terrible hack
-      // to bail out on recusive typedefs. We'll eventually need
+      // to bail out on recursive typedefs. We'll eventually need
       // to handle these properly.
       typeRegistry.declareType(typedef, getNativeType(UNKNOWN_TYPE));
 
@@ -1563,45 +1831,11 @@
       }
 
       typeRegistry.overwriteDeclaredType(typedef, realType);
-      if (candidate.getType() == Token.GETPROP) {
+      if (candidate.isGetProp()) {
         defineSlot(candidate, candidate.getParent(),
             getNativeType(NO_TYPE), false);
       }
     }
-
-    /**
-     * Handle typedefs.
-     * @param t The current traversal.
-     * @param candidate An ASSIGN or VAR node.
-     */
-    // TODO(nicksantos): Kill this.
-    private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) {
-      // old-style typedefs
-      String typedef = codingConvention.identifyTypeDefAssign(candidate);
-      if (typedef != null) {
-        // TODO(nicksantos|user): This is a terrible, terrible hack
-        // to bail out on recusive typedefs. We'll eventually need
-        // to handle these properly.
-        typeRegistry.declareType(typedef, getNativeType(UNKNOWN_TYPE));
-
-        JSDocInfo info = candidate.getJSDocInfo();
-        JSType realType = null;
-        if (info != null && info.getType() != null) {
-          realType = info.getType().evaluate(scope, typeRegistry);
-        }
-
-        if (realType == null) {
-          compiler.report(
-              JSError.make(
-                  t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));
-        }
-
-        typeRegistry.overwriteDeclaredType(typedef, realType);
-
-        // Duplicate typedefs get handled when we try to register
-        // this typedef in the scope.
-      }
-    }
   } // end GlobalScopeBuilder
 
   /**
@@ -1610,7 +1844,7 @@
    */
   private final class LocalScopeBuilder extends AbstractScopeBuilder {
     /**
-     * @param scope The scope that we're builidng.
+     * @param scope The scope that we're building.
      */
     private LocalScopeBuilder(Scope scope) {
       super(scope);
@@ -1621,6 +1855,16 @@
      */
     void build() {
       NodeTraversal.traverse(compiler, scope.getRootNode(), this);
+
+      AstFunctionContents contents =
+          getFunctionAnalysisResults(scope.getRootNode());
+      if (contents != null) {
+        for (String varName : contents.getEscapedVarNames()) {
+          Var v = scope.getVar(varName);
+          Preconditions.checkState(v.getScope() == scope);
+          v.markEscaped();
+        }
+      }
     }
 
     /**
@@ -1634,7 +1878,7 @@
     @Override public void visit(NodeTraversal t, Node n, Node parent) {
       if (n == scope.getRootNode()) return;
 
-      if (n.getType() == Token.LP && parent == scope.getRootNode()) {
+      if (n.isParamList() && parent == scope.getRootNode()) {
         handleFunctionInputs(parent);
         return;
       }
@@ -1670,7 +1914,8 @@
     private void declareArguments(Node functionNode) {
       Node astParameters = functionNode.getFirstChild().getNext();
       Node body = astParameters.getNext();
-      FunctionType functionType = (FunctionType) functionNode.getJSType();
+      FunctionType functionType =
+          JSType.toMaybeFunctionType(functionNode.getJSType());
       if (functionType != null) {
         Node jsDocParameters = functionType.getParametersNode();
         if (jsDocParameters != null) {
@@ -1678,7 +1923,7 @@
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
-                  jsDocParameter.getJSType(), true);
+                  jsDocParameter.getJSType(), false);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
@@ -1689,59 +1934,87 @@
     } // end declareArguments
   } // end LocalScopeBuilder
 
+  /**
+   * Does a first-order function analysis that just looks at simple things
+   * like what variables are escaped, and whether 'this' is used.
+   */
+  private static class FirstOrderFunctionAnalyzer
+      extends AbstractScopedCallback implements CompilerPass {
+    private final AbstractCompiler compiler;
+    private final Map<Node, AstFunctionContents> data;
+
+    FirstOrderFunctionAnalyzer(
+        AbstractCompiler compiler, Map<Node, AstFunctionContents> outParam) {
+      this.compiler = compiler;
+      this.data = outParam;
+    }
 
-  /** Find the best JSDoc for the given node. */
-  static JSDocInfo getBestJSDocInfo(Node n) {
-    JSDocInfo info = n.getJSDocInfo();
-    if (info == null) {
-      Node parent = n.getParent();
-      int parentType = parent.getType();
-      if (parentType == Token.NAME) {
-        info = parent.getJSDocInfo();
-        if (info == null && parent.getParent().hasOneChild()) {
-          info = parent.getParent().getJSDocInfo();
-        }
-      } else if (parentType == Token.ASSIGN) {
-        info = parent.getJSDocInfo();
-      } else if (NodeUtil.isObjectLitKey(parent, parent.getParent())) {
-        info = parent.getJSDocInfo();
+    @Override public void process(Node externs, Node root) {
+      if (externs == null) {
+        NodeTraversal.traverse(compiler, root, this);
+      } else {
+        NodeTraversal.traverseRoots(
+            compiler, ImmutableList.of(externs, root), this);
       }
     }
-    return info;
-  }
 
-  /** Find the l-value that the given r-value is being assigned to. */
-  private static Node getBestLValue(Node n) {
-    Node parent = n.getParent();
-    int parentType = parent.getType();
-    boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(n);
-    if (isFunctionDeclaration) {
-      return n.getFirstChild();
-    } else if (parentType == Token.NAME) {
-      return parent;
-    } else if (parentType == Token.ASSIGN) {
-      return parent.getFirstChild();
-    } else if (NodeUtil.isObjectLitKey(parent, parent.getParent())) {
-      return parent;
+    @Override public void enterScope(NodeTraversal t) {
+      if (!t.inGlobalScope()) {
+        Node n = t.getScopeRoot();
+        data.put(n, new AstFunctionContents(n));
+      }
     }
-    return null;
-  }
 
-  /** Get the name of the given l-value node. */
-  private static String getBestLValueName(@Nullable Node lValue) {
-    if (lValue == null || lValue.getParent() == null) {
-      return null;
-    }
-    if (NodeUtil.isObjectLitKey(lValue, lValue.getParent())) {
-      Node owner = getBestLValue(lValue.getParent());
-      if (owner != null) {
-        String ownerName = getBestLValueName(owner);
-        if (ownerName != null) {
-          return ownerName + "." + NodeUtil.getObjectLitKeyName(lValue);
+    @Override public void visit(NodeTraversal t, Node n, Node parent) {
+      if (t.inGlobalScope()) {
+        return;
+      }
+
+      if (n.isReturn() && n.getFirstChild() != null) {
+        data.get(t.getScopeRoot()).recordNonEmptyReturn();
+      }
+
+      if (t.getScopeDepth() <= 2) {
+        // We only need to worry about escaped variables at depth 3.
+        // An variable escaped at depth 2 is, by definition, a global variable.
+        // We treat all global variables as escaped by default, so there's
+        // no reason to do this extra computation for them.
+        return;
+      }
+
+      if (n.isName() && NodeUtil.isLValue(n)) {
+        String name = n.getString();
+        Scope scope = t.getScope();
+        Var var = scope.getVar(name);
+        if (var != null) {
+          Scope ownerScope = var.getScope();
+          if (scope != ownerScope && ownerScope.isLocal()) {
+            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);
+          }
+        }
+      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&
+          NodeUtil.isLValue(n)) {
+        String name = NodeUtil.getRootOfQualifiedName(n).getString();
+        Scope scope = t.getScope();
+        Var var = scope.getVar(name);
+        if (var != null) {
+          Scope ownerScope = var.getScope();
+          if (scope != ownerScope && ownerScope.isLocal()) {
+            data.get(ownerScope.getRootNode())
+                .recordEscapedQualifiedName(n.getQualifiedName());
+          }
         }
       }
+    }
+  }
+
+  private AstFunctionContents getFunctionAnalysisResults(@Nullable Node n) {
+    if (n == null) {
       return null;
     }
-    return lValue.getQualifiedName();
+
+    // Sometimes this will return null in things like
+    // NameReferenceGraphConstruction that build partial scopes.
+    return functionAnalysisResults.get(n);
   }
 }
diff -r -u original/test/com/google/javascript/jscomp/TypeCheckTest.java buggy/test/com/google/javascript/jscomp/TypeCheckTest.java
--- original/test/com/google/javascript/jscomp/TypeCheckTest.java	2023-06-13 15:31:38.155075273 +0800
+++ buggy/test/com/google/javascript/jscomp/TypeCheckTest.java	2023-06-12 11:40:18.211098884 +0800
@@ -19,6 +19,9 @@
 import com.google.common.base.Joiner;
 import com.google.common.collect.Lists;
 import com.google.javascript.jscomp.Scope.Var;
+import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
+import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
+import com.google.javascript.rhino.InputId;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.jstype.FunctionType;
@@ -45,7 +48,7 @@
 
   public void testInitialTypingScope() {
     Scope s = new TypedScopeCreator(compiler,
-        new DefaultCodingConvention()).createInitialScope(
+        CodingConventions.getDefault()).createInitialScope(
             new Node(Token.BLOCK));
 
     assertEquals(ARRAY_FUNCTION_TYPE, s.getVar("Array").getType());
@@ -101,11 +104,6 @@
         "/** @type {undefined|number} */var a;if (a == foo())return;}");
   }
 
-  public void testTypeCheck7() throws Exception {
-    testTypes("function foo() {delete 'abc';}",
-        TypeCheck.BAD_DELETE);
-  }
-
   public void testTypeCheck8() throws Exception {
     testTypes("/**@return {void}*/function foo(){do {} while (foo());}");
   }
@@ -230,6 +228,17 @@
         "required: string", false);
   }
 
+
+  public void testTypeCheckCustomExterns2() throws Exception {
+    testTypes(
+        DEFAULT_EXTERNS + "/** @enum {string} */ var Enum = {FOO: 1, BAR: 1};",
+        "/** @param {Enum} x */ function f(x) {} f(Enum.FOO); f(true);",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: Enum.<string>",
+        false);
+  }
+
   public void testParameterizedArray1() throws Exception {
     testTypes("/** @param {!Array.<number>} a\n" +
         "* @return {string}\n" +
@@ -244,7 +253,7 @@
         "* @return {number}\n" +
         "*/ var f = function(a) { return a[0]; };",
         "inconsistent return type\n" +
-        "found   : Array\n" +
+        "found   : Array.<number>\n" +
         "required: number");
   }
 
@@ -322,6 +331,16 @@
         "required: E.<string>");
   }
 
+  public void testParameterizedObject5() throws Exception {
+    testTypes("/** @constructor */ function F() {" +
+        "  /** @type {Object.<number, string>} */ this.numbers = {};" +
+        "}" +
+        "(new F()).numbers['ten'] = '10';",
+        "restricted index type\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
   public void testUnionOfFunctionAndType() throws Exception {
     testTypes("/** @type {null|(function(Number):void)} */ var a;" +
         "/** @type {(function(Number):void)|null} */ var b = null; a = b;");
@@ -372,8 +391,8 @@
   }
 
   public void testOptionalArgFunctionParamError() throws Exception {
-    String expectedWarning = "Parse error. variable length argument must be " +
-        "last";
+    String expectedWarning =
+        "Bad type annotation. variable length argument must be last";
     testTypes("/** @param {function(...[number], number=)} a */" +
               "function f(a) {};", expectedWarning, false);
   }
@@ -612,7 +631,7 @@
     // Don't do type inference on GETELEMs.
     testClosureTypes(
         CLOSURE_DEFS +
-        "function f(arguments) { " +
+        "function f(x) { " +
         "  return goog.isString(arguments[0]) ? arguments[0] : 0;" +
         "}", null);
   }
@@ -621,7 +640,7 @@
     // Don't do type inference on GETELEMs.
     testClosureTypes(
         CLOSURE_DEFS +
-        "function f(arguments) { " +
+        "function f(x) { " +
         "  return typeof arguments[0] == 'string' ? arguments[0] : 0;" +
         "}", null);
   }
@@ -834,6 +853,37 @@
         "};");
   }
 
+  public void testUndeclaredGlobalProperty1() throws Exception {
+    testTypes("/** @const */ var x = {}; x.y = null;" +
+        "function f(a) { x.y = a; }" +
+        "/** @param {string} a */ function g(a) { }" +
+        "function h() { g(x.y); }");
+  }
+
+  public void testUndeclaredGlobalProperty2() throws Exception {
+    testTypes("/** @const */ var x = {}; x.y = null;" +
+        "function f() { x.y = 3; }" +
+        "/** @param {string} a */ function g(a) { }" +
+        "function h() { g(x.y); }",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : (null|number)\n" +
+        "required: string");
+  }
+
+  public void testLocallyInferredGlobalProperty1() throws Exception {
+    // We used to have a bug where x.y.z leaked from f into h.
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** @type {number} */ F.prototype.z;" +
+        "/** @const */ var x = {}; /** @type {F} */ x.y;" +
+        "function f() { x.y.z = 'abc'; }" +
+        "/** @param {number} x */ function g(x) {}" +
+        "function h() { g(x.y.z); }",
+        "assignment to property z of F\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
   public void testPropertyInferredPropagation() throws Exception {
     testTypes("/** @return {Object} */function f() { return {}; }\n" +
          "function g() { var x = f(); if (x.p) x.a = 'a'; else x.a = 'b'; }\n" +
@@ -923,6 +973,38 @@
         "required: string");
   }
 
+  public void testPropertyInference9() throws Exception {
+    testTypes(
+        "/** @constructor */ function A() {}" +
+        "/** @return {function(): ?} */ function f() { " +
+        "  return function() {};" +
+        "}" +
+        "var g = f();" +
+        "/** @type {number} */ g.prototype.bar_ = null;",
+        "assignment\n" +
+        "found   : null\n" +
+        "required: number");
+  }
+
+  public void testPropertyInference10() throws Exception {
+    // NOTE(nicksantos): There used to be a bug where a property
+    // on the prototype of one structural function would leak onto
+    // the prototype of other variables with the same structural
+    // function type.
+    testTypes(
+        "/** @constructor */ function A() {}" +
+        "/** @return {function(): ?} */ function f() { " +
+        "  return function() {};" +
+        "}" +
+        "var g = f();" +
+        "/** @type {number} */ g.prototype.bar_ = 1;" +
+        "var h = f();" +
+        "/** @type {string} */ h.prototype.bar_ = 1;",
+        "assignment\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testNoPersistentTypeInferenceForObjectProperties()
       throws Exception {
     testTypes("/** @param {Object} o\n@param {string} x */\n" +
@@ -1215,7 +1297,7 @@
   }
 
   public void testNumericComparison6() throws Exception {
-    testTypes("/**@return void*/ function foo() { if (3 >= foo()) return; }",
+    testTypes("/**@return {void} */ function foo() { if (3 >= foo()) return; }",
         "right side of numeric comparison\n" +
         "found   : undefined\n" +
         "required: number");
@@ -1244,7 +1326,8 @@
   }
 
   public void testStringComparison6() throws Exception {
-    testTypes("/**@return void*/ function foo() { if ('a' >= foo()) return; }",
+    testTypes("/**@return {void} */ " +
+        "function foo() { if ('a' >= foo()) return; }",
         "right side of comparison\n" +
         "found   : undefined\n" +
         "required: string");
@@ -1408,40 +1491,55 @@
 
   public void testScoping11() throws Exception {
     // named function expressions create a binding in their body only
-    // the return is wrong but the assignment is ok since the type of b is ?
+    // the return is wrong but the assignment is OK since the type of b is ?
     testTypes(
-        "/** @return number */var a = function b(){ return b };",
+        "/** @return {number} */var a = function b(){ return b };",
         "inconsistent return type\n" +
         "found   : function (): number\n" +
         "required: number");
   }
 
+  public void testScoping12() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** @type {number} */ F.prototype.bar = 3;" +
+        "/** @param {!F} f */ function g(f) {" +
+        "  /** @return {string} */" +
+        "  function h() {" +
+        "    return f.bar;" +
+        "  }" +
+        "}",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testFunctionArguments1() throws Exception {
     testFunctionType(
-        "/** @param {number} a\n@return string */" +
+        "/** @param {number} a\n@return {string} */" +
         "function f(a) {}",
         "function (number): string");
   }
 
   public void testFunctionArguments2() throws Exception {
     testFunctionType(
-        "/** @param {number} opt_a\n@return string */" +
+        "/** @param {number} opt_a\n@return {string} */" +
         "function f(opt_a) {}",
-        "function ((number|undefined)): string");
+        "function (number=): string");
   }
 
   public void testFunctionArguments3() throws Exception {
     testFunctionType(
-        "/** @param {number} b\n@return string */" +
+        "/** @param {number} b\n@return {string} */" +
         "function f(a,b) {}",
         "function (?, number): string");
   }
 
   public void testFunctionArguments4() throws Exception {
     testFunctionType(
-        "/** @param {number} opt_a\n@return string */" +
+        "/** @param {number} opt_a\n@return {string} */" +
         "function f(a,opt_a) {}",
-        "function (?, (number|undefined)): string");
+        "function (?, number=): string");
   }
 
   public void testFunctionArguments5() throws Exception {
@@ -1458,7 +1556,7 @@
 
   public void testFunctionArguments7() throws Exception {
     testTypes(
-        "/** @param {number} opt_a\n@return string */" +
+        "/** @param {number} opt_a\n@return {string} */" +
         "function a(a,opt_a,var_args) {}");
   }
 
@@ -1494,13 +1592,13 @@
   }
 
   public void testFunctionArguments13() throws Exception {
-    // verifying that the argument type have inferable types
+    // verifying that the argument type have non-inferable types
     testTypes(
         "/** @return {boolean} */ function u() { return true; }" +
-        "/** @param {boolean} b\n@return boolean */" +
+        "/** @param {boolean} b\n@return {?boolean} */" +
         "function f(b) { if (u()) { b = null; } return b; }",
-        "inconsistent return type\n" +
-        "found   : (boolean|null)\n" +
+        "assignment\n" +
+        "found   : null\n" +
         "required: boolean");
   }
 
@@ -1578,14 +1676,14 @@
 
   public void testFunctionInference5() throws Exception {
     testFunctionType(
-        "/** @this Date\n@return string */function f(a) {}",
+        "/** @this Date\n@return {string} */function f(a) {}",
         "function (this:Date, ?): string");
   }
 
   public void testFunctionInference6() throws Exception {
     testFunctionType(
-        "/** @this Date\n@return string */function f(opt_a) {}",
-        "function (this:Date, ?): string");
+        "/** @this Date\n@return {string} */function f(opt_a) {}",
+        "function (this:Date, ?=): string");
   }
 
   public void testFunctionInference7() throws Exception {
@@ -1608,7 +1706,7 @@
 
   public void testFunctionInference10() throws Exception {
     testFunctionType(
-        "/** @this Date\n@param {boolean} b\n@return string */" +
+        "/** @this Date\n@param {boolean} b\n@return {string} */" +
         "var f = function(a,b) {};",
         "function (this:Date, ?, boolean): string");
   }
@@ -1616,7 +1714,7 @@
   public void testFunctionInference11() throws Exception {
     testFunctionType(
         "var goog = {};" +
-        "/** @return number*/goog.f = function(){};",
+        "/** @return {number}*/goog.f = function(){};",
         "goog.f",
         "function (): number");
   }
@@ -1694,6 +1792,34 @@
         "function (this:Date): ?");
   }
 
+  public void testFunctionInference21() throws Exception {
+    testTypes(
+        "var f = function() { throw 'x' };" +
+        "/** @return {boolean} */ var g = f;");
+    testFunctionType(
+        "var f = function() { throw 'x' };",
+        "f",
+        "function (): ?");
+  }
+
+  public void testFunctionInference22() throws Exception {
+    testTypes(
+        "/** @type {!Function} */ var f = function() { g(this); };" +
+        "/** @param {boolean} x */ var g = function(x) {};");
+  }
+
+  public void testFunctionInference23() throws Exception {
+    // We want to make sure that 'prop' isn't declared on all objects.
+    testTypes(
+        "/** @type {!Function} */ var f = function() {\n" +
+        "  /** @type {number} */ this.prop = 3;\n" +
+        "};" +
+        "/**\n" +
+        " * @param {Object} x\n" +
+        " * @return {string}\n" +
+        " */ var g = function(x) { return x.prop; };");
+  }
+
   public void testInnerFunction1() throws Exception {
     testTypes(
         "function f() {" +
@@ -1771,7 +1897,10 @@
         " var x = 0 || function() {};\n" +
         " function g() { if (goog.isFunction(x)) { x(1); } }" +
         " g();" +
-        "}", null);
+        "}",
+        "Function x: called with 1 argument(s). " +
+        "Function requires at least 0 argument(s) " +
+        "and no more than 0 argument(s).");
   }
 
   public void testInnerFunction7() throws Exception {
@@ -1811,6 +1940,43 @@
         "}");
   }
 
+  public void testInnerFunction10() throws Exception {
+    testTypes(
+        "function f() {" +
+        "  /** @type {?number} */ var x = null;" +
+        "  /** @return {string} */" +
+        "  function g() {" +
+        "    if (!x) {" +
+        "      x = 1;" +
+        "    }" +
+        "    return x;" +
+        "  }" +
+        "}",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testInnerFunction11() throws Exception {
+    // TODO(nicksantos): This is actually bad inference, because
+    // h sets x to null. We should fix this, but for now we do it
+    // this way so that we don't break existing binaries. We will
+    // need to change TypeInference#isUnflowable to fix this.
+    testTypes(
+        "function f() {" +
+        "  /** @type {?number} */ var x = null;" +
+        "  /** @return {number} */" +
+        "  function g() {" +
+        "    x = 1;" +
+        "    h();" +
+        "    return x;" +
+        "  }" +
+        "  function h() {" +
+        "    x = null;" +
+        "  }" +
+        "}");
+  }
+
   public void testAbstractMethodHandling1() throws Exception {
     testTypes(
         "/** @type {Function} */ var abstractFn = function() {};" +
@@ -1940,10 +2106,7 @@
         "/** @constructor \n * @extends {F} */ " +
         "function G() {}" +
         "/** @override */ G.prototype.foo = function() { };" +
-        "(new G()).foo(1);",
-        "Function G.prototype.foo: called with 1 argument(s). " +
-        "Function requires at least 0 argument(s) " +
-        "and no more than 0 argument(s).");
+        "(new G()).foo(1);");
   }
 
   public void testMethodInference7() throws Exception {
@@ -1952,11 +2115,11 @@
         "F.prototype.foo = function() { };" +
         "/** @constructor \n * @extends {F} */ " +
         "function G() {}" +
-        "/** @override */ G.prototype.foo = function(x, y) { };" +
-        "(new G()).foo();",
-        "Function G.prototype.foo: called with 0 argument(s). " +
-        "Function requires at least 2 argument(s) " +
-        "and no more than 2 argument(s).");
+        "/** @override */ G.prototype.foo = function(x, y) { };",
+        "mismatch of the foo property type and the type of the property " +
+        "it overrides from superclass F\n" +
+        "original: function (this:F): undefined\n" +
+        "override: function (this:G, ?, ?): undefined");
   }
 
   public void testMethodInference8() throws Exception {
@@ -1966,10 +2129,8 @@
         "/** @constructor \n * @extends {F} */ " +
         "function G() {}" +
         "/** @override */ " +
-        "G.prototype.foo = function(a, opt_b, var_args) { };" +
-        "(new G()).foo();",
-        "Function G.prototype.foo: called with 0 argument(s). " +
-        "Function requires at least 1 argument(s).");
+        "G.prototype.foo = function(opt_b, var_args) { };" +
+        "(new G()).foo(1, 2, 3);");
   }
 
   public void testMethodInference9() throws Exception {
@@ -1979,7 +2140,7 @@
         "/** @constructor \n * @extends {F} */ " +
         "function G() {}" +
         "/** @override */ " +
-        "G.prototype.foo = function(a, var_args, opt_b) { };",
+        "G.prototype.foo = function(var_args, opt_b) { };",
         "variable length argument must be last");
   }
 
@@ -2078,23 +2239,31 @@
   }
 
   public void testDuplicateStaticPropertyDecl4() throws Exception {
-    testTypes(
+    testClosureTypesMultipleWarnings(
         "var goog = goog || {};" +
         "/** @type {!Foo} */ goog.foo;" +
         "/** @type {string} */ goog.foo = 'x';" +
         "/** @constructor */ function Foo() {}",
-        "variable goog.foo redefined with type string, " +
-        "original definition at [testcode]:1 with type Foo");
+        Lists.newArrayList(
+            "assignment to property foo of goog\n" +
+            "found   : string\n" +
+            "required: Foo",
+            "variable goog.foo redefined with type string, " +
+            "original definition at [testcode]:1 with type Foo"));
   }
 
   public void testDuplicateStaticPropertyDecl5() throws Exception {
-    testTypes(
+    testClosureTypesMultipleWarnings(
         "var goog = goog || {};" +
         "/** @type {!Foo} */ goog.foo;" +
         "/** @type {string}\n * @suppress {duplicate} */ goog.foo = 'x';" +
         "/** @constructor */ function Foo() {}",
-        "variable goog.foo redefined with type string, " +
-        "original definition at [testcode]:1 with type Foo");
+        Lists.newArrayList(
+            "assignment to property foo of goog\n" +
+            "found   : string\n" +
+            "required: Foo",
+            "variable goog.foo redefined with type string, " +
+            "original definition at [testcode]:1 with type Foo"));
   }
 
   public void testDuplicateStaticPropertyDecl6() throws Exception {
@@ -2127,12 +2296,89 @@
         "/** @constructor */ function EventCopy() {}");
   }
 
-  public void testDuplicateLocalVarDecl() throws Exception {
+  public void testDuplicateStaticPropertyDec20() throws Exception {
     testTypes(
+        "/**\n" +
+        " * @fileoverview\n" +
+        " * @suppress {duplicate}\n" +
+        " */" +
+        "var goog = goog || {};" +
+        "/** @type {string} */ goog.foo = 'y';" +
+        "/** @type {string} */ goog.foo = 'x';");
+  }
+
+  public void testDuplicateLocalVarDecl() throws Exception {
+    testClosureTypesMultipleWarnings(
         "/** @param {number} x */\n" +
         "function f(x) { /** @type {string} */ var x = ''; }",
-        "variable x redefined with type string, " +
-        "original definition at [testcode]:2 with type number");
+        Lists.newArrayList(
+            "variable x redefined with type string, original definition" +
+            " at [testcode]:2 with type number",
+            "initializing variable\n" +
+            "found   : string\n" +
+            "required: number"));
+  }
+
+  public void testDuplicateInstanceMethod1() throws Exception {
+    // If there's no jsdoc on the methods, then we treat them like
+    // any other inferred properties.
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "F.prototype.bar = function() {};" +
+        "F.prototype.bar = function() {};");
+  }
+
+  public void testDuplicateInstanceMethod2() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** jsdoc */ F.prototype.bar = function() {};" +
+        "/** jsdoc */ F.prototype.bar = function() {};",
+        "variable F.prototype.bar redefined with type " +
+        "function (this:F): undefined, original definition at " +
+        "[testcode]:1 with type function (this:F): undefined");
+  }
+
+  public void testDuplicateInstanceMethod3() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "F.prototype.bar = function() {};" +
+        "/** jsdoc */ F.prototype.bar = function() {};",
+        "variable F.prototype.bar redefined with type " +
+        "function (this:F): undefined, original definition at " +
+        "[testcode]:1 with type function (this:F): undefined");
+  }
+
+  public void testDuplicateInstanceMethod4() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** jsdoc */ F.prototype.bar = function() {};" +
+        "F.prototype.bar = function() {};");
+  }
+
+  public void testDuplicateInstanceMethod5() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** jsdoc \n * @return {number} */ F.prototype.bar = function() {" +
+        "  return 3;" +
+        "};" +
+        "/** jsdoc \n * @suppress {duplicate} */ " +
+        "F.prototype.bar = function() { return ''; };",
+        "inconsistent return type\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testDuplicateInstanceMethod6() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** jsdoc \n * @return {number} */ F.prototype.bar = function() {" +
+        "  return 3;" +
+        "};" +
+        "/** jsdoc \n * @return {string} * \n @suppress {duplicate} */ " +
+        "F.prototype.bar = function() { return ''; };",
+        "assignment to property bar of F.prototype\n" +
+        "found   : function (this:F): string\n" +
+        "required: function (this:F): number");
   }
 
   public void testStubFunctionDeclaration1() throws Exception {
@@ -2285,7 +2531,7 @@
   public void testIn4() throws Exception {
     testTypes("Date in Object",
         "left side of 'in'\n" +
-        "found   : function (new:Date, ?, ?, ?, ?, ?, ?, ?): string\n" +
+        "found   : function (new:Date, ?=, ?=, ?=, ?=, ?=, ?=, ?=): string\n" +
         "required: string");
   }
 
@@ -2401,7 +2647,7 @@
     testTypes("/**@type number*/var a;" +
         "/**@type !Date */var b;" +
         "if (a!==b) {}",
-        "condition always evaluates to the same value\n" +
+        "condition always evaluates to true\n" +
         "left : number\n" +
         "right: Date");
   }
@@ -2487,6 +2733,60 @@
         "right: boolean");
   }
 
+  public void testComparison14() throws Exception {
+    testTypes("/** @type {function((Array|string), Object): number} */" +
+        "function f(x, y) { return x === y; }",
+        "inconsistent return type\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testComparison15() throws Exception {
+    testClosureTypes(
+        CLOSURE_DEFS +
+        "/** @constructor */ function F() {}" +
+        "/**\n" +
+        " * @param {number} x\n" +
+        " * @constructor\n" +
+        " * @extends {F}\n" +
+        " */\n" +
+        "function G(x) {}\n" +
+        "goog.inherits(G, F);\n" +
+        "/**\n" +
+        " * @param {number} x\n" +
+        " * @constructor\n" +
+        " * @extends {G}\n" +
+        " */\n" +
+        "function H(x) {}\n" +
+        "goog.inherits(H, G);\n" +
+        "/** @param {G} x */" +
+        "function f(x) { return x.constructor === H; }",
+        null);
+  }
+
+  public void testDeleteOperator1() throws Exception {
+    testTypes(
+        "var x = {};" +
+        "/** @return {string} */ function f() { return delete x['a']; }",
+        "inconsistent return type\n" +
+        "found   : boolean\n" +
+        "required: string");
+  }
+
+  public void testDeleteOperator2() throws Exception {
+    testTypes(
+        "var obj = {};" +
+        "/** \n" +
+        " * @param {string} x\n" +
+        " * @return {Object} */ function f(x) { return obj; }" +
+        "/** @param {?number} x */ function g(x) {" +
+        "  if (x) { delete f(x)['a']; }" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testEnumStaticMethod1() throws Exception {
     testTypes(
         "/** @enum */ var Foo = {AAA: 1};" +
@@ -2519,19 +2819,20 @@
 
   public void testEnum3() throws Exception {
     testTypes("/**@enum*/var a={BB:1,BB:2}",
-        "enum element BB already defined", true);
+        "variable a.BB redefined with type a.<number>, " +
+        "original definition at [testcode]:1 with type a.<number>");
   }
 
   public void testEnum4() throws Exception {
     testTypes("/**@enum*/var a={BB:'string'}",
-        "element type must match enum's type\n" +
+        "assignment to property BB of enum{a}\n" +
         "found   : string\n" +
         "required: number");
   }
 
   public void testEnum5() throws Exception {
     testTypes("/**@enum {String}*/var a={BB:'string'}",
-        "element type must match enum's type\n" +
+        "assignment to property BB of enum{a}\n" +
         "found   : string\n" +
         "required: (String|null)");
   }
@@ -2550,15 +2851,23 @@
   }
 
   public void testEnum8() throws Exception {
-    testTypes("/** @enum */var a=8;",
-        "enum initializer must be an object literal or an enum");
+    testClosureTypesMultipleWarnings("/** @enum */var a=8;",
+        Lists.newArrayList(
+            "enum initializer must be an object literal or an enum",
+            "initializing variable\n" +
+            "found   : number\n" +
+            "required: enum{a}"));
   }
 
   public void testEnum9() throws Exception {
-    testTypes(
+    testClosureTypesMultipleWarnings(
         "var goog = {};" +
         "/** @enum */goog.a=8;",
-        "enum initializer must be an object literal or an enum");
+        Lists.newArrayList(
+            "assignment to property a of goog\n" +
+            "found   : number\n" +
+            "required: enum{goog.a}",
+            "enum initializer must be an object literal or an enum"));
   }
 
   public void testEnum10() throws Exception {
@@ -2605,14 +2914,15 @@
 
   public void testEnum16() throws Exception {
     testTypes("var goog = {};" +
-        "/**@enum*/goog.a={BB:1,BB:2}",
-        "enum element BB already defined", true);
+        "/**@enum*/goog .a={BB:1,BB:2}",
+        "variable goog.a.BB redefined with type goog.a.<number>, " +
+        "original definition at [testcode]:1 with type goog.a.<number>");
   }
 
   public void testEnum17() throws Exception {
     testTypes("var goog = {};" +
         "/**@enum*/goog.a={BB:'string'}",
-        "element type must match enum's type\n" +
+        "assignment to property BB of enum{goog.a}\n" +
         "found   : string\n" +
         "required: number");
   }
@@ -2768,6 +3078,23 @@
         "required: number");
   }
 
+  public void testEnum41() throws Exception {
+    testTypes(
+        "/** @enum {number} */ var MyEnum = {/** @const */ FOO: 1};" +
+        "/** @return {string} */" +
+        "function f() { return MyEnum.FOO; }",
+        "inconsistent return type\n" +
+        "found   : MyEnum.<number>\n" +
+        "required: string");
+  }
+
+  public void testEnum42() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @enum {Object} */ var MyEnum = {FOO: {newProperty: 1, b: 2}};" +
+        "f(MyEnum.FOO.newProperty);");
+  }
+
   public void testAliasedEnum1() throws Exception {
     testTypes(
         "/** @enum */ var YourEnum = {FOO: 3};" +
@@ -2877,15 +3204,6 @@
         "required: string");
   }
 
-  public void testBackwardsTypedefUse5() throws Exception {
-    testTypes(
-        "/** @return {MyTypedef} */ function f() { return null; }" +
-        "/** @type {string} */ var MyTypedef = goog.typedef;",
-        "inconsistent return type\n" +
-        "found   : null\n" +
-        "required: string");
-  }
-
   public void testBackwardsTypedefUse6() throws Exception {
     testTypes(
         "/** @return {goog.MyTypedef} */ function f() { return null; }" +
@@ -2904,7 +3222,7 @@
   }
 
   public void testBackwardsTypedefUse8() throws Exception {
-    // Tehnically, this isn't quite right, because the JS runtime
+    // Technically, this isn't quite right, because the JS runtime
     // will coerce null -> the global object. But we'll punt on that for now.
     testTypes(
         "/** @param {!Array} x */ function g(x) {}" +
@@ -2924,6 +3242,18 @@
         "required: Array");
   }
 
+  public void testBackwardsTypedefUse10() throws Exception {
+    testTypes(
+        "/** @param {goog.MyEnum} x */ function g(x) {}" +
+        "var goog = {};" +
+        "/** @enum {goog.MyTypedef} */ goog.MyEnum = {FOO: 1};" +
+        "/** @typedef {number} */ goog.MyTypedef;" +
+        "g(1);",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: goog.MyEnum.<number>");
+  }
+
   public void testBackwardsConstructor1() throws Exception {
     testTypes(
         "function f() { (new Foo(true)); }" +
@@ -3011,7 +3341,7 @@
         "/** @extends {base}\n * @constructor */function derived() {}\n" +
         "derived.inherits(base);",
         "(new derived).constructor",
-        "function (new:derived): undefined");
+        "function (new:derived, ...[?]): ?");
   }
 
   public void testGoodExtends8() throws Exception {
@@ -3076,10 +3406,59 @@
         "required: number");
   }
 
+  public void testGoodExtends14() throws Exception {
+    testTypes(
+        CLOSURE_DEFS +
+        "/** @param {Function} f */ function g(f) {" +
+        "  /** @constructor */ function NewType() {};" +
+        "  goog.inherits(NewType, f);" +
+        "  (new NewType());" +
+        "}");
+  }
+
+  public void testGoodExtends15() throws Exception {
+    testTypes(
+        CLOSURE_DEFS +
+        "/** @constructor */ function OldType() {}" +
+        "/** @param {?function(new:OldType)} f */ function g(f) {" +
+        "  /**\n" +
+        "    * @constructor\n" +
+        "    * @extends {OldType}\n" +
+        "    */\n" +
+        "  function NewType() {};" +
+        "  goog.inherits(NewType, f);" +
+        "  NewType.prototype.method = function() {" +
+        "    NewType.superClass_.foo.call(this);" +
+        "  };" +
+        "}",
+        "Property foo never defined on OldType.prototype");
+  }
+
+  public void testGoodExtends16() throws Exception {
+    testTypes(
+        CLOSURE_DEFS +
+        "/** @param {Function} f */ function g(f) {" +
+        "  /** @constructor */ function NewType() {};" +
+        "  goog.inherits(f, NewType);" +
+        "  (new NewType());" +
+        "}");
+  }
+
+  public void testGoodExtends17() throws Exception {
+    testFunctionType(
+        "Function.prototype.inherits = function(x) {};" +
+        "/** @constructor */function base() {}\n" +
+        "/** @param {number} x */ base.prototype.bar = function(x) {};\n" +
+        "/** @extends {base}\n * @constructor */function derived() {}\n" +
+        "derived.inherits(base);",
+        "(new derived).constructor.prototype.bar",
+        "function (this:base, number): undefined");
+  }
+
   public void testBadExtends1() throws Exception {
     testTypes("/** @constructor */function base() {}\n" +
         "/** @constructor\n * @extends {not_base} */function derived() {}\n",
-        "Parse error. Unknown type not_base");
+        "Bad type annotation. Unknown type not_base");
   }
 
   public void testBadExtends2() throws Exception {
@@ -3111,7 +3490,7 @@
         "/** @constructor \n * @extends {Sub} */ function Sub2() {}" +
         "/** @param {Sub} x */ function foo(x) {}" +
         "foo(new Sub2());",
-        "Parse error. Unknown type bad");
+        "Bad type annotation. Unknown type bad");
   }
 
   public void testLateExtends() throws Exception {
@@ -3232,7 +3611,7 @@
 
   public void testGoodImplements3() throws Exception {
     testTypes("/** @interface */function Disposable() {}\n" +
-        "/** @implements {Disposable}\n * @interface */function f() {}");
+        "/** @constructor \n @implements {Disposable} */function f() {}");
   }
 
   public void testGoodImplements4() throws Exception {
@@ -3248,6 +3627,44 @@
         "goog.SubDisposable.prototype.dispose = function() {};");
   }
 
+  public void testGoodImplements5() throws Exception {
+    testTypes(
+        "/** @interface */\n" +
+        "goog.Disposable = function() {};" +
+        "/** @type {Function} */" +
+        "goog.Disposable.prototype.dispose = function() {};" +
+        "/** @implements {goog.Disposable}\n * @constructor */" +
+        "goog.SubDisposable = function() {};" +
+        "/** @param {number} key \n @override */ " +
+        "goog.SubDisposable.prototype.dispose = function(key) {};");
+  }
+
+  public void testGoodImplements6() throws Exception {
+    testTypes(
+        "var myNullFunction = function() {};" +
+        "/** @interface */\n" +
+        "goog.Disposable = function() {};" +
+        "/** @return {number} */" +
+        "goog.Disposable.prototype.dispose = myNullFunction;" +
+        "/** @implements {goog.Disposable}\n * @constructor */" +
+        "goog.SubDisposable = function() {};" +
+        "/** @return {number} \n @override */ " +
+        "goog.SubDisposable.prototype.dispose = function() { return 0; };");
+  }
+
+  public void testGoodImplements7() throws Exception {
+    testTypes(
+        "var myNullFunction = function() {};" +
+        "/** @interface */\n" +
+        "goog.Disposable = function() {};" +
+        "/** @return {number} */" +
+        "goog.Disposable.prototype.dispose = function() {};" +
+        "/** @implements {goog.Disposable}\n * @constructor */" +
+        "goog.SubDisposable = function() {};" +
+        "/** @return {number} \n @override */ " +
+        "goog.SubDisposable.prototype.dispose = function() { return 0; };");
+  }
+
   public void testBadImplements1() throws Exception {
     testTypes("/** @interface */function Base1() {}\n" +
         "/** @interface */function Base2() {}\n" +
@@ -3255,7 +3672,7 @@
         " * @implements {nonExistent}\n" +
         " * @implements {Base2}\n" +
         " */ function derived() {}",
-        "Parse error. Unknown type nonExistent");
+        "Bad type annotation. Unknown type nonExistent");
   }
 
   public void testBadImplements2() throws Exception {
@@ -3274,6 +3691,33 @@
         "property method on interface Disposable is not implemented by type f");
   }
 
+  public void testBadImplements4() throws Exception {
+    testTypes("/** @interface */function Disposable() {}\n" +
+        "/** @implements {Disposable}\n * @interface */function f() {}",
+        "f cannot implement this type; an interface can only extend, " +
+        "but not implement interfaces");
+  }
+
+  public void testBadImplements5() throws Exception {
+    testTypes("/** @interface */function Disposable() {}\n" +
+        "/** @type {number} */ Disposable.prototype.bar = function() {};",
+        "assignment to property bar of Disposable.prototype\n" +
+        "found   : function (): undefined\n" +
+        "required: number");
+  }
+
+  public void testBadImplements6() throws Exception {
+    testClosureTypesMultipleWarnings(
+        "/** @interface */function Disposable() {}\n" +
+        "/** @type {function()} */ Disposable.prototype.bar = 3;",
+        Lists.newArrayList(
+            "assignment to property bar of Disposable.prototype\n" +
+            "found   : number\n" +
+            "required: function (): ?",
+            "interface members can only be empty property declarations, " +
+            "empty functions, or goog.abstractMethod"));
+  }
+
   public void testInterfaceExtends() throws Exception {
     testTypes("/** @interface */function A() {}\n" +
         "/** @interface \n * @extends {A} */function B() {}\n" +
@@ -3284,7 +3728,7 @@
 
   public void testBadInterfaceExtends1() throws Exception {
     testTypes("/** @interface \n * @extends {nonExistent} */function A() {}",
-        "Parse error. Unknown type nonExistent");
+        "Bad type annotation. Unknown type nonExistent");
   }
 
   public void testBadInterfaceExtends2() throws Exception {
@@ -3401,7 +3845,8 @@
   public void testInterfaceAssignment8() throws Exception {
     testTypes("/** @interface */var I = function() {};\n" +
         "/** @type {I} */var i;\n" +
-        "/** @type {Object} */var o = i;");
+        "/** @type {Object} */var o = i;\n" +
+        "new Object().prototype = i.prototype;");
   }
 
   public void testInterfaceAssignment9() throws Exception {
@@ -3455,14 +3900,14 @@
 
   public void testGetprop1() throws Exception {
     testTypes("/** @return {void}*/function foo(){foo().bar;}",
-        "undefined has no properties\n" +
+        "No properties on this expression\n" +
         "found   : undefined\n" +
         "required: Object");
   }
 
   public void testGetprop2() throws Exception {
     testTypes("var x = null; x.alert();",
-        "null has no properties\n" +
+        "No properties on this expression\n" +
         "found   : null\n" +
         "required: Object");
   }
@@ -3527,6 +3972,14 @@
         "required: Object");
   }
 
+  public void testArrayAccess9() throws Exception {
+    testTypes("/** @return {?Array} */ function f() { return []; }" +
+        "f()[{}]",
+        "array access\n" +
+        "found   : {}\n" +
+        "required: number");
+  }
+
   public void testPropAccess() throws Exception {
     testTypes("/** @param {*} x */var f = function(x) {\n" +
         "var o = String(x);\n" +
@@ -3537,7 +3990,7 @@
 
   public void testPropAccess2() throws Exception {
     testTypes("var bar = void 0; bar.baz;",
-        "undefined has no properties\n" +
+        "No properties on this expression\n" +
         "found   : undefined\n" +
         "required: Object");
   }
@@ -3546,7 +3999,7 @@
     // Verifies that we don't emit two warnings, because
     // the var has been dereferenced after the first one.
     testTypes("var bar = void 0; bar.baz; bar.bax;",
-        "undefined has no properties\n" +
+        "No properties on this expression\n" +
         "found   : undefined\n" +
         "required: Object");
   }
@@ -4096,8 +4549,6 @@
   public void testClosure7() throws Exception {
     testClosureTypes(
         CLOSURE_DEFS +
-        "goog.asserts = {};" +
-        "/** @return {*} */ goog.asserts.assert = function(x) { return x; };" +
         "/** @type {string|null|undefined} */ var a = foo();" +
         "/** @type {number} */" +
         "var b = goog.asserts.assert(a);",
@@ -4141,7 +4592,7 @@
 
   public void testReturn6() throws Exception {
     testTypes(
-        "/** @param {number} opt_a\n@return string */" +
+        "/** @param {number} opt_a\n@return {string} */" +
         "function a(opt_a) { return opt_a }",
         "inconsistent return type\n" +
         "found   : (number|undefined)\n" +
@@ -4346,6 +4797,114 @@
         "required: string");
   }
 
+  public void testOverriddenParams1() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @param {...?} var_args */" +
+        "Foo.prototype.bar = function(var_args) {};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @param {number} x\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function(x) {};");
+  }
+
+  public void testOverriddenParams2() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @type {function(...[?])} */" +
+        "Foo.prototype.bar = function(var_args) {};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @type {function(number)}\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function(x) {};");
+  }
+
+  public void testOverriddenParams3() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @param {...number} var_args */" +
+        "Foo.prototype.bar = function(var_args) { };" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @param {number} x\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function(x) {};",
+        "mismatch of the bar property type and the type of the " +
+        "property it overrides from superclass Foo\n" +
+        "original: function (this:Foo, ...[number]): undefined\n" +
+        "override: function (this:SubFoo, number): undefined");
+  }
+
+  public void testOverriddenParams4() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @type {function(...[number])} */" +
+        "Foo.prototype.bar = function(var_args) {};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @type {function(number)}\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function(x) {};",
+        "mismatch of the bar property type and the type of the " +
+        "property it overrides from superclass Foo\n" +
+        "original: function (...[number]): ?\n" +
+        "override: function (number): ?");
+  }
+
+  public void testOverriddenParams5() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @param {number} x */" +
+        "Foo.prototype.bar = function(x) { };" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function() {};" +
+        "(new SubFoo()).bar();");
+  }
+
+  public void testOverriddenParams6() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @param {number} x */" +
+        "Foo.prototype.bar = function(x) { };" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function() {};" +
+        "(new SubFoo()).bar(true);",
+        "actual parameter 1 of SubFoo.prototype.bar " +
+        "does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
   public void testOverriddenReturn1() throws Exception {
     testTypes(
         "/** @constructor */ function Foo() {}" +
@@ -4376,18 +4935,106 @@
   public void testThis1() throws Exception {
     testTypes("var goog = {};" +
         "/** @constructor */goog.A = function(){};" +
-        "/** @return number */goog.A.prototype.n = function() { return this };",
+        "/** @return {number} */" +
+        "goog.A.prototype.n = function() { return this };",
         "inconsistent return type\n" +
         "found   : goog.A\n" +
         "required: number");
   }
 
+  public void testOverriddenProperty1() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @type {Object} */" +
+        "Foo.prototype.bar = {};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @type {Array}\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = [];");
+  }
+
+  public void testOverriddenProperty2() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {" +
+        "  /** @type {Object} */" +
+        "  this.bar = {};" +
+        "}" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @type {Array}\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = [];");
+  }
+
+  public void testOverriddenProperty3() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {" +
+        "}" +
+        "/** @type {string} */ Foo.prototype.data;" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/** @type {string|Object} \n @override */ " +
+        "SubFoo.prototype.data = null;",
+        "mismatch of the data property type and the type " +
+        "of the property it overrides from superclass Foo\n" +
+        "original: string\n" +
+        "override: (Object|null|string)");
+  }
+
+  public void testOverriddenProperty4() throws Exception {
+    // These properties aren't declared, so there should be no warning.
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype.bar = null;" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "SubFoo.prototype.bar = 3;");
+  }
+
+  public void testOverriddenProperty5() throws Exception {
+    // An override should be OK if the superclass property wasn't declared.
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype.bar = null;" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/** @override */ SubFoo.prototype.bar = 3;");
+  }
+
+  public void testOverriddenProperty6() throws Exception {
+    // The override keyword shouldn't be neccessary if the subclass property
+    // is inferred.
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @type {?number} */ Foo.prototype.bar = null;" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "SubFoo.prototype.bar = 3;");
+  }
+
   public void testThis2() throws Exception {
     testTypes("var goog = {};" +
         "/** @constructor */goog.A = function(){" +
         "  this.foo = null;" +
         "};" +
-        "/** @return number */" +
+        "/** @return {number} */" +
         "goog.A.prototype.n = function() { return this.foo };",
         "inconsistent return type\n" +
         "found   : null\n" +
@@ -4407,7 +5054,7 @@
         "/** @constructor */goog.A = function(){" +
         "  /** @type {string?} */this.foo = null;" +
         "};" +
-        "/** @return number */goog.A.prototype.n = function() {" +
+        "/** @return {number} */goog.A.prototype.n = function() {" +
         "  return this.foo };",
         "inconsistent return type\n" +
         "found   : (null|string)\n" +
@@ -4415,7 +5062,7 @@
   }
 
   public void testThis5() throws Exception {
-    testTypes("/** @this Date\n@return number*/function h() { return this }",
+    testTypes("/** @this Date\n@return {number}*/function h() { return this }",
         "inconsistent return type\n" +
         "found   : Date\n" +
         "required: number");
@@ -4423,7 +5070,7 @@
 
   public void testThis6() throws Exception {
     testTypes("var goog = {};" +
-        "/** @constructor\n@return !Date */" +
+        "/** @constructor\n@return {!Date} */" +
         "goog.A = function(){ return this };",
         "inconsistent return type\n" +
         "found   : goog.A\n" +
@@ -4432,7 +5079,7 @@
 
   public void testThis7() throws Exception {
     testTypes("/** @constructor */function A(){};" +
-        "/** @return number */A.prototype.n = function() { return this };",
+        "/** @return {number} */A.prototype.n = function() { return this };",
         "inconsistent return type\n" +
         "found   : A\n" +
         "required: number");
@@ -4442,7 +5089,7 @@
     testTypes("/** @constructor */function A(){" +
         "  /** @type {string?} */this.foo = null;" +
         "};" +
-        "/** @return number */A.prototype.n = function() {" +
+        "/** @return {number} */A.prototype.n = function() {" +
         "  return this.foo };",
         "inconsistent return type\n" +
         "found   : (null|string)\n" +
@@ -4481,6 +5128,80 @@
         "required: number");
   }
 
+  public void testThis12() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @constructor */ function Ctor() {}" +
+        "Ctor.prototype['method'] = function() {" +
+        "  f(this);" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : Ctor\n" +
+        "required: number");
+  }
+
+  public void testThis13() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @constructor */ function Ctor() {}" +
+        "Ctor.prototype = {" +
+        "  method: function() {" +
+        "    f(this);" +
+        "  }" +
+        "};",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : Ctor\n" +
+        "required: number");
+  }
+
+  public void testThis14() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "f(this.Object);",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : function (new:Object, *=): ?\n" +
+        "required: number");
+  }
+
+  public void testThisTypeOfFunction1() throws Exception {
+    testTypes(
+        "/** @type {function(this:Object)} */ function f() {}" +
+        "f();");
+  }
+
+  public void testThisTypeOfFunction2() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** @type {function(this:F)} */ function f() {}" +
+        "f();",
+        "\"function (this:F): ?\" must be called with a \"this\" type");
+  }
+
+  public void testThisTypeOfFunction3() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "F.prototype.bar = function() {};" +
+        "var f = (new F()).bar; f();",
+        "\"function (this:F): undefined\" must be called with a \"this\" type");
+  }
+
+  public void testThisTypeOfFunction4() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "F.prototype.moveTo = function(x, y) {};" +
+        "F.prototype.lineTo = function(x, y) {};" +
+        "function demo() {" +
+        "  var path = new F();" +
+        "  var points = [[1,1], [2,2]];" +
+        "  for (var i = 0; i < points.length; i++) {" +
+        "    (i == 0 ? path.moveTo : path.lineTo)(" +
+        "       points[i][0], points[i][1]);" +
+        "  }" +
+        "}",
+        "\"function (this:F, ?, ?): undefined\" " +
+        "must be called with a \"this\" type");
+  }
+
   public void testGlobalThis1() throws Exception {
     testTypes("/** @constructor */ function Window() {}" +
         "/** @param {string} msg */ " +
@@ -4493,11 +5214,21 @@
   }
 
   public void testGlobalThis2() throws Exception {
+    // this.alert = 3 doesn't count as a declaration, so this isn't a warning.
     testTypes("/** @constructor */ function Bindow() {}" +
         "/** @param {string} msg */ " +
         "Bindow.prototype.alert = function(msg) {};" +
         "this.alert = 3;" +
-        "(new Bindow()).alert(this.alert)",
+        "(new Bindow()).alert(this.alert)");
+  }
+
+
+  public void testGlobalThis2b() throws Exception {
+    testTypes("/** @constructor */ function Bindow() {}" +
+        "/** @param {string} msg */ " +
+        "Bindow.prototype.alert = function(msg) {};" +
+        "/** @return {number} */ this.alert = function() { return 3; };" +
+        "(new Bindow()).alert(this.alert())",
         "actual parameter 1 of Bindow.prototype.alert " +
         "does not match formal parameter\n" +
         "found   : number\n" +
@@ -4509,7 +5240,7 @@
         "/** @param {string} msg */ " +
         "function alert(msg) {};" +
         "this.alert(3);",
-        "actual parameter 1 of this.alert " +
+        "actual parameter 1 of global this.alert " +
         "does not match formal parameter\n" +
         "found   : number\n" +
         "required: string");
@@ -4520,7 +5251,7 @@
         "/** @param {string} msg */ " +
         "var alert = function(msg) {};" +
         "this.alert(3);",
-        "actual parameter 1 of this.alert " +
+        "actual parameter 1 of global this.alert " +
         "does not match formal parameter\n" +
         "found   : number\n" +
         "required: string");
@@ -4533,7 +5264,7 @@
         "  var alert = function(msg) {};" +
         "}" +
         "this.alert(3);",
-        "Property alert never defined on this");
+        "Property alert never defined on global this");
   }
 
   public void testGlobalThis6() throws Exception {
@@ -4545,6 +5276,35 @@
         "this.alert(this.x);");
   }
 
+  public void testGlobalThis7() throws Exception {
+    testTypes(
+        "/** @constructor */ function Window() {}" +
+        "/** @param {Window} msg */ " +
+        "var foo = function(msg) {};" +
+        "foo(this);");
+  }
+
+  public void testGlobalThis8() throws Exception {
+    testTypes(
+        "/** @constructor */ function Window() {}" +
+        "/** @param {number} msg */ " +
+        "var foo = function(msg) {};" +
+        "foo(this);",
+        "actual parameter 1 of foo does not match formal parameter\n" +
+        "found   : global this\n" +
+        "required: number");
+  }
+
+  public void testGlobalThis9() throws Exception {
+    testTypes(
+        // Window is not marked as a constructor, so the
+        // inheritance doesn't happen.
+        "function Window() {}" +
+        "Window.prototype.alert = function() {};" +
+        "this.alert();",
+        "Property alert never defined on global this");
+  }
+
   public void testControlFlowRestrictsType1() throws Exception {
     testTypes("/** @return {String?} */ function f() { return null; }" +
         "/** @type {String?} */ var a = f();" +
@@ -4634,7 +5394,7 @@
         "  for (var i = 0; i < 10; i++) {" +
         "    f(y);" +
         "    if (y != null) {" +
-        "      // y is None the first time it goes thru this branch\n" +
+        "      // y is None the first time it goes through this branch\n" +
         "    } else {" +
         "      y = {};" +
         "    }" +
@@ -4965,6 +5725,255 @@
         "Property indexOf never defined on String.prototype.toLowerCase");
   }
 
+  public void testIssue368() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo(){}" +
+        "/**\n" +
+        " * @param {number} one\n" +
+        " * @param {string} two\n" +
+        " */\n" +
+        "Foo.prototype.add = function(one, two) {};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar(){}" +
+        "/** @override */\n" +
+        "Bar.prototype.add = function(ignored) {};" +
+        "(new Bar()).add(1, 2);",
+        "actual parameter 2 of Bar.prototype.add does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testIssue380() throws Exception {
+    testTypes(
+        "/** @type { function(string): {innerHTML: string} } */" +
+        "document.getElementById;" +
+        "var list = /** @type {!Array.<string>} */ ['hello', 'you'];\n" +
+        "list.push('?');\n" +
+        "document.getElementById('node').innerHTML = list.toString();");
+  }
+
+  public void testIssue483() throws Exception {
+    testTypes(
+        "/** @constructor */ function C() {" +
+        "  /** @type {?Array} */ this.a = [];" +
+        "}" +
+        "C.prototype.f = function() {" +
+        "  if (this.a.length > 0) {" +
+        "    g(this.a);" +
+        "  }" +
+        "};" +
+        "/** @param {number} a */ function g(a) {}",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : Array\n" +
+        "required: number");
+  }
+
+  public void testIssue537a() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype = {method: function() {}};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {" +
+        "  Foo.call(this);" +
+        "  if (this.baz()) this.method(1);" +
+        "}" +
+        "Bar.prototype = {" +
+        "  baz: function() {" +
+        "    return true;" +
+        "  }" +
+        "};" +
+        "Bar.prototype.__proto__ = Foo.prototype;",
+        "Function Foo.prototype.method: called with 1 argument(s). " +
+        "Function requires at least 0 argument(s) " +
+        "and no more than 0 argument(s).");
+  }
+
+  public void testIssue537b() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype = {method: function() {}};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {" +
+        "  Foo.call(this);" +
+        "  if (this.baz(1)) this.method();" +
+        "}" +
+        "Bar.prototype = {" +
+        "  baz: function() {" +
+        "    return true;" +
+        "  }" +
+        "};" +
+        "Bar.prototype.__proto__ = Foo.prototype;",
+        "Function Bar.prototype.baz: called with 1 argument(s). " +
+        "Function requires at least 0 argument(s) " +
+        "and no more than 0 argument(s).");
+  }
+
+  public void testIssue537c() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {" +
+        "  Foo.call(this);" +
+        "  if (this.baz2()) alert(1);" +
+        "}" +
+        "Bar.prototype = {" +
+        "  baz: function() {" +
+        "    return true;" +
+        "  }" +
+        "};" +
+        "Bar.prototype.__proto__ = Foo.prototype;",
+        "Property baz2 never defined on Bar");
+  }
+
+  public void testIssue537d() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype = {" +
+        "  /** @return {Bar} */ x: function() { new Bar(); }," +
+        "  /** @return {Foo} */ y: function() { new Bar(); }" +
+        "};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {" +
+        "  this.xy = 3;" +
+        "}" +
+        "/** @return {Bar} */ function f() { return new Bar(); }" +
+        "/** @return {Foo} */ function g() { return new Bar(); }" +
+        "Bar.prototype = {" +
+        "  /** @return {Bar} */ x: function() { new Bar(); }," +
+        "  /** @return {Foo} */ y: function() { new Bar(); }" +
+        "};" +
+        "Bar.prototype.__proto__ = Foo.prototype;");
+  }
+
+  public void testIssue586() throws Exception {
+    testTypes(
+        "/** @constructor */" +
+        "var MyClass = function() {};" +
+        "/** @param {boolean} success */" +
+        "MyClass.prototype.fn = function(success) {};" +
+        "MyClass.prototype.test = function() {" +
+        "  this.fn();" +
+        "  this.fn = function() {};" +
+        "};",
+        "Function MyClass.prototype.fn: called with 0 argument(s). " +
+        "Function requires at least 1 argument(s) " +
+        "and no more than 1 argument(s).");
+  }
+
+  public void testIssue635() throws Exception {
+    // TODO(nicksantos): Make this emit a warning, because of the 'this' type.
+    testTypes(
+        "/** @constructor */" +
+        "function F() {}" +
+        "F.prototype.bar = function() { this.baz(); };" +
+        "F.prototype.baz = function() {};" +
+        "/** @constructor */" +
+        "function G() {}" +
+        "G.prototype.bar = F.prototype.bar;");
+  }
+
+  public void testIssue669() throws Exception {
+    testTypes(
+        "/** @return {{prop1: (Object|undefined)}} */" +
+         "function f(a) {" +
+         "  var results;" +
+         "  if (a) {" +
+         "    results = {};" +
+         "    results.prop1 = {a: 3};" +
+         "  } else {" +
+         "    results = {prop2: 3};" +
+         "  }" +
+         "  return results;" +
+         "}");
+  }
+
+  public void testIssue700() throws Exception {
+    testTypes(
+        "/**\n" +
+        " * @param {{text: string}} opt_data\n" +
+        " * @return {string}\n" +
+        " */\n" +
+        "function temp1(opt_data) {\n" +
+        "  return opt_data.text;\n" +
+        "}\n" +
+        "\n" +
+        "/**\n" +
+        " * @param {{activity: (boolean|number|string|null|Object)}} opt_data\n" +
+        " * @return {string}\n" +
+        " */\n" +
+        "function temp2(opt_data) {\n" +
+        "  /** @notypecheck */\n" +
+        "  function __inner() {\n" +
+        "    return temp1(opt_data.activity);\n" +
+        "  }\n" +
+        "  return __inner();\n" +
+        "}\n" +
+        "\n" +
+        "/**\n" +
+        " * @param {{n: number, text: string, b: boolean}} opt_data\n" +
+        " * @return {string}\n" +
+        " */\n" +
+        "function temp3(opt_data) {\n" +
+        "  return 'n: ' + opt_data.n + ', t: ' + opt_data.text + '.';\n" +
+        "}\n" +
+        "\n" +
+        "function callee() {\n" +
+        "  var output = temp3({\n" +
+        "    n: 0,\n" +
+        "    text: 'a string',\n" +
+        "    b: true\n" +
+        "  })\n" +
+        "  alert(output);\n" +
+        "}\n" +
+        "\n" +
+        "callee();");
+  }
+
+  public void testIssue725() throws Exception {
+    testTypes(
+        "/** @typedef {{name: string}} */ var RecordType1;" +
+        "/** @typedef {{name2: string}} */ var RecordType2;" +
+        "/** @param {RecordType1} rec */ function f(rec) {" +
+        "  alert(rec.name2);" +
+        "}",
+        "Property name2 never defined on rec");
+  }
+
+  public void testIssue765() throws Exception {
+    testTypes(
+        "/** @constructor */" +
+        "var AnotherType = function (parent) {" +
+        "    /** @param {string} stringParameter Description... */" +
+        "    this.doSomething = function (stringParameter) {};" +
+        "};" +
+        "/** @constructor */" +
+        "var YetAnotherType = function () {" +
+        "    this.field = new AnotherType(self);" +
+        "    this.testfun=function(stringdata) {" +
+        "        this.field.doSomething(null);" +
+        "    };" +
+        "};",
+        "actual parameter 1 of AnotherType.doSomething " +
+        "does not match formal parameter\n" +
+        "found   : null\n" +
+        "required: string");
+  }
+
   /**
    * Tests that the || operator is type checked correctly, that is of
    * the type of the first argument or of the second argument. See
@@ -5029,7 +6038,7 @@
   public void testBug909000() throws Exception {
     testTypes("/** @constructor */function A(){}\n" +
         "/** @param {!A} a\n" +
-        "@return boolean*/\n" +
+        "@return {boolean}*/\n" +
         "function y(a) { return a }",
         "inconsistent return type\n" +
         "found   : A\n" +
@@ -5103,7 +6112,7 @@
 
   public void testBug1942972() throws Exception {
     testTypes(
-        "var google = {\n"+
+        "var google = {\n" +
         "  gears: {\n" +
         "    factory: {},\n" +
         "    workerPool: {}\n" +
@@ -5152,7 +6161,7 @@
         "var x = f();" +
         "/** @type {string} */" +
         "x.y = 3;",
-        "assignment to property y of x\n" +
+        "assignment\n" +
         "found   : number\n" +
         "required: string");
   }
@@ -5193,7 +6202,7 @@
   public void testScopedConstructors2() throws Exception {
     testTypes(
         "/** @param {Function} f */" +
-        "function foo1(f) { " +
+        "function foo1(f) {" +
         "  /** @param {Function} g */" +
         "  f.prototype.bar = function(g) {};" +
         "}");
@@ -5304,7 +6313,7 @@
         "})();" +
         "/** @param {ns.Foo} x */ function f(x) {}" +
         "f(new ns.Foo(true));",
-        "Parse error. Unknown type ns.Foo");
+        "Bad type annotation. Unknown type ns.Foo");
   }
 
   public void testQualifiedNameInference9() throws Exception {
@@ -5335,11 +6344,46 @@
         "})();");
   }
 
+  public void testQualifiedNameInference11() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "function f() {" +
+        "  var x = new Foo();" +
+        "  x.onload = function() {" +
+        "    x.onload = null;" +
+        "  };" +
+        "}");
+  }
+
+  public void testQualifiedNameInference12() throws Exception {
+    // We should be able to tell that the two 'this' properties
+    // are different.
+    testTypes(
+        "/** @param {function(this:Object)} x */ function f(x) {}" +
+        "/** @constructor */ function Foo() {" +
+        "  /** @type {number} */ this.bar = 3;" +
+        "  f(function() { this.bar = true; });" +
+        "}");
+  }
+
+  public void testQualifiedNameInference13() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "function f(z) {" +
+        "  var x = new Foo();" +
+        "  if (z) {" +
+        "    x.onload = function() {};" +
+        "  } else {" +
+        "    x.onload = null;" +
+        "  };" +
+        "}");
+  }
+
   public void testSheqRefinedScope() throws Exception {
     Node n = parseAndTypeCheck(
         "/** @constructor */function A() {}\n" +
         "/** @constructor \n @extends A */ function B() {}\n" +
-        "/** @return number */\n" +
+        "/** @return {number} */\n" +
         "B.prototype.p = function() { return 1; }\n" +
         "/** @param {A} a\n @param {B} b */\n" +
         "function f(a, b) {\n" +
@@ -5497,6 +6541,17 @@
         "required: string");
   }
 
+  public void testNew17() throws Exception {
+    testTypes("var goog = {}; goog.x = 3; new goog.x",
+              "cannot instantiate non-constructor");
+  }
+
+  public void testNew18() throws Exception {
+    testTypes("var goog = {};" +
+              "/** @constructor */ goog.F = function() {};" +
+              "/** @constructor */ goog.G = goog.F;");
+  }
+
   public void testName1() throws Exception {
     assertEquals(VOID_TYPE, testNameNode("undefined"));
   }
@@ -5523,8 +6578,11 @@
   private JSType testNameNode(String name) {
     Node node = Node.newString(Token.NAME, name);
     Node parent = new Node(Token.SCRIPT, node);
+    parent.setInputId(new InputId("code"));
+
+    Node externs = new Node(Token.SCRIPT);
+    externs.setInputId(new InputId("externs"));
 
-    Node externs = new Node(Token.BLOCK);
     Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);
     externAndJsRoot.setIsSyntheticBlock(true);
 
@@ -5597,7 +6655,7 @@
         "/** @type {some.unknown.type} */var f1;" +
         "var f2 = opt_f || f1;" +
         "f2();",
-        "Parse error. Unknown type some.unknown.type");
+        "Bad type annotation. Unknown type some.unknown.type");
   }
 
   public void testCall4() throws Exception {
@@ -5716,6 +6774,78 @@
         "};");
   }
 
+  public void testFunctionBind1() throws Exception {
+    testTypes(
+        "/** @type {function(string, number): boolean} */" +
+        "function f(x, y) { return true; }" +
+        "f.bind(null, 3);",
+        "actual parameter 2 of f.bind does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testFunctionBind2() throws Exception {
+    testTypes(
+        "/** @type {function(number): boolean} */" +
+        "function f(x) { return true; }" +
+        "f(f.bind(null, 3)());",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testFunctionBind3() throws Exception {
+    testTypes(
+        "/** @type {function(number, string): boolean} */" +
+        "function f(x, y) { return true; }" +
+        "f.bind(null, 3)(true);",
+        "actual parameter 1 of function does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: string");
+  }
+
+  public void testFunctionBind4() throws Exception {
+    testTypes(
+        "/** @param {...number} x */" +
+        "function f(x) {}" +
+        "f.bind(null, 3, 3, 3)(true);",
+        "actual parameter 1 of function does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: (number|undefined)");
+  }
+
+  public void testFunctionBind5() throws Exception {
+    testTypes(
+        "/** @param {...number} x */" +
+        "function f(x) {}" +
+        "f.bind(null, true)(3, 3, 3);",
+        "actual parameter 2 of f.bind does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: (number|undefined)");
+  }
+
+  public void testGoogBind1() throws Exception {
+    testClosureTypes(
+        "var goog = {}; goog.bind = function(var_args) {};" +
+        "/** @type {function(number): boolean} */" +
+        "function f(x, y) { return true; }" +
+        "f(goog.bind(f, null, 'x')());",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testGoogBind2() throws Exception {
+    // TODO(nicksantos): We do not currently type-check the arguments
+    // of the goog.bind.
+    testClosureTypes(
+        "var goog = {}; goog.bind = function(var_args) {};" +
+        "/** @type {function(boolean): boolean} */" +
+        "function f(x, y) { return true; }" +
+        "f(goog.bind(f, null, 'x')());",
+        null);
+  }
+
   public void testCast2() throws Exception {
     // can upcast to a base type.
     testTypes("/** @constructor */function base() {}\n" +
@@ -5767,36 +6897,36 @@
 
   public void testCast7() throws Exception {
     testTypes("var x = /** @type {foo} */ (new Object());",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast8() throws Exception {
     testTypes("function f() { return /** @type {foo} */ (new Object()); }",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast9() throws Exception {
     testTypes("var foo = {};" +
         "function f() { return /** @type {foo} */ (new Object()); }",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast10() throws Exception {
     testTypes("var foo = function() {};" +
         "function f() { return /** @type {foo} */ (new Object()); }",
-        "Parse error. Unknown type foo");
+        "Bad type annotation. Unknown type foo");
   }
 
   public void testCast11() throws Exception {
     testTypes("var goog = {}; goog.foo = {};" +
         "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        "Parse error. Unknown type goog.foo");
+        "Bad type annotation. Unknown type goog.foo");
   }
 
   public void testCast12() throws Exception {
     testTypes("var goog = {}; goog.foo = function() {};" +
         "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        "Parse error. Unknown type goog.foo");
+        "Bad type annotation. Unknown type goog.foo");
   }
 
   public void testCast13() throws Exception {
@@ -5806,7 +6936,7 @@
         "goog.addDependency('zzz.js', ['goog.foo'], []);" +
         "goog.foo = function() {};" +
         "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        "Parse error. Unknown type goog.foo");
+        "Bad type annotation. Unknown type goog.foo");
   }
 
   public void testCast14() throws Exception {
@@ -5820,7 +6950,7 @@
 
   public void testCast15() throws Exception {
     // This fixes a bug where a type cast on an object literal
-    // would cause a runtime cast exception if the node was visited
+    // would cause a run-time cast exception if the node was visited
     // more than once.
     //
     // Some code assumes that an object literal must have a object type,
@@ -5829,7 +6959,7 @@
     testTypes(
         "for (var i = 0; i < 10; i++) {" +
           "var x = /** @type {Object|number} */ ({foo: 3});" +
-          "/** @param {boolean} x */ function f(x) {}" +
+          "/** @param {number} x */ function f(x) {}" +
           "f(x.foo);" +
           "f([].foo);" +
         "}",
@@ -5843,7 +6973,7 @@
           "var x = /** @type {Object|number} */ (" +
           "  {/** @type {string} */ foo: 3});" +
         "}",
-        "assignment to property foo of (Object|null|number)\n" +
+        "assignment to property foo of Object\n" +
         "found   : number\n" +
         "required: string");
   }
@@ -5874,7 +7004,7 @@
         "* @return {boolean|undefined}\n" +
         "*/\n" +
         "function g(b) { return b ? true : undefined; }\n" +
-        "/* @return {T} */\n" +
+        "/** @return {T} */\n" +
         "function h() {\n" +
         "return /** @type {T} */ (f(/** @type {boolean} */ (g(true))));\n" +
         "}");
@@ -6023,6 +7153,33 @@
         "}");
   }
 
+  public void testAnonymousPrototype1() throws Exception {
+    testTypes(
+        "var ns = {};" +
+        "/** @constructor */ ns.Foo = function() {" +
+        "  this.bar(3, 5);" +
+        "};" +
+        "ns.Foo.prototype = {" +
+        "  bar: function(x) {}" +
+        "};",
+        "Function ns.Foo.prototype.bar: called with 2 argument(s). " +
+        "Function requires at least 1 argument(s) and no more " +
+        "than 1 argument(s).");
+  }
+
+  public void testAnonymousPrototype2() throws Exception {
+    testTypes(
+        "/** @interface */ var Foo = function() {};" +
+        "Foo.prototype = {" +
+        "  foo: function(x) {}" +
+        "};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @implements {Foo}\n" +
+        " */ var Bar = function() {};",
+        "property foo on interface Foo is not implemented by type Bar");
+  }
+
   public void testAnonymousType1() throws Exception {
     testTypes("function f() {}" +
         "/** @constructor */\n" +
@@ -6100,7 +7257,7 @@
   }
 
   public void testUnknownConstructorInstanceType1() throws Exception {
-    testTypes("/** @return Array */ function g(f) { return new f(); }");
+    testTypes("/** @return {Array} */ function g(f) { return new f(); }");
   }
 
   public void testUnknownConstructorInstanceType2() throws Exception {
@@ -6190,7 +7347,7 @@
     // still the same type as the one on the variable
     assertTrue(googGetpropFoo2Type == googScopeType);
 
-    // goog.foo type on the left of the top level GETPROP node
+    // goog.foo type on the left of the top-level GETPROP node
     // (under second ASSIGN)
     JSType googFooGetprop2Type = getpropFoo2.getJSType();
     assertTrue("goog.foo incorrectly annotated in goog.foo.bar selection",
@@ -6440,9 +7597,7 @@
         "/** @constructor */goog.Super = function() {};" +
         "goog.Super.prototype.foo = 3;" +
         "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" +
-        "goog.Sub.prototype.foo = 5;",
-        "property foo already defined on superclass goog.Super; " +
-        "use @override to override it");
+        "goog.Sub.prototype.foo = 5;");
   }
 
   public void testInheritanceCheck8() throws Exception {
@@ -6459,14 +7614,15 @@
         "/** @constructor */function Super() {};" +
         "Super.prototype.foo = function() { return 3; };" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
-        "/** @override\n @return number */Sub.prototype.foo =\n" +
+        "/** @override\n @return {number} */Sub.prototype.foo =\n" +
         "function() { return 1; };");
   }
 
   public void testInheritanceCheck9_2() throws Exception {
     testTypes(
         "/** @constructor */function Super() {};" +
-        "/** @return number */Super.prototype.foo = function() { return 1; };" +
+        "/** @return {number} */" +
+        "Super.prototype.foo = function() { return 1; };" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
         "/** @override */Sub.prototype.foo =\n" +
         "function() {};");
@@ -6475,9 +7631,10 @@
   public void testInheritanceCheck9_3() throws Exception {
     testTypes(
         "/** @constructor */function Super() {};" +
-        "/** @return number */Super.prototype.foo = function() { return 1; };" +
+        "/** @return {number} */" +
+        "Super.prototype.foo = function() { return 1; };" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
-        "/** @override\n @return string */Sub.prototype.foo =\n" +
+        "/** @override\n @return {string} */Sub.prototype.foo =\n" +
         "function() { return \"some string\" };",
         "mismatch of the foo property type and the type of the property it " +
         "overrides from superclass Super\n" +
@@ -6491,14 +7648,15 @@
         "Root.prototype.foo = function() { return 3; };" +
         "/** @constructor\n @extends {Root} */function Super() {};" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
-        "/** @override\n @return number */Sub.prototype.foo =\n" +
+        "/** @override\n @return {number} */Sub.prototype.foo =\n" +
         "function() { return 1; };");
   }
 
   public void testInheritanceCheck10_2() throws Exception {
     testTypes(
         "/** @constructor */function Root() {};" +
-        "/** @return number */Root.prototype.foo = function() { return 1; };" +
+        "/** @return {number} */" +
+        "Root.prototype.foo = function() { return 1; };" +
         "/** @constructor\n @extends {Root} */function Super() {};" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
         "/** @override */Sub.prototype.foo =\n" +
@@ -6508,10 +7666,11 @@
   public void testInheritanceCheck10_3() throws Exception {
     testTypes(
         "/** @constructor */function Root() {};" +
-        "/** @return number */Root.prototype.foo = function() { return 1; };" +
+        "/** @return {number} */" +
+        "Root.prototype.foo = function() { return 1; };" +
         "/** @constructor\n @extends {Root} */function Super() {};" +
         "/** @constructor\n @extends {Super} */function Sub() {};" +
-        "/** @override\n @return string */Sub.prototype.foo =\n" +
+        "/** @override\n @return {string} */Sub.prototype.foo =\n" +
         "function() { return \"some string\" };",
         "mismatch of the foo property type and the type of the property it " +
         "overrides from superclass Root\n" +
@@ -6538,11 +7697,7 @@
         "/** @constructor */goog.Super = function() {};" +
         "goog.Super.prototype.foo = 3;" +
         "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" +
-        "/** @override */goog.Sub.prototype.foo = \"some string\";",
-        "mismatch of the foo property type and the type of the property it " +
-        "overrides from superclass goog.Super\n" +
-        "original: number\n" +
-        "override: string");
+        "/** @override */goog.Sub.prototype.foo = \"some string\";");
   }
 
   public void testInheritanceCheck13() throws Exception {
@@ -6550,7 +7705,7 @@
         "var goog = {};\n" +
         "/** @constructor\n @extends {goog.Missing} */function Sub() {};" +
         "/** @override */Sub.prototype.foo = function() {};",
-        "Parse error. Unknown type goog.Missing");
+        "Bad type annotation. Unknown type goog.Missing");
   }
 
   public void testInheritanceCheck14() throws Exception {
@@ -6560,38 +7715,61 @@
         "goog.Super = function() {};\n" +
         "/** @constructor\n @extends {goog.Super} */function Sub() {};" +
         "/** @override */Sub.prototype.foo = function() {};",
-        "Parse error. Unknown type goog.Missing");
+        "Bad type annotation. Unknown type goog.Missing");
   }
 
-  // TODO(user): We should support this way of declaring properties as it is
-  // widely used.
-  //public void testInheritanceCheck15() throws Exception {
-  //  testTypes(
-  //      "/** @constructor */function Super() {};" +
-  //      "/** @param {number} bar */Super.prototype.foo;" +
-  //      "/** @constructor\n @extends {Super} */function Sub() {};" +
-  //      "/** @override\n  @param {number} bar */Sub.prototype.foo =\n" +
-  //      "function(bar) {};");
-  //}
+  public void testInheritanceCheck15() throws Exception {
+    testTypes(
+        "/** @constructor */function Super() {};" +
+        "/** @param {number} bar */Super.prototype.foo;" +
+        "/** @constructor\n @extends {Super} */function Sub() {};" +
+        "/** @override\n  @param {number} bar */Sub.prototype.foo =\n" +
+        "function(bar) {};");
+  }
 
-//   public void testInterfacePropertyOverride1() throws Exception {
-//     testTypes(
-//         "/** @interface */function Super() {};" +
-//         "/** @desc description */Super.prototype.foo = function() {};" +
-//         "/** @interface\n @extends {Super} */function Sub() {};" +
-//         "/** @desc description */Sub.prototype.foo = function() {};",
-//         "property foo is already defined by the Super extended interface");
-//   }
+  public void testInheritanceCheck16() throws Exception {
+    testTypes(
+        "var goog = {};" +
+        "/** @constructor */goog.Super = function() {};" +
+        "/** @type {number} */ goog.Super.prototype.foo = 3;" +
+        "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" +
+        "/** @type {number} */ goog.Sub.prototype.foo = 5;",
+        "property foo already defined on superclass goog.Super; " +
+        "use @override to override it");
+  }
 
-//   public void testInterfacePropertyOverride2() throws Exception {
-//     testTypes(
-//         "/** @interface */function Root() {};" +
-//         "/** @desc description */Root.prototype.foo = function() {};" +
-//         "/** @interface\n @extends {Root} */function Super() {};" +
-//         "/** @interface\n @extends {Super} */function Sub() {};" +
-//         "/** @desc description */Sub.prototype.foo = function() {};",
-//         "property foo is already defined by the Root extended interface");
-//   }
+  public void testInheritanceCheck17() throws Exception {
+    // Make sure this warning still works, even when there's no
+    // @override tag.
+    reportMissingOverrides = CheckLevel.OFF;
+    testTypes(
+        "var goog = {};" +
+        "/** @constructor */goog.Super = function() {};" +
+        "/** @param {number} x */ goog.Super.prototype.foo = function(x) {};" +
+        "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" +
+        "/** @param {string} x */ goog.Sub.prototype.foo = function(x) {};",
+        "mismatch of the foo property type and the type of the property it " +
+        "overrides from superclass goog.Super\n" +
+        "original: function (this:goog.Super, number): undefined\n" +
+        "override: function (this:goog.Sub, string): undefined");
+  }
+
+  public void testInterfacePropertyOverride1() throws Exception {
+    testTypes(
+        "/** @interface */function Super() {};" +
+        "/** @desc description */Super.prototype.foo = function() {};" +
+        "/** @interface\n @extends {Super} */function Sub() {};" +
+        "/** @desc description */Sub.prototype.foo = function() {};");
+  }
+
+  public void testInterfacePropertyOverride2() throws Exception {
+    testTypes(
+        "/** @interface */function Root() {};" +
+        "/** @desc description */Root.prototype.foo = function() {};" +
+        "/** @interface\n @extends {Root} */function Super() {};" +
+        "/** @interface\n @extends {Super} */function Sub() {};" +
+        "/** @desc description */Sub.prototype.foo = function() {};");
+  }
 
   public void testInterfaceInheritanceCheck1() throws Exception {
     testTypes(
@@ -6635,9 +7813,9 @@
   public void testInterfaceInheritanceCheck5() throws Exception {
     testTypes(
         "/** @interface */function Super() {};" +
-        "/** @return string */Super.prototype.foo = function() {};" +
+        "/** @return {string} */Super.prototype.foo = function() {};" +
         "/** @constructor\n @implements {Super} */function Sub() {};" +
-        "/** @override\n @return number */Sub.prototype.foo =\n" +
+        "/** @override\n @return {number} */Sub.prototype.foo =\n" +
         "function() { return 1; };",
         "mismatch of the foo property type and the type of the property it " +
         "overrides from interface Super\n" +
@@ -6648,10 +7826,10 @@
   public void testInterfaceInheritanceCheck6() throws Exception {
     testTypes(
         "/** @interface */function Root() {};" +
-        "/** @return string */Root.prototype.foo = function() {};" +
+        "/** @return {string} */Root.prototype.foo = function() {};" +
         "/** @interface\n @extends {Root} */function Super() {};" +
         "/** @constructor\n @implements {Super} */function Sub() {};" +
-        "/** @override\n @return number */Sub.prototype.foo =\n" +
+        "/** @override\n @return {number} */Sub.prototype.foo =\n" +
         "function() { return 1; };",
         "mismatch of the foo property type and the type of the property it " +
         "overrides from interface Root\n" +
@@ -6677,7 +7855,7 @@
         "/** @constructor\n @implements {Super} */function Sub() {};" +
         "/** @override */Sub.prototype.foo = function() {};",
         new String[] {
-          "Parse error. Unknown type Super",
+          "Bad type annotation. Unknown type Super",
           "property foo not defined on any superclass of Sub"
         });
   }
@@ -6727,6 +7905,17 @@
         "override: number");
   }
 
+  public void testInterfaceInheritanceCheck13() throws Exception {
+    testTypes(
+        "function abstractMethod() {};\n" +
+        "/** @interface */var base = function() {};\n" +
+        "/** @extends {base} \n @interface */ var Int = function() {}\n" +
+        "/** @type {{bar : !Function}} */ var x; \n" +
+        "/** @type {!Function} */ base.prototype.bar = abstractMethod; \n" +
+        "/** @type {Int} */ foo;\n" +
+        "foo.bar();");
+  }
+
   public void testInterfacePropertyNotImplemented() throws Exception {
     testTypes(
         "/** @interface */function Int() {};" +
@@ -6801,6 +7990,65 @@
         "f({foo: function() {}});");
   }
 
+  public void testObjectLiteralDeclaration4() throws Exception {
+    testClosureTypes(
+        "var x = {" +
+        "  /** @param {boolean} x */ abc: function(x) {}" +
+        "};" +
+        "/**\n" +
+        " * @param {string} x\n" +
+        " * @suppress {duplicate}\n" +
+        " */ x.abc = function(x) {};",
+        "assignment to property abc of x\n" +
+        "found   : function (string): undefined\n" +
+        "required: function (boolean): undefined");
+    // TODO(user): suppress {duplicate} currently also silence the
+    // redefining type error in the TypeValidator. Maybe it needs
+    // a new suppress name instead?
+  }
+
+  public void testObjectLiteralDeclaration5() throws Exception {
+    testTypes(
+        "var x = {" +
+        "  /** @param {boolean} x */ abc: function(x) {}" +
+        "};" +
+        "/**\n" +
+        " * @param {boolean} x\n" +
+        " * @suppress {duplicate}\n" +
+        " */ x.abc = function(x) {};");
+  }
+
+  public void testObjectLiteralDeclaration6() throws Exception {
+    testTypes(
+        "var x = {};" +
+        "/**\n" +
+        " * @param {boolean} x\n" +
+        " * @suppress {duplicate}\n" +
+        " */ x.abc = function(x) {};" +
+        "x = {" +
+        "  /**\n" +
+        "   * @param {boolean} x\n" +
+        "   * @suppress {duplicate}\n" +
+        "   */" +
+        "  abc: function(x) {}" +
+        "};");
+  }
+
+  public void testObjectLiteralDeclaration7() throws Exception {
+    testTypes(
+        "var x = {};" +
+        "/**\n" +
+        " * @type {function(boolean): undefined}\n" +
+        " */ x.abc = function(x) {};" +
+        "x = {" +
+        "  /**\n" +
+        "   * @param {boolean} x\n" +
+        "   * @suppress {duplicate}\n" +
+        "   */" +
+        "  abc: function(x) {}" +
+        "};");
+  }
+
   public void testCallDateConstructorAsFunction() throws Exception {
     // ECMA-262 15.9.2: When Date is called as a function rather than as a
     // constructor, it returns a string.
@@ -6848,23 +8096,23 @@
   //public void testBadPropertyOnInterface1() throws Exception {
   //  testTypes("/** @interface */ u.T = function() {};\n" +
   //      "/** @return {number} */ u.T.f = function() { return 1;};",
-  //      "cannot reference an interface ouside of its definition");
+  //      "cannot reference an interface outside of its definition");
   //}
   //
   //public void testBadPropertyOnInterface2() throws Exception {
   //  testTypes("/** @interface */ function T() {};\n" +
   //      "/** @return {number} */ T.f = function() { return 1;};",
-  //      "cannot reference an interface ouside of its definition");
+  //      "cannot reference an interface outside of its definition");
   //}
   //
   //public void testBadPropertyOnInterface3() throws Exception {
   //  testTypes("/** @interface */ u.T = function() {}; u.T.x",
-  //      "cannot reference an interface ouside of its definition");
+  //      "cannot reference an interface outside of its definition");
   //}
   //
   //public void testBadPropertyOnInterface4() throws Exception {
   //  testTypes("/** @interface */ function T() {}; T.x;",
-  //      "cannot reference an interface ouside of its definition");
+  //      "cannot reference an interface outside of its definition");
   //}
 
   public void testAnnotatedPropertyOnInterface1() throws Exception {
@@ -6956,6 +8204,19 @@
         "override: string");
   }
 
+  public void testDataPropertyOnInterface4() throws Exception {
+    testTypes("/** @interface */ function T() {};\n" +
+        "/** @type {number} */T.prototype.x;\n" +
+        "/** @constructor \n" +
+        " *  @implements {T} \n" +
+        " */\n" +
+        "function C() { /** @type {string} */ \n this.x = 'foo'; }\n",
+        "mismatch of the x property type and the type of the property it " +
+        "overrides from interface T\n" +
+        "original: number\n" +
+        "override: string");
+  }
+
   public void testWarnDataPropertyOnInterface3() throws Exception {
     testTypes("/** @interface */ u.T = function () {};\n" +
         "/** @type {number} */u.T.prototype.x = 1;",
@@ -7015,11 +8276,15 @@
   }
 
   public void testErrorMismatchingPropertyOnInterface6() throws Exception {
-    testTypes("/** @interface */ function T() {};\n" +
+    testClosureTypesMultipleWarnings(
+        "/** @interface */ function T() {};\n" +
         "/** @return {number} */T.prototype.x = 1",
-        "interface members can only be empty property declarations, "
-        + "empty functions, or goog.abstractMethod"
-        );
+        Lists.newArrayList(
+            "assignment to property x of T.prototype\n" +
+            "found   : number\n" +
+            "required: function (this:T): number",
+            "interface members can only be empty property declarations, " +
+            "empty functions, or goog.abstractMethod"));
   }
 
   public void testInterfaceNonEmptyFunction() throws Exception {
@@ -7057,13 +8322,11 @@
   }
 
   public void testDirectPrototypeAssign() throws Exception {
+    // For now, we just ignore @type annotations on the prototype.
     testTypes(
         "/** @constructor */ function Foo() {}" +
         "/** @constructor */ function Bar() {}" +
-        "/** @type {Array} */ Bar.prototype = new Foo()",
-        "assignment to property prototype of Bar\n" +
-        "found   : Foo\n" +
-        "required: (Array|null)");
+        "/** @type {Array} */ Bar.prototype = new Foo()");
   }
 
   // In all testResolutionViaRegistry* tests, since u is unknown, u.T can only
@@ -7325,11 +8588,62 @@
         "  function g() { x = 'y'; } g(); " +
         "  return x === 3;" +
         "}",
-        "condition always evaluates to the same value\n" +
+        "condition always evaluates to false\n" +
         "left : (null|string)\n" +
         "right: number");
   }
 
+  public void testTypeInferenceWithNoEntry1() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype.init = function() {" +
+        "  /** @type {?{baz: number}} */ this.bar = {baz: 3};" +
+        "};" +
+        "/**\n" +
+        " * @extends {Foo}\n" +
+        " * @constructor\n" +
+        " */" +
+        "function SubFoo() {}" +
+        "/** Method */" +
+        "SubFoo.prototype.method = function() {" +
+        "  for (var i = 0; i < 10; i++) {" +
+        "    f(this.bar);" +
+        "    f(this.bar.baz);" +
+        "  }" +
+        "};",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : (null|{baz: number})\n" +
+        "required: number");
+  }
+
+  public void testTypeInferenceWithNoEntry2() throws Exception {
+    testClosureTypes(
+        CLOSURE_DEFS +
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @param {!Object} x */ function g(x) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype.init = function() {" +
+        "  /** @type {?{baz: number}} */ this.bar = {baz: 3};" +
+        "};" +
+        "/**\n" +
+        " * @extends {Foo}\n" +
+        " * @constructor\n" +
+        " */" +
+        "function SubFoo() {}" +
+        "/** Method */" +
+        "SubFoo.prototype.method = function() {" +
+        "  for (var i = 0; i < 10; i++) {" +
+        "    f(this.bar);" +
+        "    goog.asserts.assert(this.bar);" +
+        "    g(this.bar);" +
+        "  }" +
+        "};",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : (null|{baz: number})\n" +
+        "required: number");
+  }
+
   public void testForwardPropertyReference() throws Exception {
     testTypes("/** @constructor */ var Foo = function() { this.init(); };" +
         "/** @return {string} */" +
@@ -7348,12 +8662,10 @@
   public void testNoForwardTypeDeclaration() throws Exception {
     testTypes(
         "/** @param {MyType} x */ function f(x) {}",
-        "Parse error. Unknown type MyType");
+        "Bad type annotation. Unknown type MyType");
   }
 
   public void testNoForwardTypeDeclarationAndNoBraces() throws Exception {
-    // To better support third-party code, we do not warn when
-    // there are no braces around an unknown type name.
     testTypes("/** @return The result. */ function f() {}");
   }
 
@@ -7454,68 +8766,6 @@
         "required: (MyType|null|number)");
   }
 
-  public void testMalformedOldTypeDef() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "goog.Bar = goog.typedef",
-        "Typedef for goog.Bar does not have any type information");
-  }
-
-  public void testMalformedOldTypeDef2() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @typedef {boolean} */ goog.Bar = goog.typedef",
-        "Typedef for goog.Bar does not have any type information");
-  }
-
-  public void testDuplicateOldTypeDef() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @constructor */ goog.Bar = function() {};" +
-        "/** @type {number} */ goog.Bar = goog.typedef",
-        "variable goog.Bar redefined with type number, " +
-        "original definition at [testcode]:1 " +
-        "with type function (new:goog.Bar): undefined");
-  }
-
-  public void testOldTypeDef1() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @type {number} */ goog.Bar = goog.typedef;" +
-        "/** @param {goog.Bar} x */ function f(x) {}" +
-        "f(3);");
-  }
-
-  public void testOldTypeDef2() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @type {number} */ goog.Bar = goog.typedef;" +
-        "/** @param {goog.Bar} x */ function f(x) {}" +
-        "f('3');",
-        "actual parameter 1 of f does not match formal parameter\n" +
-        "found   : string\n" +
-        "required: number");
-  }
-
-  public void testOldTypeDef3() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @type {number} */ var Bar = goog.typedef;" +
-        "/** @param {Bar} x */ function f(x) {}" +
-        "f('3');",
-        "actual parameter 1 of f does not match formal parameter\n" +
-        "found   : string\n" +
-        "required: number");
-  }
-
-  public void testCircularOldTypeDef() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @type {number|Array.<goog.Bar>} */ goog.Bar = goog.typedef;" +
-        "/** @param {goog.Bar} x */ function f(x) {}" +
-        "f(3); f([3]); f([[3]]);");
-  }
-
   public void testDuplicateTypeDef() throws Exception {
     testTypes(
         "var goog = {};" +
@@ -7572,7 +8822,7 @@
     // Notice that the error message is slightly different than
     // the one for testTypeDef4, even though they should be the same.
     // This is an implementation detail necessary for NamedTypes work out
-    // ok, and it should change if NamedTypes ever go away.
+    // OK, and it should change if NamedTypes ever go away.
     testTypes(
         "/** @param {AB} x */ function f(x) {}" +
         "/** @constructor */ function A() {}" +
@@ -7614,6 +8864,16 @@
     assertEquals(100.0, getTypedPercent(js), 0.1);
   }
 
+  public void testGetTypedPercent5() throws Exception {
+    String js = "/** @enum {number} */ keys = {A: 1,B: 2,C: 3};";
+    assertEquals(100.0, getTypedPercent(js), 0.1);
+  }
+
+  public void testGetTypedPercent6() throws Exception {
+    String js = "a = {TRUE: 1, FALSE: 0};";
+    assertEquals(100.0, getTypedPercent(js), 0.1);
+  }
+
   private double getTypedPercent(String js) throws Exception {
     Node n = compiler.parseTestCode(js);
 
@@ -7978,6 +9238,34 @@
         "function g(x) { return x.isVisible; }");
   }
 
+  public void testMissingProperty38() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @constructor */ function Bar() {}" +
+        "/** @return {Foo|Bar} */ function f() { return new Foo(); }" +
+        "f().missing;",
+        "Property missing never defined on (Bar|Foo|null)");
+  }
+
+  public void testMissingProperty39() throws Exception {
+    testTypes(
+        "/** @return {string|number} */ function f() { return 3; }" +
+        "f().length;");
+  }
+
+  public void testMissingProperty40() throws Exception {
+    testClosureTypes(
+        "goog.addDependency('zzz.js', ['MissingType'], []);" +
+        "/** @param {(Array|MissingType)} x */" +
+        "function f(x) { x.impossible(); }", null);
+  }
+
+  public void testMissingProperty41() throws Exception {
+    testTypes(
+        "/** @param {(Array|Date)} x */" +
+        "function f(x) { if (x.impossible) x.impossible(); }");
+  }
+
   public void testReflectObject1() throws Exception {
     testClosureTypes(
         "var goog = {}; goog.reflect = {}; " +
@@ -8004,7 +9292,7 @@
         "function extend(x, y) {}" +
         "/** @constructor */ function Foo() {}" +
         "extend(Foo, /** @lends */ ({bar: 1}));",
-        "Parse error. missing object name in @lends tag");
+        "Bad type annotation. missing object name in @lends tag");
   }
 
   public void testLends2() throws Exception {
@@ -8054,7 +9342,7 @@
         "function extend(x, y) {}" +
         "/** @constructor */ function Foo() {}" +
         "extend(Foo, /** @lends {Foo.prototype|Foo} */ ({bar: 1}));",
-        "Parse error. expected closing }");
+        "Bad type annotation. expected closing }");
   }
 
   public void testLends8() throws Exception {
@@ -8071,8 +9359,39 @@
         "/** @constructor */ function Foo() {}" +
         "extend(Foo, /** @lends {!Foo} */ ({bar: 1}));",
         Lists.newArrayList(
-            "Parse error. expected closing }",
-            "Parse error. missing object name in @lends tag"));
+            "Bad type annotation. expected closing }",
+            "Bad type annotation. missing object name in @lends tag"));
+  }
+
+  public void testLends10() throws Exception {
+    testTypes(
+        "function defineClass(x) { return function() {}; } " +
+        "/** @constructor */" +
+        "var Foo = defineClass(" +
+        "    /** @lends {Foo.prototype} */ ({/** @type {number} */ bar: 1}));" +
+        "/** @return {string} */ function f() { return (new Foo()).bar; }",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testLends11() throws Exception {
+    testTypes(
+        "function defineClass(x, y) { return function() {}; } " +
+        "/** @constructor */" +
+        "var Foo = function() {};" +
+        "/** @return {*} */ Foo.prototype.bar = function() { return 3; };" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "var SubFoo = defineClass(Foo, " +
+        "    /** @lends {SubFoo.prototype} */ ({\n" +
+        "      /** @return {number} */ bar: function() { return 3; }}));" +
+        "/** @return {string} */ function f() { return (new SubFoo()).bar(); }",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
   }
 
   public void testDeclaredNativeTypeEquality() throws Exception {
@@ -8184,7 +9503,7 @@
         false);
   }
 
-  public void testBadTemplateType1() throws Exception {
+  public void testTemplateType1() throws Exception {
     testTypes(
         "/**\n" +
         "* @param {T} x\n" +
@@ -8193,11 +9512,12 @@
         "* @template T\n" +
         "*/\n" +
         "function f(x, y, z) {}\n" +
-        "f(this, this, function() { this });",
-        FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format(), true);
+        "f(this, this, function() { this });");
   }
 
-  public void testBadTemplateType2() throws Exception {
+  public void testTemplateType2() throws Exception {
+    // "this" types need to be coerced for ES3 style function or left
+    // allow for ES5-strict methods.
     testTypes(
         "/**\n" +
         "* @param {T} x\n" +
@@ -8205,32 +9525,26 @@
         "* @template T\n" +
         "*/\n" +
         "function f(x, y) {}\n" +
-        "f(0, function() {});",
-        TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format(), true);
+        "f(0, function() {});");
   }
 
-  public void testBadTemplateType3() throws Exception {
-    testTypes(
-        "/**\n" +
-        " * @param {T} x\n" +
-        " * @template T\n" +
-        "*/\n" +
-        "function f(x) {}\n" +
-        "f(this);",
-        TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format(), true);
-  }
-
-  public void testBadTemplateType4() throws Exception {
+  public void disable_testBadTemplateType4() throws Exception {
+    // TODO(johnlenz): Add a check for useless of template types.
+    // Unless there are at least two references to a Template type in
+    // a definition it isn't useful.
     testTypes(
         "/**\n" +
         "* @template T\n" +
         "*/\n" +
         "function f() {}\n" +
         "f();",
-        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);
+        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());
   }
 
-  public void testBadTemplateType5() throws Exception {
+  public void disable_testBadTemplateType5() throws Exception {
+    // TODO(johnlenz): Add a check for useless of template types.
+    // Unless there are at least two references to a Template type in
+    // a definition it isn't useful.
     testTypes(
         "/**\n" +
         "* @template T\n" +
@@ -8238,10 +9552,14 @@
         "*/\n" +
         "function f() {}\n" +
         "f();",
-        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);
+        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());
   }
 
-  public void testFunctionLiteralUndefinedThisArgument() throws Exception {
+  public void disable_testFunctionLiteralUndefinedThisArgument()
+      throws Exception {
+    // TODO(johnlenz): this was a weird error.  We should add a general
+    // restriction on what is accepted for T. Something like:
+    // "@template T of {Object|string}" or some such.
     testTypes(""
         + "/**\n"
         + " * @param {function(this:T, ...)?} fn\n"
@@ -8264,16 +9582,19 @@
         + "baz(function() { this; }, {});");
   }
 
-  public void testFunctionLiteralUnreadThisArgument() throws Exception {
+  public void testFunctionLiteralDefinedThisArgument2() throws Exception {
     testTypes(""
+        + "/** @param {string} x */ function f(x) {}"
         + "/**\n"
-        + " * @param {function(this:T, ...)?} fn\n"
-        + " * @param {?T} opt_obj\n"
+        + " * @param {?function(this:T, ...)} fn\n"
+        + " * @param {T=} opt_obj\n"
         + " * @template T\n"
         + " */\n"
         + "function baz(fn, opt_obj) {}\n"
-        + "baz(function() {}, {});",
-        "Function literal argument does not refer to bound this argument");
+        + "function g() { baz(function() { f(this.length); }, []); }",
+        "actual parameter 1 of f does not match formal parameter\n"
+        + "found   : number\n"
+        + "required: string");
   }
 
   public void testFunctionLiteralUnreadNullThisArgument() throws Exception {
@@ -8287,12 +9608,249 @@
         + "baz(function() {}, null);");
   }
 
+  public void testUnionTemplateThisType() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** @return {F|Array} */ function g() { return []; }" +
+        "/** @param {F} x */ function h(x) { }" +
+        "/**\n" +
+        "* @param {T} x\n" +
+        "* @param {function(this:T, ...)} y\n" +
+        "* @template T\n" +
+        "*/\n" +
+        "function f(x, y) {}\n" +
+        "f(g(), function() { h(this); });",
+        "actual parameter 1 of h does not match formal parameter\n" +
+        "found   : Object\n" +
+        "required: (F|null)");
+  }
+
   public void testActiveXObject() throws Exception {
     testTypes(
         "/** @type {Object} */ var x = new ActiveXObject();" +
         "/** @type { {impossibleProperty} } */ var y = new ActiveXObject();");
   }
 
+  public void testRecordType1() throws Exception {
+    testTypes(
+        "/** @param {{prop: number}} x */" +
+        "function f(x) {}" +
+        "f({});",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : {prop: (number|undefined)}\n" +
+        "required: {prop: number}");
+  }
+
+  public void testRecordType2() throws Exception {
+    testTypes(
+        "/** @param {{prop: (number|undefined)}} x */" +
+        "function f(x) {}" +
+        "f({});");
+  }
+
+  public void testRecordType3() throws Exception {
+    testTypes(
+        "/** @param {{prop: number}} x */" +
+        "function f(x) {}" +
+        "f({prop: 'x'});",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : {prop: (number|string)}\n" +
+        "required: {prop: number}");
+  }
+
+  public void testRecordType4() throws Exception {
+    // Notice that we do not do flow-based inference on the object type:
+    // We don't try to prove that x.prop may not be string until x
+    // gets passed to g.
+    testClosureTypesMultipleWarnings(
+        "/** @param {{prop: (number|undefined)}} x */" +
+        "function f(x) {}" +
+        "/** @param {{prop: (string|undefined)}} x */" +
+        "function g(x) {}" +
+        "var x = {}; f(x); g(x);",
+        Lists.newArrayList(
+            "actual parameter 1 of f does not match formal parameter\n" +
+            "found   : {prop: (number|string|undefined)}\n" +
+            "required: {prop: (number|undefined)}",
+            "actual parameter 1 of g does not match formal parameter\n" +
+            "found   : {prop: (number|string|undefined)}\n" +
+            "required: {prop: (string|undefined)}"));
+  }
+
+  public void testRecordType5() throws Exception {
+    testTypes(
+        "/** @param {{prop: (number|undefined)}} x */" +
+        "function f(x) {}" +
+        "/** @param {{otherProp: (string|undefined)}} x */" +
+        "function g(x) {}" +
+        "var x = {}; f(x); g(x);");
+  }
+
+  public void testRecordType6() throws Exception {
+    testTypes(
+        "/** @return {{prop: (number|undefined)}} x */" +
+        "function f() { return {}; }");
+  }
+
+  public void testRecordType7() throws Exception {
+    testTypes(
+        "/** @return {{prop: (number|undefined)}} x */" +
+        "function f() { var x = {}; g(x); return x; }" +
+        "/** @param {number} x */" +
+        "function g(x) {}",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : {prop: (number|undefined)}\n" +
+        "required: number");
+  }
+
+  public void testRecordType8() throws Exception {
+    testTypes(
+        "/** @return {{prop: (number|string)}} x */" +
+        "function f() { var x = {prop: 3}; g(x.prop); return x; }" +
+        "/** @param {string} x */" +
+        "function g(x) {}",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testDuplicateRecordFields1() throws Exception {
+    testTypes("/**"
+         + "* @param {{x:string, x:number}} a"
+         + "*/"
+         + "function f(a) {};",
+         "Parse error. Duplicate record field x");
+  }
+
+  public void testDuplicateRecordFields2() throws Exception {
+    testTypes("/**"
+         + "* @param {{name:string,number:x,number:y}} a"
+         + " */"
+         + "function f(a) {};",
+         new String[] {"Bad type annotation. Unknown type x",
+           "Parse error. Duplicate record field number",
+           "Bad type annotation. Unknown type y"});
+  }
+
+  public void testMultipleExtendsInterface1() throws Exception {
+    testTypes("/** @interface */ function base1() {}\n"
+        + "/** @interface */ function base2() {}\n"
+        + "/** @interface\n"
+        + "* @extends {base1}\n"
+        + "* @extends {base2}\n"
+        + "*/\n"
+        + "function derived() {}");
+  }
+
+  public void testMultipleExtendsInterface2() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @desc description */Int0.prototype.foo = function() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
+        "function Int2() {};" +
+        "/** @constructor\n @implements {Int2} */function Foo() {};",
+        "property foo on interface Int0 is not implemented by type Foo");
+  }
+
+  public void testMultipleExtendsInterface3() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @desc description */Int1.prototype.foo = function() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
+        "function Int2() {};" +
+        "/** @constructor\n @implements {Int2} */function Foo() {};",
+        "property foo on interface Int1 is not implemented by type Foo");
+  }
+
+  public void testMultipleExtendsInterface4() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} \n" +
+        " @extends {number} */" +
+        "function Int2() {};" +
+        "/** @constructor\n @implements {Int2} */function Foo() {};",
+        "Int2 @extends non-object type number");
+  }
+
+  public void testMultipleExtendsInterface5() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @constructor */function Int1() {};" +
+        "/** @desc description @ return {string} x */" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
+        "function Int2() {};",
+        "Int2 cannot extend this type; a constructor can only extend " +
+        "objects and an interface can only extend interfaces");
+  }
+
+  public void testMultipleExtendsInterface6() throws Exception {
+    testTypes(
+        "/** @interface */function Super1() {};" +
+        "/** @interface */function Super2() {};" +
+        "/** @param {number} bar */Super2.prototype.foo = function(bar) {};" +
+        "/** @interface\n @extends {Super1}\n " +
+        "@extends {Super2} */function Sub() {};" +
+        "/** @override\n @param {string} bar */Sub.prototype.foo =\n" +
+        "function(bar) {};",
+        "mismatch of the foo property type and the type of the property it " +
+        "overrides from superclass Super2\n" +
+        "original: function (this:Super2, number): undefined\n" +
+        "override: function (this:Sub, string): undefined");
+  }
+
+  public void testMultipleExtendsInterfaceAssignment() throws Exception {
+    testTypes("/** @interface */var I1 = function() {};\n" +
+        "/** @interface */ var I2 = function() {}\n" +
+        "/** @interface\n@extends {I1}\n@extends {I2}*/" +
+        "var I3 = function() {};\n" +
+        "/** @constructor\n@implements {I3}*/var T = function() {};\n" +
+        "var t = new T();\n" +
+         "/** @type {I1} */var i1 = t;\n" +
+         "/** @type {I2} */var i2 = t;\n" +
+         "/** @type {I3} */var i3 = t;\n" +
+         "i1 = i3;\n" +
+         "i2 = i3;\n");
+  }
+
+  public void testMultipleExtendsInterfaceParamPass() throws Exception {
+    testTypes("/** @interface */var I1 = function() {};\n" +
+        "/** @interface */ var I2 = function() {}\n" +
+        "/** @interface\n@extends {I1}\n@extends {I2}*/" +
+        "var I3 = function() {};\n" +
+        "/** @constructor\n@implements {I3}*/var T = function() {};\n" +
+        "var t = new T();\n" +
+        "/** @param x I1 \n@param y I2\n@param z I3*/function foo(x,y,z){};\n" +
+        "foo(t,t,t)\n");
+  }
+
+  public void testBadMultipleExtendsClass() throws Exception {
+    testTypes("/** @constructor */ function base1() {}\n"
+        + "/** @constructor */ function base2() {}\n"
+        + "/** @constructor\n"
+        + "* @extends {base1}\n"
+        + "* @extends {base2}\n"
+        + "*/\n"
+        + "function derived() {}",
+        "Bad type annotation. type annotation incompatible "
+        + "with other annotations");
+  }
+
+  public void testInterfaceExtendsResolution() throws Exception {
+    testTypes("/** @interface \n @extends {A} */ function B() {};\n" +
+        "/** @constructor \n @implements {B} */ function C() {};\n" +
+        "/** @interface */ function A() {};");
+  }
+
+  public void testPropertyCanBeDefinedInObject() throws Exception {
+    testTypes("/** @interface */ function I() {};" +
+        "I.prototype.bar = function() {};" +
+        "/** @type {Object} */ var foo;" +
+        "foo.bar();");
+  }
+
   private void checkObjectType(ObjectType objectType, String propertyName,
         JSType expectedType) {
     assertTrue("Expected " + objectType.getReferenceName() +
@@ -8304,6 +9862,258 @@
         expectedType, objectType.getPropertyType(propertyName));
   }
 
+  public void testExtendedInterfacePropertiesCompatibility1() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
+        "function Int2() {};",
+        "Interface Int2 has a property foo with incompatible types in its " +
+        "super interfaces Int0 and Int1");
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility2() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @interface */function Int2() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @type {Object} */" +
+        "Int2.prototype.foo;" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} \n" +
+        "@extends {Int2}*/" +
+        "function Int3() {};",
+        new String[] {
+            "Interface Int3 has a property foo with incompatible types in " +
+            "its super interfaces Int0 and Int1",
+            "Interface Int3 has a property foo with incompatible types in " +
+            "its super interfaces Int1 and Int2"
+        });
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility3() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};",
+        "Interface Int3 has a property foo with incompatible types in its " +
+        "super interfaces Int0 and Int1");
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility4() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface \n @extends {Int0} */ function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @interface */function Int2() {};" +
+        "/** @interface \n @extends {Int2} */ function Int3() {};" +
+        "/** @type {string} */" +
+        "Int2.prototype.foo;" +
+        "/** @interface \n @extends {Int1} \n @extends {Int3} */" +
+        "function Int4() {};",
+        "Interface Int4 has a property foo with incompatible types in its " +
+        "super interfaces Int0 and Int2");
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility5() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};" +
+        "/** @interface */function Int4() {};" +
+        "/** @type {number} */" +
+        "Int4.prototype.foo;" +
+        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
+        "function Int5() {};",
+        new String[] {
+            "Interface Int3 has a property foo with incompatible types in its" +
+            " super interfaces Int0 and Int1",
+            "Interface Int5 has a property foo with incompatible types in its" +
+            " super interfaces Int1 and Int4"});
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility6() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};" +
+        "/** @interface */function Int4() {};" +
+        "/** @type {string} */" +
+        "Int4.prototype.foo;" +
+        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
+        "function Int5() {};",
+        "Interface Int3 has a property foo with incompatible types in its" +
+        " super interfaces Int0 and Int1");
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility7() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};" +
+        "/** @interface */function Int4() {};" +
+        "/** @type {Object} */" +
+        "Int4.prototype.foo;" +
+        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
+        "function Int5() {};",
+        new String[] {
+            "Interface Int3 has a property foo with incompatible types in its" +
+            " super interfaces Int0 and Int1",
+            "Interface Int5 has a property foo with incompatible types in its" +
+            " super interfaces Int1 and Int4"});
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility8() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.bar;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};" +
+        "/** @interface */function Int4() {};" +
+        "/** @type {Object} */" +
+        "Int4.prototype.foo;" +
+        "/** @type {Null} */" +
+        "Int4.prototype.bar;" +
+        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
+        "function Int5() {};",
+        new String[] {
+            "Interface Int5 has a property bar with incompatible types in its" +
+            " super interfaces Int1 and Int4",
+            "Interface Int5 has a property foo with incompatible types in its" +
+            " super interfaces Int0 and Int4"});
+  }
+
+  public void testGenerics1() throws Exception {
+    String FN_DECL = "/** \n" +
+        " * @param {T} x \n" +
+        " * @param {function(T):T} y \n" +
+        " * @template T\n" +
+        " */ \n" +
+        "function f(x,y) { return y(x); }\n";
+
+    testTypes(
+        FN_DECL +
+        "/** @type {string} */" +
+        "var out;" +
+        "/** @type {string} */" +
+        "var result = f('hi', function(x){ out = x; return x; });");
+
+    testTypes(
+        FN_DECL +
+        "/** @type {string} */" +
+        "var out;" +
+        "var result = f(0, function(x){ out = x; return x; });",
+        "assignment\n" +
+        "found   : number\n" +
+        "required: string");
+
+    testTypes(
+        FN_DECL +
+        "var out;" +
+        "/** @type {string} */" +
+        "var result = f(0, function(x){ out = x; return x; });",
+        "assignment\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void disable_testBackwardsInferenceGoogArrayFilter1()
+      throws Exception {
+    // TODO(johnlenz): this doesn't fail because any Array is regarded as
+    // a subtype of any other array regardless of the type parameter.
+    testClosureTypes(
+        CLOSURE_DEFS +
+        "/** @type {Array.<string>} */" +
+        "var arr;\n" +
+        "/** @type {Array.<number>} */" +
+        "var result = goog.array.filter(" +
+        "   arr," +
+        "   function(item,index,src) {return false;});",
+        "assignment\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testBackwardsInferenceGoogArrayFilter2() throws Exception {
+    testClosureTypes(
+        CLOSURE_DEFS +
+        "/** @type {number} */" +
+        "var out;" +
+        "/** @type {Array.<string>} */" +
+        "var arr;\n" +
+        "var out4 = goog.array.filter(" +
+        "   arr," +
+        "   function(item,index,src) {out = item;});",
+        "assignment\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testBackwardsInferenceGoogArrayFilter3() throws Exception {
+    testClosureTypes(
+        CLOSURE_DEFS +
+        "/** @type {string} */" +
+        "var out;" +
+        "/** @type {Array.<string>} */ var arr;\n" +
+        "var result = goog.array.filter(" +
+        "   arr," +
+        "   function(item,index,src) {out = index;});",
+        "assignment\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testBackwardsInferenceGoogArrayFilter4() throws Exception {
+    testClosureTypes(
+        CLOSURE_DEFS +
+        "/** @type {string} */" +
+        "var out;" +
+        "/** @type {Array.<string>} */ var arr;\n" +
+        "var out4 = goog.array.filter(" +
+        "   arr," +
+        "   function(item,index,srcArr) {out = srcArr;});",
+        "assignment\n" +
+        "found   : (null|{length: number})\n" +
+        "required: string");
+  }
+
   private void testTypes(String js) throws Exception {
     testTypes(js, (String) null);
   }
@@ -8334,7 +10144,7 @@
         0, compiler.getErrorCount());
 
     // For processing goog.addDependency for forward typedefs.
-    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)
+    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)
         .process(null, n);
 
     CodingConvention convention = compiler.getCodingConvention();
@@ -8347,7 +10157,10 @@
         registry)
         .processForTesting(null, n);
 
-    assertEquals(0, compiler.getErrorCount());
+    assertEquals(
+        "unexpected error(s) : " +
+        Joiner.on(", ").join(compiler.getErrors()),
+        0, compiler.getErrorCount());
 
     if (descriptions == null) {
       assertEquals(
@@ -8420,12 +10233,13 @@
   private TypeCheckResult parseAndTypeCheckWithScope(
       String externs, String js) {
     compiler.init(
-        Lists.newArrayList(JSSourceFile.fromCode("[externs]", externs)),
-        Lists.newArrayList(JSSourceFile.fromCode("[testcode]", js)),
+        Lists.newArrayList(SourceFile.fromCode("[externs]", externs)),
+        Lists.newArrayList(SourceFile.fromCode("[testcode]", js)),
         compiler.getOptions());
 
-    Node n = compiler.getInput("[testcode]").getAstRoot(compiler);
-    Node externsNode = compiler.getInput("[externs]").getAstRoot(compiler);
+    Node n = compiler.getInput(new InputId("[testcode]")).getAstRoot(compiler);
+    Node externsNode = compiler.getInput(new InputId("[externs]"))
+        .getAstRoot(compiler);
     Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);
     externAndJsRoot.setIsSyntheticBlock(true);
 
