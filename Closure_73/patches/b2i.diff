diff -r -u buggy/src/com/google/javascript/jscomp/CodeGenerator.java inducing/src/com/google/javascript/jscomp/CodeGenerator.java
--- buggy/src/com/google/javascript/jscomp/CodeGenerator.java	2023-06-12 11:34:26.134214763 +0800
+++ inducing/src/com/google/javascript/jscomp/CodeGenerator.java	2023-06-12 11:34:26.382219296 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004 The Closure Compiler Authors.
+ * Copyright 2004 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,12 +18,11 @@
 
 import com.google.common.base.Charsets;
 import com.google.common.base.Preconditions;
-import com.google.javascript.jscomp.NodeUtil.MatchNotFunction;
+import com.google.common.base.StringUtil;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.TokenStream;
 
-import java.io.IOException;
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
 
@@ -31,19 +30,16 @@
  * CodeGenerator generates codes from a parse tree, sending it to the specified
  * CodeConsumer.
  *
+*
+*
  */
 class CodeGenerator {
 
-  private static final char[] HEX_CHARS
-      = { '0', '1', '2', '3', '4', '5', '6', '7',
-          '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
-
   private final CodeConsumer cc;
 
   private final CharsetEncoder outputCharsetEncoder;
 
-  CodeGenerator(
-      CodeConsumer consumer, Charset outputCharset) {
+  CodeGenerator(CodeConsumer consumer, Charset outputCharset) {
     cc = consumer;
     if (outputCharset == null || outputCharset == Charsets.US_ASCII) {
       // If we want our default (pretending to be UTF-8, but escaping anything
@@ -60,13 +56,6 @@
     this(consumer, null);
   }
 
-  /**
-   * Insert a ECMASCRIPT 5 strict annotation.
-   */
-  public void tagAsStrict() {
-    add("'use strict';");
-  }
-
   void add(String str) {
     cc.add(str);
   }
@@ -92,10 +81,7 @@
 
     // Handle all binary operators
     if (opstr != null && first != last) {
-      Preconditions.checkState(
-          childCount == 2,
-          "Bad binary operator \"%s\": expected 2 arguments but got %s",
-          opstr, childCount);
+      Preconditions.checkState(childCount == 2);
       int p = NodeUtil.precedence(type);
       addLeftExpr(first, p, context);
       cc.addOp(opstr, true);
@@ -124,7 +110,7 @@
     switch (type) {
       case Token.TRY: {
         Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&
-                !first.getNext().hasMoreThanOneChild());
+                first.getNext().getChildCount() <= 1);
         Preconditions.checkState(childCount >= 2 && childCount <= 3);
 
         add("try");
@@ -145,7 +131,12 @@
       }
 
       case Token.CATCH:
-        Preconditions.checkState(childCount == 2);
+        Preconditions.checkState(childCount == 3);
+        if (first.getNext().getType() != Token.EMPTY) {
+          throw new Error("Catch conditions not suppored because I think" +
+                          " that it may be a netscape only feature.");
+        }
+
         add("catch(");
         add(first);
         add(")");
@@ -179,11 +170,6 @@
         }
         break;
 
-      case Token.LABEL_NAME:
-        Preconditions.checkState(!n.getString().isEmpty());
-        addIdentifier(n.getString());
-        break;
-
       case Token.NAME:
         if (first == null || first.getType() == Token.EMPTY) {
           addIdentifier(n.getString());
@@ -199,11 +185,12 @@
             addExpr(first, 0, getContextForNoInOperator(context));
           }
         }
+
         break;
 
       case Token.ARRAYLIT:
         add("[");
-        addArrayList(first);
+        addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));
         add("]");
         break;
 
@@ -214,7 +201,6 @@
         break;
 
       case Token.COMMA:
-        Preconditions.checkState(childCount == 2);
         addList(first, false, context);
         break;
 
@@ -227,7 +213,8 @@
       case Token.VOID:
       case Token.NOT:
       case Token.BITNOT:
-      case Token.POS: {
+      case Token.POS:
+      case Token.NEG: {
         // All of these unary operators are right-associative
         Preconditions.checkState(childCount == 1);
         cc.addOp(NodeUtil.opToStrNoFail(type), false);
@@ -235,30 +222,14 @@
         break;
       }
 
-      case Token.NEG: {
-        Preconditions.checkState(childCount == 1);
-
-        // It's important to our sanity checker that the code
-        // we print produces the same AST as the code we parse back.
-        // NEG is a weird case because Rhino parses "- -2" as "2".
-        if (n.getFirstChild().getType() == Token.NUMBER) {
-          cc.addNumber(-n.getFirstChild().getDouble());
-        } else {
-          cc.addOp(NodeUtil.opToStrNoFail(type), false);
-          addExpr(first, NodeUtil.precedence(type));
-        }
-
-        break;
-      }
-
       case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
         addLeftExpr(first, p + 1, context);
         cc.addOp("?", true);
-        addExpr(first.getNext(), 1);
+        addExpr(first.getNext(), p);
         cc.addOp(":", true);
-        addExpr(last, 1);
+        addExpr(last, p);
         break;
       }
 
@@ -291,9 +262,6 @@
         break;
 
       case Token.FUNCTION:
-        if (n.getClass() != Node.class) {
-          throw new Error("Unexpected Node subclass.");
-        }
         Preconditions.checkState(childCount == 3);
         boolean funcNeedsParens = (context == Context.START_OF_EXPR);
         if (funcNeedsParens) {
@@ -312,67 +280,13 @@
         }
         break;
 
-      case Token.GET:
-      case Token.SET:
-        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);
-        Preconditions.checkState(childCount == 1);
-        Preconditions.checkState(first.getType() == Token.FUNCTION);
-
-        // Get methods are unnamed
-        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
-        if (type == Token.GET) {
-          // Get methods have no parameters.
-          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
-          add("get ");
-        } else {
-          // Set methods have one parameter.
-          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
-          add("set ");
-        }
-
-        // The name is on the GET or SET node.
-        String name = n.getString();
-        Node fn = first;
-        Node parameters = fn.getChildAtIndex(1);
-        Node body = fn.getLastChild();
-
-        // Add the property name.
-        if (!n.isQuotedString() &&
-            TokenStream.isJSIdentifier(name) &&
-            // do not encode literally any non-literal characters that were
-            // unicode escaped.
-            NodeUtil.isLatin(name)) {
-          add(name);
-        } else {
-          // Determine if the string is a simple number.
-          double d = getSimpleNumber(name);
-          if (!Double.isNaN(d)) {
-            cc.addNumber(d);
-          } else {
-            add(jsString(n.getString(), outputCharsetEncoder));
-          }
-        }
-
-        add(parameters);
-        add(body, Context.PRESERVE_BLOCK);
-        break;
-
       case Token.SCRIPT:
       case Token.BLOCK: {
-        if (n.getClass() != Node.class) {
-          throw new Error("Unexpected Node subclass.");
-        }
-        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
-        if (preserveBlock) {
+        boolean stripBlock = n.isSyntheticBlock() ||
+            ((context != Context.PRESERVE_BLOCK) && (n.getChildCount() < 2));
+        if (!stripBlock) {
           cc.beginBlock();
         }
-
-        boolean preferLineBreaks =
-            type == Token.SCRIPT ||
-            (type == Token.BLOCK &&
-                !preserveBlock &&
-                n.getParent() != null &&
-                n.getParent().getType() == Token.SCRIPT);
         for (Node c = first; c != null; c = c.getNext()) {
           add(c, Context.STATEMENT);
 
@@ -387,12 +301,12 @@
 
           // Prefer to break lines in between top-level statements
           // because top level statements are more homogeneous.
-          if (preferLineBreaks) {
+          if (type == Token.SCRIPT) {
             cc.notePreferredLineBreak();
           }
         }
-        if (preserveBlock) {
-          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
+        if (!stripBlock) {
+          cc.endBlock(context == Context.STATEMENT);
         }
         break;
       }
@@ -410,7 +324,7 @@
           add(";");
           add(first.getNext().getNext());
           add(")");
-          addNonEmptyStatement(
+          addNonEmptyExpression(
               last, getContextForNonEmptyExpression(context), false);
         } else {
           Preconditions.checkState(childCount == 3);
@@ -419,7 +333,7 @@
           add("in");
           add(first.getNext());
           add(")");
-          addNonEmptyStatement(
+          addNonEmptyExpression(
               last, getContextForNonEmptyExpression(context), false);
         }
         break;
@@ -427,7 +341,7 @@
       case Token.DO:
         Preconditions.checkState(childCount == 2);
         add("do");
-        addNonEmptyStatement(first, Context.OTHER, false);
+        addNonEmptyExpression(first, Context.OTHER, false);
         add("while(");
         add(last);
         add(")");
@@ -439,7 +353,7 @@
         add("while(");
         add(first);
         add(")");
-        addNonEmptyStatement(
+        addNonEmptyExpression(
             last, getContextForNonEmptyExpression(context), false);
         break;
 
@@ -448,12 +362,8 @@
         break;
 
       case Token.GETPROP: {
-        Preconditions.checkState(
-            childCount == 2,
-            "Bad GETPROP: expected 2 children, but got %s", childCount);
-        Preconditions.checkState(
-            last.getType() == Token.STRING,
-            "Bad GETPROP: RHS should be STRING");
+        Preconditions.checkState(childCount == 2);
+        Preconditions.checkState(last.getType() == Token.STRING);
         boolean needsParens = (first.getType() == Token.NUMBER);
         if (needsParens) {
           add("(");
@@ -468,9 +378,7 @@
       }
 
       case Token.GETELEM:
-        Preconditions.checkState(
-            childCount == 2,
-            "Bad GETELEM: expected 2 children but got %s", childCount);
+        Preconditions.checkState(childCount == 2);
         addLeftExpr(first, NodeUtil.precedence(type), context);
         add("[");
         add(first.getNext());
@@ -482,7 +390,7 @@
         add("with(");
         add(first);
         add(")");
-        addNonEmptyStatement(
+        addNonEmptyExpression(
             last, getContextForNonEmptyExpression(context), false);
         break;
 
@@ -490,7 +398,7 @@
       case Token.DEC: {
         Preconditions.checkState(childCount == 1);
         String o = type == Token.INC ? "++" : "--";
-        int postProp = n.getIntProp(Node.INCRDECR_PROP);
+        int postProp = n.getIntProp(Node.INCRDECR_PROP, 0);
         // A non-zero post-prop value indicates a post inc/dec, default of zero
         // is a pre-inc/dec.
         if (postProp != 0) {
@@ -504,23 +412,7 @@
       }
 
       case Token.CALL:
-        // We have two special cases here:
-        // 1) If the left hand side of the call is a direct reference to eval,
-        // then it must have a DIRECT_EVAL annotation. If it does not, then
-        // that means it was originally an indirect call to eval, and that
-        // indirectness must be preserved.
-        // 2) If the left hand side of the call is a property reference,
-        // then the call must not a FREE_CALL annotation. If it does, then
-        // that means it was originally an call without an explicit this and
-        // that must be preserved.
-        if (isIndirectEval(first)
-            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
-          add("(0,");
-          addExpr(first, NodeUtil.precedence(Token.COMMA));
-          add(")");
-        } else {
-          addLeftExpr(first, NodeUtil.precedence(type), context);
-        }
+        addLeftExpr(first, NodeUtil.precedence(type), context);
         add("(");
         addList(first.getNext());
         add(")");
@@ -539,13 +431,13 @@
         add(")");
 
         if (hasElse) {
-          addNonEmptyStatement(
+          addNonEmptyExpression(
               first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
           add("else");
-          addNonEmptyStatement(
+          addNonEmptyExpression(
               last, getContextForNonEmptyExpression(context), false);
         } else {
-          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
+          addNonEmptyExpression(first.getNext(), Context.OTHER, false);
           Preconditions.checkState(childCount == 2);
         }
 
@@ -566,9 +458,6 @@
         Preconditions.checkState(childCount <= 1);
         add("continue");
         if (childCount == 1) {
-          if (first.getType() != Token.LABEL_NAME) {
-            throw new Error("Unexpected token type. Should be LABEL_NAME.");
-          }
           add(" ");
           add(first);
         }
@@ -585,9 +474,6 @@
         Preconditions.checkState(childCount <= 1);
         add("break");
         if (childCount == 1) {
-          if (first.getType() != Token.LABEL_NAME) {
-            throw new Error("Unexpected token type. Should be LABEL_NAME.");
-          }
           add(" ");
           add(first);
         }
@@ -595,8 +481,9 @@
         break;
 
       case Token.EXPR_VOID:
-        throw new Error("Unexpected EXPR_VOID. Should be EXPR_RESULT.");
-
+        // TODO(johnlenz): Enable this exception once the external users of
+        //     CodePrinter have been corrected.
+        // throw new Error("EXPR_VOID should not be used in this codebase.");
       case Token.EXPR_RESULT:
         Preconditions.checkState(childCount == 1);
         add(first, Context.START_OF_EXPR);
@@ -608,9 +495,9 @@
         int precedence = NodeUtil.precedence(type);
 
         // If the first child contains a CALL, then claim higher precedence
-        // to force parentheses. Otherwise, when parsed, NEW will bind to the
-        // first viable parentheses (don't traverse into functions).
-        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {
+        // to force parens. Otherwise, when parsed, NEW will bind to the
+        // first viable parens
+        if (NodeUtil.containsCall(first)) {
           precedence = NodeUtil.precedence(first.getType()) + 1;
         }
         addExpr(first, precedence);
@@ -625,12 +512,7 @@
         break;
 
       case Token.STRING:
-        if (childCount !=
-            ((n.getParent() != null &&
-              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {
-          throw new IllegalStateException(
-              "Unexpected String children: " + n.getParent().toStringTree());
-        }
+        Preconditions.checkState(childCount == 0);
         add(jsString(n.getString(), outputCharsetEncoder));
         break;
 
@@ -641,42 +523,31 @@
         break;
 
       case Token.OBJECTLIT: {
+        Preconditions.checkState(childCount % 2 == 0);
         boolean needsParens = (context == Context.START_OF_EXPR);
         if (needsParens) {
           add("(");
         }
         add("{");
-        for (Node c = first; c != null; c = c.getNext()) {
+        for (Node c = first; c != null; c = c.getNext().getNext()) {
           if (c != first) {
             cc.listSeparator();
           }
 
-          if (c.getType() == Token.GET || c.getType() == Token.SET) {
-            add(c);
+          // Object literal property names don't have to be quoted if they are
+          // not JavaScript keywords
+          if (c.getType() == Token.STRING &&
+              !TokenStream.isKeyword(c.getString()) &&
+              TokenStream.isJSIdentifier(c.getString()) &&
+              // do not encode literally any non-literal characters that were
+              // unicode escaped.
+              NodeUtil.isLatin(c.getString())) {
+            add(c.getString());
           } else {
-            Preconditions.checkState(c.getType() == Token.STRING);
-            String key = c.getString();
-            // Object literal property names don't have to be quoted if they
-            // are not JavaScript keywords
-            if (!c.isQuotedString() &&
-                !TokenStream.isKeyword(key) &&
-                TokenStream.isJSIdentifier(key) &&
-                // do not encode literally any non-literal characters that
-                // were unicode escaped.
-                NodeUtil.isLatin(key)) {
-              add(key);
-            } else {
-              // Determine if the string is a simple number.
-              double d = getSimpleNumber(key);
-              if (!Double.isNaN(d)) {
-                cc.addNumber(d);
-              } else {
-                addExpr(c, 1);
-              }
-            }
-            add(":");
-            addExpr(c.getFirstChild(), 1);
+            addExpr(c, 1);
           }
+          add(":");
+          addExpr(c.getNext(), 1);
         }
         add("}");
         if (needsParens) {
@@ -709,12 +580,9 @@
 
       case Token.LABEL:
         Preconditions.checkState(childCount == 2);
-        if (first.getType() != Token.LABEL_NAME) {
-          throw new Error("Unexpected token type. Should be LABEL_NAME.");
-        }
         add(first);
         add(":");
-        addNonEmptyStatement(
+        addNonEmptyExpression(
             last, getContextForNonEmptyExpression(context), true);
         break;
 
@@ -730,35 +598,6 @@
     cc.endSourceMapping(n);
   }
 
-  static boolean isSimpleNumber(String s) {
-    int len = s.length();
-    for (int index = 0; index < len; index++) {
-      char c = s.charAt(index);
-      if (c < '0' || c > '9') {
-        return false;
-      }
-    }
-    return len > 0;
-  }
-
-  static double getSimpleNumber(String s) {
-    if (isSimpleNumber(s)) {
-      long l = Long.parseLong(s);
-      if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {
-        return l;
-      }
-    }
-    return Double.NaN;
-  }
-
-  /**
-   * @return Whether the name is an indirect eval.
-   */
-  private boolean isIndirectEval(Node n) {
-    return n.getType() == Token.NAME && "eval".equals(n.getString()) &&
-        !n.getBooleanProp(Node.DIRECT_EVAL);
-  }
-
   /**
    * Adds a block or expression, substituting a VOID with an empty statement.
    * This is used for "for (...);" and "if (...);" type statements.
@@ -766,25 +605,20 @@
    * @param n The node to print.
    * @param context The context to determine how the node should be printed.
    */
-  private void addNonEmptyStatement(
+  private void addNonEmptyExpression(
       Node n, Context context, boolean allowNonBlockChild) {
     Node nodeToProcess = n;
 
     if (!allowNonBlockChild && n.getType() != Token.BLOCK) {
-      throw new Error("Missing BLOCK child.");
+      // TODO(johnlenz) : Enable this when the JsMinifier is corrected.
+      // throw new Error("Missing BLOCK child.");
     }
 
-    // Strip unneeded blocks, that is blocks with <2 children unless
-    // the CodePrinter specifically wants to keep them.
+    // Strip unneeded blocks, that is blocks with <2 children.
     if (n.getType() == Token.BLOCK) {
-      int count = getNonEmptyChildCount(n, 2);
+      int count = getNonEmptyChildCount(n);
       if (count == 0) {
-        if (cc.shouldPreserveExtraBlocks()) {
-          cc.beginBlock();
-          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
-        } else {
-          cc.endStatement(true);
-        }
+        cc.endStatement(true);
         return;
       }
 
@@ -793,22 +627,18 @@
         //   Safari needs a block around function declarations.
         //   IE6/7 needs a block around DOs.
         Node firstAndOnlyChild = getFirstNonEmptyChild(n);
-        boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks();
-        if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {
+        if (firstAndOnlyChild.getType() == Token.FUNCTION ||
+            firstAndOnlyChild.getType() == Token.DO) {
           cc.beginBlock();
           add(firstAndOnlyChild, Context.STATEMENT);
           cc.maybeLineBreak();
-          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
+          cc.endBlock(context == Context.STATEMENT);
           return;
         } else {
           // Continue with the only child.
           nodeToProcess = firstAndOnlyChild;
         }
       }
-
-      if (count > 1) {
-        context = Context.PRESERVE_BLOCK;
-      }
     }
 
     if (nodeToProcess.getType() == Token.EMPTY) {
@@ -825,32 +655,6 @@
   }
 
   /**
-   * @return Whether the Node is a DO or FUNCTION (with or without
-   * labels).
-   */
-  private boolean isOneExactlyFunctionOrDo(Node n) {
-    if (n.getType() == Token.LABEL) {
-      Node labeledStatement = n.getLastChild();
-      if (labeledStatement.getType() != Token.BLOCK) {
-        return isOneExactlyFunctionOrDo(labeledStatement);
-      } else {
-        // For labels with block children, we need to ensure that a
-        // labeled FUNCTION or DO isn't generated when extraneous BLOCKs
-        // are skipped.
-        if (getNonEmptyChildCount(n, 2) == 1) {
-          return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));
-        } else {
-          // Either a empty statement or an block with more than one child,
-          // way it isn't a FUNCTION or DO.
-          return false;
-        }
-      }
-    } else {
-      return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);
-    }
-  }
-
-  /**
    * Adds a node at the left-hand side of an expression. Unlike
    * {@link #addExpr(Node,int)}, this preserves information about the context.
    *
@@ -907,19 +711,27 @@
    * slot.
    * @param firstInList The first in the node list (chained through the next
    * property).
+   * @param skipIndexes If not null, then the array of skipped entries in the
+   * array.
    */
-  void addArrayList(Node firstInList) {
-    boolean lastWasEmpty = false;
+  void addList(Node firstInList, int[] skipIndexes) {
+    int nextSlot = 0;
+    int nextSkipSlot = 0;
     for (Node n = firstInList; n != null; n = n.getNext()) {
+      while (skipIndexes != null && nextSkipSlot < skipIndexes.length) {
+        if (nextSlot == skipIndexes[nextSkipSlot]) {
+          cc.listSeparator();
+          nextSlot++;
+          nextSkipSlot++;
+        } else {
+          break;
+        }
+      }
       if (n != firstInList) {
         cc.listSeparator();
       }
       addExpr(n, 1);
-      lastWasEmpty = n.getType() == Token.EMPTY;
-    }
-
-    if (lastWasEmpty) {
-      cc.listSeparator();
+      nextSlot++;
     }
   }
 
@@ -970,13 +782,6 @@
     return strEscape(s, '/', "\"", "'", "\\", outputCharsetEncoder);
   }
 
-  /**
-   * Escapes the given string to a double quoted (") JavaScript/JSON string
-   */
-  static String escapeToDoubleQuotedJsString(String s) {
-    return strEscape(s, '"',  "\\\"", "\'", "\\\\", null);
-  }
-
   /* If the user doesn't want to specify an output charset encoder, assume
      they want Latin/ASCII characters only.
    */
@@ -990,12 +795,11 @@
                           String singlequoteEscape,
                           String backslashEscape,
                           CharsetEncoder outputCharsetEncoder) {
-    StringBuilder sb = new StringBuilder(s.length() + 2);
+    StringBuilder sb = new StringBuilder();
     sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
-        case '\0': sb.append("\\0"); break;
         case '\n': sb.append("\\n"); break;
         case '\r': sb.append("\\r"); break;
         case '\t': sb.append("\\t"); break;
@@ -1011,18 +815,10 @@
             sb.append(c);
           }
           break;
-        case '<':
-          // Break </script into <\/script
+        case '<':                       // Break </script into <\/script
           final String END_SCRIPT = "/script";
-
-          // Break <!-- into <\!--
-          final String START_COMMENT = "!--";
-
           if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
-                              END_SCRIPT.length())) {
-            sb.append("<\\");
-          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
-                                     START_COMMENT.length())) {
+              END_SCRIPT.length())) {
             sb.append("<\\");
           } else {
             sb.append(c);
@@ -1036,7 +832,7 @@
               sb.append(c);
             } else {
               // Unicode-escape the character.
-              appendHexJavaScriptRepresentation(sb, c);
+              StringUtil.appendHexJavaScriptRepresentation(sb, c);
             }
           } else {
             // No charsetEncoder provided - pass straight latin characters
@@ -1048,7 +844,7 @@
               // Other characters can be misinterpreted by some js parsers,
               // or perhaps mangled by proxies along the way,
               // so we play it safe and unicode escape them.
-              appendHexJavaScriptRepresentation(sb, c);
+              StringUtil.appendHexJavaScriptRepresentation(sb, c);
             }
           }
       }
@@ -1073,23 +869,17 @@
       if (c > 0x1F && c < 0x7F) {
         sb.append(c);
       } else {
-        appendHexJavaScriptRepresentation(sb, c);
+        StringUtil.appendHexJavaScriptRepresentation(sb, c);
       }
     }
     return sb.toString();
   }
-  /**
-   * @param maxCount The maximum number of children to look for.
-   * @return The number of children of this node that are non empty up to
-   * maxCount.
-   */
-  private static int getNonEmptyChildCount(Node n, int maxCount) {
+
+  /** Gets the number of children of this node that are non empty. */
+  private static int getNonEmptyChildCount(Node n) {
     int i = 0;
-    Node c = n.getFirstChild();
-    for (; c != null && i < maxCount; c = c.getNext()) {
-      if (c.getType() == Token.BLOCK) {
-        i += getNonEmptyChildCount(c, maxCount-i);
-      } else if (c.getType() != Token.EMPTY) {
+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
+      if (c.getType() != Token.EMPTY) {
         i++;
       }
     }
@@ -1099,12 +889,7 @@
   /** Gets the first non-empty child of the given node. */
   private static Node getFirstNonEmptyChild(Node n) {
     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
-      if (c.getType() == Token.BLOCK) {
-        Node result = getFirstNonEmptyChild(c);
-        if (result != null) {
-          return result;
-        }
-      } else if (c.getType() != Token.EMPTY) {
+      if (c.getType() != Token.EMPTY) {
         return c;
       }
     }
@@ -1150,44 +935,4 @@
     return (context == Context.IN_FOR_INIT_CLAUSE
         ? Context.OTHER : context);
   }
-
-  /**
-   * @see #appendHexJavaScriptRepresentation(int, Appendable)
-   */
-  private static void appendHexJavaScriptRepresentation(
-      StringBuilder sb, char c) {
-    try {
-      appendHexJavaScriptRepresentation(c, sb);
-    } catch (IOException ex) {
-      // StringBuilder does not throw IOException.
-      throw new RuntimeException(ex);
-    }
-  }
-
-  /**
-   * Returns a javascript representation of the character in a hex escaped
-   * format.
-   *
-   * @param codePoint The codepoint to append.
-   * @param out The buffer to which the hex representation should be appended.
-   */
-  private static void appendHexJavaScriptRepresentation(
-      int codePoint, Appendable out)
-      throws IOException {
-    if (Character.isSupplementaryCodePoint(codePoint)) {
-      // Handle supplementary unicode values which are not representable in
-      // javascript.  We deal with these by escaping them as two 4B sequences
-      // so that they will round-trip properly when sent from java to javascript
-      // and back.
-      char[] surrogates = Character.toChars(codePoint);
-      appendHexJavaScriptRepresentation(surrogates[0], out);
-      appendHexJavaScriptRepresentation(surrogates[1], out);
-      return;
-    }
-    out.append("\\u")
-        .append(HEX_CHARS[(codePoint >>> 12) & 0xf])
-        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])
-        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])
-        .append(HEX_CHARS[codePoint & 0xf]);
-  }
 }
diff -r -u buggy/test/com/google/javascript/jscomp/CodePrinterTest.java inducing/test/com/google/javascript/jscomp/CodePrinterTest.java
--- buggy/test/com/google/javascript/jscomp/CodePrinterTest.java	2023-06-12 11:34:26.134214763 +0800
+++ inducing/test/com/google/javascript/jscomp/CodePrinterTest.java	2023-06-12 11:34:26.390219442 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004 The Closure Compiler Authors.
+ * Copyright 2004 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,12 +16,14 @@
 
 package com.google.javascript.jscomp;
 
-import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
+import com.google.common.collect.ImmutableList;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 
 import junit.framework.TestCase;
 
+import java.util.List;
+
 public class CodePrinterTest extends TestCase {
   static Node parse(String js) {
     return parse(js, false);
@@ -29,43 +31,21 @@
 
   static Node parse(String js, boolean checkTypes) {
     Compiler compiler = new Compiler();
-    CompilerOptions options = new CompilerOptions();
-    // Allow getters and setters.
-    options.setLanguageIn(LanguageMode.ECMASCRIPT5);
-    compiler.initOptions(options);
     Node n = compiler.parseTestCode(js);
 
     if (checkTypes) {
-      DefaultPassConfig passConfig = new DefaultPassConfig(null);
-      CompilerPass typeResolver = passConfig.resolveTypes.create(compiler);
+      CompilerPass typeResolver = new DefaultPassConfig(null)
+          .resolveTypes.create(compiler);
       Node externs = new Node(Token.SCRIPT);
-      externs.setIsSyntheticBlock(true);
       Node externAndJsRoot = new Node(Token.BLOCK, externs, n);
       externAndJsRoot.setIsSyntheticBlock(true);
       typeResolver.process(externs, n);
-      CompilerPass inferTypes = passConfig.inferTypes.create(compiler);
-      inferTypes.process(externs, n);
     }
 
-    checkUnexpectedErrorsOrWarnings(compiler, 0);
+    assertEquals("Errors for: " + js, 0, compiler.getErrorCount());
     return n;
   }
 
-  private static void checkUnexpectedErrorsOrWarnings(
-      Compiler compiler, int expected) {
-    int actual = compiler.getErrors().length + compiler.getWarnings().length;
-    if (actual != expected) {
-      String msg = "";
-      for (JSError err : compiler.getErrors()) {
-        msg += "Error:" + err.toString() + "\n";
-      }
-      for (JSError err : compiler.getWarnings()) {
-        msg += "Warning:" + err.toString() + "\n";
-      }
-      assertEquals("Unexpected warnings or errors.\n " + msg, expected, actual);
-    }
-  }
-
   String parsePrint(String js, boolean prettyprint, int lineThreshold) {
     return new CodePrinter.Builder(parse(js)).setPrettyPrint(prettyprint)
         .setLineLengthThreshold(lineThreshold).build();
@@ -81,21 +61,9 @@
       int lineThreshold, boolean outputTypes) {
     return new CodePrinter.Builder(parse(js, true)).setPrettyPrint(prettyprint)
         .setOutputTypes(outputTypes)
-        .setLineLengthThreshold(lineThreshold).setLineBreak(lineBreak)
-        .build();
-  }
-
-  String parsePrint(String js, boolean prettyprint, boolean lineBreak,
-                    int lineThreshold, boolean outputTypes,
-                    boolean tagAsStrict) {
-    return new CodePrinter.Builder(parse(js, true)).setPrettyPrint(prettyprint)
-        .setOutputTypes(outputTypes)
-        .setLineLengthThreshold(lineThreshold).setLineBreak(lineBreak)
-        .setTagAsStrict(tagAsStrict)
-        .build();
+        .setLineLengthThreshold(lineThreshold).setLineBreak(lineBreak).build();
   }
 
-
   String printNode(Node n) {
     return new CodePrinter.Builder(n).setLineLengthThreshold(
         CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD).build();
@@ -160,10 +128,6 @@
 
     assertPrint("/--> <\\/script>/g", "/--\\> <\\/script>/g");
 
-    // Break HTML start comments. Certain versions of Webkit
-    // begin an HTML comment when they see this.
-    assertPrint("'<!-- I am a string -->'", "\"<\\!-- I am a string --\\>\"");
-
     // Precedence
     assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");
     assertPrint("(delete a[0])/10", "delete a[0]/10");
@@ -214,11 +178,11 @@
     assertPrint("1 || ({})", "1||{}");
     assertPrint("({}) ? 1 : 2", "({})?1:2");
     assertPrint("0 ? ({}) : 2", "0?{}:2");
-    assertPrint("0 ? 1 : ({})", "0?1:{}");
+    assertPrint("0 ? 1 : ({})", "0?1:{}");    
     assertPrint("typeof ({})", "typeof{}");
     assertPrint("f({})", "f({})");
 
-    // Anonymous function expressions.
+    // Anonymous functions.
     assertPrint("(function(){})", "(function(){})");
     assertPrint("(function(){})()", "(function(){})()");
     assertPrint("(function(){})instanceof Object",
@@ -229,28 +193,12 @@
     assertPrint("var x = function() { }();", "var x=function(){}()");
     assertPrint("(function() {}), 2", "(function(){}),2");
 
-    // Name functions expression.
+    // Named functions
     assertPrint("(function f(){})", "(function f(){})");
-
-    // Function declaration.
     assertPrint("function f(){}", "function f(){}");
 
     // Make sure we don't treat non-latin character escapes as raw strings.
-    assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");
-    assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");
-
-    // Test if statement and for statements with single statements in body.
-    assertPrint("if (true) { alert();}", "if(true)alert()");
-    assertPrint("if (false) {} else {alert(\"a\");}",
-        "if(false);else alert(\"a\")");
-    assertPrint("for(;;) { alert();};", "for(;;)alert()");
-
-    assertPrint("do { alert(); } while(true);",
-        "do alert();while(true)");
-    assertPrint("myLabel: { alert();}",
-        "myLabel:alert()");
-    assertPrint("myLabel: for(;;) continue myLabel;",
-        "myLabel:for(;;)continue myLabel");
+    assertPrint("({ 'a': 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");
 
     // Test nested var statement
     assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");
@@ -271,7 +219,7 @@
     assertPrint("+ - + + - + 3", "+-+ +-+3"); // chained unary plus/minus
     assertPrint("+(--x)", "+--x");
     assertPrint("-(++x)", "-++x");
-
+    
     // needs a space to prevent an ambiguous parse
     assertPrint("-(--x)", "- --x");
     assertPrint("!(~~5)", "!~~5");
@@ -324,32 +272,6 @@
     assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");
   }
 
-  public void testPrintArray() {
-    assertPrint("[void 0, void 0]", "[void 0,void 0]");
-    assertPrint("[undefined, undefined]", "[undefined,undefined]");
-    assertPrint("[ , , , undefined]", "[,,,undefined]");
-    assertPrint("[ , , , 0]", "[,,,0]");
-  }
-
-  public void testHook() {
-    assertPrint("a ? b = 1 : c = 2", "a?b=1:c=2");
-    assertPrint("x = a ? b = 1 : c = 2", "x=a?b=1:c=2");
-    assertPrint("(x = a) ? b = 1 : c = 2", "(x=a)?b=1:c=2");
-
-    assertPrint("x, a ? b = 1 : c = 2", "x,a?b=1:c=2");
-    assertPrint("x, (a ? b = 1 : c = 2)", "x,a?b=1:c=2");
-    assertPrint("(x, a) ? b = 1 : c = 2", "(x,a)?b=1:c=2");
-
-    assertPrint("a ? (x, b) : c = 2", "a?(x,b):c=2");
-    assertPrint("a ? b = 1 : (x,c)", "a?b=1:(x,c)");
-
-    assertPrint("a ? b = 1 : c = 2 + x", "a?b=1:c=2+x");
-    assertPrint("(a ? b = 1 : c = 2) + x", "(a?b=1:c=2)+x");
-    assertPrint("a ? b = 1 : (c = 2) + x", "a?b=1:(c=2)+x");
-
-    assertPrint("a ? (b?1:2) : 3", "a?b?1:2:3");
-  }
-
   public void testPrintInOperatorInForLoop() {
     // Check for in expression in for's init expression.
     // Check alone, with + (higher precedence), with ?: (lower precedence),
@@ -383,7 +305,6 @@
   }
 
   private void assertPrint(String js, String expected) {
-    parse(expected); // validate the expected string is valid js
     assertEquals(expected,
         parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
   }
@@ -461,253 +382,47 @@
             CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
   }
 
+
   public void testPrettyPrinter() {
     // Ensure that the pretty printer inserts line breaks at appropriate
     // places.
-    assertPrettyPrint("(function(){})();","(function() {\n})();\n");
+    assertPrettyPrint("(function(){})();","(function() {\n})()");
     assertPrettyPrint("var a = (function() {});alert(a);",
-        "var a = function() {\n};\nalert(a);\n");
-
-    // Check we correctly handle putting brackets around all if clauses so
-    // we can put breakpoints inside statements.
-    assertPrettyPrint("if (1) {}",
-        "if(1) {\n" +
-        "}\n");
-    assertPrettyPrint("if (1) {alert(\"\");}",
-        "if(1) {\n" +
-        "  alert(\"\")\n" +
-        "}\n");
-    assertPrettyPrint("if (1)alert(\"\");",
-        "if(1) {\n" +
-        "  alert(\"\")\n" +
-        "}\n");
-    assertPrettyPrint("if (1) {alert();alert();}",
-        "if(1) {\n" +
-        "  alert();\n" +
-        "  alert()\n" +
-        "}\n");
-
-    // Don't add blocks if they weren't there already.
-    assertPrettyPrint("label: alert();",
-        "label:alert();\n");
-
-    // But if statements and loops get blocks automagically.
-    assertPrettyPrint("if (1) alert();",
-        "if(1) {\n" +
-        "  alert()\n" +
-        "}\n");
-    assertPrettyPrint("for (;;) alert();",
-        "for(;;) {\n" +
-        "  alert()\n" +
-        "}\n");
-
-    assertPrettyPrint("while (1) alert();",
-        "while(1) {\n" +
-        "  alert()\n" +
-        "}\n");
-
-    // Do we put else clauses in blocks?
-    assertPrettyPrint("if (1) {} else {alert(a);}",
-        "if(1) {\n" +
-        "}else {\n  alert(a)\n}\n");
-
-    // Do we add blocks to else clauses?
-    assertPrettyPrint("if (1) alert(a); else alert(b);",
-        "if(1) {\n" +
-        "  alert(a)\n" +
-        "}else {\n" +
-        "  alert(b)\n" +
-        "}\n");
-
-    // Do we put for bodies in blocks?
-    assertPrettyPrint("for(;;) { alert();}",
-        "for(;;) {\n" +
-         "  alert()\n" +
-         "}\n");
-    assertPrettyPrint("for(;;) {}",
-        "for(;;) {\n" +
-        "}\n");
-    assertPrettyPrint("for(;;) { alert(); alert(); }",
-        "for(;;) {\n" +
-        "  alert();\n" +
-        "  alert()\n" +
-        "}\n");
-
-    // How about do loops?
-    assertPrettyPrint("do { alert(); } while(true);",
-        "do {\n" +
-        "  alert()\n" +
-        "}while(true);\n");
-
-    // label?
-    assertPrettyPrint("myLabel: { alert();}",
-        "myLabel: {\n" +
-        "  alert()\n" +
-        "}\n");
-
-    // Don't move the label on a loop, because then break {label} and
-    // continue {label} won't work.
-    assertPrettyPrint("myLabel: for(;;) continue myLabel;",
-        "myLabel:for(;;) {\n" +
-        "  continue myLabel\n" +
-        "}\n");
-
-    assertPrettyPrint("var a;", "var a;\n");
-  }
-
-  public void testPrettyPrinter2() {
-    assertPrettyPrint(
-        "if(true) f();",
-        "if(true) {\n" +
-        "  f()\n" +
-        "}\n");
-
-    assertPrettyPrint(
-        "if (true) { f() } else { g() }",
-        "if(true) {\n" +
-        "  f()\n" +
-        "}else {\n" +
-        "  g()\n" +
-        "}\n");
-
-    assertPrettyPrint(
-        "if(true) f(); for(;;) g();",
-        "if(true) {\n" +
-        "  f()\n" +
-        "}\n" +
-        "for(;;) {\n" +
-        "  g()\n" +
-        "}\n");
-  }
-
-  public void testPrettyPrinter3() {
-    assertPrettyPrint(
-        "try {} catch(e) {}if (1) {alert();alert();}",
-        "try {\n" +
-        "}catch(e) {\n" +
-        "}\n" +
-        "if(1) {\n" +
-        "  alert();\n" +
-        "  alert()\n" +
-        "}\n");
-
-    assertPrettyPrint(
-        "try {} finally {}if (1) {alert();alert();}",
-        "try {\n" +
-        "}finally {\n" +
-        "}\n" +
-        "if(1) {\n" +
-        "  alert();\n" +
-        "  alert()\n" +
-        "}\n");
-
-    assertPrettyPrint(
-        "try {} catch(e) {} finally {} if (1) {alert();alert();}",
-        "try {\n" +
-        "}catch(e) {\n" +
-        "}finally {\n" +
-        "}\n" +
-        "if(1) {\n" +
-        "  alert();\n" +
-        "  alert()\n" +
-        "}\n");
-  }
-
-  public void testPrettyPrinter4() {
-    assertPrettyPrint(
-        "function f() {}if (1) {alert();}",
-        "function f() {\n" +
-        "}\n" +
-        "if(1) {\n" +
-        "  alert()\n" +
-        "}\n");
-
-    assertPrettyPrint(
-        "var f = function() {};if (1) {alert();}",
-        "var f = function() {\n" +
-        "};\n" +
-        "if(1) {\n" +
-        "  alert()\n" +
-        "}\n");
-
-    assertPrettyPrint(
-        "(function() {})();if (1) {alert();}",
-        "(function() {\n" +
-        "})();\n" +
-        "if(1) {\n" +
-        "  alert()\n" +
-        "}\n");
-
-    assertPrettyPrint(
-        "(function() {alert();alert();})();if (1) {alert();}",
-        "(function() {\n" +
-        "  alert();\n" +
-        "  alert()\n" +
-        "})();\n" +
-        "if(1) {\n" +
-        "  alert()\n" +
-        "}\n");
+        "var a = function() {\n};\nalert(a)");
   }
 
   public void testTypeAnnotations() {
-    assertTypeAnnotations(
-        "/** @constructor */ function Foo(){}",
-        "/**\n * @return {undefined}\n * @constructor\n */\n"
-        + "function Foo() {\n}\n");
-  }
-
-  public void testTypeAnnotationsTypeDef() {
-    // TODO(johnlenz): It would be nice if there were some way to preserve
-    // typedefs but currently they are resolved into the basic types in the
-    // type registry.
-    assertTypeAnnotations(
-        "/** @typedef {Array.<number>} */ goog.java.Long;\n"
-        + "/** @param {!goog.java.Long} a*/\n"
-        + "function f(a){};\n",
-        "goog.java.Long;\n"
-        + "/**\n"
-        + " * @param {(Array|null)} a\n"
-        + " * @return {undefined}\n"
-        + " */\n"
-        + "function f(a) {\n}\n");
+    assertTypeAnnotations("/** @constructor */ function Foo(){}",
+        "/**\n * @constructor\n */\nfunction Foo() {\n}\n");
   }
 
   public void testTypeAnnotationsAssign() {
     assertTypeAnnotations("/** @constructor */ var Foo = function(){}",
-        "/**\n * @return {undefined}\n * @constructor\n */\n"
-        + "var Foo = function() {\n};\n");
+        "/**\n * @constructor\n */\nvar Foo = function() {\n}");
   }
 
   public void testTypeAnnotationsNamespace() {
     assertTypeAnnotations("var a = {};"
         + "/** @constructor */ a.Foo = function(){}",
-        "var a = {};\n"
-        + "/**\n * @return {undefined}\n * @constructor\n */\n"
-        + "a.Foo = function() {\n};\n");
+        "var a = {};\n/**\n * @constructor\n */\na.Foo = function() {\n}");
   }
 
   public void testTypeAnnotationsMemberSubclass() {
     assertTypeAnnotations("var a = {};"
         + "/** @constructor */ a.Foo = function(){};"
         + "/** @constructor \n @extends {a.Foo} */ a.Bar = function(){}",
-        "var a = {};\n"
-        + "/**\n * @return {undefined}\n * @constructor\n */\n"
-        + "a.Foo = function() {\n};\n"
-        + "/**\n * @return {undefined}\n * @extends {a.Foo}\n"
-        + " * @constructor\n */\n"
-        + "a.Bar = function() {\n};\n");
+        "var a = {};\n/**\n * @constructor\n */\na.Foo = function() {\n};\n"
+        + "/**\n * @extends {a.Foo}\n * @constructor\n */\n"
+        + "a.Bar = function() {\n}");
   }
 
   public void testTypeAnnotationsInterface() {
     assertTypeAnnotations("var a = {};"
         + "/** @interface */ a.Foo = function(){};"
         + "/** @interface \n @extends {a.Foo} */ a.Bar = function(){}",
-        "var a = {};\n"
-        + "/**\n * @interface\n */\n"
-        + "a.Foo = function() {\n};\n"
-        + "/**\n * @extends {a.Foo}\n"
-        + " * @interface\n */\n"
-        + "a.Bar = function() {\n};\n");
+        "var a = {};\n/**\n * @interface\n */\na.Foo = function() {\n};\n"
+        + "/**\n * @extends {a.Foo}\n * @interface\n */\n"
+        + "a.Bar = function() {\n}");
   }
 
   public void testTypeAnnotationsMember() {
@@ -715,19 +430,18 @@
         + "/** @constructor */ a.Foo = function(){}"
         + "/** @param {string} foo\n"
         + "  * @return {number} */\n"
-        + "a.Foo.prototype.foo = function(foo) { return 3; };"
+        + "a.Foo.prototype.foo = function(foo) {};"
         + "/** @type {string|undefined} */"
         + "a.Foo.prototype.bar = '';",
         "var a = {};\n"
-        + "/**\n * @return {undefined}\n * @constructor\n */\n"
-        + "a.Foo = function() {\n};\n"
+        + "/**\n * @constructor\n */\na.Foo = function() {\n};\n"
         + "/**\n"
         + " * @param {string} foo\n"
         + " * @return {number}\n"
         + " */\n"
-        + "a.Foo.prototype.foo = function(foo) {\n  return 3\n};\n"
-        + "/** @type {string} */\n"
-        + "a.Foo.prototype.bar = \"\";\n");
+        + "a.Foo.prototype.foo = function(foo) {\n};\n"
+        + "/** @type {(string|undefined)} */\n"
+        + "a.Foo.prototype.bar = \"\"");
   }
 
   public void testTypeAnnotationsImplements() {
@@ -739,117 +453,12 @@
         + " * @implements {a.I} \n @implements {a.I2}\n"
         + "*/ a.Bar = function(){}",
         "var a = {};\n"
-        + "/**\n * @return {undefined}\n * @constructor\n */\n"
-        + "a.Foo = function() {\n};\n"
-        + "/**\n * @interface\n */\n"
-        + "a.I = function() {\n};\n"
-        + "/**\n * @interface\n */\n"
-        + "a.I2 = function() {\n};\n"
-        + "/**\n * @return {undefined}\n * @extends {a.Foo}\n"
-        + " * @implements {a.I}\n"
+        + "/**\n * @constructor\n */\na.Foo = function() {\n};\n"
+        + "/**\n * @interface\n */\na.I = function() {\n};\n"
+        + "/**\n * @interface\n */\na.I2 = function() {\n};\n"
+        + "/**\n * @extends {a.Foo}\n * @implements {a.I}\n"
         + " * @implements {a.I2}\n * @constructor\n */\n"
-        + "a.Bar = function() {\n};\n");
-  }
-
-  public void testTypeAnnotationsDispatcher1() {
-    assertTypeAnnotations(
-        "var a = {};\n" +
-        "/** \n" +
-        " * @constructor \n" +
-        " * @javadispatch \n" +
-        " */\n" +
-        "a.Foo = function(){}",
-        "var a = {};\n" +
-        "/**\n" +
-        " * @return {undefined}\n" +
-        " * @constructor\n" +
-        " * @javadispatch\n" +
-        " */\n" +
-        "a.Foo = function() {\n" +
-        "};\n");
-  }
-
-  public void testTypeAnnotationsDispatcher2() {
-    assertTypeAnnotations(
-        "var a = {};\n" +
-        "/** \n" +
-        " * @constructor \n" +
-        " */\n" +
-        "a.Foo = function(){}\n" +
-        "/**\n" +
-        " * @javadispatch\n" +
-        " */\n" +
-        "a.Foo.prototype.foo = function() {};",
-
-        "var a = {};\n" +
-        "/**\n" +
-        " * @return {undefined}\n" +
-        " * @constructor\n" +
-        " */\n" +
-        "a.Foo = function() {\n" +
-        "};\n" +
-        "/**\n" +
-        " * @return {undefined}\n" +
-        " * @javadispatch\n" +
-        " */\n" +
-        "a.Foo.prototype.foo = function() {\n" +
-        "};\n");
-  }
-
-  public void testU2UFunctionTypeAnnotation() {
-    assertTypeAnnotations(
-        "/** @type {!Function} */ var x = function() {}",
-        "/**\n * @constructor\n */\nvar x = function() {\n};\n");
-  }
-
-  public void testEmitUnknownParamTypesAsAllType() {
-    assertTypeAnnotations(
-        "var a = function(x) {}",
-        "/**\n" +
-        " * @param {*} x\n" +
-        " * @return {undefined}\n" +
-        " */\n" +
-        "var a = function(x) {\n};\n");
-  }
-
-  public void testOptionalTypesAnnotation() {
-    assertTypeAnnotations(
-        "/**\n" +
-        " * @param {string=} x \n" +
-        " */\n" +
-        "var a = function(x) {}",
-        "/**\n" +
-        " * @param {string=} x\n" +
-        " * @return {undefined}\n" +
-        " */\n" +
-        "var a = function(x) {\n};\n");
-  }
-
-  public void testVariableArgumentsTypesAnnotation() {
-    assertTypeAnnotations(
-        "/**\n" +
-        " * @param {...string} x \n" +
-        " */\n" +
-        "var a = function(x) {}",
-        "/**\n" +
-        " * @param {...string} x\n" +
-        " * @return {undefined}\n" +
-        " */\n" +
-        "var a = function(x) {\n};\n");
-  }
-
-  public void testTempConstructor() {
-    assertTypeAnnotations(
-        "var x = function() {\n/**\n * @constructor\n */\nfunction t1() {}\n" +
-        " /**\n * @constructor\n */\nfunction t2() {}\n" +
-        " t1.prototype = t2.prototype}",
-        "/**\n * @return {undefined}\n */\nvar x = function() {\n" +
-        "  /**\n * @return {undefined}\n * @constructor\n */\n" +
-        "function t1() {\n  }\n" +
-        "  /**\n * @return {undefined}\n * @constructor\n */\n" +
-        "function t2() {\n  }\n" +
-        "  t1.prototype = t2.prototype\n};\n"
-    );
+        + "a.Bar = function() {\n}");
   }
 
   private void assertPrettyPrint(String js, String expected) {
@@ -864,10 +473,16 @@
             CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));
   }
 
+  /**
+   * This test case is more involved since we need to run a constant folding
+   * pass to get the -4 converted to a negative number, as opposed to a
+   * number node with a number 4 attached to the negation unary operator.
+   */
   public void testSubtraction() {
     Compiler compiler = new Compiler();
     Node n = compiler.parseTestCode("x - -4");
     assertEquals(0, compiler.getErrorCount());
+    NodeTraversal.traverse(compiler, n, new FoldConstants(compiler));
 
     assertEquals(
         "x- -4",
@@ -875,21 +490,6 @@
             CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD).build());
   }
 
-  public void testFunctionWithCall() {
-    assertPrint(
-        "var user = new function() {"
-        + "alert(\"foo\")}",
-        "var user=new function(){"
-        + "alert(\"foo\")}");
-    assertPrint(
-        "var user = new function() {"
-        + "this.name = \"foo\";"
-        + "this.local = function(){alert(this.name)};}",
-        "var user=new function(){"
-        + "this.name=\"foo\";"
-        + "this.local=function(){alert(this.name)}}");
-  }
-
   public void testLineLength() {
     // list
     assertLineLength("var aba,bcb,cdc",
@@ -935,277 +535,104 @@
   }
 
   public void testParsePrintParse() {
-    testReparse("3;");
-    testReparse("var a = b;");
-    testReparse("var x, y, z;");
-    testReparse("try { foo() } catch(e) { bar() }");
-    testReparse("try { foo() } catch(e) { bar() } finally { stuff() }");
-    testReparse("try { foo() } finally { stuff() }");
-    testReparse("throw 'me'");
-    testReparse("function foo(a) { return a + 4; }");
-    testReparse("function foo() { return; }");
-    testReparse("var a = function(a, b) { foo(); return a + b; }");
-    testReparse("b = [3, 4, 'paul', \"Buchhe it\",,5];");
-    testReparse("v = (5, 6, 7, 8)");
-    testReparse("d = 34.0; x = 0; y = .3; z = -22");
-    testReparse("d = -x; t = !x + ~y;");
-    testReparse("'hi'; /* just a test */ stuff(a,b) \n" +
-            " foo(); // and another \n" +
-            " bar();");
-    testReparse("a = b++ + ++c; a = b++-++c; a = - --b; a = - ++b;");
-    testReparse("a++; b= a++; b = ++a; b = a--; b = --a; a+=2; b-=5");
-    testReparse("a = (2 + 3) * 4;");
-    testReparse("a = 1 + (2 + 3) + 4;");
-    testReparse("x = a ? b : c; x = a ? (b,3,5) : (foo(),bar());");
-    testReparse("a = b | c || d ^ e " +
-            "&& f & !g != h << i <= j < k >>> l > m * n % !o");
-    testReparse("a == b; a != b; a === b; a == b == a;" +
-            " (a == b) == a; a == (b == a);");
-    testReparse("if (a > b) a = b; if (b < 3) a = 3; else c = 4;");
-    testReparse("if (a == b) { a++; } if (a == 0) { a++; } else { a --; }");
-    testReparse("for (var i in a) b += i;");
-    testReparse("for (var i = 0; i < 10; i++){ b /= 2;" +
-            " if (b == 2)break;else continue;}");
-    testReparse("for (x = 0; x < 10; x++) a /= 2;");
-    testReparse("for (;;) a++;");
-    testReparse("while(true) { blah(); }while(true) blah();");
-    testReparse("do stuff(); while(a>b);");
-    testReparse("[0, null, , true, false, this];");
-    testReparse("s.replace(/absc/, 'X').replace(/ab/gi, 'Y');");
-    testReparse("new Foo; new Bar(a, b,c);");
-    testReparse("with(foo()) { x = z; y = t; } with(bar()) a = z;");
-    testReparse("delete foo['bar']; delete foo;");
-    testReparse("var x = { 'a':'paul', 1:'3', 2:(3,4) };");
-    testReparse("switch(a) { case 2: case 3: stuff(); break;" +
-        "case 4: morestuff(); break; default: done();}");
-    testReparse("x = foo['bar'] + foo['my stuff'] + foo[bar] + f.stuff;");
-    testReparse("a.v = b.v; x['foo'] = y['zoo'];");
-    testReparse("'test' in x; 3 in x; a in x;");
-    testReparse("'foo\"bar' + \"foo'c\" + 'stuff\\n and \\\\more'");
-    testReparse("x.__proto__;");
-  }
-
-  private void testReparse(String code) {
-    Compiler compiler = new Compiler();
-    Node parse1 = parse(code);
-    Node parse2 = parse(new CodePrinter.Builder(parse1).build());
-    String explanation = parse1.checkTreeEquals(parse2);
-    assertNull("\nExpected: " + compiler.toSource(parse1) +
-        "\nResult: " + compiler.toSource(parse2) +
-        "\n" + explanation, explanation);
+    List<String> parsePrintParseTestCases = ImmutableList.of(
+        "3;",
+        "var a = b;",
+        "var x, y, z;",
+        "try { foo() } catch(e) { bar() }",
+        "try { foo() } catch(e) { bar() } finally { stuff() }",
+        "try { foo() } finally { stuff() }",
+        "throw 'me'",
+        "function foo(a) { return a + 4; }",
+        "function foo() { return; }",
+        "var a = function(a, b) { foo(); return a + b; }",
+        "b = [3, 4, 'paul', \"Buchhe it\",,5];",
+        "v = (5, 6, 7, 8)",
+        "d = 34.0; x = 0; y = .3; z = -22",
+        "d = -x; t = !x + ~y;",
+        "'hi'; /* just a test */ stuff(a,b) \n foo(); // and another \n bar();",
+        "a = b++ + ++c; a = b++-++c; a = - --b; a = - ++b;",
+        "a++; b= a++; b = ++a; b = a--; b = --a; a+=2; b-=5",
+        "a = (2 + 3) * 4;",
+        "a = 1 + (2 + 3) + 4;",
+        "x = a ? b : c; x = a ? (b,3,5) : (foo(),bar());",
+        "a = b | c || d ^ e && f & !g != h << i <= j < k >>> l > m * n % !o",
+        "a == b; a != b; a === b; a == b == a; (a == b) == a; a == (b == a);",
+        "if (a > b) a = b; if (b < 3) a = 3; else c = 4;",
+        "if (a == b) { a++; } if (a == 0) { a++; } else { a --; }",
+        "for (var i in a) b += i;",
+        "for (var i = 0; i < 10; i++){ b /= 2; if (b == 2)break;else continue;}",
+        "for (x = 0; x < 10; x++) a /= 2;",
+        "for (;;) a++;",
+        "while(true) { blah(); }while(true) blah();",
+        "do stuff(); while(a>b);",
+        "[0, null, , true, false, this];",
+        "s.replace(/absc/, 'X').replace(/ab/gi, 'Y');",
+        "new Foo; new Bar(a, b,c);",
+        "with(foo()) { x = z; y = t; } with(bar()) a = z;",
+        "delete foo['bar']; delete foo;",
+        "var x = { 'a':'paul', 1:'3', 2:(3,4) };",
+        "switch(a) { case 2: case 3: { stuff(); break; }" +
+        "case 4: morestuff(); break; default: done();}",
+        "x = foo['bar'] + foo['my stuff'] + foo[bar] + f.stuff;",
+        "a.v = b.v; x['foo'] = y['zoo'];",
+        "'test' in x; 3 in x; a in x;",
+        "'foo\"bar' + \"foo'c\" + 'stuff\\n and \\\\more'",
+        "x.__proto__;");
+
+    for (String testCase : parsePrintParseTestCases) {
+      Node parse1 = parse(testCase);
+      Node parse2 = parse(new CodePrinter.Builder(parse1).build());
+      assertTrue(testCase, parse1.checkTreeEqualsSilent(parse2));
+    }
   }
 
   public void testDoLoopIECompatiblity() {
     // Do loops within IFs cause syntax errors in IE6 and IE7.
-    assertPrint("function f(){if(e1){do foo();while(e2)}else foo()}",
-        "function f(){if(e1){do foo();while(e2)}else foo()}");
+    assertPrint("function(){if(e1){do foo();while(e2)}else foo()}",
+        "function(){if(e1){do foo();while(e2)}else foo()}");
 
-    assertPrint("function f(){if(e1)do foo();while(e2)else foo()}",
-        "function f(){if(e1){do foo();while(e2)}else foo()}");
+    assertPrint("function(){if(e1)do foo();while(e2)else foo()}",
+        "function(){if(e1){do foo();while(e2)}else foo()}");
 
     assertPrint("if(x){do{foo()}while(y)}else bar()",
         "if(x){do foo();while(y)}else bar()");
 
     assertPrint("if(x)do{foo()}while(y);else bar()",
         "if(x){do foo();while(y)}else bar()");
-
-    assertPrint("if(x){do{foo()}while(y)}",
-        "if(x){do foo();while(y)}");
-
-    assertPrint("if(x)do{foo()}while(y);",
-        "if(x){do foo();while(y)}");
-
-    assertPrint("if(x)A:do{foo()}while(y);",
-        "if(x){A:do foo();while(y)}");
-
-    assertPrint("var i = 0;a: do{b: do{i++;break b;} while(0);} while(0);",
-        "var i=0;a:do{b:do{i++;break b}while(0)}while(0)");
   }
 
   public void testFunctionSafariCompatiblity() {
-    // Functions within IFs cause syntax errors on Safari.
-    assertPrint("function f(){if(e1){function goo(){return true}}else foo()}",
-        "function f(){if(e1){function goo(){return true}}else foo()}");
+    // Do loops within IFs cause syntax errors in IE6 and IE7.
+    assertPrint("function(){if(e1){function goo(){return true}}else foo()}",
+        "function(){if(e1){function goo(){return true}}else foo()}");
 
-    assertPrint("function f(){if(e1)function goo(){return true}else foo()}",
-        "function f(){if(e1){function goo(){return true}}else foo()}");
+    assertPrint("function(){if(e1)function goo(){return true}else foo()}",
+        "function(){if(e1){function goo(){return true}}else foo()}");
 
     assertPrint("if(e1){function goo(){return true}}",
         "if(e1){function goo(){return true}}");
 
     assertPrint("if(e1)function goo(){return true}",
         "if(e1){function goo(){return true}}");
-
-    assertPrint("if(e1)A:function goo(){return true}",
-        "if(e1){A:function goo(){return true}}");
   }
-
+  
   public void testExponents() {
-    assertPrintNumber("1", 1);
-    assertPrintNumber("10", 10);
-    assertPrintNumber("100", 100);
-    assertPrintNumber("1E3", 1000);
-    assertPrintNumber("1E4", 10000);
-    assertPrintNumber("1E5", 100000);
-    assertPrintNumber("-1", -1);
-    assertPrintNumber("-10", -10);
-    assertPrintNumber("-100", -100);
-    assertPrintNumber("-1E3", -1000);
-    assertPrintNumber("-12341234E4", -123412340000L);
-    assertPrintNumber("1E18", 1000000000000000000L);
-    assertPrintNumber("1E5", 100000.0);
-    assertPrintNumber("100000.1", 100000.1);
-
-    assertPrintNumber("1.0E-6", 0.000001);
-  }
-
-  // Make sure to test as both a String and a Node, because
-  // negative numbers do not parse consistently from strings.
-  private void assertPrintNumber(String expected, double number) {
-    assertPrint(String.valueOf(number), expected);
-    assertPrintNode(expected, Node.newNumber(number));
-  }
-
-  private void assertPrintNumber(String expected, int number) {
-    assertPrint(String.valueOf(number), expected);
-    assertPrintNode(expected, Node.newNumber(number));
-  }
-
-  public void testDirectEval() {
-    assertPrint("eval('1');", "eval(\"1\")");
-  }
-
-  public void testIndirectEval() {
-    Node n = parse("eval('1');");
-    assertPrintNode("eval(\"1\")", n);
-    n.getFirstChild().getFirstChild().getFirstChild().putBooleanProp(
-        Node.DIRECT_EVAL, false);
-    assertPrintNode("(0,eval)(\"1\")", n);
-  }
-
-  public void testFreeCall1() {
-    assertPrint("foo(a);", "foo(a)");
-    assertPrint("x.foo(a);", "x.foo(a)");
-  }
-
-  public void testFreeCall2() {
-    Node n = parse("foo(a);");
-    assertPrintNode("foo(a)", n);
-    Node call =  n.getFirstChild().getFirstChild();
-    assertTrue(call.getType() == Token.CALL);
-    call.putBooleanProp(Node.FREE_CALL, true);
-    assertPrintNode("foo(a)", n);
-  }
-
-  public void testFreeCall3() {
-    Node n = parse("x.foo(a);");
-    assertPrintNode("x.foo(a)", n);
-    Node call =  n.getFirstChild().getFirstChild();
-    assertTrue(call.getType() == Token.CALL);
-    call.putBooleanProp(Node.FREE_CALL, true);
-    assertPrintNode("(0,x.foo)(a)", n);
-  }
-
-  public void testPrintScript() {
-    // Verify that SCRIPT nodes not marked as synthetic are printed as
-    // blocks.
-    Node ast = new Node(Token.SCRIPT,
-        new Node(Token.EXPR_RESULT, Node.newString("f")),
-        new Node(Token.EXPR_RESULT, Node.newString("g")));
-    String result = new CodePrinter.Builder(ast).setPrettyPrint(true).build();
-    assertEquals("\"f\";\n\"g\";\n", result);
-  }
-
-  public void testObjectLit() {
-    assertPrint("({x:1})", "({x:1})");
-    assertPrint("var x=({x:1})", "var x={x:1}");
-    assertPrint("var x={'x':1}", "var x={\"x\":1}");
-    assertPrint("var x={1:1}", "var x={1:1}");
-  }
-
-  public void testObjectLit2() {
-    assertPrint("var x={1:1}", "var x={1:1}");
-    assertPrint("var x={'1':1}", "var x={1:1}");
-    assertPrint("var x={'1.0':1}", "var x={\"1.0\":1}");
-    assertPrint("var x={1.5:1}", "var x={\"1.5\":1}");
-
-  }
-
-  public void testObjectLit3() {
-    assertPrint("var x={3E9:1}",
-                "var x={3E9:1}");
-    assertPrint("var x={'3000000000':1}", // More than 31 bits
-                "var x={3E9:1}");
-    assertPrint("var x={'3000000001':1}",
-                "var x={3000000001:1}");
-    assertPrint("var x={'6000000001':1}",  // More than 32 bits
-                "var x={6000000001:1}");
-    assertPrint("var x={\"12345678901234567\":1}",  // More than 53 bits
-                "var x={\"12345678901234567\":1}");
-  }
-
-  public void testGetter() {
-    assertPrint("var x = {}", "var x={}");
-    assertPrint("var x = {get a() {return 1}}", "var x={get a(){return 1}}");
-    assertPrint(
-      "var x = {get a() {}, get b(){}}",
-      "var x={get a(){},get b(){}}");
-
-    assertPrint(
-      "var x = {get 'a'() {return 1}}",
-      "var x={get \"a\"(){return 1}}");
-
-    assertPrint(
-      "var x = {get 1() {return 1}}",
-      "var x={get 1(){return 1}}");
-
-    assertPrint(
-      "var x = {get \"()\"() {return 1}}",
-      "var x={get \"()\"(){return 1}}");
-  }
-
-  public void testSetter() {
-    assertPrint("var x = {}", "var x={}");
-    assertPrint(
-       "var x = {set a(y) {return 1}}",
-       "var x={set a(y){return 1}}");
-
-    assertPrint(
-      "var x = {get 'a'() {return 1}}",
-      "var x={get \"a\"(){return 1}}");
-
-    assertPrint(
-      "var x = {set 1(y) {return 1}}",
-      "var x={set 1(y){return 1}}");
-
-    assertPrint(
-      "var x = {set \"(x)\"(y) {return 1}}",
-      "var x={set \"(x)\"(y){return 1}}");
-  }
-
-  public void testNegCollapse() {
-    // Collapse the negative symbol on numbers at generation time,
-    // to match the Rhino behavior.
-    assertPrint("var x = - - 2;", "var x=2");
-    assertPrint("var x = - (2);", "var x=-2");
-  }
-
-  public void testStrict() {
-    String result = parsePrint("var x", false, false, 0, false, true);
-    assertEquals("'use strict';var x", result);
-  }
-
-  public void testArrayLiteral() {
-    assertPrint("var x = [,];","var x=[,]");
-    assertPrint("var x = [,,];","var x=[,,]");
-    assertPrint("var x = [,s,,];","var x=[,s,,]");
-    assertPrint("var x = [,s];","var x=[,s]");
-    assertPrint("var x = [s,];","var x=[s]");
-  }
-
-  public void testZero() {
-    assertPrint("var x ='\\0';", "var x=\"\\0\"");
-    assertPrint("var x ='\\x00';", "var x=\"\\0\"");
-    assertPrint("var x ='\\u0000';", "var x=\"\\0\"");
+    assertPrint("1", "1");
+    assertPrint("10", "10");
+    assertPrint("100", "100");
+    assertPrint("1000", "1E3");
+    assertPrint("10000", "1E4");
+    assertPrint("100000", "1E5");
+    assertPrint("-1", "-1");
+    assertPrint("-10", "-10");
+    assertPrint("-100", "-100");
+    assertPrint("-1000", "-1E3");
+    assertPrint("-123412340000", "-12341234E4");
+    assertPrint("1000000000000000000", "1E18");
+    assertPrint("100000.0", "1E5");
+    assertPrint("100000.1", "100000.1");
+    
+    assertPrint("0.000001", "1.0E-6");
   }
 }
