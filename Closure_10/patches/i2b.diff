diff -r -u inducing/src/com/google/javascript/jscomp/NodeUtil.java buggy/src/com/google/javascript/jscomp/NodeUtil.java
--- inducing/src/com/google/javascript/jscomp/NodeUtil.java	2023-06-12 11:40:17.135149457 +0800
+++ buggy/src/com/google/javascript/jscomp/NodeUtil.java	2023-06-12 11:40:16.847163016 +0800
@@ -21,34 +21,37 @@
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
+import com.google.javascript.rhino.IR;
+import com.google.javascript.rhino.InputId;
 import com.google.javascript.rhino.JSDocInfo;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.TokenStream;
 import com.google.javascript.rhino.jstype.FunctionType;
 import com.google.javascript.rhino.jstype.JSType;
+import com.google.javascript.rhino.jstype.StaticSourceFile;
 import com.google.javascript.rhino.jstype.TernaryValue;
 
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import javax.annotation.Nullable;
 
 /**
- * NodeUtil contains utilities that get properties from the Node object.
+ * NodeUtil contains generally useful AST utilities.
  *
  */
 public final class NodeUtil {
 
-  final static String JSC_PROPERTY_NAME_FN = "JSCompiler_renameProperty";
+  static final long MAX_POSITIVE_INTEGER_NUMBER = (long) Math.pow(2, 53);
 
-  // TODO(user): Eliminate this class and make all of the static methods
-  // instance methods of com.google.javascript.rhino.Node.
+  static final String JSC_PROPERTY_NAME_FN = "JSCompiler_renameProperty";
+
+  static final char LARGEST_BASIC_LATIN = 0x7f;
 
   /** the set of builtin constructors that don't have side effects. */
   private static final Set<String> CONSTRUCTORS_WITHOUT_SIDE_EFFECTS =
@@ -69,45 +72,55 @@
    * Note: unlike getBooleanValue this function does not return UNKNOWN
    * for expressions with side-effects.
    */
-  static TernaryValue getExpressionBooleanValue(Node n) {
+  static TernaryValue getImpureBooleanValue(Node n) {
     switch (n.getType()) {
       case Token.ASSIGN:
       case Token.COMMA:
         // For ASSIGN and COMMA the value is the value of the RHS.
-        return getExpressionBooleanValue(n.getLastChild());
+        return getImpureBooleanValue(n.getLastChild());
       case Token.NOT:
-        TernaryValue value = getExpressionBooleanValue(n.getLastChild());
+        TernaryValue value = getImpureBooleanValue(n.getLastChild());
         return value.not();
       case Token.AND: {
-        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());
-        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());
+        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
+        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
         return lhs.and(rhs);
       }
       case Token.OR:  {
-        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());
-        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());
+        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
+        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
         return lhs.or(rhs);
       }
       case Token.HOOK:  {
-        TernaryValue trueValue = getExpressionBooleanValue(
+        TernaryValue trueValue = getImpureBooleanValue(
             n.getFirstChild().getNext());
-        TernaryValue falseValue = getExpressionBooleanValue(n.getLastChild());
+        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());
         if (trueValue.equals(falseValue)) {
           return trueValue;
         } else {
           return TernaryValue.UNKNOWN;
         }
       }
+      case Token.ARRAYLIT:
+      case Token.OBJECTLIT:
+        // ignoring side-effects
+        return TernaryValue.TRUE;
+
+      case Token.VOID:
+        return TernaryValue.FALSE;
+
       default:
-        return getBooleanValue(n);
+        return getPureBooleanValue(n);
     }
   }
 
   /**
    * Gets the boolean value of a node that represents a literal. This method
-   * effectively emulates the <code>Boolean()</code> JavaScript cast function.
+   * effectively emulates the <code>Boolean()</code> JavaScript cast function
+   * except it return UNKNOWN for known values with side-effects, use
+   * getExpressionBooleanValue if you don't care about side-effects.
    */
-  static TernaryValue getBooleanValue(Node n) {
+  static TernaryValue getPureBooleanValue(Node n) {
     switch (n.getType()) {
       case Token.STRING:
         return TernaryValue.forBoolean(n.getString().length() > 0);
@@ -115,11 +128,19 @@
       case Token.NUMBER:
         return TernaryValue.forBoolean(n.getDouble() != 0);
 
+      case Token.NOT:
+        return getPureBooleanValue(n.getLastChild()).not();
+
       case Token.NULL:
       case Token.FALSE:
-      case Token.VOID:
         return TernaryValue.FALSE;
 
+      case Token.VOID:
+        if (!mayHaveSideEffects(n.getFirstChild())) {
+          return TernaryValue.FALSE;
+        }
+        break;
+
       case Token.NAME:
         String name = n.getString();
         if ("undefined".equals(name)
@@ -133,25 +154,30 @@
         break;
 
       case Token.TRUE:
-      case Token.ARRAYLIT:
-      case Token.OBJECTLIT:
       case Token.REGEXP:
         return TernaryValue.TRUE;
+
+      case Token.ARRAYLIT:
+      case Token.OBJECTLIT:
+        if (!mayHaveSideEffects(n)) {
+          return TernaryValue.TRUE;
+        }
+        break;
     }
 
     return TernaryValue.UNKNOWN;
   }
 
-
   /**
    * Gets the value of a node as a String, or null if it cannot be converted.
    * When it returns a non-null String, this method effectively emulates the
    * <code>String()</code> JavaScript cast function.
    */
   static String getStringValue(Node n) {
-    // TODO(user): Convert constant array, object, and regex literals as well.
+    // TODO(user): regex literals as well.
     switch (n.getType()) {
       case Token.STRING:
+      case Token.STRING_KEY:
         return n.getString();
 
       case Token.NAME:
@@ -164,27 +190,80 @@
         break;
 
       case Token.NUMBER:
-        double value = n.getDouble();
-        long longValue = (long) value;
-
-        // Return "1" instead of "1.0"
-        if (longValue == value) {
-          return Long.toString(longValue);
-        } else {
-          return Double.toString(n.getDouble());
-        }
+        return getStringValue(n.getDouble());
 
       case Token.FALSE:
+        return "false";
+
       case Token.TRUE:
+        return "true";
+
       case Token.NULL:
-        return Node.tokenToName(n.getType());
+        return "null";
 
       case Token.VOID:
         return "undefined";
+
+      case Token.NOT:
+        TernaryValue child = getPureBooleanValue(n.getFirstChild());
+        if (child != TernaryValue.UNKNOWN) {
+          return child.toBoolean(true) ? "false" : "true"; // reversed.
+        }
+        break;
+
+      case Token.ARRAYLIT:
+        return arrayToString(n);
+
+      case Token.OBJECTLIT:
+        return "[object Object]";
     }
     return null;
   }
 
+  static String getStringValue(double value) {
+    long longValue = (long) value;
+
+    // Return "1" instead of "1.0"
+    if (longValue == value) {
+      return Long.toString(longValue);
+    } else {
+      return Double.toString(value);
+    }
+  }
+
+  /**
+   * When converting arrays to string using Array.prototype.toString or
+   * Array.prototype.join, the rules for conversion to String are different
+   * than converting each element individually.  Specifically, "null" and
+   * "undefined" are converted to an empty string.
+   * @param n A node that is a member of an Array.
+   * @return The string representation.
+   */
+  static String getArrayElementStringValue(Node n) {
+    return (NodeUtil.isNullOrUndefined(n) || n.isEmpty())
+        ? "" : getStringValue(n);
+  }
+
+  static String arrayToString(Node literal) {
+    Node first = literal.getFirstChild();
+    StringBuilder result = new StringBuilder();
+    int nextSlot = 0;
+    int nextSkipSlot = 0;
+    for (Node n = first; n != null; n = n.getNext()) {
+      String childValue = getArrayElementStringValue(n);
+      if (childValue == null) {
+        return null;
+      }
+      if (n != first) {
+        result.append(',');
+      }
+      result.append(childValue);
+
+      nextSlot++;
+    }
+    return result.toString();
+  }
+
   /**
    * Gets the value of a node as a Number, or null if it cannot be converted.
    * When it returns a non-null Double, this method effectively emulates the
@@ -224,63 +303,86 @@
         return null;
 
       case Token.NEG:
-        if (n.getChildCount() == 1 && n.getFirstChild().getType() == Token.NAME
+        if (n.getChildCount() == 1 && n.getFirstChild().isName()
             && n.getFirstChild().getString().equals("Infinity")) {
           return Double.NEGATIVE_INFINITY;
         }
         return null;
 
-      case Token.STRING:
-        String s = trimJsWhiteSpace(n.getString());
-        // return ScriptRuntime.toNumber(s);
-        if (s.length() == 0) {
-          return 0.0;
+      case Token.NOT:
+        TernaryValue child = getPureBooleanValue(n.getFirstChild());
+        if (child != TernaryValue.UNKNOWN) {
+          return child.toBoolean(true) ? 0.0 : 1.0; // reversed.
         }
+        break;
 
-        if (s.length() > 2
-            && s.charAt(0) == '0'
-            && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
-          // Attempt to convert hex numbers.
-          try {
-            return Double.valueOf(Integer.parseInt(s.substring(2), 16));
-          } catch (NumberFormatException e) {
-            return Double.NaN;
-          }
-        }
+      case Token.STRING:
+        return getStringNumberValue(n.getString());
 
-        if (s.length() > 3
-            && (s.charAt(0) == '-' || s.charAt(0) == '+')
-            && s.charAt(1) == '0'
-            && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
-          // hex numbers with explicit signs vary between browsers.
-          return null;
-        }
+      case Token.ARRAYLIT:
+      case Token.OBJECTLIT:
+        String value = getStringValue(n);
+        return value != null ? getStringNumberValue(value) : null;
+    }
 
-        // FireFox and IE treat the "Infinity" differently. FireFox is case
-        // insensitive, but IE treats "infinity" as NaN.  So leave it alone.
-        if (s.equals("infinity")
-            || s.equals("-infinity")
-            || s.equals("+infinity")) {
-          return null;
-        }
+    return null;
+  }
 
-        try {
-          return Double.parseDouble(s);
-        } catch (NumberFormatException e) {
-          return Double.NaN;
-        }
+  static Double getStringNumberValue(String rawJsString) {
+    if (rawJsString.contains("\u000b")) {
+      // vertical tab is not always whitespace
+      return null;
     }
 
-    return null;
+    String s = trimJsWhiteSpace(rawJsString);
+    // return ScriptRuntime.toNumber(s);
+    if (s.length() == 0) {
+      return 0.0;
+    }
+
+    if (s.length() > 2
+        && s.charAt(0) == '0'
+        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
+      // Attempt to convert hex numbers.
+      try {
+        return Double.valueOf(Integer.parseInt(s.substring(2), 16));
+      } catch (NumberFormatException e) {
+        return Double.NaN;
+      }
+    }
+
+    if (s.length() > 3
+        && (s.charAt(0) == '-' || s.charAt(0) == '+')
+        && s.charAt(1) == '0'
+        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
+      // hex numbers with explicit signs vary between browsers.
+      return null;
+    }
+
+    // Firefox and IE treat the "Infinity" differently. Firefox is case
+    // insensitive, but IE treats "infinity" as NaN.  So leave it alone.
+    if (s.equals("infinity")
+        || s.equals("-infinity")
+        || s.equals("+infinity")) {
+      return null;
+    }
+
+    try {
+      return Double.parseDouble(s);
+    } catch (NumberFormatException e) {
+      return Double.NaN;
+    }
   }
 
   static String trimJsWhiteSpace(String s) {
     int start = 0;
     int end = s.length();
-    while (end > 0 && isStrWhiteSpaceChar(s.charAt(end-1))) {
+    while (end > 0
+        && isStrWhiteSpaceChar(s.charAt(end - 1)) == TernaryValue.TRUE) {
       end--;
     }
-    while (start < end && isStrWhiteSpaceChar(s.charAt(start))) {
+    while (start < end
+        && isStrWhiteSpaceChar(s.charAt(start)) == TernaryValue.TRUE) {
       start++;
     }
     return s.substring(start, end);
@@ -289,21 +391,23 @@
   /**
    * Copied from Rhino's ScriptRuntime
    */
-  static boolean isStrWhiteSpaceChar(int c) {
+  public static TernaryValue isStrWhiteSpaceChar(int c) {
     switch (c) {
+      case '\u000B': // <VT>
+        return TernaryValue.UNKNOWN;  // IE says "no", ECMAScript says "yes"
       case ' ': // <SP>
       case '\n': // <LF>
       case '\r': // <CR>
       case '\t': // <TAB>
       case '\u00A0': // <NBSP>
       case '\u000C': // <FF>
-      case '\u000B': // <VT>
       case '\u2028': // <LS>
       case '\u2029': // <PS>
       case '\uFEFF': // <BOM>
-        return true;
+        return TernaryValue.TRUE;
       default:
-        return Character.getType(c) == Character.SPACE_SEPARATOR;
+        return (Character.getType(c) == Character.SPACE_SEPARATOR)
+            ? TernaryValue.TRUE : TernaryValue.FALSE;
     }
   }
 
@@ -323,13 +427,13 @@
    * @return the function's name, or {@code null} if it has no name
    */
   static String getFunctionName(Node n) {
+    Preconditions.checkState(n.isFunction());
     Node parent = n.getParent();
-    String name = n.getFirstChild().getString();
     switch (parent.getType()) {
       case Token.NAME:
         // var name = function() ...
         // var name2 = function name1() ...
-        return parent.getString();
+        return parent.getQualifiedName();
 
       case Token.ASSIGN:
         // qualified.name = function() ...
@@ -338,7 +442,8 @@
 
       default:
         // function name() ...
-        return name != null && name.length() != 0 ? name : null;
+        String name = n.getFirstChild().getQualifiedName();
+        return name;
     }
   }
 
@@ -357,7 +462,11 @@
    * @param n a node whose type is {@link Token#FUNCTION}
    * @return the function's name, or {@code null} if it has no name
    */
-  static String getNearestFunctionName(Node n) {
+  public static String getNearestFunctionName(Node n) {
+    if (!n.isFunction()) {
+      return null;
+    }
+
     String name = getFunctionName(n);
     if (name != null) {
       return name;
@@ -366,9 +475,9 @@
     // Check for the form { 'x' : function() { } }
     Node parent = n.getParent();
     switch (parent.getType()) {
-      case Token.SET:
-      case Token.GET:
-      case Token.STRING:
+      case Token.SETTER_DEF:
+      case Token.GETTER_DEF:
+      case Token.STRING_KEY:
         // Return the name of the literal's key.
         return parent.getString();
       case Token.NUMBER:
@@ -390,6 +499,8 @@
       case Token.TRUE:
       case Token.FALSE:
         return true;
+      case Token.NOT:
+        return isImmutableValue(n.getFirstChild());
       case Token.VOID:
       case Token.NEG:
         return isImmutableValue(n.getFirstChild());
@@ -406,6 +517,55 @@
   }
 
   /**
+   * Returns true if the operator on this node is symmetric
+   */
+  static boolean isSymmetricOperation(Node n) {
+    switch (n.getType()) {
+      case Token.EQ: // equal
+      case Token.NE: // not equal
+      case Token.SHEQ: // exactly equal
+      case Token.SHNE: // exactly not equal
+      case Token.MUL: // multiply, unlike add it only works on numbers
+                      // or results NaN if any of the operators is not a number
+        return true;
+    }
+    return false;
+  }
+
+  /**
+   * Returns true if the operator on this node is relational.
+   * the returned set does not include the equalities.
+   */
+  static boolean isRelationalOperation(Node n) {
+    switch (n.getType()) {
+      case Token.GT: // equal
+      case Token.GE: // not equal
+      case Token.LT: // exactly equal
+      case Token.LE: // exactly not equal
+        return true;
+    }
+    return false;
+  }
+
+  /**
+   * Returns the inverse of an operator if it is invertible.
+   * ex. '>' ==> '<'
+   */
+  static int getInverseOperator(int type) {
+    switch (type) {
+      case Token.GT:
+        return Token.LT;
+      case Token.LT:
+        return Token.GT;
+      case Token.GE:
+        return Token.LE;
+      case Token.LE:
+        return Token.GE;
+    }
+    return Token.ERROR;
+  }
+
+  /**
    * Returns true if this is a literal value. We define a literal value
    * as any node that evaluates to the same thing regardless of when or
    * where it is evaluated. So /xyz/ and [3, 5] are literals, but
@@ -418,7 +578,7 @@
    * </code>
    * If it is evaluated in a different scope, then it
    * captures a different variable. Even if the function did not read
-   * any captured vairables directly, it would still fail this definition,
+   * any captured variables directly, it would still fail this definition,
    * because it affects the lifecycle of variables in the enclosing scope.
    *
    * However, a function literal with respect to a particular scope is
@@ -430,6 +590,14 @@
   static boolean isLiteralValue(Node n, boolean includeFunctions) {
     switch (n.getType()) {
       case Token.ARRAYLIT:
+        for (Node child = n.getFirstChild(); child != null;
+             child = child.getNext()) {
+          if ((!child.isEmpty()) && !isLiteralValue(child, includeFunctions)) {
+            return false;
+          }
+        }
+        return true;
+
       case Token.REGEXP:
         // Return true only if all children are const.
         for (Node child = n.getFirstChild(); child != null;
@@ -496,7 +664,7 @@
         return isValidDefineValue(val.getFirstChild(), defines)
             && isValidDefineValue(val.getLastChild(), defines);
 
-      // Uniary operators are valid if the child is valid.
+      // Unary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
       case Token.POS:
@@ -518,12 +686,12 @@
    * @param block The node.
    */
   static boolean isEmptyBlock(Node block) {
-    if (block.getType() != Token.BLOCK) {
+    if (!block.isBlock()) {
       return false;
     }
 
     for (Node n = block.getFirstChild(); n != null; n = n.getNext()) {
-      if (n.getType() != Token.EMPTY) {
+      if (!n.isEmpty()) {
         return false;
       }
     }
@@ -583,10 +751,8 @@
    * @param child The expression itself.
    * @return Newly created EXPR node with the child as subexpression.
    */
-  public static Node newExpr(Node child) {
-    Node expr = new Node(Token.EXPR_RESULT, child)
-        .copyInformationFrom(child);
-    return expr;
+  static Node newExpr(Node child) {
+    return IR.exprResult(child).srcref(child);
   }
 
   /**
@@ -632,7 +798,7 @@
       case Token.HOOK:
       case Token.IF:
       case Token.IN:
-      case Token.LP:
+      case Token.PARAM_LIST:
       case Token.NUMBER:
       case Token.OR:
       case Token.THIS:
@@ -640,6 +806,7 @@
       case Token.FALSE:
       case Token.NULL:
       case Token.STRING:
+      case Token.STRING_KEY:
       case Token.SWITCH:
       case Token.TRY:
       case Token.EMPTY:
@@ -704,13 +871,13 @@
         return true;
 
       default:
-        if (isSimpleOperatorType(n.getType())) {
+        if (isSimpleOperator(n)) {
           break;
         }
 
         if (isAssignmentOp(n)) {
           Node assignTarget = n.getFirstChild();
-          if (isName(assignTarget)) {
+          if (assignTarget.isName()) {
             return true;
           }
 
@@ -768,7 +935,7 @@
   /**
    * Do calls to this constructor have side effects?
    *
-   * @param callNode - construtor call node
+   * @param callNode - constructor call node
    */
   static boolean constructorCallHasSideEffects(Node callNode) {
     return constructorCallHasSideEffects(callNode, null);
@@ -776,7 +943,7 @@
 
   static boolean constructorCallHasSideEffects(
       Node callNode, AbstractCompiler compiler) {
-    if (callNode.getType() != Token.NEW) {
+    if (!callNode.isNew()) {
       throw new IllegalStateException(
           "Expected NEW node, got " + Token.name(callNode.getType()));
     }
@@ -786,7 +953,7 @@
     }
 
     Node nameNode = callNode.getFirstChild();
-    if (nameNode.getType() == Token.NAME &&
+    if (nameNode.isName() &&
         CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(nameNode.getString())) {
       return false;
     }
@@ -825,7 +992,7 @@
    */
   static boolean functionCallHasSideEffects(
       Node callNode, @Nullable AbstractCompiler compiler) {
-    if (callNode.getType() != Token.CALL) {
+    if (!callNode.isCall()) {
       throw new IllegalStateException(
           "Expected CALL node, got " + Token.name(callNode.getType()));
     }
@@ -837,12 +1004,12 @@
     Node nameNode = callNode.getFirstChild();
 
     // Built-in functions with no side effects.
-    if (nameNode.getType() == Token.NAME) {
+    if (nameNode.isName()) {
       String name = nameNode.getString();
       if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
         return false;
       }
-    } else if (nameNode.getType() == Token.GETPROP) {
+    } else if (nameNode.isGetProp()) {
       if (callNode.hasOneChild()
           && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
                 nameNode.getLastChild().getString())) {
@@ -854,26 +1021,27 @@
         return false;
       }
 
-      // Functions in the "Math" namespace have no side effects.
-      if (nameNode.getFirstChild().getType() == Token.NAME) {
-        String namespaceName = nameNode.getFirstChild().getString();
-        if (namespaceName.equals("Math")) {
+      // Math.floor has no side-effects.
+      // TODO(nicksantos): This is a terrible terrible hack, until
+      // I create a definitionProvider that understands namespacing.
+      if (nameNode.getFirstChild().isName()) {
+        if ("Math.floor".equals(nameNode.getQualifiedName())) {
           return false;
         }
       }
 
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
-        if (nameNode.getFirstChild().getType() == Token.REGEXP
+        if (nameNode.getFirstChild().isRegExp()
             && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
           return false;
-        } else if (nameNode.getFirstChild().getType() == Token.STRING
+        } else if (nameNode.getFirstChild().isString()
             && STRING_REGEXP_METHODS.contains(
                 nameNode.getLastChild().getString())) {
           Node param = nameNode.getNext();
           if (param != null &&
-              (param.getType() == Token.STRING
-                  || param.getType() == Token.REGEXP))
-          return false;
+              (param.isString() || param.isRegExp())) {
+            return false;
+          }
         }
       }
     }
@@ -885,7 +1053,7 @@
    * @return Whether the call has a local result.
    */
   static boolean callHasLocalResult(Node n) {
-    Preconditions.checkState(n.getType() == Token.CALL);
+    Preconditions.checkState(n.isCall());
     return (n.getSideEffectFlags() & Node.FLAG_LOCAL_RESULTS) > 0;
   }
 
@@ -893,7 +1061,7 @@
    * @return Whether the new has a local result.
    */
   static boolean newHasLocalResult(Node n) {
-    Preconditions.checkState(n.getType() == Token.NEW);
+    Preconditions.checkState(n.isNew());
     return n.isOnlyModifiesThisCall();
   }
 
@@ -1047,36 +1215,48 @@
       case Token.POS:
       case Token.NEG:    return 13;
 
-      case Token.ARRAYLIT:
       case Token.CALL:
-      case Token.EMPTY:
-      case Token.FALSE:
-      case Token.FUNCTION:
       case Token.GETELEM:
       case Token.GETPROP:
-      case Token.GET_REF:
-      case Token.IF:
-      case Token.LP:
+      // Data values
+      case Token.ARRAYLIT:
+      case Token.EMPTY:  // TODO(johnlenz): remove this.
+      case Token.FALSE:
+      case Token.FUNCTION:
       case Token.NAME:
       case Token.NULL:
       case Token.NUMBER:
       case Token.OBJECTLIT:
       case Token.REGEXP:
-      case Token.RETURN:
       case Token.STRING:
+      case Token.STRING_KEY:
       case Token.THIS:
       case Token.TRUE:
         return 15;
 
       default: throw new Error("Unknown precedence for " +
-                               Node.tokenToName(type) +
+                               Token.name(type) +
                                " (type " + type + ")");
     }
   }
 
+  static boolean isUndefined(Node n) {
+    switch (n.getType()) {
+      case Token.VOID:
+        return true;
+      case Token.NAME:
+        return n.getString().equals("undefined");
+    }
+    return false;
+  }
+
+  static boolean isNullOrUndefined(Node n) {
+    return n.isNull() || isUndefined(n);
+  }
+
   /**
-   * Apply the supplied predicate against the potential
-   * all possible result of the expression.
+   * Apply the supplied predicate against
+   * all possible result Nodes of the expression.
    */
   static boolean valueCheck(Node n, Predicate<Node> p) {
     switch (n.getType()) {
@@ -1096,6 +1276,7 @@
   }
 
   static class NumbericResultPredicate implements Predicate<Node> {
+    @Override
     public boolean apply(Node n) {
       return isNumericResultHelper(n);
     }
@@ -1148,6 +1329,7 @@
   }
 
   static class BooleanResultPredicate implements Predicate<Node> {
+    @Override
     public boolean apply(Node n) {
       return isBooleanResultHelper(n);
     }
@@ -1164,8 +1346,6 @@
   }
 
   static boolean isBooleanResultHelper(Node n) {
-    // TODO(johnlenz): Add a recursive option to recurse into
-    // AND, OR, HOOK, COMMA and ASSIGN, like "getExpressionBooleanValue".
     switch (n.getType()) {
       // Primitives
       case Token.TRUE:
@@ -1179,32 +1359,23 @@
       case Token.GT:
       case Token.LE:
       case Token.GE:
-      // Queryies
+      // Queries
       case Token.IN:
       case Token.INSTANCEOF:
       // Inversion
       case Token.NOT:
+      // delete operator returns a boolean.
+      case Token.DELPROP:
         return true;
       default:
         return false;
     }
   }
 
-  static boolean isUndefined(Node n) {
-    switch (n.getType()) {
-      case Token.VOID:
-        return true;
-      case Token.NAME:
-        return n.getString().equals("undefined");
-    }
-    return false;
-  }
 
-  static boolean isNull(Node n) {
-    return n.getType() == Token.NULL;
-  }
 
   static class MayBeStringResultPredicate implements Predicate<Node> {
+    @Override
     public boolean apply(Node n) {
       return mayBeStringHelper(n);
     }
@@ -1230,7 +1401,7 @@
 
   static boolean mayBeStringHelper(Node n) {
     return !isNumericResult(n) && !isBooleanResult(n)
-        && !isUndefined(n) && !isNull(n);
+        && !isUndefined(n) && !n.isNull();
   }
 
   /**
@@ -1316,11 +1487,7 @@
       case Token.ASSIGN_MOD:
         return Token.MOD;
     }
-    throw new IllegalArgumentException("Not an assiment op");
-  }
-
-  static boolean isExpressionNode(Node n) {
-    return n.getType() == Token.EXPR_RESULT;
+    throw new IllegalArgumentException("Not an assignment op:" + n);
   }
 
   /**
@@ -1335,43 +1502,15 @@
    * Returns true if the shallow scope contains references to 'this' keyword
    */
   static boolean referencesThis(Node n) {
-    return containsType(n, Token.THIS, new MatchNotFunction());
+    Node start = (n.isFunction()) ? n.getLastChild() : n;
+    return containsType(start, Token.THIS, MATCH_NOT_FUNCTION);
   }
 
   /**
    * Is this a GETPROP or GETELEM node?
    */
   static boolean isGet(Node n) {
-    return n.getType() == Token.GETPROP
-        || n.getType() == Token.GETELEM;
-  }
-
-  /**
-   * Is this a GETPROP node?
-   */
-  static boolean isGetProp(Node n) {
-    return n.getType() == Token.GETPROP;
-  }
-
-  /**
-   * Is this a NAME node?
-   */
-  static boolean isName(Node n) {
-    return n.getType() == Token.NAME;
-  }
-
-  /**
-   * Is this a NEW node?
-   */
-  static boolean isNew(Node n) {
-    return n.getType() == Token.NEW;
-  }
-
-  /**
-   * Is this a VAR node?
-   */
-  static boolean isVar(Node n) {
-    return n.getType() == Token.VAR;
+    return n.isGetProp() || n.isGetElem();
   }
 
   /**
@@ -1383,7 +1522,7 @@
   static boolean isVarDeclaration(Node n) {
     // There is no need to verify that parent != null because a NAME node
     // always has a parent in a valid parse tree.
-    return n.getType() == Token.NAME && n.getParent().getType() == Token.VAR;
+    return n.isName() && n.getParent().isVar();
   }
 
   /**
@@ -1391,11 +1530,11 @@
    * @return The value node representing the new value.
    */
   static Node getAssignedValue(Node n) {
-    Preconditions.checkState(isName(n));
+    Preconditions.checkState(n.isName());
     Node parent = n.getParent();
-    if (isVar(parent)) {
+    if (parent.isVar()) {
       return n.getFirstChild();
-    } else if (isAssign(parent) && parent.getFirstChild() == n) {
+    } else if (parent.isAssign() && parent.getFirstChild() == n) {
       return n.getNext();
     } else {
       return null;
@@ -1403,13 +1542,6 @@
   }
 
   /**
-   * Is this a STRING node?
-   */
-  static boolean isString(Node n) {
-    return n.getType() == Token.STRING;
-  }
-
-  /**
    * Is this node an assignment expression statement?
    *
    * @param n The node
@@ -1417,15 +1549,8 @@
    *     first child is ASSIGN
    */
   static boolean isExprAssign(Node n) {
-    return n.getType() == Token.EXPR_RESULT
-        && n.getFirstChild().getType() == Token.ASSIGN;
-  }
-
-  /**
-   * Is this an ASSIGN node?
-   */
-  static boolean isAssign(Node n) {
-    return n.getType() == Token.ASSIGN;
+    return n.isExprResult()
+        && n.getFirstChild().isAssign();
   }
 
   /**
@@ -1436,15 +1561,15 @@
    *     first child is CALL
    */
   static boolean isExprCall(Node n) {
-    return n.getType() == Token.EXPR_RESULT
-        && n.getFirstChild().getType() == Token.CALL;
+    return n.isExprResult()
+        && n.getFirstChild().isCall();
   }
 
   /**
    * @return Whether the node represents a FOR-IN loop.
    */
   static boolean isForIn(Node n) {
-    return n.getType() == Token.FOR
+    return n.isFor()
         && n.getChildCount() == 3;
   }
 
@@ -1489,7 +1614,7 @@
         return true;
       }
 
-      if (NodeUtil.isFunction(parent)) {
+      if (parent.isFunction()) {
         break;
       }
     }
@@ -1511,7 +1636,7 @@
       case Token.CATCH:
       case Token.SWITCH:
       case Token.CASE:
-      case Token.DEFAULT:
+      case Token.DEFAULT_CASE:
         return true;
       default:
         return false;
@@ -1540,7 +1665,7 @@
       case Token.SWITCH:
       case Token.CASE:
         return parent.getFirstChild() != n;
-      case Token.DEFAULT:
+      case Token.DEFAULT_CASE:
         return true;
       default:
         Preconditions.checkState(isControlStructure(parent));
@@ -1578,14 +1703,17 @@
    * @return Whether the node is of a type that contain other statements.
    */
   static boolean isStatementBlock(Node n) {
-    return n.getType() == Token.SCRIPT || n.getType() == Token.BLOCK;
+    return n.isScript() || n.isBlock();
   }
 
   /**
    * @return Whether the node is used as a statement.
    */
   static boolean isStatement(Node n) {
-    Node parent = n.getParent();
+    return isStatementParent(n.getParent());
+  }
+
+  static boolean isStatementParent(Node parent) {
     // It is not possible to determine definitely if a node is a statement
     // or not if it is not part of the AST.  A FUNCTION node can be
     // either part of an expression or a statement.
@@ -1602,7 +1730,7 @@
 
   /** Whether the node is part of a switch statement. */
   static boolean isSwitchCase(Node n) {
-    return n.getType() == Token.CASE || n.getType() == Token.DEFAULT;
+    return n.isCase() || n.isDefaultCase();
   }
 
   /**
@@ -1610,24 +1738,19 @@
    *       function parameter (not a label or a empty function expression name).
    */
   static boolean isReferenceName(Node n) {
-    return isName(n) && !n.getString().isEmpty();
-  }
-
-  /** @return Whether the node is a label name. */
-  static boolean isLabelName(Node n) {
-    return (n != null && n.getType() == Token.LABEL_NAME);
+    return n.isName() && !n.getString().isEmpty();
   }
 
   /** Whether the child node is the FINALLY block of a try. */
   static boolean isTryFinallyNode(Node parent, Node child) {
-    return parent.getType() == Token.TRY && parent.getChildCount() == 3
+    return parent.isTry() && parent.getChildCount() == 3
         && child == parent.getLastChild();
   }
 
   /** Whether the node is a CATCH container BLOCK. */
   static boolean isTryCatchNodeContainer(Node n) {
     Node parent = n.getParent();
-    return parent.getType() == Token.TRY
+    return parent.isTry()
         && parent.getFirstChild().getNext() == n;
   }
 
@@ -1638,10 +1761,10 @@
         // A finally can only be removed if there is a catch.
         parent.removeChild(node);
       } else {
-        // Otherwise only its children can be removed.
+        // Otherwise, only its children can be removed.
         node.detachChildren();
       }
-    } else if (node.getType() == Token.CATCH) {
+    } else if (node.isCatch()) {
       // The CATCH can can only be removed if there is a finally clause.
       Node tryNode = node.getParent().getParent();
       Preconditions.checkState(NodeUtil.hasFinally(tryNode));
@@ -1652,7 +1775,7 @@
       Node tryNode = node.getParent();
       Preconditions.checkState(NodeUtil.hasFinally(tryNode));
       node.detachChildren();
-    } else if (node.getType() == Token.BLOCK) {
+    } else if (node.isBlock()) {
       // Simply empty the block.  This maintains source location and
       // "synthetic"-ness.
       node.detachChildren();
@@ -1660,7 +1783,7 @@
         || isSwitchCase(node)) {
       // A statement in a block can simply be removed.
       parent.removeChild(node);
-    } else if (parent.getType() == Token.VAR) {
+    } else if (parent.isVar()) {
       if (parent.hasMoreThanOneChild()) {
         parent.removeChild(node);
       } else {
@@ -1669,21 +1792,21 @@
         // This would leave an empty VAR, remove the VAR itself.
         removeChild(parent.getParent(), parent);
       }
-    } else if (parent.getType() == Token.LABEL
+    } else if (parent.isLabel()
         && node == parent.getLastChild()) {
       // Remove the node from the parent, so it can be reused.
       parent.removeChild(node);
       // A LABEL without children can not be referred to, remove it.
       removeChild(parent.getParent(), parent);
-    } else if (parent.getType() == Token.FOR
+    } else if (parent.isFor()
         && parent.getChildCount() == 4) {
       // Only Token.FOR can have an Token.EMPTY other control structure
       // need something for the condition. Others need to be replaced
       // or the structure removed.
-      parent.replaceChild(node, new Node(Token.EMPTY));
+      parent.replaceChild(node, IR.empty());
     } else {
       throw new IllegalStateException("Invalid attempt to remove node: " +
-          node.toString() + " of "+ parent.toString());
+          node.toString() + " of " + parent.toString());
     }
   }
 
@@ -1691,10 +1814,9 @@
    * Add a finally block if one does not exist.
    */
   static void maybeAddFinally(Node tryNode) {
-    Preconditions.checkState(tryNode.getType() == Token.TRY);
+    Preconditions.checkState(tryNode.isTry());
     if (!NodeUtil.hasFinally(tryNode)) {
-      tryNode.addChildrenToBack(new Node(Token.BLOCK)
-          .copyInformationFrom(tryNode));
+      tryNode.addChildrenToBack(IR.block().srcref(tryNode));
     }
   }
 
@@ -1703,7 +1825,7 @@
    * @return Whether the block was removed.
    */
   static boolean tryMergeBlock(Node block) {
-    Preconditions.checkState(block.getType() == Token.BLOCK);
+    Preconditions.checkState(block.isBlock());
     Node parent = block.getParent();
     // Try to remove the block if its parent is a block/script or if its
     // parent is label and it has exactly one child.
@@ -1722,56 +1844,28 @@
   }
 
   /**
-   * Is this a CALL node?
-   */
-  static boolean isCall(Node n) {
-    return n.getType() == Token.CALL;
-  }
-
-  /**
    * @param node A node
    * @return Whether the call is a NEW or CALL node.
    */
   static boolean isCallOrNew(Node node) {
-    return NodeUtil.isCall(node) || NodeUtil.isNew(node);
-  }
-
-  /**
-   * Is this a FUNCTION node?
-   */
-  static boolean isFunction(Node n) {
-    return n.getType() == Token.FUNCTION;
+    return node.isCall() || node.isNew();
   }
 
   /**
    * Return a BLOCK node for the given FUNCTION node.
    */
   static Node getFunctionBody(Node fn) {
-    Preconditions.checkArgument(isFunction(fn));
+    Preconditions.checkArgument(fn.isFunction());
     return fn.getLastChild();
   }
 
   /**
-   * Is this a THIS node?
-   */
-  static boolean isThis(Node node) {
-    return node.getType() == Token.THIS;
-  }
-
-  /**
-   * Is this node or any of its children a CALL?
-   */
-  static boolean containsCall(Node n) {
-    return containsType(n, Token.CALL);
-  }
-
-  /**
    * Is this node a function declaration? A function declaration is a function
    * that has a name that is added to the current scope (i.e. a function that
    * is not part of a expression; see {@link #isFunctionExpression}).
    */
   static boolean isFunctionDeclaration(Node n) {
-    return n.getType() == Token.FUNCTION && isStatement(n);
+    return n.isFunction() && isStatement(n);
   }
 
   /**
@@ -1781,8 +1875,8 @@
    */
   static boolean isHoistedFunctionDeclaration(Node n) {
     return isFunctionDeclaration(n)
-        && (n.getParent().getType() == Token.SCRIPT
-            || n.getParent().getParent().getType() == Token.FUNCTION);
+        && (n.getParent().isScript()
+            || n.getParent().getParent().isFunction());
   }
 
   /**
@@ -1809,7 +1903,16 @@
    * @return Whether n is an function used within an expression.
    */
   static boolean isFunctionExpression(Node n) {
-    return n.getType() == Token.FUNCTION && !isStatement(n);
+    return n.isFunction() && !isStatement(n);
+  }
+
+  /**
+   * Returns whether this is a bleeding function (an anonymous named function
+   * that bleeds into the inner scope).
+   */
+  static boolean isBleedingFunctionName(Node n) {
+    return n.isName() && !n.getString().isEmpty() &&
+        isFunctionExpression(n.getParent());
   }
 
   /**
@@ -1827,11 +1930,12 @@
    * looking for references to the "arguments" var_args object.
    */
   static boolean isVarArgsFunction(Node function) {
-    Preconditions.checkArgument(isFunction(function));
+    // TODO(johnlenz): rename this function
+    Preconditions.checkArgument(function.isFunction());
     return isNameReferenced(
         function.getLastChild(),
         "arguments",
-        new MatchNotFunction());
+        MATCH_NOT_FUNCTION);
   }
 
   /**
@@ -1840,11 +1944,11 @@
    *    a['f'](...)
    */
   static boolean isObjectCallMethod(Node callNode, String methodName) {
-    if (callNode.getType() == Token.CALL) {
+    if (callNode.isCall()) {
       Node functionIndentifyingExpression = callNode.getFirstChild();
       if (isGet(functionIndentifyingExpression)) {
         Node last = functionIndentifyingExpression.getLastChild();
-        if (last != null && last.getType() == Token.STRING) {
+        if (last != null && last.isString()) {
           String propName = last.getString();
           return (propName.equals(methodName));
         }
@@ -1873,34 +1977,6 @@
   }
 
   /**
-   * @return Whether the callNode represents an expression in the form of:
-   *    x.apply(...)
-   *    x['apply'](...)
-   *  or
-   *    x.call(...)
-   *    x['call'](...)
-   */
-  static boolean isFunctionObjectCallOrApply(Node callNode) {
-    return isFunctionObjectCall(callNode) || isFunctionObjectApply(callNode);
-  }
-
-  /**
-   * @return Whether the callNode represents an expression in the form of:
-   *    x.call(...)
-   *    x['call'](...)
-   * where x is a NAME node.
-   */
-  static boolean isSimpleFunctionObjectCall(Node callNode) {
-    if (isFunctionObjectCall(callNode)) {
-      if (callNode.getFirstChild().getFirstChild().getType() == Token.NAME) {
-        return true;
-      }
-    }
-
-    return false;
-  }
-
-  /**
    * Determines whether this node is strictly on the left hand side of an assign
    * or var initialization. Notably, this does not include all L-values, only
    * statements where the node is used only as an L-value.
@@ -1909,9 +1985,39 @@
    * @param parent Parent of the node
    * @return True if n is the left hand of an assign
    */
-  static boolean isLhs(Node n, Node parent) {
-    return (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) ||
-           parent.getType() == Token.VAR;
+  static boolean isVarOrSimpleAssignLhs(Node n, Node parent) {
+    return (parent.isAssign() && parent.getFirstChild() == n) ||
+           parent.isVar();
+  }
+
+  /**
+   * Determines whether this node is used as an L-value. Notice that sometimes
+   * names are used as both L-values and R-values.
+   *
+   * We treat "var x;" as a pseudo-L-value, which kind of makes sense if you
+   * treat it as "assignment to 'undefined' at the top of the scope". But if
+   * we're honest with ourselves, it doesn't make sense, and we only do this
+   * because it makes sense to treat this as syntactically similar to
+   * "var x = 0;".
+   *
+   * @param n The node
+   * @return True if n is an L-value.
+   */
+  public static boolean isLValue(Node n) {
+    Preconditions.checkArgument(n.isName() || n.isGetProp() ||
+        n.isGetElem());
+    Node parent = n.getParent();
+    if (parent == null) {
+      return false;
+    }
+    return (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)
+        || (NodeUtil.isForIn(parent) && parent.getFirstChild() == n)
+        || parent.isVar()
+        || (parent.isFunction() && parent.getFirstChild() == n)
+        || parent.isDec()
+        || parent.isInc()
+        || parent.isParamList()
+        || parent.isCatch();
   }
 
   /**
@@ -1923,11 +2029,9 @@
    */
   static boolean isObjectLitKey(Node node, Node parent) {
     switch (node.getType()) {
-      case Token.NUMBER:
-      case Token.STRING:
-        return parent.getType() == Token.OBJECTLIT;
-      case Token.GET:
-      case Token.SET:
+      case Token.STRING_KEY:
+      case Token.GETTER_DEF:
+      case Token.SETTER_DEF:
         return true;
     }
     return false;
@@ -1940,11 +2044,9 @@
    */
   static String getObjectLitKeyName(Node key) {
     switch (key.getType()) {
-      case Token.NUMBER:
-        return NodeUtil.getStringValue(key);
-      case Token.STRING:
-      case Token.GET:
-      case Token.SET:
+      case Token.STRING_KEY:
+      case Token.GETTER_DEF:
+      case Token.SETTER_DEF:
         return key.getString();
     }
     throw new IllegalStateException("Unexpected node type: " + key);
@@ -1957,19 +2059,19 @@
   static JSType getObjectLitKeyTypeFromValueType(Node key, JSType valueType) {
     if (valueType != null) {
       switch (key.getType()) {
-        case Token.GET:
+        case Token.GETTER_DEF:
           // GET must always return a function type.
           if (valueType.isFunctionType()) {
-            FunctionType fntype = ((FunctionType) valueType);
+            FunctionType fntype = valueType.toMaybeFunctionType();
             valueType = fntype.getReturnType();
           } else {
             return null;
           }
           break;
-        case Token.SET:
+        case Token.SETTER_DEF:
           if (valueType.isFunctionType()) {
             // SET must always return a function type.
-            FunctionType fntype = ((FunctionType) valueType);
+            FunctionType fntype = valueType.toMaybeFunctionType();
             Node param = fntype.getParametersNode().getFirstChild();
             // SET function must always have one parameter.
             valueType = param.getJSType();
@@ -1990,8 +2092,8 @@
    */
   static boolean isGetOrSetKey(Node node) {
     switch (node.getType()) {
-      case Token.GET:
-      case Token.SET:
+      case Token.GETTER_DEF:
+      case Token.SETTER_DEF:
         return true;
     }
     return false;
@@ -2099,11 +2201,10 @@
 
     Node parent = getAddingRoot(branch);
     for (Node nameNode : vars) {
-      Node var = new Node(
-          Token.VAR,
-          Node.newString(Token.NAME, nameNode.getString())
-              .copyInformationFrom(nameNode))
-          .copyInformationFrom(nameNode);
+      Node var = IR.var(
+          IR.name(nameNode.getString())
+              .srcref(nameNode))
+          .srcref(nameNode);
       copyNameAnnotations(nameNode, var.getFirstChild());
       parent.addChildToFront(var);
     }
@@ -2139,44 +2240,26 @@
     }
 
     // make sure that the adding root looks ok
-    Preconditions.checkState(addingRoot.getType() == Token.BLOCK ||
-        addingRoot.getType() == Token.SCRIPT);
+    Preconditions.checkState(addingRoot.isBlock() ||
+        addingRoot.isScript());
     Preconditions.checkState(addingRoot.getFirstChild() == null ||
-        addingRoot.getFirstChild().getType() != Token.SCRIPT);
+        !addingRoot.getFirstChild().isScript());
     return addingRoot;
   }
 
-  /** Creates function name(params_0, ..., params_n) { body }. */
-  public static Node newFunctionNode(String name, List<Node> params,
-      Node body, int lineno, int charno) {
-    Node parameterParen = new Node(Token.LP, lineno, charno);
-    for (Node param : params) {
-      parameterParen.addChildToBack(param);
-    }
-    Node function = new Node(Token.FUNCTION, lineno, charno);
-    function.addChildrenToBack(
-        Node.newString(Token.NAME, name, lineno, charno));
-    function.addChildToBack(parameterParen);
-    function.addChildToBack(body);
-    return function;
-  }
-
   /**
    * Creates a node representing a qualified name.
    *
    * @param name A qualified name (e.g. "foo" or "foo.bar.baz")
-   * @param lineno The source line offset.
-   * @param charno The source character offset from start of the line.
    * @return A NAME or GETPROP node
    */
   public static Node newQualifiedNameNode(
-      CodingConvention convention, String name, int lineno, int charno) {
+      CodingConvention convention, String name) {
     int endPos = name.indexOf('.');
     if (endPos == -1) {
-      return newName(convention, name, lineno, charno);
+      return newName(convention, name);
     }
-    Node node = newName(
-        convention, name.substring(0, endPos), lineno, charno);
+    Node node = newName(convention, name.substring(0, endPos));
     int startPos;
     do {
       startPos = endPos + 1;
@@ -2184,11 +2267,11 @@
       String part = (endPos == -1
                      ? name.substring(startPos)
                      : name.substring(startPos, endPos));
-      Node propNode = Node.newString(Token.STRING, part, lineno, charno);
+      Node propNode = IR.string(part);
       if (convention.isConstantKey(part)) {
         propNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
       }
-      node = new Node(Token.GETPROP, node, propNode, lineno, charno);
+      node = IR.getprop(node, propNode);
     } while (endPos != -1);
 
     return node;
@@ -2210,7 +2293,7 @@
   static Node newQualifiedNameNode(
       CodingConvention convention, String name, Node basisNode,
       String originalName) {
-    Node node = newQualifiedNameNode(convention, name, -1, -1);
+    Node node = newQualifiedNameNode(convention, name);
     setDebugInformation(node, basisNode, originalName);
     return node;
   }
@@ -2221,16 +2304,15 @@
   static Node getRootOfQualifiedName(Node qName) {
     for (Node current = qName; true;
          current = current.getFirstChild()) {
-      int type = current.getType();
-      if (type == Token.NAME || type == Token.THIS) {
+      if (current.isName() || current.isThis()) {
         return current;
       }
-      Preconditions.checkState(type == Token.GETPROP);
+      Preconditions.checkState(current.isGetProp());
     }
   }
 
   /**
-   * Sets the debug information (source file info and orignal name)
+   * Sets the debug information (source file info and original name)
    * on the given node.
    *
    * @param node The node on which to set the debug information.
@@ -2244,8 +2326,8 @@
   }
 
   private static Node newName(
-      CodingConvention convention, String name, int lineno, int charno) {
-    Node nameNode = Node.newString(Token.NAME, name, lineno, charno);
+      CodingConvention convention, String name) {
+    Node nameNode = IR.name(name);
     if (convention.isConstant(name)) {
       nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
     }
@@ -2257,19 +2339,13 @@
    * location information from the basis node.
    *
    * @param name The name for the new NAME node.
-   * @param basisNode The node that represents the name as currently found in
+   * @param srcref The node that represents the name as currently found in
    *     the AST.
    *
    * @return The node created.
    */
-  static Node newName(
-      CodingConvention convention, String name, Node basisNode) {
-    Node nameNode = Node.newString(Token.NAME, name);
-    if (convention.isConstantKey(name)) {
-      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
-    }
-    nameNode.copyInformationFrom(basisNode);
-    return nameNode;
+  static Node newName(CodingConvention convention, String name, Node srcref) {
+    return newName(convention, name).srcref(srcref);
   }
 
   /**
@@ -2306,9 +2382,7 @@
    *
    * @return True if all characters in the string are in Basic Latin set.
    */
-
   static boolean isLatin(String s) {
-    char LARGEST_BASIC_LATIN = 0x7f;
     int len = s.length();
     for (int index = 0; index < len; index++) {
       char c = s.charAt(index);
@@ -2320,28 +2394,54 @@
   }
 
   /**
-   * Determines whether the given name can appear on the right side of
-   * the dot operator. Many properties (like reserved words) cannot.
+   * Determines whether the given name is a valid variable name.
    */
-  static boolean isValidPropertyName(String name) {
+  static boolean isValidSimpleName(String name) {
     return TokenStream.isJSIdentifier(name) &&
         !TokenStream.isKeyword(name) &&
         // no Unicode escaped characters - some browsers are less tolerant
         // of Unicode characters that might be valid according to the
         // language spec.
-        // Note that by this point, unicode escapes have been converted
+        // Note that by this point, Unicode escapes have been converted
         // to UTF-16 characters, so we're only searching for character
         // values, not escapes.
         isLatin(name);
   }
 
+  /**
+   * Determines whether the given name is a valid qualified name.
+   */
+  // TODO(nicksantos): This should be moved into a "Language" API,
+  // so that the results are different for es5 and es3.
+  public static boolean isValidQualifiedName(String name) {
+    if (name.endsWith(".") || name.startsWith(".")) {
+      return false;
+    }
+    String[] parts = name.split("\\.");
+    for (String part : parts) {
+      if (!isValidSimpleName(part)) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  /**
+   * Determines whether the given name can appear on the right side of
+   * the dot operator. Many properties (like reserved words) cannot.
+   */
+  static boolean isValidPropertyName(String name) {
+    return isValidSimpleName(name);
+  }
+
   private static class VarCollector implements Visitor {
     final Map<String, Node> vars = Maps.newLinkedHashMap();
 
+    @Override
     public void visit(Node n) {
-      if (n.getType() == Token.NAME) {
+      if (n.isName()) {
         Node parent = n.getParent();
-        if (parent != null && parent.getType() == Token.VAR) {
+        if (parent != null && parent.isVar()) {
           String name = n.getString();
           if (!vars.containsKey(name)) {
             vars.put(name, n);
@@ -2354,12 +2454,12 @@
   /**
    * Retrieves vars declared in the current node tree, excluding descent scopes.
    */
-  public static Collection<Node> getVarsDeclaredInBranch(Node root) {
+  static Collection<Node> getVarsDeclaredInBranch(Node root) {
     VarCollector collector = new VarCollector();
     visitPreOrder(
         root,
         collector,
-        new MatchNotFunction());
+        MATCH_NOT_FUNCTION);
     return collector.vars.values();
   }
 
@@ -2374,6 +2474,9 @@
     return isPrototypeProperty(n.getFirstChild().getFirstChild());
   }
 
+  /**
+   * @return Whether the node represents a qualified prototype property.
+   */
   static boolean isPrototypeProperty(Node n) {
     String lhsString = n.getQualifiedName();
     if (lhsString == null) {
@@ -2388,7 +2491,7 @@
    */
   static Node getPrototypeClassName(Node qName) {
     Node cur = qName;
-    while (isGetProp(cur)) {
+    while (cur.isGetProp()) {
       if (cur.getLastChild().getString().equals("prototype")) {
         return cur.getFirstChild();
       } else {
@@ -2413,8 +2516,7 @@
    *   "void 0"
    */
   static Node newUndefinedNode(Node srcReferenceNode) {
-    // TODO(johnlenz): Why this instead of the more common "undefined"?
-    Node node = new Node(Token.VOID, Node.newNumber(0));
+    Node node = IR.voidNode(IR.number(0));
     if (srcReferenceNode != null) {
         node.copyInformationFromForTree(srcReferenceNode);
     }
@@ -2425,14 +2527,13 @@
    * Create a VAR node containing the given name and initial value expression.
    */
   static Node newVarNode(String name, Node value) {
-    Node nodeName = Node.newString(Token.NAME, name);
+    Node nodeName = IR.name(name);
     if (value != null) {
       Preconditions.checkState(value.getNext() == null);
       nodeName.addChildToBack(value);
-      nodeName.copyInformationFrom(value);
+      nodeName.srcref(value);
     }
-    Node var = new Node(Token.VAR, nodeName)
-        .copyInformationFrom(nodeName);
+    Node var = IR.var(nodeName).srcref(nodeName);
 
     return var;
   }
@@ -2447,9 +2548,9 @@
       this.name = name;
     }
 
+    @Override
     public boolean apply(Node n) {
-      return n.getType() == Token.NAME
-          && n.getString().equals(name);
+      return n.isName() && n.getString().equals(name);
     }
   }
 
@@ -2463,6 +2564,7 @@
       this.type = type;
     }
 
+    @Override
     public boolean apply(Node n) {
       return n.getType() == type;
     }
@@ -2473,28 +2575,33 @@
    * A predicate for matching var or function declarations.
    */
   static class MatchDeclaration implements Predicate<Node> {
+    @Override
     public boolean apply(Node n) {
-      return isFunctionDeclaration(n) || n.getType() == Token.VAR;
+      return isFunctionDeclaration(n) || n.isVar();
     }
   }
 
   /**
    * A predicate for matching anything except function nodes.
    */
-  static class MatchNotFunction implements Predicate<Node>{
+  private static class MatchNotFunction implements Predicate<Node>{
+    @Override
     public boolean apply(Node n) {
-      return !isFunction(n);
+      return !n.isFunction();
     }
   }
 
+  static final Predicate<Node> MATCH_NOT_FUNCTION = new MatchNotFunction();
+
   /**
    * A predicate for matching statements without exiting the current scope.
    */
   static class MatchShallowStatement implements Predicate<Node>{
+    @Override
     public boolean apply(Node n) {
       Node parent = n.getParent();
-      return n.getType() == Token.BLOCK
-          || (!isFunction(n) && (parent == null
+      return n.isBlock()
+          || (!n.isFunction() && (parent == null
               || isControlStructure(parent)
               || isStatementBlock(parent)));
     }
@@ -2585,42 +2692,42 @@
   }
 
   /**
-   * A pre-order traversal, calling Vistor.visit for each child matching
+   * A pre-order traversal, calling Visitor.visit for each child matching
    * the predicate.
    */
   static void visitPreOrder(Node node,
-                     Visitor vistor,
+                     Visitor visitor,
                      Predicate<Node> traverseChildrenPred) {
-    vistor.visit(node);
+    visitor.visit(node);
 
     if (traverseChildrenPred.apply(node)) {
       for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {
-        visitPreOrder(c, vistor, traverseChildrenPred);
+        visitPreOrder(c, visitor, traverseChildrenPred);
       }
     }
   }
 
   /**
-   * A post-order traversal, calling Vistor.visit for each child matching
+   * A post-order traversal, calling Visitor.visit for each child matching
    * the predicate.
    */
   static void visitPostOrder(Node node,
-                     Visitor vistor,
+                     Visitor visitor,
                      Predicate<Node> traverseChildrenPred) {
     if (traverseChildrenPred.apply(node)) {
       for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {
-        visitPostOrder(c, vistor, traverseChildrenPred);
+        visitPostOrder(c, visitor, traverseChildrenPred);
       }
     }
 
-    vistor.visit(node);
+    visitor.visit(node);
   }
 
   /**
    * @return Whether a TRY node has a finally block.
    */
   static boolean hasFinally(Node n) {
-    Preconditions.checkArgument(n.getType() == Token.TRY);
+    Preconditions.checkArgument(n.isTry());
     return n.getChildCount() == 3;
   }
 
@@ -2629,7 +2736,7 @@
    * of a TRY.
    */
   static Node getCatchBlock(Node n) {
-    Preconditions.checkArgument(n.getType() == Token.TRY);
+    Preconditions.checkArgument(n.isTry());
     return n.getFirstChild().getNext();
   }
 
@@ -2638,17 +2745,17 @@
    * @see NodeUtil#getCatchBlock
    */
   static boolean hasCatchHandler(Node n) {
-    Preconditions.checkArgument(n.getType() == Token.BLOCK);
-    return n.hasChildren() && n.getFirstChild().getType() == Token.CATCH;
+    Preconditions.checkArgument(n.isBlock());
+    return n.hasChildren() && n.getFirstChild().isCatch();
   }
 
   /**
     * @param fnNode The function.
     * @return The Node containing the Function parameters.
     */
-  static Node getFnParameters(Node fnNode) {
+  public static Node getFunctionParameters(Node fnNode) {
     // Function NODE: [ FUNCTION -> NAME, LP -> ARG1, ARG2, ... ]
-    Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION);
+    Preconditions.checkArgument(fnNode.isFunction());
     return fnNode.getFirstChild().getNext();
   }
 
@@ -2662,7 +2769,7 @@
    *     IS_CONSTANT_NAME property.
    * <li>The normalize pass renames any variable with the IS_CONSTANT_NAME
    *     annotation and that is initialized to a constant value with
-   *     a variable name inlucding $$constant.
+   *     a variable name including $$constant.
    * <li>Return true here if the variable includes $$constant in its name.
    * </ol>
    *
@@ -2677,7 +2784,7 @@
   static boolean isConstantByConvention(
       CodingConvention convention, Node node, Node parent) {
     String name = node.getString();
-    if (parent.getType() == Token.GETPROP &&
+    if (parent.isGetProp() &&
         node == parent.getLastChild()) {
       return convention.isConstantKey(name);
     } else if (isObjectLitKey(node, parent)) {
@@ -2688,38 +2795,18 @@
   }
 
   /**
-   * @param nameNode A name node
-   * @return The JSDocInfo for the name node
-   */
-  static JSDocInfo getInfoForNameNode(Node nameNode) {
-    JSDocInfo info = null;
-    Node parent = null;
-    if (nameNode != null) {
-      info = nameNode.getJSDocInfo();
-      parent = nameNode.getParent();
-    }
-
-    if (info == null && parent != null &&
-        ((parent.getType() == Token.VAR && parent.hasOneChild()) ||
-          parent.getType() == Token.FUNCTION)) {
-      info = parent.getJSDocInfo();
-    }
-    return info;
-  }
-
-  /**
    * Get the JSDocInfo for a function.
    */
-  static JSDocInfo getFunctionInfo(Node n) {
-    Preconditions.checkState(n.getType() == Token.FUNCTION);
+  public static JSDocInfo getFunctionJSDocInfo(Node n) {
+    Preconditions.checkState(n.isFunction());
     JSDocInfo fnInfo = n.getJSDocInfo();
     if (fnInfo == null && NodeUtil.isFunctionExpression(n)) {
       // Look for the info on other nodes.
       Node parent = n.getParent();
-      if (parent.getType() == Token.ASSIGN) {
+      if (parent.isAssign()) {
         // on ASSIGNs
         fnInfo = parent.getJSDocInfo();
-      } else if (parent.getType() == Token.NAME) {
+      } else if (parent.isName()) {
         // on var NAME = function() { ... };
         fnInfo = parent.getParent().getJSDocInfo();
       }
@@ -2731,21 +2818,46 @@
    * @param n The node.
    * @return The source name property on the node or its ancestors.
    */
-  static String getSourceName(Node n) {
+  public static String getSourceName(Node n) {
     String sourceName = null;
     while (sourceName == null && n != null) {
-      sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
+      sourceName = n.getSourceFileName();
+      n = n.getParent();
+    }
+    return sourceName;
+  }
+
+  /**
+   * @param n The node.
+   * @return The source name property on the node or its ancestors.
+   */
+  public static StaticSourceFile getSourceFile(Node n) {
+    StaticSourceFile sourceName = null;
+    while (sourceName == null && n != null) {
+      sourceName = n.getStaticSourceFile();
       n = n.getParent();
     }
     return sourceName;
   }
 
   /**
+   * @param n The node.
+   * @return The InputId property on the node or its ancestors.
+   */
+  public static InputId getInputId(Node n) {
+    while (n != null && !n.isScript()) {
+      n = n.getParent();
+    }
+
+    return (n != null && n.isScript()) ? n.getInputId() : null;
+  }
+
+  /**
    * A new CALL node with the "FREE_CALL" set based on call target.
    */
   static Node newCallNode(Node callTarget, Node... parameters) {
-    boolean isFreeCall = isName(callTarget);
-    Node call = new Node(Token.CALL, callTarget);
+    boolean isFreeCall = !isGet(callTarget);
+    Node call = IR.call(callTarget);
     call.putBooleanProp(Node.FREE_CALL, isFreeCall);
     for (Node parameter : parameters) {
       call.addChildToBack(parameter);
@@ -2812,6 +2924,7 @@
       case Token.OBJECTLIT:
         // Literals objects with non-literal children are allowed.
         return true;
+      case Token.DELPROP:
       case Token.IN:
         // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
         return true;
@@ -2850,7 +2963,7 @@
    * argument or null if no such parameter exists.
    */
   static Node getArgumentForFunction(Node function, int index) {
-    Preconditions.checkState(isFunction(function));
+    Preconditions.checkState(function.isFunction());
     return getNthSibling(
         function.getFirstChild().getNext().getFirstChild(), index);
   }
@@ -2869,8 +2982,227 @@
     Node getNode = call.getFirstChild();
     if (isGet(getNode)) {
       Node propNode = getNode.getLastChild();
-      return isString(propNode) && "toString".equals(propNode.getString());
+      return propNode.isString() && "toString".equals(propNode.getString());
     }
     return false;
   }
+
+  /** Find the best JSDoc for the given node. */
+  static JSDocInfo getBestJSDocInfo(Node n) {
+    JSDocInfo info = n.getJSDocInfo();
+    if (info == null) {
+      Node parent = n.getParent();
+      if (parent == null) {
+        return null;
+      }
+
+      if (parent.isName()) {
+        return getBestJSDocInfo(parent);
+      } else if (parent.isAssign()) {
+        return parent.getJSDocInfo();
+      } else if (isObjectLitKey(parent, parent.getParent())) {
+        return parent.getJSDocInfo();
+      } else if (parent.isFunction()) {
+        return parent.getJSDocInfo();
+      } else if (parent.isVar() && parent.hasOneChild()) {
+        return parent.getJSDocInfo();
+      } else if ((parent.isHook() && parent.getFirstChild() != n) ||
+                 parent.isOr() ||
+                 parent.isAnd() ||
+                 (parent.isComma() && parent.getFirstChild() != n)) {
+        return getBestJSDocInfo(parent);
+      }
+    }
+    return info;
+  }
+
+  /** Find the l-value that the given r-value is being assigned to. */
+  static Node getBestLValue(Node n) {
+    Node parent = n.getParent();
+    boolean isFunctionDeclaration = isFunctionDeclaration(n);
+    if (isFunctionDeclaration) {
+      return n.getFirstChild();
+    } else if (parent.isName()) {
+      return parent;
+    } else if (parent.isAssign()) {
+      return parent.getFirstChild();
+    } else if (isObjectLitKey(parent, parent.getParent())) {
+      return parent;
+    } else if (
+        (parent.isHook() && parent.getFirstChild() != n) ||
+        parent.isOr() ||
+        parent.isAnd() ||
+        (parent.isComma() && parent.getFirstChild() != n)) {
+      return getBestLValue(parent);
+    }
+    return null;
+  }
+
+  /** Gets the r-value of a node returned by getBestLValue. */
+  static Node getRValueOfLValue(Node n) {
+    Node parent = n.getParent();
+    switch (parent.getType()) {
+      case Token.ASSIGN:
+        return n.getNext();
+      case Token.VAR:
+        return n.getFirstChild();
+      case Token.FUNCTION:
+        return parent;
+    }
+    return null;
+  }
+
+  /** Get the owner of the given l-value node. */
+  static Node getBestLValueOwner(@Nullable Node lValue) {
+    if (lValue == null || lValue.getParent() == null) {
+      return null;
+    }
+    if (isObjectLitKey(lValue, lValue.getParent())) {
+      return getBestLValue(lValue.getParent());
+    } else if (isGet(lValue)) {
+      return lValue.getFirstChild();
+    }
+
+    return null;
+  }
+
+  /** Get the name of the given l-value node. */
+  static String getBestLValueName(@Nullable Node lValue) {
+    if (lValue == null || lValue.getParent() == null) {
+      return null;
+    }
+    if (isObjectLitKey(lValue, lValue.getParent())) {
+      Node owner = getBestLValue(lValue.getParent());
+      if (owner != null) {
+        String ownerName = getBestLValueName(owner);
+        if (ownerName != null) {
+          return ownerName + "." + getObjectLitKeyName(lValue);
+        }
+      }
+      return null;
+    }
+    return lValue.getQualifiedName();
+  }
+
+  /**
+   * @returns false iff the result of the expression is not consumed.
+   */
+  static boolean isExpressionResultUsed(Node expr) {
+    // TODO(johnlenz): consider sharing some code with trySimpleUnusedResult.
+    Node parent = expr.getParent();
+    switch (parent.getType()) {
+      case Token.BLOCK:
+      case Token.EXPR_RESULT:
+        return false;
+      case Token.HOOK:
+      case Token.AND:
+      case Token.OR:
+        return (expr == parent.getFirstChild())
+            ? true : isExpressionResultUsed(parent);
+      case Token.COMMA:
+        Node gramps = parent.getParent();
+        if (gramps.isCall() &&
+            parent == gramps.getFirstChild()) {
+          // Semantically, a direct call to eval is different from an indirect
+          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first
+          // expression to a comma to be a no-op if it's used to indirect
+          // an eval. This we pretend that this is "used".
+          if (expr == parent.getFirstChild() &&
+              parent.getChildCount() == 2 &&
+              expr.getNext().isName() &&
+              "eval".equals(expr.getNext().getString())) {
+            return true;
+          }
+        }
+
+        return (expr == parent.getFirstChild())
+            ? false : isExpressionResultUsed(parent);
+      case Token.FOR:
+        if (!NodeUtil.isForIn(parent)) {
+          // Only an expression whose result is in the condition part of the
+          // expression is used.
+          return (parent.getChildAtIndex(1) == expr);
+        }
+        break;
+    }
+    return true;
+  }
+
+  /**
+   * @param n The expression to check.
+   * @return Whether the expression is unconditionally executed only once in the
+   *     containing execution scope.
+   */
+  static boolean isExecutedExactlyOnce(Node n) {
+    inspect: do {
+      Node parent = n.getParent();
+      switch (parent.getType()) {
+        case Token.IF:
+        case Token.HOOK:
+        case Token.AND:
+        case Token.OR:
+          if (parent.getFirstChild() != n) {
+            return false;
+          }
+          // other ancestors may be conditional
+          continue inspect;
+        case Token.FOR:
+          if (NodeUtil.isForIn(parent)) {
+            if (parent.getChildAtIndex(1) != n) {
+              return false;
+            }
+          } else {
+            if (parent.getFirstChild() != n) {
+              return false;
+            }
+          }
+          // other ancestors may be conditional
+          continue inspect;
+        case Token.WHILE:
+        case Token.DO:
+          return false;
+        case Token.TRY:
+          // Consider all code under a try/catch to be conditionally executed.
+          if (!hasFinally(parent) || parent.getLastChild() != n) {
+            return false;
+          }
+          continue inspect;
+        case Token.CASE:
+        case Token.DEFAULT_CASE:
+          return false;
+        case Token.SCRIPT:
+        case Token.FUNCTION:
+          // Done, we've reached the scope root.
+          break inspect;
+      }
+    } while ((n = n.getParent()) != null);
+    return true;
+  }
+
+  /**
+   * @return An appropriate AST node for the boolean value.
+   */
+  static Node booleanNode(boolean value) {
+    return value ? IR.trueNode() : IR.falseNode();
+  }
+
+  /**
+   * @return An appropriate AST node for the double value.
+   */
+  static Node numberNode(double value, Node srcref) {
+    Node result;
+    if (Double.isNaN(value)) {
+      result = IR.name("NaN");
+    } else if (value == Double.POSITIVE_INFINITY) {
+      result = IR.name("Infinity");
+    } else if (value == Double.NEGATIVE_INFINITY) {
+      result = IR.neg(IR.name("Infinity"));
+    } else {
+      result = IR.number(value);
+    }
+    if (srcref != null) {
+      result.srcrefTree(srcref);
+    }
+    return result;
+  }
 }
diff -r -u inducing/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java buggy/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
--- inducing/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java	2023-06-12 11:40:17.135149457 +0800
+++ buggy/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java	2023-06-12 11:40:16.847163016 +0800
@@ -27,11 +27,14 @@
 import java.util.Set;
 
 /**
- * Tests for PeepholeFoldConstants in isolation. Tests for the interaction of
- * multiple peephole passes are in PeepholeIntegrationTest.
+ * Tests for {@link PeepholeFoldConstants} in isolation. Tests for
+ * the interaction of multiple peephole passes are in
+ * {@link PeepholeIntegrationTest}.
  */
 public class PeepholeFoldConstantsTest extends CompilerTestCase {
 
+  private boolean late;
+
   // TODO(user): Remove this when we no longer need to do string comparison.
   private PeepholeFoldConstantsTest(boolean compareAsTree) {
     super("", compareAsTree);
@@ -43,14 +46,14 @@
 
   @Override
   public void setUp() {
+    late = false;
     enableLineNumberCheck(true);
   }
 
   @Override
   public CompilerPass getProcessor(final Compiler compiler) {
     CompilerPass peepholePass = new PeepholeOptimizationsPass(compiler,
-          new PeepholeFoldConstants());
-
+          new PeepholeFoldConstants(late));
     return peepholePass;
   }
 
@@ -139,6 +142,36 @@
     fold("null === undefined", "false");
     fold("void 0 === undefined", "true");
 
+    fold("undefined == NaN", "false");
+    fold("NaN == undefined", "false");
+    fold("undefined == Infinity", "false");
+    fold("Infinity == undefined", "false");
+    fold("undefined == -Infinity", "false");
+    fold("-Infinity == undefined", "false");
+    fold("({}) == undefined", "false");
+    fold("undefined == ({})", "false");
+    fold("([]) == undefined", "false");
+    fold("undefined == ([])", "false");
+    fold("(/a/g) == undefined", "false");
+    fold("undefined == (/a/g)", "false");
+    fold("(function(){}) == undefined", "false");
+    fold("undefined == (function(){})", "false");
+
+    fold("undefined != NaN", "true");
+    fold("NaN != undefined", "true");
+    fold("undefined != Infinity", "true");
+    fold("Infinity != undefined", "true");
+    fold("undefined != -Infinity", "true");
+    fold("-Infinity != undefined", "true");
+    fold("({}) != undefined", "true");
+    fold("undefined != ({})", "true");
+    fold("([]) != undefined", "true");
+    fold("undefined != ([])", "true");
+    fold("(/a/g) != undefined", "true");
+    fold("undefined != (/a/g)", "true");
+    fold("(function(){}) != undefined", "true");
+    fold("undefined != (function(){})", "true");
+
     foldSame("this == undefined");
     foldSame("x == undefined");
   }
@@ -170,6 +203,104 @@
     fold("undefined === void 0", "true");
   }
 
+  public void testNullComparison1() {
+    fold("null == undefined", "true");
+    fold("null == null", "true");
+    fold("null == void 0", "true");
+
+    fold("null == 0", "false");
+    fold("null == 1", "false");
+    fold("null == 'hi'", "false");
+    fold("null == true", "false");
+    fold("null == false", "false");
+
+    fold("null === undefined", "false");
+    fold("null === null", "true");
+    fold("null === void 0", "false");
+
+    foldSame("null == this");
+    foldSame("null == x");
+
+    fold("null != undefined", "false");
+    fold("null != null", "false");
+    fold("null != void 0", "false");
+
+    fold("null != 0", "true");
+    fold("null != 1", "true");
+    fold("null != 'hi'", "true");
+    fold("null != true", "true");
+    fold("null != false", "true");
+
+    fold("null !== undefined", "true");
+    fold("null !== void 0", "true");
+    fold("null !== null", "false");
+
+    foldSame("null != this");
+    foldSame("null != x");
+
+    fold("null < null", "false");
+    fold("null > null", "false");
+    fold("null >= null", "true");
+    fold("null <= null", "true");
+
+    foldSame("0 < null"); // foldable
+    fold("true > null", "true");
+    foldSame("'hi' >= null"); // foldable
+    fold("null <= null", "true");
+
+    foldSame("null < 0");  // foldable
+    fold("null > true", "false");
+    foldSame("null >= 'hi'"); // foldable
+    fold("null <= null", "true");
+
+    fold("null == null", "true");
+    fold("0 == null", "false");
+    fold("1 == null", "false");
+    fold("'hi' == null", "false");
+    fold("true == null", "false");
+    fold("false == null", "false");
+    fold("null === null", "true");
+    fold("void 0 === null", "false");
+
+    fold("null == NaN", "false");
+    fold("NaN == null", "false");
+    fold("null == Infinity", "false");
+    fold("Infinity == null", "false");
+    fold("null == -Infinity", "false");
+    fold("-Infinity == null", "false");
+    fold("({}) == null", "false");
+    fold("null == ({})", "false");
+    fold("([]) == null", "false");
+    fold("null == ([])", "false");
+    fold("(/a/g) == null", "false");
+    fold("null == (/a/g)", "false");
+    fold("(function(){}) == null", "false");
+    fold("null == (function(){})", "false");
+
+    fold("null != NaN", "true");
+    fold("NaN != null", "true");
+    fold("null != Infinity", "true");
+    fold("Infinity != null", "true");
+    fold("null != -Infinity", "true");
+    fold("-Infinity != null", "true");
+    fold("({}) != null", "true");
+    fold("null != ({})", "true");
+    fold("([]) != null", "true");
+    fold("null != ([])", "true");
+    fold("(/a/g) != null", "true");
+    fold("null != (/a/g)", "true");
+    fold("(function(){}) != null", "true");
+    fold("null != (function(){})", "true");
+
+    foldSame("({a:f()}) == null");
+    foldSame("null == ({a:f()})");
+    foldSame("([f()]) == null");
+    foldSame("null == ([f()])");
+
+    foldSame("this == null");
+    foldSame("x == null");
+  }
+
   public void testUnaryOps() {
     // These cases are handled by PeepholeRemoveDeadCode.
     foldSame("!foo()");
@@ -181,7 +312,8 @@
     fold("a=!10", "a=false");
     fold("a=!false", "a=true");
     fold("a=!foo()", "a=!foo()");
-    fold("a=-0", "a=0");
+    fold("a=-0", "a=-0.0");
+    fold("a=-(0)", "a=-0.0");
     fold("a=-Infinity", "a=-Infinity");
     fold("a=-NaN", "a=NaN");
     fold("a=-foo()", "a=-foo()");
@@ -218,6 +350,8 @@
 
   public void testFoldLogicalOp() {
     fold("x = true && x", "x = x");
+    foldSame("x = [foo()] && x");
+
     fold("x = false && x", "x = false");
     fold("x = true || x", "x = true");
     fold("x = false || x", "x = x");
@@ -322,7 +456,8 @@
     fold("x = 12 | NaN", "x=12");
   }
 
-  public void testFoldingMixTypes() {
+  public void testFoldingMixTypesLate() {
+    late = true;
     fold("x = x + '2'", "x+='2'");
     fold("x = +x + +'2'", "x = +x + 2");
     fold("x = x - '2'", "x-=2");
@@ -339,6 +474,24 @@
     fold("x = y | ('x'?'1':'2')", "x=y|('x'?1:2)");
   }
 
+  public void testFoldingMixTypesEarly() {
+    late = false;
+    foldSame("x = x + '2'");
+    fold("x = +x + +'2'", "x = +x + 2");
+    fold("x = x - '2'", "x = x - 2");
+    fold("x = x ^ '2'", "x = x ^ 2");
+    fold("x = '2' ^ x", "x = 2 ^ x");
+    fold("x = '2' & x", "x = 2 & x");
+    fold("x = '2' | x", "x = 2 | x");
+
+    fold("x = '2' | y", "x=2|y");
+    fold("x = y | '2'", "x=y|2");
+    fold("x = y | (a && '2')", "x=y|(a&&2)");
+    fold("x = y | (a,'2')", "x=y|(a,2)");
+    fold("x = y | (a?'1':'2')", "x=y|(a?1:2)");
+    fold("x = y | ('x'?'1':'2')", "x=y|('x'?1:2)");
+  }
+
   public void testFoldingAdd() {
     fold("x = null + true", "x=1");
     foldSame("x = a + true");
@@ -421,7 +574,7 @@
     fold("x = foo() + 'a' + 2", "x = foo()+\"a2\"");
     fold("x = '' + null", "x = \"null\"");
     fold("x = true + '' + false", "x = \"truefalse\"");
-    fold("x = '' + []", "x = \"\"+[]");      // cannot fold (but nice if we can)
+    fold("x = '' + []", "x = ''");      // cannot fold (but nice if we can)
   }
 
   public void testFoldConstructor() {
@@ -429,126 +582,25 @@
     fold("x = ob[new String(12)]", "x = ob['12']");
     fold("x = ob[new String(false)]", "x = ob['false']");
     fold("x = ob[new String(null)]", "x = ob['null']");
+    fold("x = 'a' + new String('b')", "x = 'ab'");
+    fold("x = 'a' + new String(23)", "x = 'a23'");
+    fold("x = 2 + new String(1)", "x = '21'");
     foldSame("x = ob[new String(a)]");
     foldSame("x = new String('a')");
     foldSame("x = (new String('a'))[3]");
   }
 
-  public void testStringIndexOf() {
-    fold("x = 'abcdef'.indexOf('b')", "x = 1");
-    fold("x = 'abcdefbe'.indexOf('b', 2)", "x = 6");
-    fold("x = 'abcdef'.indexOf('bcd')", "x = 1");
-    fold("x = 'abcdefsdfasdfbcdassd'.indexOf('bcd', 4)", "x = 13");
-
-    fold("x = 'abcdef'.lastIndexOf('b')", "x = 1");
-    fold("x = 'abcdefbe'.lastIndexOf('b')", "x = 6");
-    fold("x = 'abcdefbe'.lastIndexOf('b', 5)", "x = 1");
-
-    // Both elements must be string. Dont do anything if either one is not
-    // string.
-    fold("x = 'abc1def'.indexOf(1)", "x = 3");
-    fold("x = 'abcNaNdef'.indexOf(NaN)", "x = 3");
-    fold("x = 'abcundefineddef'.indexOf(undefined)", "x = 3");
-    fold("x = 'abcnulldef'.indexOf(null)", "x = 3");
-    fold("x = 'abctruedef'.indexOf(true)", "x = 3");
-
-    // The following testcase fails with JSC_PARSE_ERROR. Hence omitted.
-    // foldSame("x = 1.indexOf('bcd');");
-    foldSame("x = NaN.indexOf('bcd')");
-    foldSame("x = undefined.indexOf('bcd')");
-    foldSame("x = null.indexOf('bcd')");
-    foldSame("x = true.indexOf('bcd')");
-    foldSame("x = false.indexOf('bcd')");
-
-    // Avoid dealing with regex or other types.
-    foldSame("x = 'abcdef'.indexOf(/b./)");
-    foldSame("x = 'abcdef'.indexOf({a:2})");
-    foldSame("x = 'abcdef'.indexOf([1,2])");
-  }
-
-  public void testStringJoinAdd() {
-    fold("x = ['a', 'b', 'c'].join('')", "x = \"abc\"");
-    fold("x = [].join(',')", "x = \"\"");
-    fold("x = ['a'].join(',')", "x = \"a\"");
-    fold("x = ['a', 'b', 'c'].join(',')", "x = \"a,b,c\"");
-    fold("x = ['a', foo, 'b', 'c'].join(',')",
-        "x = [\"a\",foo,\"b,c\"].join(\",\")");
-    fold("x = [foo, 'a', 'b', 'c'].join(',')",
-        "x = [foo,\"a,b,c\"].join(\",\")");
-    fold("x = ['a', 'b', 'c', foo].join(',')",
-        "x = [\"a,b,c\",foo].join(\",\")");
-
-    // Works with numbers
-    fold("x = ['a=', 5].join('')", "x = \"a=5\"");
-    fold("x = ['a', '5'].join(7)", "x = \"a75\"");
-
-    // Works on boolean
-    fold("x = ['a=', false].join('')", "x = \"a=false\"");
-    fold("x = ['a', '5'].join(true)", "x = \"atrue5\"");
-    fold("x = ['a', '5'].join(false)", "x = \"afalse5\"");
-
-    // Only optimize if it's a size win.
-    fold("x = ['a', '5', 'c'].join('a very very very long chain')",
-         "x = [\"a\",\"5\",\"c\"].join(\"a very very very long chain\")");
-
-    // TODO(user): Its possible to fold this better.
-    foldSame("x = ['', foo].join(',')");
-    foldSame("x = ['', foo, ''].join(',')");
-
-    fold("x = ['', '', foo, ''].join(',')", "x = [',', foo, ''].join(',')");
-    fold("x = ['', '', foo, '', ''].join(',')",
-         "x = [',', foo, ','].join(',')");
-
-    fold("x = ['', '', foo, '', '', bar].join(',')",
-         "x = [',', foo, ',', bar].join(',')");
-
-    fold("x = [1,2,3].join('abcdef')",
-         "x = '1abcdef2abcdef3'");
-  }
-
-  public void testStringJoinAdd_b1992789() {
-    fold("x = ['a'].join('')", "x = \"a\"");
-    fold("x = [foo()].join('')", "x = '' + foo()");
-    fold("[foo()].join('')", "'' + foo()");
-  }
-
-  public void testFoldStringSubstr() {
-    fold("x = 'abcde'.substr(0,2)", "x = 'ab'");
-    fold("x = 'abcde'.substr(1,2)", "x = 'bc'");
-    fold("x = 'abcde'['substr'](1,3)", "x = 'bcd'");
-    fold("x = 'abcde'.substr(2)", "x = 'cde'");
-
-    // we should be leaving negative indexes alone for now
-    foldSame("x = 'abcde'.substr(-1)");
-    foldSame("x = 'abcde'.substr(1, -2)");
-    foldSame("x = 'abcde'.substr(1, 2, 3)");
-    foldSame("x = 'a'.substr(0, 2)");
-  }
-
-  public void testFoldStringSubstring() {
-    fold("x = 'abcde'.substring(0,2)", "x = 'ab'");
-    fold("x = 'abcde'.substring(1,2)", "x = 'b'");
-    fold("x = 'abcde'['substring'](1,3)", "x = 'bc'");
-    fold("x = 'abcde'.substring(2)", "x = 'cde'");
-
-    // we should be leaving negative indexes alone for now
-    foldSame("x = 'abcde'.substring(-1)");
-    foldSame("x = 'abcde'.substring(1, -2)");
-    foldSame("x = 'abcde'.substring(1, 2, 3)");
-    foldSame("x = 'a'.substring(0, 2)");
-  }
-
   public void testFoldArithmetic() {
     fold("x = 10 + 20", "x = 30");
     fold("x = 2 / 4", "x = 0.5");
     fold("x = 2.25 * 3", "x = 6.75");
     fold("z = x * y", "z = x * y");
     fold("x = y * 5", "x = y * 5");
-    fold("x = 1 / 0", "", PeepholeFoldConstants.DIVIDE_BY_0_ERROR);
+    fold("x = 1 / 0", "x = 1 / 0");
     fold("x = 3 % 2", "x = 1");
     fold("x = 3 % -2", "x = 1");
     fold("x = -1 % 3", "x = -1");
-    fold("x = 1 % 0", "", PeepholeFoldConstants.DIVIDE_BY_0_ERROR);
+    fold("x = 1 % 0", "x = 1 % 0");
   }
 
   public void testFoldArithmetic2() {
@@ -603,7 +655,7 @@
     fold("x = -1 >= 9", "x = false");
 
     fold("x = true == true", "x = true");
-    fold("x = true == true", "x = true");
+    fold("x = false == false", "x = true");
     fold("x = false == null", "x = false");
     fold("x = false == true", "x = false");
     fold("x = true == null", "x = false");
@@ -653,7 +705,7 @@
     fold("x = y === y", "x = y===y");
 
     fold("x = true === true", "x = true");
-    fold("x = true === true", "x = true");
+    fold("x = false === false", "x = true");
     fold("x = false === null", "x = false");
     fold("x = false === true", "x = false");
     fold("x = true === null", "x = false");
@@ -683,7 +735,34 @@
     fold("true === null", "false");
   }
 
+  public void testFoldComparison3() {
+    fold("x = !1 == !0", "x = false");
+
+    fold("x = !0 == !0", "x = true");
+    fold("x = !1 == !1", "x = true");
+    fold("x = !1 == null", "x = false");
+    fold("x = !1 == !0", "x = false");
+    fold("x = !0 == null", "x = false");
+
+    fold("!0 == !0", "true");
+    fold("!1 == null", "false");
+    fold("!1 == !0", "false");
+    fold("!0 == null", "false");
+
+    fold("x = !0 === !0", "x = true");
+    fold("x = !1 === !1", "x = true");
+    fold("x = !1 === null", "x = false");
+    fold("x = !1 === !0", "x = false");
+    fold("x = !0 === null", "x = false");
+
+    fold("!0 === !0", "true");
+    fold("!1 === null", "false");
+    fold("!1 === !0", "false");
+    fold("!0 === null", "false");
+  }
+
   public void testFoldGetElem() {
+    fold("x = [,10][0]", "x = void 0");
     fold("x = [10, 20][0]", "x = 10");
     fold("x = [10, 20][1]", "x = 20");
     fold("x = [10, 20][0.5]", "",
@@ -692,6 +771,10 @@
         PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);
     fold("x = [10, 20][2]",     "",
         PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);
+
+    foldSame("x = [foo(), 0][1]");
+    fold("x = [0, foo()][1]", "x = foo()");
+    foldSame("x = [0, foo()][0]");
   }
 
   public void testFoldComplex() {
@@ -711,6 +794,9 @@
     fold("x = [1,2,3].length", "x = 3");
     fold("x = [a,b].length", "x = 2");
 
+    // Not handled yet
+    fold("x = [,,1].length", "x = 3");
+
     // Cannot fold
     fold("x = [foo(), 0].length", "x = [foo(),0].length");
     fold("x = y.length", "x = y.length");
@@ -721,7 +807,7 @@
     fold("x = ''.length", "x = 0");
     fold("x = '123'.length", "x = 3");
 
-    // Test unicode escapes are accounted for.
+    // Test Unicode escapes are accounted for.
     fold("x = '123\u01dc'.length", "x = 4");
   }
 
@@ -751,6 +837,8 @@
     fold("'' instanceof String", "false");
     fold("true instanceof Object", "false");
     fold("true instanceof Boolean", "false");
+    fold("!0 instanceof Object", "false");
+    fold("!0 instanceof Boolean", "false");
     fold("false instanceof Object", "false");
     fold("null instanceof Object", "false");
     fold("undefined instanceof Object", "false");
@@ -782,7 +870,8 @@
     fold("print(1/2)", "print(0.5)");
   }
 
-  public void testAssignOps() {
+  public void testAssignOpsLate() {
+    late = true;
     fold("x=x+y", "x+=y");
     foldSame("x=y+x");
     fold("x=x*y", "x*=y");
@@ -798,6 +887,29 @@
     fold("x=y*x", "x*=y");
     fold("x.y=x.y+z", "x.y+=z");
     foldSame("next().x = next().x + 1");
+    // This is OK, really.
+    fold("({a:1}).a = ({a:1}).a + 1", "({a:1}).a = 2");
+  }
+
+ public void testAssignOpsEarly() {
+    late = false;
+    foldSame("x=x+y");
+    foldSame("x=y+x");
+    foldSame("x=x*y");
+    foldSame("x=y*x");
+    foldSame("x.y=x.y+z");
+    foldSame("next().x = next().x + 1");
+
+    foldSame("x=x-y");
+    foldSame("x=y-x");
+    foldSame("x=x|y");
+    foldSame("x=y|x");
+    foldSame("x=x*y");
+    foldSame("x=y*x");
+    foldSame("x.y=x.y+z");
+    foldSame("next().x = next().x + 1");
+    // This is OK, really.
+    fold("({a:1}).a = ({a:1}).a + 1", "({a:1}).a = 2");
   }
 
   public void testFoldAdd1() {
@@ -902,6 +1014,121 @@
     fold("x/false", "x/0");  // should we add an error check? :)
   }
 
+  public void testNotFoldBackToTrueFalse() {
+    late = false;
+    fold("!0", "true");
+    fold("!1", "false");
+    fold("!3", "false");
+
+    late = true;
+    foldSame("!0");
+    foldSame("!1");
+    fold("!3", "false");
+    foldSame("false");
+    foldSame("true");
+  }
+
+  public void testFoldBangConstants() {
+    fold("1 + !0", "2");
+    fold("1 + !1", "1");
+    fold("'a ' + !1", "'a false'");
+    fold("'a ' + !0", "'a true'");
+  }
+
+  public void testFoldMixed() {
+    fold("''+[1]", "'1'");
+    foldSame("false+[]"); // would like: "\"false\""
+  }
+
+  public void testFoldVoid() {
+    foldSame("void 0");
+    fold("void 1", "void 0");
+    fold("void x", "void 0");
+    fold("void x()", "void x()");
+  }
+
+  public void testObjectLiteral() {
+    test("(!{})", "false");
+    test("(!{a:1})", "false");
+    testSame("(!{a:foo()})");
+    testSame("(!{'a':foo()})");
+  }
+
+  public void testArrayLiteral() {
+    test("(![])", "false");
+    test("(![1])", "false");
+    test("(![a])", "false");
+    testSame("(![foo()])");
+  }
+
+  public void testIssue601() {
+    testSame("'\\v' == 'v'");
+    testSame("'v' == '\\v'");
+    testSame("'\\u000B' == '\\v'");
+  }
+
+  public void testFoldObjectLiteralRef1() {
+    // Leave extra side-effects in place
+    testSame("var x = ({a:foo(),b:bar()}).a");
+    testSame("var x = ({a:1,b:bar()}).a");
+    testSame("function f() { return {b:foo(), a:2}.a; }");
+
+    // on the LHS the object act as a temporary leave it in place.
+    testSame("({a:x}).a = 1");
+    test("({a:x}).a += 1", "({a:x}).a = x + 1");
+    testSame("({a:x}).a ++");
+    testSame("({a:x}).a --");
+
+    // functions can't reference the object through 'this'.
+    testSame("({a:function(){return this}}).a");
+    testSame("({get a() {return this}}).a");
+    testSame("({set a(b) {return this}}).a");
+
+    // Leave unknown props alone, the might be on the prototype
+    testSame("({}).a");
+
+    // setters by themselves don't provide a definition
+    testSame("({}).a");
+    testSame("({set a(b) {}}).a");
+    // sets don't hide other definitions.
+    test("({a:1,set a(b) {}}).a", "1");
+
+    // get is transformed to a call (gets don't have self referential names)
+    test("({get a() {}}).a", "(function (){})()");
+    // sets don't hide other definitions.
+    test("({get a() {},set a(b) {}}).a", "(function (){})()");
+
+    // a function remains a function not a call.
+    test("var x = ({a:function(){return 1}}).a",
+         "var x = function(){return 1}");
+
+    test("var x = ({a:1}).a", "var x = 1");
+    test("var x = ({a:1, a:2}).a", "var x = 2");
+    test("var x = ({a:1, a:foo()}).a", "var x = foo()");
+    test("var x = ({a:foo()}).a", "var x = foo()");
+
+    test("function f() { return {a:1, b:2}.a; }",
+         "function f() { return 1; }");
+
+    // GETELEM is handled the same way.
+    test("var x = ({'a':1})['a']", "var x = 1");
+  }
+
+  public void testFoldObjectLiteralRef2() {
+    late = false;
+    test("({a:x}).a += 1", "({a:x}).a = x + 1");
+    late = true;
+    testSame("({a:x}).a += 1");
+  }
+
+  public void testIEString() {
+    testSame("!+'\\v1'");
+  }
+
+  public void testIssue522() {
+    testSame("[][1] = 1;");
+  }
+
   private static final List<String> LITERAL_OPERANDS =
       ImmutableList.of(
           "null",
@@ -909,6 +1136,8 @@
           "void 0",
           "true",
           "false",
+          "!0",
+          "!1",
           "0",
           "1",
           "''",
@@ -916,11 +1145,11 @@
           "'abc'",
           "'def'",
           "NaN",
-          "Infinity"
+          "Infinity",
           // TODO(nicksantos): Add more literals
-          //-Infinity
+          "-Infinity"
           //"({})",
-          //"[]",
+          // "[]"
           //"[0]",
           //"Object",
           //"(function() {})"
@@ -957,7 +1186,9 @@
             assertSameResults(join(a, op, b), "false");
             assertSameResults(join(a, inverse, b), "false");
           } else if (a.equals(b) && equalitors.contains(op)) {
-            if (a.equals("NaN") || a.equals("Infinity")) {
+            if (a.equals("NaN") ||
+                a.equals("Infinity") ||
+                a.equals("-Infinity")) {
               foldSame(join(a, op, b));
               foldSame(join(a, inverse, b));
             } else {
@@ -973,6 +1204,7 @@
   }
 
   public void testCommutativeOperators() {
+    late = true;
     List<String> operators =
         ImmutableList.of(
             "==",
@@ -1000,13 +1232,17 @@
     }
   }
 
+  public void testConvertToNumberNegativeInf() {
+    foldSame("var x = 3 * (r ? Infinity : -Infinity);");
+  }
+
   private String join(String operandA, String op, String operandB) {
     return operandA + " " + op + " " + operandB;
   }
 
   private void assertSameResultsOrUncollapsed(String exprA, String exprB) {
     String resultA = process(exprA);
-    String resultB = process(exprB);
+    String resultB = process(exprB);  // TODO: why is nothing done with this?
     if (resultA.equals(print(exprA))) {
       foldSame(exprA);
       foldSame(exprB);
@@ -1041,8 +1277,8 @@
     Compiler compiler = createCompiler();
     CompilerOptions options = getOptions();
     compiler.init(
-        new JSSourceFile[] {},
-        new JSSourceFile[] { JSSourceFile.fromCode("testcode", js) },
+        ImmutableList.<SourceFile>of(),
+        ImmutableList.of(SourceFile.fromCode("testcode", js)),
         options);
     Node root = compiler.parseInputs();
     assertTrue("Unexpected parse error(s): " +
