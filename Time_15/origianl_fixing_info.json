{
  "logger": {
    "currentLogLevel": 20,
    "name": "root.bean.benchmarks.Defects4JBug"
  },
  "d4jCmd": "/home/liumengjiao/Desktop/defects4j/framework/bin/defects4j",
  "dataDir": "/home/liumengjiao/Desktop/CI/Benchmark/data/changesInfo/",
  "properties": {
    "trigger.tests": "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
    "test.dir": "src/test/java",
    "clz.modified": "org.joda.time.field.FieldUtils",
    "src.dir": "src/main/java"
  },
  "timeoutSecond": 100,
  "proj": "Time",
  "id": "15",
  "workingDir": "../bugs/Time_15_buggy",
  "buggyCommit": "383354adc669c3fd8d9e6fe3a25403df993e11e7",
  "inducingCommit": "f574d59dd322be0df10694c296bbdff9a7a2fba2",
  "originalCommit": "6f5522f58c1d2abdec37b5d22e5981716d4ec731",
  "bug_name": "Time_15",
  "derive": "defects4j",
  "original_fixing_commit": "0cefc4c212e92e5dccdfa658785c419483317558",
  "buildFiles_changed": true,
  "regression": true,
  "inducing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "JodaTime/src/java/org/joda/time/DateTimeZone.java",
        "JodaTime/src/java/org/joda/time/DateTimeZone.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "org.joda.time.DateTimeZone:getShortName:[long instant, Locale locale]:String",
            "org.joda.time.DateTimeZone:getConvertedId:[String id]:String",
            "org.joda.time.DateTimeZone:forOffsetMillis:[int millisOffset]:DateTimeZone",
            "org.joda.time.DateTimeZone:forID:[String id]:DateTimeZone",
            "org.joda.time.DateTimeZone:getNameKey:[long instant]:String",
            "org.joda.time.DateTimeZone:getProvider:[]:Provider",
            "org.joda.time.DateTimeZone:parseOffset:[String str]:int",
            "org.joda.time.DateTimeZone:setProvider0:[Provider provider]:void",
            "org.joda.time.DateTimeZone:getNameProvider:[]:NameProvider",
            "org.joda.time.DateTimeZone:forOffsetHoursMinutes:[int hoursOffset, int minutesOffset]:DateTimeZone",
            "org.joda.time.DateTimeZone:forOffsetHours:[int hoursOffset]:DateTimeZone",
            "org.joda.time.DateTimeZone:fixedOffsetZone:[String id, int offset]:DateTimeZone",
            "org.joda.time.DateTimeZone:getDefaultProvider:[]:Provider",
            "org.joda.time.DateTimeZone:getDefault:[]:DateTimeZone",
            "org.joda.time.DateTimeZone:offsetFormatter:[]:DateTimeFormatter",
            "org.joda.time.DateTimeZone:setDefault:[DateTimeZone zone]:void",
            "org.joda.time.DateTimeZone:setNameProvider:[NameProvider nameProvider]:void",
            "org.joda.time.DateTimeZone:forTimeZone:[TimeZone zone]:DateTimeZone",
            "org.joda.time.DateTimeZone:getShortName:[long instant]:String",
            "org.joda.time.DateTimeZone:getAvailableIDs:[]:Set",
            "org.joda.time.DateTimeZone:getDefaultNameProvider:[]:NameProvider",
            "org.joda.time.DateTimeZone:printOffset:[int offset]:String"
          ],
          "num": 22
        },
        {
          "qualified_names": [
            "org.joda.time.DateTimeZone:getProvider:[]:Provider",
            "org.joda.time.DateTimeZone:getMillisKeepLocal:[DateTimeZone newZone, long oldInstant]:long",
            "org.joda.time.DateTimeZone:writeReplace:[]:Object",
            "org.joda.time.DateTimeZone:fixedOffsetZone:[String id, int offset]:DateTimeZone",
            "org.joda.time.DateTimeZone:getDefaultProvider:[]:Provider",
            "org.joda.time.DateTimeZone\\$Stub:Stub:[String id]:null",
            "org.joda.time.DateTimeZone:forTimeZone:[TimeZone zone]:DateTimeZone",
            "org.joda.time.DateTimeZone:getName:[long instant]:String",
            "org.joda.time.DateTimeZone:getDefaultNameProvider:[]:NameProvider",
            "org.joda.time.DateTimeZone:printOffset:[int offset]:String",
            "org.joda.time.DateTimeZone:getShortName:[long instant, Locale locale]:String",
            "org.joda.time.DateTimeZone:getName:[long instant, Locale locale]:String",
            "org.joda.time.DateTimeZone:forID:[String id]:DateTimeZone",
            "org.joda.time.DateTimeZone:setNameProvider:[NameProvider nameProvider]:void",
            "org.joda.time.DateTimeZone:forOffsetHours:[int hoursOffset]:DateTimeZone",
            "org.joda.time.DateTimeZone:setDefault:[DateTimeZone zone]:void",
            "org.joda.time.DateTimeZone:getConvertedId:[String id]:String",
            "org.joda.time.DateTimeZone:getStandardOffset:[long instant]:int",
            "org.joda.time.DateTimeZone:getNameKey:[long instant]:String",
            "org.joda.time.DateTimeZone:getShortName:[long instant]:String",
            "org.joda.time.DateTimeZone:getNameProvider:[]:NameProvider",
            "org.joda.time.DateTimeZone:setProvider0:[Provider provider]:void",
            "org.joda.time.DateTimeZone:isFixed:[]:boolean",
            "org.joda.time.DateTimeZone:getOffset:[ReadableInstant instant]:int",
            "org.joda.time.DateTimeZone:forOffsetHoursMinutes:[int hoursOffset, int minutesOffset]:DateTimeZone",
            "org.joda.time.DateTimeZone:previousTransition:[long instant]:long",
            "org.joda.time.DateTimeZone:parseOffset:[String str]:int",
            "org.joda.time.DateTimeZone:getOffsetFromLocal:[long instantLocal]:int",
            "org.joda.time.DateTimeZone:nextTransition:[long instant]:long",
            "org.joda.time.DateTimeZone:getOffset:[long instant]:int",
            "org.joda.time.DateTimeZone\\$Stub:readResolve:[]:Object",
            "org.joda.time.DateTimeZone:DateTimeZone:[String id]:null",
            "org.joda.time.DateTimeZone:toString:[]:String",
            "org.joda.time.DateTimeZone:offsetFormatter:[]:DateTimeFormatter",
            "org.joda.time.DateTimeZone:forOffsetMillis:[int millisOffset]:DateTimeZone",
            "org.joda.time.DateTimeZone:setNameProvider0:[NameProvider nameProvider]:void",
            "org.joda.time.DateTimeZone:setProvider:[Provider provider]:void"
          ],
          "num": 37
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "2",
            "5",
            "6",
            "8",
            "9",
            "10",
            "11",
            "12",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "27",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "37",
            "38",
            "39",
            "40",
            "41",
            "42",
            "43",
            "44",
            "45",
            "46",
            "47",
            "48",
            "49",
            "50",
            "51",
            "52",
            "68",
            "88",
            "89",
            "90",
            "121",
            "129",
            "131",
            "134",
            "135",
            "136",
            "145",
            "146",
            "149",
            "151",
            "158",
            "177",
            "186",
            "188",
            "189",
            "190",
            "191",
            "196",
            "198",
            "200",
            "202",
            "207",
            "212",
            "213",
            "214",
            "215",
            "221",
            "228",
            "230",
            "232",
            "234",
            "241",
            "244",
            "245",
            "256",
            "257",
            "258",
            "259",
            "267",
            "268",
            "269",
            "270",
            "271",
            "273",
            "274",
            "276",
            "277",
            "278",
            "279",
            "280",
            "281",
            "282",
            "285",
            "287",
            "303",
            "308",
            "314",
            "328",
            "340",
            "345",
            "351",
            "359",
            "399",
            "404",
            "411",
            "412",
            "413",
            "414",
            "415",
            "416",
            "417",
            "418",
            "419",
            "420",
            "421",
            "422",
            "423",
            "424",
            "425",
            "426",
            "427",
            "428",
            "429",
            "430",
            "431",
            "432",
            "433",
            "434",
            "435",
            "436",
            "437",
            "438",
            "439",
            "440",
            "441",
            "442",
            "443",
            "444",
            "445",
            "446",
            "447",
            "448",
            "449",
            "450",
            "451",
            "452",
            "453",
            "454",
            "455",
            "456",
            "457",
            "458",
            "459",
            "460",
            "461",
            "462",
            "463",
            "464",
            "465",
            "466",
            "467",
            "468",
            "469",
            "475",
            "498",
            "510",
            "524",
            "539",
            "549",
            "563",
            "578",
            "584",
            "592",
            "594",
            "598",
            "607",
            "625",
            "627",
            "641",
            "642",
            "645",
            "651",
            "652",
            "655",
            "690",
            "699",
            "709",
            "710",
            "725",
            "726"
          ],
          "num": 202
        },
        {
          "qualified_names": [
            "2",
            "4",
            "5",
            "6",
            "8",
            "10",
            "11",
            "12",
            "13",
            "14",
            "23",
            "24",
            "29",
            "31",
            "32",
            "33",
            "36",
            "56",
            "57",
            "58",
            "89",
            "90",
            "95",
            "97",
            "99",
            "101",
            "103",
            "106",
            "107",
            "108",
            "109",
            "118",
            "119",
            "120",
            "123",
            "125",
            "126",
            "134",
            "149",
            "154",
            "162",
            "164",
            "166",
            "167",
            "168",
            "169",
            "174",
            "176",
            "178",
            "180",
            "185",
            "190",
            "191",
            "192",
            "193",
            "194",
            "195",
            "196",
            "202",
            "203",
            "204",
            "205",
            "206",
            "207",
            "208",
            "209",
            "210",
            "211",
            "212",
            "213",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "220",
            "221",
            "222",
            "223",
            "224",
            "225",
            "226",
            "227",
            "228",
            "229",
            "230",
            "231",
            "232",
            "233",
            "234",
            "235",
            "236",
            "237",
            "238",
            "239",
            "240",
            "241",
            "242",
            "243",
            "244",
            "245",
            "246",
            "247",
            "248",
            "249",
            "250",
            "251",
            "252",
            "253",
            "254",
            "255",
            "256",
            "257",
            "258",
            "259",
            "260",
            "261",
            "262",
            "269",
            "271",
            "273",
            "275",
            "283",
            "285",
            "286",
            "287",
            "288",
            "289",
            "300",
            "301",
            "302",
            "303",
            "304",
            "305",
            "306",
            "313",
            "315",
            "317",
            "318",
            "319",
            "321",
            "322",
            "323",
            "324",
            "325",
            "326",
            "327",
            "328",
            "329",
            "330",
            "331",
            "332",
            "333",
            "336",
            "337",
            "338",
            "350",
            "351",
            "352",
            "353",
            "354",
            "355",
            "356",
            "357",
            "358",
            "364",
            "365",
            "366",
            "367",
            "368",
            "369",
            "370",
            "371",
            "376",
            "382",
            "383",
            "384",
            "385",
            "399",
            "406",
            "407",
            "408",
            "409",
            "410",
            "411",
            "412",
            "413",
            "414",
            "415",
            "416",
            "417",
            "418",
            "419",
            "420",
            "421",
            "422",
            "423",
            "424",
            "425",
            "426",
            "427",
            "428",
            "429",
            "430",
            "431",
            "432",
            "433",
            "434",
            "435",
            "436",
            "437",
            "438",
            "439",
            "440",
            "441",
            "442",
            "443",
            "444",
            "445",
            "446",
            "447",
            "448",
            "449",
            "450",
            "451",
            "452",
            "453",
            "454",
            "455",
            "456",
            "457",
            "463",
            "464",
            "465",
            "466",
            "467",
            "468",
            "469",
            "470",
            "475",
            "481",
            "482",
            "483",
            "484",
            "493",
            "494",
            "495",
            "496",
            "497",
            "498",
            "499",
            "500",
            "501",
            "502",
            "503",
            "504",
            "505",
            "506",
            "507",
            "508",
            "509",
            "510",
            "511",
            "512",
            "513",
            "514",
            "515",
            "516",
            "517",
            "518",
            "519",
            "520",
            "521",
            "522",
            "523",
            "524",
            "525",
            "526",
            "527",
            "528",
            "529",
            "530",
            "570",
            "573",
            "574",
            "575",
            "576",
            "577",
            "578",
            "579",
            "580",
            "581",
            "582",
            "583",
            "584",
            "585",
            "586",
            "587",
            "588",
            "589",
            "590",
            "591",
            "592",
            "593",
            "594",
            "595",
            "596",
            "597",
            "598",
            "599",
            "600",
            "601",
            "602",
            "603",
            "604",
            "605",
            "606",
            "607",
            "608",
            "609",
            "610",
            "611",
            "612",
            "613",
            "614",
            "615",
            "616",
            "617",
            "618",
            "619",
            "620",
            "621",
            "622",
            "623",
            "624",
            "625",
            "626",
            "627",
            "628",
            "629",
            "630",
            "631",
            "632",
            "633",
            "634",
            "635",
            "636",
            "637",
            "638",
            "639",
            "640",
            "641",
            "642",
            "643",
            "644",
            "645",
            "646",
            "649",
            "661",
            "662",
            "663",
            "664",
            "665",
            "666",
            "667",
            "690",
            "702",
            "716",
            "717",
            "732",
            "742",
            "756",
            "757",
            "772",
            "778",
            "786",
            "791",
            "800",
            "818",
            "820",
            "827",
            "828",
            "829",
            "830",
            "831",
            "832",
            "833",
            "834",
            "835",
            "836",
            "837",
            "838",
            "839",
            "840",
            "841",
            "842",
            "843",
            "844",
            "852",
            "853",
            "856",
            "862",
            "863",
            "866",
            "902",
            "912",
            "922",
            "923",
            "924",
            "927",
            "928",
            "929",
            "930",
            "943",
            "944"
          ],
          "num": 416
        }
      ],
      "diff": "diff --git a/JodaTime/src/java/org/joda/time/DateTimeZone.java b/JodaTime/src/java/org/joda/time/DateTimeZone.java\nindex ed21bef..f996f10 100644\n--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java\n@@ -1,55 +1,17 @@\n /*\n- * Joda Software License, Version 1.0\n+ *  Copyright 2001-2005 Stephen Colebourne\n  *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n  *\n- * Copyright (c) 2001-2004 Stephen Colebourne.  \n- * All rights reserved.\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n  *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer. \n- *\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in\n- *    the documentation and/or other materials provided with the\n- *    distribution.\n- *\n- * 3. The end-user documentation included with the redistribution,\n- *    if any, must include the following acknowledgment:  \n- *       \"This product includes software developed by the\n- *        Joda project (http://www.joda.org/).\"\n- *    Alternately, this acknowledgment may appear in the software itself,\n- *    if and wherever such third-party acknowledgments normally appear.\n- *\n- * 4. The name \"Joda\" must not be used to endorse or promote products\n- *    derived from this software without prior written permission. For\n- *    written permission, please contact licence@joda.org.\n- *\n- * 5. Products derived from this software may not be called \"Joda\",\n- *    nor may \"Joda\" appear in their name, without prior written\n- *    permission of the Joda project.\n- *\n- * THIS SOFTWARE IS PROVIDED ``AS IS\u0027\u0027 AND ANY EXPRESSED OR IMPLIED\n- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- * \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n- *\n- * This software consists of voluntary contributions made by many\n- * individuals on behalf of the Joda project and was originally \n- * created by Stephen Colebourne \u003cscolebourne@joda.org\u003e. For more\n- * information on the Joda project, please see \u003chttp://www.joda.org/\u003e.\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n  */\n package org.joda.time;\n \n@@ -58,14 +20,20 @@\n import java.io.ObjectOutputStream;\n import java.io.ObjectStreamException;\n import java.io.Serializable;\n+import java.lang.ref.Reference;\n+import java.lang.ref.SoftReference;\n import java.util.HashMap;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n+import java.util.TimeZone;\n \n+import org.joda.time.chrono.BaseChronology;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.FieldUtils;\n import org.joda.time.format.DateTimeFormatter;\n import org.joda.time.format.DateTimeFormatterBuilder;\n-import org.joda.time.tz.DateTimeZonePermission;\n+import org.joda.time.format.FormatUtils;\n import org.joda.time.tz.DefaultNameProvider;\n import org.joda.time.tz.FixedDateTimeZone;\n import org.joda.time.tz.NameProvider;\n@@ -85,9 +53,9 @@\n  * Time (GMT).  This is similar, but not precisely identical, to Universal \n  * Coordinated Time, or UTC. This library only uses the term UTC.\n  * \u003cp\u003e\n- * Using this system, Pacific Time, USA is expressed as UTC-08:00, or UTC-07:00\n- * in the summer. The offset -08:00 indicates that Pacific Time is obtained \n- * from UTC by adding -08:00, that is, by subtracting 8 hours.\n+ * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n+ * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n+ * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n  * \u003cp\u003e\n  * The offset differs in the summer because of daylight saving time, or DST.\n  * The folowing definitions of time are generally used:\n@@ -118,22 +86,27 @@\n  */\n public abstract class DateTimeZone implements Serializable {\n     \n-    static final long serialVersionUID \u003d 5546345482340108586L;\n+    /** Serialization version. */\n+    private static final long serialVersionUID \u003d 5546345482340108586L;\n \n     /** The time zone for Universal Coordinated Time */\n     public static final DateTimeZone UTC \u003d new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n \n+    /** The instance that is providing time zones. */\n     private static Provider cProvider;\n+    /** The instance that is providing time zone names. */\n     private static NameProvider cNameProvider;\n+    /** The set of ID strings. */\n     private static Set cAvailableIDs;\n-\n+    /** The default time zone. */\n     private static DateTimeZone cDefault;\n-\n+    /** A formatter for printing and parsing zones. */\n     private static DateTimeFormatter cOffsetFormatter;\n \n-    /**\n-     * Cache of old zone IDs to new zone IDs\n-     */\n+    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n+    private static Map iFixedOffsetCache;\n+\n+    /** Cache of old zone IDs to new zone IDs */\n     private static Map cZoneIdConversion;\n \n     static {\n@@ -142,13 +115,15 @@\n \n         try {\n             try {\n-                cDefault \u003d getInstance(System.getProperty(\"user.timezone\"));\n-            } catch (RuntimeException ignored) {\n+                cDefault \u003d forID(System.getProperty(\"user.timezone\"));\n+            } catch (RuntimeException ex) {\n+                // ignored\n             }\n             if (cDefault \u003d\u003d null) {\n-                cDefault \u003d getInstance(java.util.TimeZone.getDefault());\n+                cDefault \u003d forTimeZone(TimeZone.getDefault());\n             }\n-        } catch (IllegalArgumentException ignored) {\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n         }\n \n         if (cDefault \u003d\u003d null) {\n@@ -156,6 +131,7 @@\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Gets the default time zone.\n      * \n@@ -170,11 +146,12 @@\n      * \n      * @param zone  the default datetime zone object, must not be null\n      * @throws IllegalArgumentException if the zone is null\n+     * @throws SecurityException if the application has insufficient security rights\n      */\n     public static void setDefault(DateTimeZone zone) throws SecurityException {\n         SecurityManager sm \u003d System.getSecurityManager();\n         if (sm !\u003d null) {\n-            sm.checkPermission(new DateTimeZonePermission(\"setDefault\"));\n+            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n         }\n         if (zone \u003d\u003d null) {\n             throw new IllegalArgumentException(\"The datetime zone must not be null\");\n@@ -182,67 +159,134 @@\n         cDefault \u003d zone;\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n-     * Get the time zone by id.\n+     * Gets a time zone instance for the specified time zone id.\n      * \u003cp\u003e\n-     * The time zone id may be one of those returned by getAvailableIDs. Short\n-     * ids, as accepted by {@link java.util.TimeZone}, are not accepted. All\n-     * IDs must be specified in the long format. The exception is UTC, which is\n-     * an acceptable id.\n+     * The time zone id may be one of those returned by getAvailableIDs.\n+     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n+     * All IDs must be specified in the long format.\n+     * The exception is UTC, which is an acceptable id.\n      * \u003cp\u003e\n      * Alternatively a locale independent, fixed offset, datetime zone can\n      * be specified. The form \u003ccode\u003e[+-]hh:mm\u003c/code\u003e can be used.\n      * \n-     * @param id  the ID of the datetime zone\n+     * @param id  the ID of the datetime zone, null means default\n      * @return the DateTimeZone object for the ID\n-     * @throws IllegalArgumentException if the ID is null or not recognised\n+     * @throws IllegalArgumentException if the ID is not recognised\n      */\n-    public static DateTimeZone getInstance(String id) throws IllegalArgumentException {\n+    public static DateTimeZone forID(String id) {\n         if (id \u003d\u003d null) {\n-            throw new IllegalArgumentException(\"The datetime zone id must not be null\");\n+            return getDefault();\n         }\n         if (id.equals(\"UTC\")) {\n             return DateTimeZone.UTC;\n         }\n-        DateTimeZone zone \u003d cProvider.getDateTimeZone(id);\n+        DateTimeZone zone \u003d cProvider.getZone(id);\n         if (zone !\u003d null) {\n             return zone;\n         }\n         if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n-            int offset \u003d -(int)offsetFormatter().parseMillis(id);\n-            // Canonicalize the id.\n-            id \u003d offsetFormatter().print(0, UTC, offset);\n-            return new FixedDateTimeZone(id, null, offset, offset);\n+            int offset \u003d parseOffset(id);\n+            if (offset \u003d\u003d 0L) {\n+                return DateTimeZone.UTC;\n+            } else {\n+                id \u003d printOffset(offset);\n+                return fixedOffsetZone(id, offset);\n+            }\n         }\n         throw new IllegalArgumentException(\"The datetime zone id is not recognised: \" + id);\n     }\n \n     /**\n-     * Get the time zone by Java TimeZone.\n+     * Gets a time zone instance for the specified offset to UTC in hours.\n+     * This method assumes standard length hours.\n+     * \u003cp\u003e\n+     * This factory is a convenient way of constructing zones with a fixed offset.\n+     * \n+     * @param hoursOffset  the offset in hours from UTC\n+     * @return the DateTimeZone object for the offset\n+     * @throws IllegalArgumentException if the offset is too large or too small\n+     */\n+    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n+        return forOffsetHoursMinutes(hoursOffset, 0);\n+    }\n+\n+    /**\n+     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n+     * This method assumes 60 minutes in an hour, and standard length minutes.\n+     * \u003cp\u003e\n+     * This factory is a convenient way of constructing zones with a fixed offset.\n+     * The minutes value is always positive and in the range 0 to 59.\n+     * If constructed with the values (-2, 30), the resultiong zone is \u0027-02:30\u0027.\n+     * \n+     * @param hoursOffset  the offset in hours from UTC\n+     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n+     * @return the DateTimeZone object for the offset\n+     * @throws IllegalArgumentException if the offset or minute is too large or too small\n+     */\n+    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n+        if (hoursOffset \u003d\u003d 0 \u0026\u0026 minutesOffset \u003d\u003d 0) {\n+            return DateTimeZone.UTC;\n+        }\n+        if (minutesOffset \u003c 0 || minutesOffset \u003e 59) {\n+            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n+        }\n+        int offset \u003d 0;\n+        try {\n+            int hoursInMinutes \u003d FieldUtils.safeMultiply(hoursOffset, 60);\n+            if (hoursInMinutes \u003c 0) {\n+                minutesOffset \u003d FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n+            } else {\n+                minutesOffset \u003d FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n+            }\n+            offset \u003d FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n+        } catch (ArithmeticException ex) {\n+            throw new IllegalArgumentException(\"Offset is too large\");\n+        }\n+        return forOffsetMillis(offset);\n+    }\n+\n+    /**\n+     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n+     *\n+     * @param millisOffset  the offset in millis from UTC\n+     * @return the DateTimeZone object for the offset\n+     */\n+    public static DateTimeZone forOffsetMillis(int millisOffset) {\n+        String id \u003d printOffset(millisOffset);\n+        return fixedOffsetZone(id, millisOffset);\n+    }\n+\n+    /**\n+     * Gets a time zone instance for a JDK TimeZone.\n      * \u003cp\u003e\n      * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n      * excluded IDs are the short three letter form (except UTC). This \n      * method will attempt to convert between time zones created using the\n      * short IDs and the full version.\n      * \n-     * @param zone the zone to convert\n+     * @param zone  the zone to convert, null means default\n      * @return the DateTimeZone object for the zone\n-     * @throws IllegalArgumentException if the zone is null or not recognised\n+     * @throws IllegalArgumentException if the zone is not recognised\n      */\n-    public static DateTimeZone getInstance(java.util.TimeZone zone) {\n+    public static DateTimeZone forTimeZone(TimeZone zone) {\n         if (zone \u003d\u003d null) {\n-            throw new IllegalArgumentException(\"The TimeZone must not be null\");\n+            return getDefault();\n         }\n         final String id \u003d zone.getID();\n         if (id.equals(\"UTC\")) {\n             return DateTimeZone.UTC;\n         }\n \n-        DateTimeZone dtz;\n         // Convert from old alias before consulting provider since they may differ.\n+        DateTimeZone dtz \u003d null;\n         String convId \u003d getConvertedId(id);\n-        if (convId \u003d\u003d null || (dtz \u003d cProvider.getDateTimeZone(convId)) \u003d\u003d null) {\n-            dtz \u003d cProvider.getDateTimeZone(id);\n+        if (convId !\u003d null) {\n+            dtz \u003d cProvider.getZone(convId);\n+        }\n+        if (dtz \u003d\u003d null) {\n+            dtz \u003d cProvider.getZone(id);\n         }\n         if (dtz !\u003d null) {\n             return dtz;\n@@ -253,38 +297,46 @@\n             convId \u003d zone.getDisplayName();\n             if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                 convId \u003d convId.substring(3);\n-                int offset \u003d -(int)offsetFormatter().parseMillis(convId);\n-                // Canonicalize the id.\n-                convId \u003d offsetFormatter().print(0, UTC, offset);\n-                return new FixedDateTimeZone(convId, null, offset, offset);\n+                int offset \u003d parseOffset(convId);\n+                if (offset \u003d\u003d 0L) {\n+                    return DateTimeZone.UTC;\n+                } else {\n+                    convId \u003d printOffset(offset);\n+                    return fixedOffsetZone(convId, offset);\n+                }\n             }\n         }\n \n         throw new IllegalArgumentException(\"The datetime zone id is not recognised: \" + id);\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n-     * Gets the available IDs according to the given millisecond time\n-     * zone offset.\n-     * \u003cp\u003e\n-     * For example, \"America/Phoenix\" and \"America/Denver\"\n-     * both have GMT-07:00, but differ in daylight saving behavior.\n+     * Gets the zone using a fixed offset amount.\n      * \n-     * @param rawOffset  the given millisecond time zone GMT offset\n-     * @return an unmodifiable Set of String IDs\n+     * @param id  the zone id\n+     * @param offset  the offset in millis\n+     * @return the zone\n      */\n-    /*\n-    public static Set getAvailableIDs(int rawOffset) {\n-        String[] ids \u003d TimeZone.getAvailableIDs(rawOffset);\n-        Set set \u003d new HashSet();\n-        for (int i \u003d 0; i \u003c ids.length; i++) {\n-            if (cZones.containsKey(ids[i])) {\n-                set.add(ids[i]);\n+    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n+        if (offset \u003d\u003d 0) {\n+            return DateTimeZone.UTC;\n+        }\n+        if (iFixedOffsetCache \u003d\u003d null) {\n+            iFixedOffsetCache \u003d new HashMap();\n+        }\n+        DateTimeZone zone;\n+        Reference ref \u003d (Reference) iFixedOffsetCache.get(id);\n+        if (ref !\u003d null) {\n+            zone \u003d (DateTimeZone) ref.get();\n+            if (zone !\u003d null) {\n+                return zone;\n             }\n         }\n-        return Collections.unmodifiableSet(set);\n+        zone \u003d new FixedDateTimeZone(id, null, offset, offset);\n+        iFixedOffsetCache.put(id, new SoftReference(zone));\n+        return zone;\n     }\n-    */\n \n     /**\n      * Gets all the available IDs supported.\n@@ -295,23 +347,42 @@\n         return cAvailableIDs;\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the zone provider factory.\n+     * \u003cp\u003e\n+     * The zone provider is a pluggable instance factory that supplies the\n+     * actual instances of DateTimeZone.\n+     * \n+     * @return the provider\n+     */\n     public static Provider getProvider() {\n         return cProvider;\n     }\n \n     /**\n-     * @param provider provider to use, or null for default\n+     * Sets the zone provider factory.\n+     * \u003cp\u003e\n+     * The zone provider is a pluggable instance factory that supplies the\n+     * actual instances of DateTimeZone.\n+     * \n+     * @param provider  provider to use, or null for default\n+     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n+     * @throws IllegalArgumentException if the provider is invalid\n      */\n     public static void setProvider(Provider provider) throws SecurityException {\n         SecurityManager sm \u003d System.getSecurityManager();\n         if (sm !\u003d null) {\n-            sm.checkPermission(new DateTimeZonePermission(\"setProvider\"));\n+            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n         }\n         setProvider0(provider);\n     }\n \n     /**\n-     * Doesn\u0027t perform a security check.\n+     * Sets the zone provider factory without performing the security check.\n+     * \n+     * @param provider  provider to use, or null for default\n+     * @throws IllegalArgumentException if the provider is invalid\n      */\n     private static void setProvider0(Provider provider) {\n         if (provider \u003d\u003d null) {\n@@ -325,30 +396,92 @@\n         if (!ids.contains(\"UTC\")) {\n             throw new IllegalArgumentException(\"The provider doesn\u0027t support UTC\");\n         }\n-        if (!UTC.equals(provider.getDateTimeZone(\"UTC\"))) {\n+        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n             throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n         }\n         cProvider \u003d provider;\n         cAvailableIDs \u003d ids;\n     }\n \n+    /**\n+     * Gets the default zone provider.\n+     * \u003cp\u003e\n+     * Tries the system property \u003ccode\u003eorg.joda.time.DateTimeZone.Provider\u003c/code\u003e.\n+     * Then tries a \u003ccode\u003eZoneInfoProvider\u003c/code\u003e using the data in \u003ccode\u003eorg/joda/time/tz/data\u003c/code\u003e.\n+     * Then uses \u003ccode\u003eUTCProvider\u003c/code\u003e.\n+     * \n+     * @return the default name provider\n+     */\n+    private static Provider getDefaultProvider() {\n+        Provider provider \u003d null;\n+\n+        try {\n+            String providerClass \u003d\n+                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n+            if (providerClass !\u003d null) {\n+                try {\n+                    provider \u003d (Provider) Class.forName(providerClass).newInstance();\n+                } catch (Exception ex) {\n+                    Thread thread \u003d Thread.currentThread();\n+                    thread.getThreadGroup().uncaughtException(thread, ex);\n+                }\n+            }\n+        } catch (SecurityException ex) {\n+            // ignored\n+        }\n+\n+        if (provider \u003d\u003d null) {\n+            try {\n+                provider \u003d new ZoneInfoProvider(\"org/joda/time/tz/data\");\n+            } catch (Exception ex) {\n+                Thread thread \u003d Thread.currentThread();\n+                thread.getThreadGroup().uncaughtException(thread, ex);\n+            }\n+        }\n+\n+        if (provider \u003d\u003d null) {\n+            provider \u003d new UTCProvider();\n+        }\n+\n+        return provider;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the name provider factory.\n+     * \u003cp\u003e\n+     * The name provider is a pluggable instance factory that supplies the\n+     * names of each DateTimeZone.\n+     * \n+     * @return the provider\n+     */\n     public static NameProvider getNameProvider() {\n         return cNameProvider;\n     }\n \n     /**\n-     * @param nameProvider provider to use, or null for default\n+     * Sets the name provider factory.\n+     * \u003cp\u003e\n+     * The name provider is a pluggable instance factory that supplies the\n+     * names of each DateTimeZone.\n+     * \n+     * @param nameProvider  provider to use, or null for default\n+     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n+     * @throws IllegalArgumentException if the provider is invalid\n      */\n     public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n         SecurityManager sm \u003d System.getSecurityManager();\n         if (sm !\u003d null) {\n-            sm.checkPermission(new DateTimeZonePermission(\"setNameProvider\"));\n+            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n         }\n         setNameProvider0(nameProvider);\n     }\n \n     /**\n-     * Doesn\u0027t perform a security check.\n+     * Sets the name provider factory without performing the security check.\n+     * \n+     * @param nameProvider  provider to use, or null for default\n+     * @throws IllegalArgumentException if the provider is invalid\n      */\n     private static void setNameProvider0(NameProvider nameProvider) {\n         if (nameProvider \u003d\u003d null) {\n@@ -357,6 +490,44 @@\n         cNameProvider \u003d nameProvider;\n     }\n \n+    /**\n+     * Gets the default name provider.\n+     * \u003cp\u003e\n+     * Tries the system property \u003ccode\u003eorg.joda.time.DateTimeZone.NameProvider\u003c/code\u003e.\n+     * Then uses \u003ccode\u003eDefaultNameProvider\u003c/code\u003e.\n+     * \n+     * @return the default name provider\n+     */\n+    private static NameProvider getDefaultNameProvider() {\n+        NameProvider nameProvider \u003d null;\n+        try {\n+            String providerClass \u003d System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n+            if (providerClass !\u003d null) {\n+                try {\n+                    nameProvider \u003d (NameProvider) Class.forName(providerClass).newInstance();\n+                } catch (Exception ex) {\n+                    Thread thread \u003d Thread.currentThread();\n+                    thread.getThreadGroup().uncaughtException(thread, ex);\n+                }\n+            }\n+        } catch (SecurityException ex) {\n+            // ignore\n+        }\n+\n+        if (nameProvider \u003d\u003d null) {\n+            nameProvider \u003d new DefaultNameProvider();\n+        }\n+\n+        return nameProvider;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts an old style id to a new style id.\n+     * \n+     * @param id  the old style id\n+     * @return the new style id, null if not found\n+     */\n     private static synchronized String getConvertedId(String id) {\n         Map map \u003d cZoneIdConversion;\n         if (map \u003d\u003d null) {\n@@ -396,83 +567,104 @@\n             map.put(\"NST\", \"Pacific/Auckland\");\n             cZoneIdConversion \u003d map;\n         }\n-        return (String)map.get(id);\n+        return (String) map.get(id);\n     }\n \n+    private static int parseOffset(String str) {\n+        Chronology chrono;\n+        if (cDefault !\u003d null) {\n+            chrono \u003d ISOChronology.getInstanceUTC();\n+        } else {\n+            // Can\u0027t use a real chronology if called during class\n+            // initialization. Offset parser doesn\u0027t need it anyhow.\n+            chrono \u003d new BaseChronology() {\n+                public DateTimeZone getZone() {\n+                    return null;\n+                }\n+                public Chronology withUTC() {\n+                    return this;\n+                }\n+                public Chronology withZone(DateTimeZone zone) {\n+                    return this;\n+                }\n+                public String toString() {\n+                    return getClass().getName();\n+                }\n+            };\n+        }\n+\n+        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n+    }\n+\n+    /**\n+     * Formats a timezone offset string.\n+     * \u003cp\u003e\n+     * This method is kept separate from the formatting classes to speed and\n+     * simplify startup and classloading.\n+     * \n+     * @param offset  the offset in milliseconds\n+     * @return the time zone string\n+     */\n+    private static String printOffset(int offset) {\n+        StringBuffer buf \u003d new StringBuffer();\n+        if (offset \u003e\u003d 0) {\n+            buf.append(\u0027+\u0027);\n+        } else {\n+            buf.append(\u0027-\u0027);\n+            offset \u003d -offset;\n+        }\n+\n+        int hours \u003d offset / DateTimeConstants.MILLIS_PER_HOUR;\n+        FormatUtils.appendPaddedInteger(buf, hours, 2);\n+        offset -\u003d hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n+\n+        int minutes \u003d offset / DateTimeConstants.MILLIS_PER_MINUTE;\n+        buf.append(\u0027:\u0027);\n+        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n+        offset -\u003d minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n+        if (offset \u003d\u003d 0) {\n+            return buf.toString();\n+        }\n+\n+        int seconds \u003d offset / DateTimeConstants.MILLIS_PER_SECOND;\n+        buf.append(\u0027:\u0027);\n+        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n+        offset -\u003d seconds * DateTimeConstants.MILLIS_PER_SECOND;\n+        if (offset \u003d\u003d 0) {\n+            return buf.toString();\n+        }\n+\n+        buf.append(\u0027.\u0027);\n+        FormatUtils.appendPaddedInteger(buf, offset, 3);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Gets a printer/parser for managing the offset id formatting.\n+     * \n+     * @return the formatter\n+     */\n     private static synchronized DateTimeFormatter offsetFormatter() {\n         if (cOffsetFormatter \u003d\u003d null) {\n-            cOffsetFormatter \u003d new DateTimeFormatterBuilder(UTC)\n+            cOffsetFormatter \u003d new DateTimeFormatterBuilder()\n                 .appendTimeZoneOffset(null, true, 2, 4)\n                 .toFormatter();\n         }\n         return cOffsetFormatter;\n     }\n \n-    private static Provider getDefaultProvider() {\n-        Provider provider \u003d null;\n-\n-        try {\n-            String providerClass \u003d\n-                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n-            if (providerClass !\u003d null) {\n-                try {\n-                    provider \u003d (Provider)Class.forName(providerClass).newInstance();\n-                }\n-                catch (Exception e) {\n-                    Thread t \u003d Thread.currentThread();\n-                    t.getThreadGroup().uncaughtException(t, e);\n-                }\n-            }\n-        } catch (SecurityException e) {\n-        }\n-\n-        if (provider \u003d\u003d null) {\n-            try {\n-                provider \u003d new ZoneInfoProvider(\"org/joda/time/tz/data\");\n-            } catch (Exception e) {\n-                Thread t \u003d Thread.currentThread();\n-                t.getThreadGroup().uncaughtException(t, e);\n-            }\n-        }\n-\n-        if (provider \u003d\u003d null) {\n-            provider \u003d new UTCProvider();\n-        }\n-\n-        return provider;\n-    }\n-\n-    private static NameProvider getDefaultNameProvider() {\n-        NameProvider nameProvider \u003d null;\n-\n-        try {\n-            String providerClass \u003d\n-                System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n-            if (providerClass !\u003d null) {\n-                try {\n-                    nameProvider \u003d (NameProvider)Class.forName(providerClass).newInstance();\n-                }\n-                catch (Exception e) {\n-                    Thread t \u003d Thread.currentThread();\n-                    t.getThreadGroup().uncaughtException(t, e);\n-                }\n-            }\n-        } catch (SecurityException e) {\n-        }\n-\n-        if (nameProvider \u003d\u003d null) {\n-            nameProvider \u003d new DefaultNameProvider();\n-        }\n-\n-        return nameProvider;\n-    }\n-\n     // Instance fields and methods\n     //--------------------------------------------------------------------\n \n     private final String iID;\n \n-    public DateTimeZone(String id) {\n+    /**\n+     * Constructor.\n+     * \n+     * @param id  the id to use\n+     * @throws IllegalArgumentException if the id is null\n+     */\n+    protected DateTimeZone(String id) {\n         if (id \u003d\u003d null) {\n             throw new IllegalArgumentException(\"Id must not be null\");\n         }\n@@ -495,7 +687,7 @@\n      * Returns a non-localized name that is unique to this time zone. It can be\n      * combined with id to form a unique key for fetching localized names.\n      *\n-     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n      * @return name key or null if id should be used for names\n      */\n     public abstract String getNameKey(long instant);\n@@ -507,7 +699,7 @@\n      * If the name is not available for the locale, then this method returns a\n      * string in the format \u003ccode\u003e[+-]hh:mm\u003c/code\u003e.\n      * \n-     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n      * @return the human-readable short name in the default locale\n      */\n     public final String getShortName(long instant) {\n@@ -521,7 +713,8 @@\n      * If the name is not available for the locale, then this method returns a\n      * string in the format \u003ccode\u003e[+-]hh:mm\u003c/code\u003e.\n      * \n-     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param locale  the locale to get the name for\n      * @return the human-readable short name in the specified locale\n      */\n     public String getShortName(long instant, Locale locale) {\n@@ -536,7 +729,7 @@\n         if (name !\u003d null) {\n             return name;\n         }\n-        return offsetFormatter().print(instant, this);\n+        return printOffset(getOffset(instant));\n     }\n \n     /**\n@@ -546,7 +739,7 @@\n      * If the name is not available for the locale, then this method returns a\n      * string in the format \u003ccode\u003e[+-]hh:mm\u003c/code\u003e.\n      * \n-     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n      * @return the human-readable long name in the default locale\n      */\n     public final String getName(long instant) {\n@@ -560,7 +753,8 @@\n      * If the name is not available for the locale, then this method returns a\n      * string in the format \u003ccode\u003e[+-]hh:mm\u003c/code\u003e.\n      * \n-     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param locale  the locale to get the name for\n      * @return the human-readable long name in the specified locale\n      */\n     public String getName(long instant, Locale locale) {\n@@ -575,13 +769,13 @@\n         if (name !\u003d null) {\n             return name;\n         }\n-        return offsetFormatter().print(instant, this);\n+        return printOffset(getOffset(instant));\n     }\n \n     /**\n      * Gets the millisecond offset to add to UTC to get local time.\n      * \n-     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the offset for\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n      * @return the millisecond offset to add to UTC to get local time\n      */\n     public abstract int getOffset(long instant);\n@@ -589,13 +783,12 @@\n     /**\n      * Gets the millisecond offset to add to UTC to get local time.\n      * \n-     * @param instant instant to get the offset for\n+     * @param instant  instant to get the offset for, null means now\n      * @return the millisecond offset to add to UTC to get local time\n-     * @throws IllegalArgumentException if the instant is null\n      */\n     public final int getOffset(ReadableInstant instant) {\n         if (instant \u003d\u003d null) {\n-            throw new IllegalArgumentException(\"The instant must not be null\");\n+            return getOffset(DateTimeUtils.currentTimeMillis());\n         }\n         return getOffset(instant.getMillis());\n     }\n@@ -604,7 +797,7 @@\n      * Gets the standard millisecond offset to add to UTC to get local time,\n      * when standard time is in effect.\n      * \n-     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the offset for\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n      * @return the millisecond offset to add to UTC to get local time\n      */\n     public abstract int getStandardOffset(long instant);\n@@ -622,15 +815,33 @@\n      * offset transitions (due to DST or other historical changes), ranges of\n      * local times may map to different UTC times.\n      *\n-     * @param instantLocal the millisecond instant, relative to this time zone, to\n+     * @param instantLocal  the millisecond instant, relative to this time zone, to\n      * get the offset for\n-     * @return the millisceond offset to subtract from local time to get UTC time.\n+     * @return the millisecond offset to subtract from local time to get UTC time\n      */\n     public int getOffsetFromLocal(long instantLocal) {\n         return getOffset(instantLocal - getOffset(instantLocal));\n     }\n \n     /**\n+     * Gets the millisecond instant in another zone keeping the same local time.\n+     * \u003cp\u003e\n+     * The conversion is performed by converting the specified UTC millis to local\n+     * millis in this zone, then converting back to UTC millis in the new zone.\n+     *\n+     * @param newZone  the new zone, null means default\n+     * @param oldInstant  the UTC millisecond instant to convert\n+     * @return the UTC millisecond instant with the same local time in the new zone\n+     */\n+    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n+        if (newZone \u003d\u003d null) {\n+            newZone \u003d DateTimeZone.getDefault();\n+        }\n+        long instantLocal \u003d oldInstant + getOffset(oldInstant);\n+        return instantLocal - newZone.getOffsetFromLocal(instantLocal);\n+    }\n+\n+    /**\n      * Returns true if this time zone has no transitions.\n      *\n      * @return true if no transitions\n@@ -638,21 +849,21 @@\n     public abstract boolean isFixed();\n \n     /**\n-     * Advances the given instant to where the time zone offset or name\n-     * changes. If the instant returned is exactly the same as passed in, then\n+     * Advances the given instant to where the time zone offset or name changes.\n+     * If the instant returned is exactly the same as passed in, then\n      * no changes occur after the given instant.\n      *\n-     * @param instant milliseconds from 1970-01-01T00:00:00Z\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n      * @return milliseconds from 1970-01-01T00:00:00Z\n      */\n     public abstract long nextTransition(long instant);\n \n     /**\n-     * Retreats the given instant to where the time zone offset or name\n-     * changes. If the instant returned is exactly the same as passed in, then\n+     * Retreats the given instant to where the time zone offset or name changes.\n+     * If the instant returned is exactly the same as passed in, then\n      * no changes occur before the given instant.\n      *\n-     * @param instant milliseconds from 1970-01-01T00:00:00Z\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n      * @return milliseconds from 1970-01-01T00:00:00Z\n      */\n     public abstract long previousTransition(long instant);\n@@ -688,6 +899,7 @@\n \n     /**\n      * Gets the datetime zone as a string, which is simply its ID.\n+     * @return the id of the zone\n      */\n     public String toString() {\n         return getID();\n@@ -697,6 +909,7 @@\n      * By default, when DateTimeZones are serialized, only a \"stub\" object\n      * referring to the id is written out. When the stub is read in, it\n      * replaces itself with a DateTimeZone object.\n+     * @return a stub object to go in the stream\n      */\n     protected Object writeReplace() throws ObjectStreamException {\n         return new Stub(iID);\n@@ -706,10 +919,15 @@\n      * Used to serialize DateTimeZones by id.\n      */\n     private static final class Stub implements Serializable {\n-        static final long serialVersionUID \u003d -6471952376487863581L;\n-\n+        /** Serialization lock. */\n+        private static final long serialVersionUID \u003d -6471952376487863581L;\n+        /** The ID of the zone. */\n         private transient String iID;\n \n+        /**\n+         * Constructor.\n+         * @param id  the id of the zone\n+         */\n         Stub(String id) {\n             iID \u003d id;\n         }\n@@ -722,8 +940,8 @@\n             iID \u003d in.readUTF();\n         }\n \n-        protected Object readResolve() throws ObjectStreamException {\n-            return getInstance(iID);\n+        private Object readResolve() throws ObjectStreamException {\n+            return forID(iID);\n         }\n     }\n }\n",
      "operations": [
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "JodaTime/src/java/org/joda/time/Partial.java",
        "JodaTime/src/java/org/joda/time/Partial.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [],
          "num": 0
        },
        {
          "qualified_names": [
            "org.joda.time.Partial:Partial:[DateTimeFieldType type, int value, Chronology chronology]:null",
            "org.joda.time.Partial:getValue:[int index]:int",
            "org.joda.time.Partial:toString:[String pattern, Locale locale]:String",
            "org.joda.time.Partial\\$Property:getReadablePartial:[]:ReadablePartial",
            "org.joda.time.Partial\\$Property:Property:[Partial partial, int fieldIndex]:null",
            "org.joda.time.Partial:size:[]:int",
            "org.joda.time.Partial:Partial:[Partial partial, int[] values]:null",
            "org.joda.time.Partial:withChronologyRetainFields:[Chronology newChronology]:Partial",
            "org.joda.time.Partial\\$Property:setCopy:[String text]:Partial",
            "org.joda.time.Partial:getValues:[]:int[]",
            "org.joda.time.Partial:Partial:[DateTimeFieldType type, int value]:null",
            "org.joda.time.Partial:getField:[int index, Chronology chrono]:DateTimeField",
            "org.joda.time.Partial:withField:[DateTimeFieldType fieldType, int value]:Partial",
            "org.joda.time.Partial:Partial:[ReadablePartial partial]:null",
            "org.joda.time.Partial:getFieldTypes:[]:DateTimeFieldType[]",
            "org.joda.time.Partial\\$Property:setCopy:[int value]:Partial",
            "org.joda.time.Partial:without:[DateTimeFieldType fieldType]:Partial",
            "org.joda.time.Partial:Partial:[]:null",
            "org.joda.time.Partial:toString:[]:String",
            "org.joda.time.Partial:Partial:[DateTimeFieldType[] types, int[] values, Chronology chronology]:null",
            "org.joda.time.Partial:getChronology:[]:Chronology",
            "org.joda.time.Partial:isMatch:[ReadableInstant instant]:boolean",
            "org.joda.time.Partial\\$Property:get:[]:int",
            "org.joda.time.Partial\\$Property:addWrapFieldToCopy:[int valueToAdd]:Partial",
            "org.joda.time.Partial:getFieldType:[int index]:DateTimeFieldType",
            "org.joda.time.Partial:plus:[ReadablePeriod period]:Partial",
            "org.joda.time.Partial:minus:[ReadablePeriod period]:Partial",
            "org.joda.time.Partial\\$Property:getField:[]:DateTimeField",
            "org.joda.time.Partial:Partial:[Chronology chrono]:null",
            "org.joda.time.Partial:withFieldAdded:[DurationFieldType fieldType, int amount]:Partial",
            "org.joda.time.Partial:toString:[String pattern]:String",
            "org.joda.time.Partial:Partial:[DateTimeFieldType[] types, int[] values]:null",
            "org.joda.time.Partial:property:[DateTimeFieldType type]:Property",
            "org.joda.time.Partial:Partial:[Chronology chronology, DateTimeFieldType[] types, int[] values]:null",
            "org.joda.time.Partial:toStringList:[]:String",
            "org.joda.time.Partial\\$Property:setCopy:[String text, Locale locale]:Partial",
            "org.joda.time.Partial:with:[DateTimeFieldType fieldType, int value]:Partial",
            "org.joda.time.Partial\\$Property:getPartial:[]:Partial",
            "org.joda.time.Partial\\$Property:addToCopy:[int valueToAdd]:Partial",
            "org.joda.time.Partial:getFormatter:[]:DateTimeFormatter",
            "org.joda.time.Partial:withFieldAddWrapped:[DurationFieldType fieldType, int amount]:Partial",
            "org.joda.time.Partial:withPeriodAdded:[ReadablePeriod period, int scalar]:Partial"
          ],
          "num": 42
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "-1"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10",
            "11",
            "12",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "27",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "37",
            "38",
            "39",
            "40",
            "41",
            "42",
            "43",
            "44",
            "45",
            "46",
            "47",
            "48",
            "49",
            "50",
            "51",
            "52",
            "53",
            "54",
            "55",
            "56",
            "57",
            "58",
            "59",
            "60",
            "61",
            "62",
            "63",
            "64",
            "65",
            "66",
            "67",
            "68",
            "69",
            "70",
            "71",
            "72",
            "73",
            "74",
            "75",
            "76",
            "77",
            "78",
            "79",
            "80",
            "81",
            "82",
            "83",
            "84",
            "85",
            "86",
            "87",
            "88",
            "89",
            "90",
            "91",
            "92",
            "93",
            "94",
            "95",
            "96",
            "97",
            "98",
            "99",
            "100",
            "101",
            "102",
            "103",
            "104",
            "105",
            "106",
            "107",
            "108",
            "109",
            "110",
            "111",
            "112",
            "113",
            "114",
            "115",
            "116",
            "117",
            "118",
            "119",
            "120",
            "121",
            "122",
            "123",
            "124",
            "125",
            "126",
            "127",
            "128",
            "129",
            "130",
            "131",
            "132",
            "133",
            "134",
            "135",
            "136",
            "137",
            "138",
            "139",
            "140",
            "141",
            "142",
            "143",
            "144",
            "145",
            "146",
            "147",
            "148",
            "149",
            "150",
            "151",
            "152",
            "153",
            "154",
            "155",
            "156",
            "157",
            "158",
            "159",
            "160",
            "161",
            "162",
            "163",
            "164",
            "165",
            "166",
            "167",
            "168",
            "169",
            "170",
            "171",
            "172",
            "173",
            "174",
            "175",
            "176",
            "177",
            "178",
            "179",
            "180",
            "181",
            "182",
            "183",
            "184",
            "185",
            "186",
            "187",
            "188",
            "189",
            "190",
            "191",
            "192",
            "193",
            "194",
            "195",
            "196",
            "197",
            "198",
            "199",
            "200",
            "201",
            "202",
            "203",
            "204",
            "205",
            "206",
            "207",
            "208",
            "209",
            "210",
            "211",
            "212",
            "213",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "220",
            "221",
            "222",
            "223",
            "224",
            "225",
            "226",
            "227",
            "228",
            "229",
            "230",
            "231",
            "232",
            "233",
            "234",
            "235",
            "236",
            "237",
            "238",
            "239",
            "240",
            "241",
            "242",
            "243",
            "244",
            "245",
            "246",
            "247",
            "248",
            "249",
            "250",
            "251",
            "252",
            "253",
            "254",
            "255",
            "256",
            "257",
            "258",
            "259",
            "260",
            "261",
            "262",
            "263",
            "264",
            "265",
            "266",
            "267",
            "268",
            "269",
            "270",
            "271",
            "272",
            "273",
            "274",
            "275",
            "276",
            "277",
            "278",
            "279",
            "280",
            "281",
            "282",
            "283",
            "284",
            "285",
            "286",
            "287",
            "288",
            "289",
            "290",
            "291",
            "292",
            "293",
            "294",
            "295",
            "296",
            "297",
            "298",
            "299",
            "300",
            "301",
            "302",
            "303",
            "304",
            "305",
            "306",
            "307",
            "308",
            "309",
            "310",
            "311",
            "312",
            "313",
            "314",
            "315",
            "316",
            "317",
            "318",
            "319",
            "320",
            "321",
            "322",
            "323",
            "324",
            "325",
            "326",
            "327",
            "328",
            "329",
            "330",
            "331",
            "332",
            "333",
            "334",
            "335",
            "336",
            "337",
            "338",
            "339",
            "340",
            "341",
            "342",
            "343",
            "344",
            "345",
            "346",
            "347",
            "348",
            "349",
            "350",
            "351",
            "352",
            "353",
            "354",
            "355",
            "356",
            "357",
            "358",
            "359",
            "360",
            "361",
            "362",
            "363",
            "364",
            "365",
            "366",
            "367",
            "368",
            "369",
            "370",
            "371",
            "372",
            "373",
            "374",
            "375",
            "376",
            "377",
            "378",
            "379",
            "380",
            "381",
            "382",
            "383",
            "384",
            "385",
            "386",
            "387",
            "388",
            "389",
            "390",
            "391",
            "392",
            "393",
            "394",
            "395",
            "396",
            "397",
            "398",
            "399",
            "400",
            "401",
            "402",
            "403",
            "404",
            "405",
            "406",
            "407",
            "408",
            "409",
            "410",
            "411",
            "412",
            "413",
            "414",
            "415",
            "416",
            "417",
            "418",
            "419",
            "420",
            "421",
            "422",
            "423",
            "424",
            "425",
            "426",
            "427",
            "428",
            "429",
            "430",
            "431",
            "432",
            "433",
            "434",
            "435",
            "436",
            "437",
            "438",
            "439",
            "440",
            "441",
            "442",
            "443",
            "444",
            "445",
            "446",
            "447",
            "448",
            "449",
            "450",
            "451",
            "452",
            "453",
            "454",
            "455",
            "456",
            "457",
            "458",
            "459",
            "460",
            "461",
            "462",
            "463",
            "464",
            "465",
            "466",
            "467",
            "468",
            "469",
            "470",
            "471",
            "472",
            "473",
            "474",
            "475",
            "476",
            "477",
            "478",
            "479",
            "480",
            "481",
            "482",
            "483",
            "484",
            "485",
            "486",
            "487",
            "488",
            "489",
            "490",
            "491",
            "492",
            "493",
            "494",
            "495",
            "496",
            "497",
            "498",
            "499",
            "500",
            "501",
            "502",
            "503",
            "504",
            "505",
            "506",
            "507",
            "508",
            "509",
            "510",
            "511",
            "512",
            "513",
            "514",
            "515",
            "516",
            "517",
            "518",
            "519",
            "520",
            "521",
            "522",
            "523",
            "524",
            "525",
            "526",
            "527",
            "528",
            "529",
            "530",
            "531",
            "532",
            "533",
            "534",
            "535",
            "536",
            "537",
            "538",
            "539",
            "540",
            "541",
            "542",
            "543",
            "544",
            "545",
            "546",
            "547",
            "548",
            "549",
            "550",
            "551",
            "552",
            "553",
            "554",
            "555",
            "556",
            "557",
            "558",
            "559",
            "560",
            "561",
            "562",
            "563",
            "564",
            "565",
            "566",
            "567",
            "568",
            "569",
            "570",
            "571",
            "572",
            "573",
            "574",
            "575",
            "576",
            "577",
            "578",
            "579",
            "580",
            "581",
            "582",
            "583",
            "584",
            "585",
            "586",
            "587",
            "588",
            "589",
            "590",
            "591",
            "592",
            "593",
            "594",
            "595",
            "596",
            "597",
            "598",
            "599",
            "600",
            "601",
            "602",
            "603",
            "604",
            "605",
            "606",
            "607",
            "608",
            "609",
            "610",
            "611",
            "612",
            "613",
            "614",
            "615",
            "616",
            "617",
            "618",
            "619",
            "620",
            "621",
            "622",
            "623",
            "624",
            "625",
            "626",
            "627",
            "628",
            "629",
            "630",
            "631",
            "632",
            "633",
            "634",
            "635",
            "636",
            "637",
            "638",
            "639",
            "640",
            "641",
            "642",
            "643",
            "644",
            "645",
            "646",
            "647",
            "648",
            "649",
            "650",
            "651",
            "652",
            "653",
            "654",
            "655",
            "656",
            "657",
            "658",
            "659",
            "660",
            "661",
            "662",
            "663",
            "664",
            "665",
            "666",
            "667",
            "668",
            "669",
            "670",
            "671",
            "672",
            "673",
            "674",
            "675",
            "676",
            "677",
            "678",
            "679",
            "680",
            "681",
            "682",
            "683",
            "684",
            "685",
            "686",
            "687",
            "688",
            "689",
            "690",
            "691",
            "692",
            "693",
            "694",
            "695",
            "696",
            "697",
            "698",
            "699",
            "700",
            "701",
            "702",
            "703",
            "704",
            "705",
            "706",
            "707",
            "708",
            "709",
            "710",
            "711",
            "712",
            "713",
            "714",
            "715",
            "716",
            "717",
            "718",
            "719",
            "720",
            "721",
            "722",
            "723",
            "724",
            "725",
            "726",
            "727",
            "728",
            "729",
            "730",
            "731",
            "732",
            "733",
            "734",
            "735",
            "736",
            "737",
            "738",
            "739",
            "740",
            "741",
            "742",
            "743",
            "744",
            "745",
            "746",
            "747",
            "748",
            "749",
            "750",
            "751",
            "752",
            "753",
            "754",
            "755",
            "756",
            "757",
            "758",
            "759",
            "760",
            "761",
            "762",
            "763",
            "764",
            "765",
            "766",
            "767",
            "768",
            "769",
            "770",
            "771",
            "772",
            "773",
            "774",
            "775",
            "776",
            "777",
            "778",
            "779",
            "780",
            "781",
            "782",
            "783",
            "784",
            "785",
            "786",
            "787",
            "788",
            "789",
            "790",
            "791",
            "792",
            "793",
            "794",
            "795",
            "796",
            "797",
            "798",
            "799",
            "800",
            "801",
            "802",
            "803",
            "804",
            "805",
            "806",
            "807",
            "808",
            "809",
            "810",
            "811",
            "812",
            "813",
            "814",
            "815",
            "816",
            "817",
            "818",
            "819",
            "820",
            "821",
            "822",
            "823",
            "824",
            "825",
            "826",
            "827",
            "828",
            "829",
            "830",
            "831",
            "832",
            "833",
            "834",
            "835",
            "836",
            "837",
            "838",
            "839",
            "840",
            "841",
            "842",
            "843",
            "844",
            "845",
            "846",
            "847",
            "848",
            "849",
            "850",
            "851",
            "852",
            "853",
            "854",
            "855",
            "856",
            "857",
            "858",
            "859",
            "860",
            "861",
            "862",
            "863",
            "864",
            "865",
            "866",
            "867",
            "868",
            "869",
            "870",
            "871",
            "872",
            "873",
            "874",
            "875",
            "876",
            "877",
            "878",
            "879",
            "880",
            "881",
            "882",
            "883",
            "884",
            "885",
            "886",
            "887",
            "888",
            "889",
            "890",
            "891",
            "892",
            "893",
            "894",
            "895",
            "896",
            "897",
            "898",
            "899",
            "900",
            "901",
            "902",
            "903",
            "904",
            "905",
            "906",
            "907",
            "908",
            "909",
            "910",
            "911",
            "912",
            "913",
            "914",
            "915",
            "916",
            "917",
            "918",
            "919",
            "920",
            "921",
            "922",
            "923",
            "924",
            "925",
            "926",
            "927",
            "928",
            "929",
            "930",
            "931",
            "932",
            "933",
            "934",
            "935",
            "936",
            "937",
            "938",
            "939",
            "940",
            "941",
            "942",
            "943",
            "944",
            "945"
          ],
          "num": 945
        }
      ],
      "diff": "diff --git a/JodaTime/src/java/org/joda/time/Partial.java b/JodaTime/src/java/org/joda/time/Partial.java\nnew file mode 100644\nindex 0000000..095e88b\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/Partial.java\n@@ -0,0 +1,945 @@\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.joda.time.base.AbstractPartial;\n+import org.joda.time.field.AbstractPartialFieldProperty;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * Partial is an immutable partial datetime supporting any set of datetime fields.\n+ * \u003cp\u003e\n+ * A Partial instance can be used to hold any combination of fields.\n+ * The instance does not contain a time zone, so any datetime is local.\n+ * \u003cp\u003e\n+ * A Partial can be matched against an instant using {@link #isMatch(ReadableInstant)}.\n+ * This method compares each field on this partial with those of the instant\n+ * and determines if the partial matches the instant.\n+ * Given this definition, an empty Partial instance represents any datetime\n+ * and always matches.\n+ * \u003cp\u003e\n+ * Calculations on Partial are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * \u003cp\u003e\n+ * Each individual field can be queried in two ways:\n+ * \u003cul\u003e\n+ * \u003cli\u003e\u003ccode\u003eget(DateTimeFieldType.monthOfYear())\u003c/code\u003e\n+ * \u003cli\u003e\u003ccode\u003eproperty(DateTimeFieldType.monthOfYear()).get()\u003c/code\u003e\n+ * \u003c/ul\u003e\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * \u003cul\u003e\n+ * \u003cli\u003enumeric value - \u003ccode\u003emonthOfYear().get()\u003c/code\u003e\n+ * \u003cli\u003etext value - \u003ccode\u003emonthOfYear().getAsText()\u003c/code\u003e\n+ * \u003cli\u003eshort text value - \u003ccode\u003emonthOfYear().getAsShortText()\u003c/code\u003e\n+ * \u003cli\u003emaximum/minimum values - \u003ccode\u003emonthOfYear().getMaximumValue()\u003c/code\u003e\n+ * \u003cli\u003eadd/subtract - \u003ccode\u003emonthOfYear().addToCopy()\u003c/code\u003e\n+ * \u003cli\u003eset - \u003ccode\u003emonthOfYear().setCopy()\u003c/code\u003e\n+ * \u003c/ul\u003e\n+ * \u003cp\u003e\n+ * Partial is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.1\n+ */\n+public final class Partial\n+        extends AbstractPartial\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID \u003d 12324121189002L;\n+\n+    /** The chronology in use. */\n+    private final Chronology iChronology;\n+    /** The set of field types. */\n+    private final DateTimeFieldType[] iTypes;\n+    /** The values of each field in this partial. */\n+    private final int[] iValues;\n+    /** The formatter to use, [0] may miss some fields, [1] doesn\u0027t miss any fields. */\n+    private transient DateTimeFormatter[] iFormatter;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a Partial with no fields or values, which can be considered\n+     * to represent any date.\n+     * \u003cp\u003e\n+     * This is most useful when constructing partials, for example:\n+     * \u003cpre\u003e\n+     * Partial p \u003d new Partial()\n+     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n+     *     .with(DateTimeFieldType.hourOfDay(), 12)\n+     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n+     * \u003c/pre\u003e\n+     * Note that, although this is a clean way to write code, it is fairly\n+     * inefficient internally.\n+     * \u003cp\u003e\n+     * The constructor uses the default ISO chronology.\n+     */\n+    public Partial() {\n+        this((Chronology) null);\n+    }\n+\n+    /**\n+     * Constructs a Partial with no fields or values, which can be considered\n+     * to represent any date.\n+     * \u003cp\u003e\n+     * This is most useful when constructing partials, for example:\n+     * \u003cpre\u003e\n+     * Partial p \u003d new Partial(chrono)\n+     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n+     *     .with(DateTimeFieldType.hourOfDay(), 12)\n+     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n+     * \u003c/pre\u003e\n+     * Note that, although this is a clean way to write code, it is fairly\n+     * inefficient internally.\n+     *\n+     * @param chrono  the chronology, null means ISO\n+     */\n+    public Partial(Chronology chrono) {\n+        super();\n+        iChronology \u003d DateTimeUtils.getChronology(chrono).withUTC();\n+        iTypes \u003d new DateTimeFieldType[0];\n+        iValues \u003d new int[0];\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified field and value.\n+     * \u003cp\u003e\n+     * The constructor uses the default ISO chronology.\n+     * \n+     * @param type  the single type to create the partial from, not null\n+     * @param value  the value to store\n+     * @throws IllegalArgumentException if the type or value is invalid\n+     */\n+    public Partial(DateTimeFieldType type, int value) {\n+        this(type, value, null);\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified field and value.\n+     * \u003cp\u003e\n+     * The constructor uses the specified chronology.\n+     * \n+     * @param type  the single type to create the partial from, not null\n+     * @param value  the value to store\n+     * @param chronology  the chronology, null means ISO\n+     * @throws IllegalArgumentException if the type or value is invalid\n+     */\n+    public Partial(DateTimeFieldType type, int value, Chronology chronology) {\n+        super();\n+        chronology \u003d DateTimeUtils.getChronology(chronology).withUTC();\n+        iChronology \u003d chronology;\n+        if (type \u003d\u003d null) {\n+            throw new IllegalArgumentException(\"The field type must not be null\");\n+        }\n+        iTypes \u003d new DateTimeFieldType[] {type};\n+        iValues \u003d new int[] {value};\n+        chronology.validate(this, iValues);\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified fields and values.\n+     * The fields must be specified in the order largest to smallest.\n+     * \u003cp\u003e\n+     * The constructor uses the specified chronology.\n+     * \n+     * @param types  the types to create the partial from, not null\n+     * @param values  the values to store, not null\n+     * @throws IllegalArgumentException if the types or values are invalid\n+     */\n+    public Partial(DateTimeFieldType[] types, int[] values) {\n+        this(types, values, null);\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified fields and values.\n+     * The fields must be specified in the order largest to smallest.\n+     * \u003cp\u003e\n+     * The constructor uses the specified chronology.\n+     * \n+     * @param types  the types to create the partial from, not null\n+     * @param values  the values to store, not null\n+     * @param chronology  the chronology, null means ISO\n+     * @throws IllegalArgumentException if the types or values are invalid\n+     */\n+    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n+        super();\n+        chronology \u003d DateTimeUtils.getChronology(chronology).withUTC();\n+        iChronology \u003d chronology;\n+        if (types \u003d\u003d null) {\n+            throw new IllegalArgumentException(\"Types array must not be null\");\n+        }\n+        if (values \u003d\u003d null) {\n+            throw new IllegalArgumentException(\"Values array must not be null\");\n+        }\n+        if (values.length !\u003d types.length) {\n+            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n+        }\n+        if (types.length \u003d\u003d 0) {\n+            iTypes \u003d types;\n+            iValues \u003d values;\n+            return;\n+        }\n+        for (int i \u003d 0; i \u003c types.length; i++) {\n+            if (types[i] \u003d\u003d null) {\n+                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n+            }\n+        }\n+        DurationField lastUnitField \u003d null;\n+        for (int i \u003d 0; i \u003c types.length; i++) {\n+            DateTimeFieldType loopType \u003d types[i];\n+            DurationField loopUnitField \u003d loopType.getDurationType().getField(iChronology);\n+            if (i \u003e 0) {\n+                int compare \u003d lastUnitField.compareTo(loopUnitField);\n+                if (compare \u003c 0 || (compare !\u003d 0 \u0026\u0026 loopUnitField.isSupported() \u003d\u003d false)) {\n+                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n+                            types[i - 1].getName() + \" \u003c \" + loopType.getName());\n+                } else if (compare \u003d\u003d 0) {\n+                    if (types[i - 1].getRangeDurationType() \u003d\u003d null) {\n+                        if (loopType.getRangeDurationType() \u003d\u003d null) {\n+                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n+                        }\n+                    } else {\n+                        if (loopType.getRangeDurationType() \u003d\u003d null) {\n+                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n+                                    types[i - 1].getName() + \" \u003c \" + loopType.getName());\n+                        }\n+                        DurationField lastRangeField \u003d types[i - 1].getRangeDurationType().getField(iChronology);\n+                        DurationField loopRangeField \u003d loopType.getRangeDurationType().getField(iChronology);\n+                        if (lastRangeField.compareTo(loopRangeField) \u003c 0) {\n+                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n+                                    types[i - 1].getName() + \" \u003c \" + loopType.getName());\n+                        }\n+                        if (lastRangeField.compareTo(loopRangeField) \u003d\u003d 0) {\n+                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n+                        }\n+                    }\n+                }\n+            }\n+            lastUnitField \u003d loopUnitField;\n+        }\n+        \n+        iTypes \u003d (DateTimeFieldType[]) types.clone();\n+        chronology.validate(this, values);\n+        iValues \u003d (int[]) values.clone();\n+    }\n+\n+    /**\n+     * Constructs a Partial by copying all the fields and types from\n+     * another partial.\n+     * \u003cp\u003e\n+     * This is most useful when copying from a YearMonthDay or TimeOfDay.\n+     */\n+    public Partial(ReadablePartial partial) {\n+        super();\n+        if (partial \u003d\u003d null) {\n+            throw new IllegalArgumentException(\"The partial must not be null\");\n+        }\n+        iChronology \u003d DateTimeUtils.getChronology(partial.getChronology()).withUTC();\n+        iTypes \u003d new DateTimeFieldType[partial.size()];\n+        iValues \u003d new int[partial.size()];\n+        for (int i \u003d 0; i \u003c partial.size(); i++) {\n+            iTypes[i] \u003d partial.getFieldType(i);\n+            iValues[i] \u003d partial.getValue(i);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified values.\n+     * This constructor assigns and performs no validation.\n+     * \n+     * @param partial  the partial to copy\n+     * @param values  the values to store\n+     * @throws IllegalArgumentException if the types or values are invalid\n+     */\n+    Partial(Partial partial, int[] values) {\n+        super();\n+        iChronology \u003d partial.iChronology;\n+        iTypes \u003d partial.iTypes;\n+        iValues \u003d values;\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified chronology, fields and values.\n+     * This constructor assigns and performs no validation.\n+     * \n+     * @param chronology  the chronology\n+     * @param types  the types to create the partial from\n+     * @param values  the values to store\n+     * @throws IllegalArgumentException if the types or values are invalid\n+     */\n+    Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) {\n+        super();\n+        iChronology \u003d chronology;\n+        iTypes \u003d types;\n+        iValues \u003d values;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial.\n+     * \n+     * @return the field count\n+     */\n+    public int size() {\n+        return iTypes.length;\n+    }\n+\n+    /**\n+     * Gets the chronology of the partial which is never null.\n+     * \u003cp\u003e\n+     * The {@link Chronology} is the calculation engine behind the partial and\n+     * provides conversion and validation of the fields in a particular calendar system.\n+     * \n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * \n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        return iTypes[index].getField(chrono);\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeFieldType getFieldType(int index) {\n+        return iTypes[index];\n+    }\n+\n+    /**\n+     * Gets an array of the field type of each of the fields that\n+     * this partial supports.\n+     * \u003cp\u003e\n+     * The fields are returned largest to smallest.\n+     *\n+     * @return the array of field types (cloned), largest to smallest\n+     */\n+    public DateTimeFieldType[] getFieldTypes() {\n+        return (DateTimeFieldType[]) iTypes.clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value of the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the value\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        return iValues[index];\n+    }\n+\n+    /**\n+     * Gets an array of the value of each of the fields that\n+     * this partial supports.\n+     * \u003cp\u003e\n+     * The fields are returned largest to smallest.\n+     * Each value corresponds to the same array index as \u003ccode\u003egetFieldTypes()\u003c/code\u003e\n+     *\n+     * @return the current values of each field (cloned), largest to smallest\n+     */\n+    public int[] getValues() {\n+        return (int[]) iValues.clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new Partial instance with the specified chronology.\n+     * This instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * This method retains the values of the fields, thus the result will\n+     * typically refer to a different instant.\n+     * \u003cp\u003e\n+     * The time zone of the specified chronology is ignored, as Partial\n+     * operates without a time zone.\n+     *\n+     * @param newChronology  the new chronology, null means ISO\n+     * @return a copy of this datetime with a different chronology\n+     * @throws IllegalArgumentException if the values are invalid for the new chronology\n+     */\n+    public Partial withChronologyRetainFields(Chronology newChronology) {\n+        newChronology \u003d DateTimeUtils.getChronology(newChronology);\n+        newChronology \u003d newChronology.withUTC();\n+        if (newChronology \u003d\u003d getChronology()) {\n+            return this;\n+        } else {\n+            Partial newPartial \u003d new Partial(newChronology, iTypes, iValues);\n+            newChronology.validate(newPartial, iValues);\n+            return newPartial;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this date with the specified field set to a new value.\n+     * \u003cp\u003e\n+     * If this partial did not previously support the field, the new one will.\n+     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n+     * \u003cp\u003e\n+     * For example, if the field type is \u003ccode\u003edayOfMonth\u003c/code\u003e then the day\n+     * would be changed/added in the returned instance.\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public Partial with(DateTimeFieldType fieldType, int value) {\n+        if (fieldType \u003d\u003d null) {\n+            throw new IllegalArgumentException(\"The field type must not be null\");\n+        }\n+        int index \u003d indexOf(fieldType);\n+        if (index \u003d\u003d -1) {\n+            DateTimeFieldType[] newTypes \u003d new DateTimeFieldType[iTypes.length + 1];\n+            int[] newValues \u003d new int[newTypes.length];\n+            \n+            // find correct insertion point to keep largest-smallest order\n+            int i \u003d 0;\n+            DurationField unitField \u003d fieldType.getDurationType().getField(iChronology);\n+            if (unitField.isSupported()) {\n+                for (; i \u003c iTypes.length; i++) {\n+                    DateTimeFieldType loopType \u003d iTypes[i];\n+                    DurationField loopUnitField \u003d loopType.getDurationType().getField(iChronology);\n+                    if (loopUnitField.isSupported()) {\n+                        int compare \u003d unitField.compareTo(loopUnitField);\n+                        if (compare \u003e 0) {\n+                            break;\n+                        } else if (compare \u003d\u003d 0) {\n+                            DurationField rangeField \u003d fieldType.getRangeDurationType().getField(iChronology);\n+                            DurationField loopRangeField \u003d loopType.getRangeDurationType().getField(iChronology);\n+                            if (rangeField.compareTo(loopRangeField) \u003e 0) {\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            System.arraycopy(iTypes, 0, newTypes, 0, i);\n+            System.arraycopy(iValues, 0, newValues, 0, i);\n+            newTypes[i] \u003d fieldType;\n+            newValues[i] \u003d value;\n+            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n+            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n+            \n+            Partial newPartial \u003d new Partial(iChronology, newTypes, newValues);\n+            iChronology.validate(newPartial, newValues);\n+            return newPartial;\n+        }\n+        if (value \u003d\u003d getValue(index)) {\n+            return this;\n+        }\n+        int[] newValues \u003d getValues();\n+        newValues \u003d getField(index).set(this, index, newValues, value);\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this date with the specified field removed.\n+     * \u003cp\u003e\n+     * If this partial did not previously support the field, no error occurs.\n+     *\n+     * @param fieldType  the field type to remove, may be null\n+     * @return a copy of this instance with the field removed\n+     */\n+    public Partial without(DateTimeFieldType fieldType) {\n+        int index \u003d indexOf(fieldType);\n+        if (index !\u003d -1) {\n+            DateTimeFieldType[] newTypes \u003d new DateTimeFieldType[size() - 1];\n+            int[] newValues \u003d new int[size() - 1];\n+            System.arraycopy(iTypes, 0, newTypes, 0, index);\n+            System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\n+            System.arraycopy(iValues, 0, newValues, 0, index);\n+            System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\n+            Partial newPartial \u003d new Partial(iChronology, newTypes, newValues);\n+            iChronology.validate(newPartial, newValues);\n+            return newPartial;\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this Partial with the specified field set to a new value.\n+     * \u003cp\u003e\n+     * If this partial does not support the field, an exception is thrown.\n+     * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.\n+     * \u003cp\u003e\n+     * For example, if the field type is \u003ccode\u003edayOfMonth\u003c/code\u003e then the day\n+     * would be changed in the returned instance if supported.\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public Partial withField(DateTimeFieldType fieldType, int value) {\n+        int index \u003d indexOfSupported(fieldType);\n+        if (value \u003d\u003d getValue(index)) {\n+            return this;\n+        }\n+        int[] newValues \u003d getValues();\n+        newValues \u003d getField(index).set(this, index, newValues, value);\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this Partial with the value of the specified field increased.\n+     * If this partial does not support the field, an exception is thrown.\n+     * \u003cp\u003e\n+     * If the addition is zero, then \u003ccode\u003ethis\u003c/code\u003e is returned.\n+     * The addition will overflow into larger fields (eg. minute to hour).\n+     * However, it will not wrap around if the top maximum is reached.\n+     *\n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public Partial withFieldAdded(DurationFieldType fieldType, int amount) {\n+        int index \u003d indexOfSupported(fieldType);\n+        if (amount \u003d\u003d 0) {\n+            return this;\n+        }\n+        int[] newValues \u003d getValues();\n+        newValues \u003d getField(index).add(this, index, newValues, amount);\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this Partial with the value of the specified field increased.\n+     * If this partial does not support the field, an exception is thrown.\n+     * \u003cp\u003e\n+     * If the addition is zero, then \u003ccode\u003ethis\u003c/code\u003e is returned.\n+     * The addition will overflow into larger fields (eg. minute to hour).\n+     * If the maximum is reached, the addition will wra.\n+     *\n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {\n+        int index \u003d indexOfSupported(fieldType);\n+        if (amount \u003d\u003d 0) {\n+            return this;\n+        }\n+        int[] newValues \u003d getValues();\n+        newValues \u003d getField(index).addWrapPartial(this, index, newValues, amount);\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this Partial with the specified period added.\n+     * \u003cp\u003e\n+     * If the addition is zero, then \u003ccode\u003ethis\u003c/code\u003e is returned.\n+     * Fields in the period that aren\u0027t present in the partial are ignored.\n+     * \u003cp\u003e\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using the method\n+     * {@link #withFieldAdded(DurationFieldType, int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period \u003d\u003d null || scalar \u003d\u003d 0) {\n+            return this;\n+        }\n+        int[] newValues \u003d getValues();\n+        for (int i \u003d 0; i \u003c period.size(); i++) {\n+            DurationFieldType fieldType \u003d period.getFieldType(i);\n+            int index \u003d indexOf(fieldType);\n+            if (index \u003e\u003d 0) {\n+                newValues \u003d getField(index).add(this, index, newValues,\n+                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n+            }\n+        }\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this instance with the specified period added.\n+     * \u003cp\u003e\n+     * If the amount is zero or null, then \u003ccode\u003ethis\u003c/code\u003e is returned.\n+     *\n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public Partial plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    /**\n+     * Gets a copy of this instance with the specified period take away.\n+     * \u003cp\u003e\n+     * If the amount is zero or null, then \u003ccode\u003ethis\u003c/code\u003e is returned.\n+     *\n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this instance with the period taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public Partial minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains\n+     * many useful methods for getting and manipulating the partial.\n+     * \u003cp\u003e\n+     * See also {@link ReadablePartial#get(DateTimeFieldType)}.\n+     *\n+     * @param type  the field type to get the property for, not null\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        return new Property(this, indexOfSupported(type));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Does this partial match the specified instant.\n+     * \u003cp\u003e\n+     * A match occurs when all the fields of this partial are the same as the\n+     * corresponding fields on the specified instant.\n+     *\n+     * @param instant  an instant to check against, null means now in default zone\n+     * @return true if this partial matches the specified instant\n+     */\n+    public boolean isMatch(ReadableInstant instant) {\n+        long millis \u003d DateTimeUtils.getInstantMillis(instant);\n+        Chronology chrono \u003d DateTimeUtils.getInstantChronology(instant);\n+        for (int i \u003d 0; i \u003c iTypes.length; i++) {\n+            int value \u003d iTypes[i].getField(chrono).get(millis);\n+            if (value !\u003d iValues[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a formatter suitable for the fields in this partial.\n+     * \u003cp\u003e\n+     * If there is no appropriate ISO format, null is returned.\n+     * This method may return a formatter that does not display all the\n+     * fields of the partial. This might occur when you have overlapping\n+     * fields, such as dayOfWeek and dayOfMonth.\n+     *\n+     * @return a formatter suitable for the fields in this partial, null\n+     *  if none is suitable\n+     */\n+    public DateTimeFormatter getFormatter() {\n+        DateTimeFormatter[] f \u003d iFormatter;\n+        if (f \u003d\u003d null) {\n+            if (size() \u003d\u003d 0) {\n+                return null;\n+            }\n+            f \u003d new DateTimeFormatter[2];\n+            try {\n+                List list \u003d new ArrayList(Arrays.asList(iTypes));\n+                f[0] \u003d ISODateTimeFormat.forFields(list, true, false);\n+                if (list.size() \u003d\u003d 0) {\n+                    f[1] \u003d f[0];\n+                }\n+            } catch (IllegalArgumentException ex) {\n+                // ignore\n+            }\n+            iFormatter \u003d f;\n+        }\n+        return f[0];\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date in an appropriate ISO8601 format.\n+     * \u003cp\u003e\n+     * This method will output the partial in one of two ways.\n+     * If {@link #getFormatter()}\n+     * \n+     * If there is no appropriate ISO format a dump of the fields is output\n+     * via {@link #toStringList()}. An appropr\n+     * \n+     * @return ISO8601 formatted string\n+     */\n+    public String toString() {\n+        DateTimeFormatter[] f \u003d iFormatter;\n+        if (f \u003d\u003d null) {\n+            getFormatter();\n+            f \u003d iFormatter;\n+            if (f \u003d\u003d null) {\n+                return toStringList();\n+            }\n+        }\n+        DateTimeFormatter f1 \u003d f[1];\n+        if (f1 \u003d\u003d null) {\n+            return toStringList();\n+        }\n+        return f1.print(this);\n+    }\n+\n+    /**\n+     * Gets a string version of the partial that lists all the fields.\n+     * \u003cp\u003e\n+     * This method exists to provide a better debugging toString than\n+     * the standard toString. This method lists all the fields and their\n+     * values in a style similar to the collections framework.\n+     *\n+     * @return a toString format that lists all the fields\n+     */\n+    public String toStringList() {\n+        int size \u003d size();\n+        StringBuffer buf \u003d new StringBuffer(20 * size);\n+        buf.append(\u0027[\u0027);\n+        for (int i \u003d 0; i \u003c size; i++) {\n+            if (i \u003e 0) {\n+                buf.append(\u0027,\u0027).append(\u0027 \u0027);\n+            }\n+            buf.append(iTypes[i].getName());\n+            buf.append(\u0027\u003d\u0027);\n+            buf.append(iValues[i]);\n+        }\n+        buf.append(\u0027]\u0027);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     * Unsupported fields will appear as special unicode characters.\n+     *\n+     * @param pattern  the pattern specification, null means use \u003ccode\u003etoString\u003c/code\u003e\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern \u003d\u003d null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     * Unsupported fields will appear as special unicode characters.\n+     *\n+     * @param pattern  the pattern specification, null means use \u003ccode\u003etoString\u003c/code\u003e\n+     * @param locale  Locale to use, null means default\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) {\n+        if (pattern \u003d\u003d null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The property class for \u003ccode\u003eYearMonthDay\u003c/code\u003e.\n+     * \u003cp\u003e\n+     * This class binds a \u003ccode\u003eYearMonthDay\u003c/code\u003e to a \u003ccode\u003eDateTimeField\u003c/code\u003e.\n+     * \n+     * @author Stephen Colebourne\n+     * @since 1.1\n+     */\n+    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID \u003d 53278362873888L;\n+\n+        /** The partial */\n+        private final Partial iPartial;\n+        /** The field index */\n+        private final int iFieldIndex;\n+\n+        /**\n+         * Constructs a property.\n+         * \n+         * @param partial  the partial instance\n+         * @param fieldIndex  the index in the partial\n+         */\n+        Property(Partial partial, int fieldIndex) {\n+            super();\n+            iPartial \u003d partial;\n+            iFieldIndex \u003d fieldIndex;\n+        }\n+\n+        /**\n+         * Gets the field that this property uses.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iPartial.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        protected ReadablePartial getReadablePartial() {\n+            return iPartial;\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public Partial getPartial() {\n+            return iPartial;\n+        }\n+\n+        /**\n+         * Gets the value of this field.\n+         * \n+         * @return the field value\n+         */\n+        public int get() {\n+            return iPartial.getValue(iFieldIndex);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to the value of this field in a copy of this Partial.\n+         * \u003cp\u003e\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it will affect larger fields.\n+         * Smaller fields are unaffected.\n+         * \u003cp\u003e\n+         * If the result would be too large, beyond the maximum year, then an\n+         * IllegalArgumentException is thrown.\n+         * \u003cp\u003e\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the value isn\u0027t valid\n+         */\n+        public Partial addToCopy(int valueToAdd) {\n+            int[] newValues \u003d iPartial.getValues();\n+            newValues \u003d getField().add(iPartial, iFieldIndex, newValues, valueToAdd);\n+            return new Partial(iPartial, newValues);\n+        }\n+\n+        /**\n+         * Adds to the value of this field in a copy of this Partial wrapping\n+         * within this field if the maximum value is reached.\n+         * \u003cp\u003e\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it wraps within this field.\n+         * Other fields are unaffected.\n+         * \u003cp\u003e\n+         * For example,\n+         * \u003ccode\u003e2004-12-20\u003c/code\u003e addWrapField one month returns \u003ccode\u003e2004-01-20\u003c/code\u003e.\n+         * \u003cp\u003e\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the value isn\u0027t valid\n+         */\n+        public Partial addWrapFieldToCopy(int valueToAdd) {\n+            int[] newValues \u003d iPartial.getValues();\n+            newValues \u003d getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);\n+            return new Partial(iPartial, newValues);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the Partial.\n+         * \u003cp\u003e\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the value isn\u0027t valid\n+         */\n+        public Partial setCopy(int value) {\n+            int[] newValues \u003d iPartial.getValues();\n+            newValues \u003d getField().set(iPartial, iFieldIndex, newValues, value);\n+            return new Partial(iPartial, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the Partial to a parsed text value.\n+         * \u003cp\u003e\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the text value isn\u0027t valid\n+         */\n+        public Partial setCopy(String text, Locale locale) {\n+            int[] newValues \u003d iPartial.getValues();\n+            newValues \u003d getField().set(iPartial, iFieldIndex, newValues, text, locale);\n+            return new Partial(iPartial, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the Partial to a parsed text value.\n+         * \u003cp\u003e\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the text value isn\u0027t valid\n+         */\n+        public Partial setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+    }\n+\n+}\n",
      "operations": [
        {
          "type": "update-node",
          "from": "",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "JodaTime/src/java/org/joda/time/TimeOfDay.java",
        "JodaTime/src/java/org/joda/time/TimeOfDay.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [],
          "num": 0
        },
        {
          "qualified_names": [
            "org.joda.time.TimeOfDay:TimeOfDay:[DateTimeZone zone]:null",
            "org.joda.time.TimeOfDay:getFieldTypes:[]:DateTimeFieldType[]",
            "org.joda.time.TimeOfDay:plusSeconds:[int seconds]:TimeOfDay",
            "org.joda.time.TimeOfDay:minus:[ReadablePeriod period]:TimeOfDay",
            "org.joda.time.TimeOfDay:TimeOfDay:[Object instant, Chronology chronology]:null",
            "org.joda.time.TimeOfDay:plusMillis:[int millis]:TimeOfDay",
            "org.joda.time.TimeOfDay:getMillisOfSecond:[]:int",
            "org.joda.time.TimeOfDay\\$Property:Property:[TimeOfDay partial, int fieldIndex]:null",
            "org.joda.time.TimeOfDay:withChronologyRetainFields:[Chronology newChronology]:TimeOfDay",
            "org.joda.time.TimeOfDay:toString:[]:String",
            "org.joda.time.TimeOfDay:size:[]:int",
            "org.joda.time.TimeOfDay:minusMinutes:[int minutes]:TimeOfDay",
            "org.joda.time.TimeOfDay:TimeOfDay:[int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology]:null",
            "org.joda.time.TimeOfDay:plusHours:[int hours]:TimeOfDay",
            "org.joda.time.TimeOfDay:hourOfDay:[]:Property",
            "org.joda.time.TimeOfDay:secondOfMinute:[]:Property",
            "org.joda.time.TimeOfDay:toDateTimeToday:[]:DateTime",
            "org.joda.time.TimeOfDay\\$Property:setCopy:[String text]:TimeOfDay",
            "org.joda.time.TimeOfDay:plusMinutes:[int minutes]:TimeOfDay",
            "org.joda.time.TimeOfDay\\$Property:setCopy:[String text, Locale locale]:TimeOfDay",
            "org.joda.time.TimeOfDay:getMinuteOfHour:[]:int",
            "org.joda.time.TimeOfDay:TimeOfDay:[long instant]:null",
            "org.joda.time.TimeOfDay:getField:[int index, Chronology chrono]:DateTimeField",
            "org.joda.time.TimeOfDay:fromMillisOfDay:[long millisOfDay, Chronology chrono]:TimeOfDay",
            "org.joda.time.TimeOfDay:TimeOfDay:[int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology]:null",
            "org.joda.time.TimeOfDay:getHourOfDay:[]:int",
            "org.joda.time.TimeOfDay:TimeOfDay:[int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond]:null",
            "org.joda.time.TimeOfDay:withFieldAdded:[DurationFieldType fieldType, int amount]:TimeOfDay",
            "org.joda.time.TimeOfDay:TimeOfDay:[TimeOfDay partial, int[] values]:null",
            "org.joda.time.TimeOfDay:property:[DateTimeFieldType type]:Property",
            "org.joda.time.TimeOfDay\\$Property:get:[]:int",
            "org.joda.time.TimeOfDay\\$Property:addToCopy:[int valueToAdd]:TimeOfDay",
            "org.joda.time.TimeOfDay\\$Property:addNoWrapToCopy:[int valueToAdd]:TimeOfDay",
            "org.joda.time.TimeOfDay:TimeOfDay:[int hourOfDay, int minuteOfHour]:null",
            "org.joda.time.TimeOfDay\\$Property:getField:[]:DateTimeField",
            "org.joda.time.TimeOfDay\\$Property:getTimeOfDay:[]:TimeOfDay",
            "org.joda.time.TimeOfDay:getFieldType:[int index]:DateTimeFieldType",
            "org.joda.time.TimeOfDay:withPeriodAdded:[ReadablePeriod period, int scalar]:TimeOfDay",
            "org.joda.time.TimeOfDay:millisOfSecond:[]:Property",
            "org.joda.time.TimeOfDay:minusHours:[int hours]:TimeOfDay",
            "org.joda.time.TimeOfDay\\$Property:addWrapFieldToCopy:[int valueToAdd]:TimeOfDay",
            "org.joda.time.TimeOfDay:withField:[DateTimeFieldType fieldType, int value]:TimeOfDay",
            "org.joda.time.TimeOfDay\\$Property:setCopy:[int value]:TimeOfDay",
            "org.joda.time.TimeOfDay:plus:[ReadablePeriod period]:TimeOfDay",
            "org.joda.time.TimeOfDay:minusMillis:[int millis]:TimeOfDay",
            "org.joda.time.TimeOfDay:TimeOfDay:[Object instant]:null",
            "org.joda.time.TimeOfDay:TimeOfDay:[int hourOfDay, int minuteOfHour, int secondOfMinute]:null",
            "org.joda.time.TimeOfDay:toDateTimeToday:[DateTimeZone zone]:DateTime",
            "org.joda.time.TimeOfDay:TimeOfDay:[Chronology chronology]:null",
            "org.joda.time.TimeOfDay:TimeOfDay:[int hourOfDay, int minuteOfHour, Chronology chronology]:null",
            "org.joda.time.TimeOfDay:TimeOfDay:[]:null",
            "org.joda.time.TimeOfDay:fromMillisOfDay:[long millisOfDay]:TimeOfDay",
            "org.joda.time.TimeOfDay:getSecondOfMinute:[]:int",
            "org.joda.time.TimeOfDay:minusSeconds:[int seconds]:TimeOfDay",
            "org.joda.time.TimeOfDay:TimeOfDay:[TimeOfDay partial, Chronology chrono]:null",
            "org.joda.time.TimeOfDay:TimeOfDay:[long instant, Chronology chronology]:null",
            "org.joda.time.TimeOfDay:minuteOfHour:[]:Property",
            "org.joda.time.TimeOfDay\\$Property:getReadablePartial:[]:ReadablePartial"
          ],
          "num": 58
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "-1"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10",
            "11",
            "12",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "27",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "37",
            "38",
            "39",
            "40",
            "41",
            "42",
            "43",
            "44",
            "45",
            "46",
            "47",
            "48",
            "49",
            "50",
            "51",
            "52",
            "53",
            "54",
            "55",
            "56",
            "57",
            "58",
            "59",
            "60",
            "61",
            "62",
            "63",
            "64",
            "65",
            "66",
            "67",
            "68",
            "69",
            "70",
            "71",
            "72",
            "73",
            "74",
            "75",
            "76",
            "77",
            "78",
            "79",
            "80",
            "81",
            "82",
            "83",
            "84",
            "85",
            "86",
            "87",
            "88",
            "89",
            "90",
            "91",
            "92",
            "93",
            "94",
            "95",
            "96",
            "97",
            "98",
            "99",
            "100",
            "101",
            "102",
            "103",
            "104",
            "105",
            "106",
            "107",
            "108",
            "109",
            "110",
            "111",
            "112",
            "113",
            "114",
            "115",
            "116",
            "117",
            "118",
            "119",
            "120",
            "121",
            "122",
            "123",
            "124",
            "125",
            "126",
            "127",
            "128",
            "129",
            "130",
            "131",
            "132",
            "133",
            "134",
            "135",
            "136",
            "137",
            "138",
            "139",
            "140",
            "141",
            "142",
            "143",
            "144",
            "145",
            "146",
            "147",
            "148",
            "149",
            "150",
            "151",
            "152",
            "153",
            "154",
            "155",
            "156",
            "157",
            "158",
            "159",
            "160",
            "161",
            "162",
            "163",
            "164",
            "165",
            "166",
            "167",
            "168",
            "169",
            "170",
            "171",
            "172",
            "173",
            "174",
            "175",
            "176",
            "177",
            "178",
            "179",
            "180",
            "181",
            "182",
            "183",
            "184",
            "185",
            "186",
            "187",
            "188",
            "189",
            "190",
            "191",
            "192",
            "193",
            "194",
            "195",
            "196",
            "197",
            "198",
            "199",
            "200",
            "201",
            "202",
            "203",
            "204",
            "205",
            "206",
            "207",
            "208",
            "209",
            "210",
            "211",
            "212",
            "213",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "220",
            "221",
            "222",
            "223",
            "224",
            "225",
            "226",
            "227",
            "228",
            "229",
            "230",
            "231",
            "232",
            "233",
            "234",
            "235",
            "236",
            "237",
            "238",
            "239",
            "240",
            "241",
            "242",
            "243",
            "244",
            "245",
            "246",
            "247",
            "248",
            "249",
            "250",
            "251",
            "252",
            "253",
            "254",
            "255",
            "256",
            "257",
            "258",
            "259",
            "260",
            "261",
            "262",
            "263",
            "264",
            "265",
            "266",
            "267",
            "268",
            "269",
            "270",
            "271",
            "272",
            "273",
            "274",
            "275",
            "276",
            "277",
            "278",
            "279",
            "280",
            "281",
            "282",
            "283",
            "284",
            "285",
            "286",
            "287",
            "288",
            "289",
            "290",
            "291",
            "292",
            "293",
            "294",
            "295",
            "296",
            "297",
            "298",
            "299",
            "300",
            "301",
            "302",
            "303",
            "304",
            "305",
            "306",
            "307",
            "308",
            "309",
            "310",
            "311",
            "312",
            "313",
            "314",
            "315",
            "316",
            "317",
            "318",
            "319",
            "320",
            "321",
            "322",
            "323",
            "324",
            "325",
            "326",
            "327",
            "328",
            "329",
            "330",
            "331",
            "332",
            "333",
            "334",
            "335",
            "336",
            "337",
            "338",
            "339",
            "340",
            "341",
            "342",
            "343",
            "344",
            "345",
            "346",
            "347",
            "348",
            "349",
            "350",
            "351",
            "352",
            "353",
            "354",
            "355",
            "356",
            "357",
            "358",
            "359",
            "360",
            "361",
            "362",
            "363",
            "364",
            "365",
            "366",
            "367",
            "368",
            "369",
            "370",
            "371",
            "372",
            "373",
            "374",
            "375",
            "376",
            "377",
            "378",
            "379",
            "380",
            "381",
            "382",
            "383",
            "384",
            "385",
            "386",
            "387",
            "388",
            "389",
            "390",
            "391",
            "392",
            "393",
            "394",
            "395",
            "396",
            "397",
            "398",
            "399",
            "400",
            "401",
            "402",
            "403",
            "404",
            "405",
            "406",
            "407",
            "408",
            "409",
            "410",
            "411",
            "412",
            "413",
            "414",
            "415",
            "416",
            "417",
            "418",
            "419",
            "420",
            "421",
            "422",
            "423",
            "424",
            "425",
            "426",
            "427",
            "428",
            "429",
            "430",
            "431",
            "432",
            "433",
            "434",
            "435",
            "436",
            "437",
            "438",
            "439",
            "440",
            "441",
            "442",
            "443",
            "444",
            "445",
            "446",
            "447",
            "448",
            "449",
            "450",
            "451",
            "452",
            "453",
            "454",
            "455",
            "456",
            "457",
            "458",
            "459",
            "460",
            "461",
            "462",
            "463",
            "464",
            "465",
            "466",
            "467",
            "468",
            "469",
            "470",
            "471",
            "472",
            "473",
            "474",
            "475",
            "476",
            "477",
            "478",
            "479",
            "480",
            "481",
            "482",
            "483",
            "484",
            "485",
            "486",
            "487",
            "488",
            "489",
            "490",
            "491",
            "492",
            "493",
            "494",
            "495",
            "496",
            "497",
            "498",
            "499",
            "500",
            "501",
            "502",
            "503",
            "504",
            "505",
            "506",
            "507",
            "508",
            "509",
            "510",
            "511",
            "512",
            "513",
            "514",
            "515",
            "516",
            "517",
            "518",
            "519",
            "520",
            "521",
            "522",
            "523",
            "524",
            "525",
            "526",
            "527",
            "528",
            "529",
            "530",
            "531",
            "532",
            "533",
            "534",
            "535",
            "536",
            "537",
            "538",
            "539",
            "540",
            "541",
            "542",
            "543",
            "544",
            "545",
            "546",
            "547",
            "548",
            "549",
            "550",
            "551",
            "552",
            "553",
            "554",
            "555",
            "556",
            "557",
            "558",
            "559",
            "560",
            "561",
            "562",
            "563",
            "564",
            "565",
            "566",
            "567",
            "568",
            "569",
            "570",
            "571",
            "572",
            "573",
            "574",
            "575",
            "576",
            "577",
            "578",
            "579",
            "580",
            "581",
            "582",
            "583",
            "584",
            "585",
            "586",
            "587",
            "588",
            "589",
            "590",
            "591",
            "592",
            "593",
            "594",
            "595",
            "596",
            "597",
            "598",
            "599",
            "600",
            "601",
            "602",
            "603",
            "604",
            "605",
            "606",
            "607",
            "608",
            "609",
            "610",
            "611",
            "612",
            "613",
            "614",
            "615",
            "616",
            "617",
            "618",
            "619",
            "620",
            "621",
            "622",
            "623",
            "624",
            "625",
            "626",
            "627",
            "628",
            "629",
            "630",
            "631",
            "632",
            "633",
            "634",
            "635",
            "636",
            "637",
            "638",
            "639",
            "640",
            "641",
            "642",
            "643",
            "644",
            "645",
            "646",
            "647",
            "648",
            "649",
            "650",
            "651",
            "652",
            "653",
            "654",
            "655",
            "656",
            "657",
            "658",
            "659",
            "660",
            "661",
            "662",
            "663",
            "664",
            "665",
            "666",
            "667",
            "668",
            "669",
            "670",
            "671",
            "672",
            "673",
            "674",
            "675",
            "676",
            "677",
            "678",
            "679",
            "680",
            "681",
            "682",
            "683",
            "684",
            "685",
            "686",
            "687",
            "688",
            "689",
            "690",
            "691",
            "692",
            "693",
            "694",
            "695",
            "696",
            "697",
            "698",
            "699",
            "700",
            "701",
            "702",
            "703",
            "704",
            "705",
            "706",
            "707",
            "708",
            "709",
            "710",
            "711",
            "712",
            "713",
            "714",
            "715",
            "716",
            "717",
            "718",
            "719",
            "720",
            "721",
            "722",
            "723",
            "724",
            "725",
            "726",
            "727",
            "728",
            "729",
            "730",
            "731",
            "732",
            "733",
            "734",
            "735",
            "736",
            "737",
            "738",
            "739",
            "740",
            "741",
            "742",
            "743",
            "744",
            "745",
            "746",
            "747",
            "748",
            "749",
            "750",
            "751",
            "752",
            "753",
            "754",
            "755",
            "756",
            "757",
            "758",
            "759",
            "760",
            "761",
            "762",
            "763",
            "764",
            "765",
            "766",
            "767",
            "768",
            "769",
            "770",
            "771",
            "772",
            "773",
            "774",
            "775",
            "776",
            "777",
            "778",
            "779",
            "780",
            "781",
            "782",
            "783",
            "784",
            "785",
            "786",
            "787",
            "788",
            "789",
            "790",
            "791",
            "792",
            "793",
            "794",
            "795",
            "796",
            "797",
            "798",
            "799",
            "800",
            "801",
            "802",
            "803",
            "804",
            "805",
            "806",
            "807",
            "808",
            "809",
            "810",
            "811",
            "812",
            "813",
            "814",
            "815",
            "816",
            "817",
            "818",
            "819",
            "820",
            "821",
            "822",
            "823",
            "824",
            "825",
            "826",
            "827",
            "828",
            "829",
            "830",
            "831",
            "832",
            "833",
            "834",
            "835",
            "836",
            "837",
            "838",
            "839",
            "840",
            "841",
            "842",
            "843",
            "844",
            "845",
            "846",
            "847",
            "848",
            "849",
            "850",
            "851",
            "852",
            "853",
            "854",
            "855",
            "856",
            "857",
            "858",
            "859",
            "860",
            "861",
            "862",
            "863",
            "864",
            "865",
            "866",
            "867",
            "868",
            "869",
            "870",
            "871",
            "872",
            "873",
            "874",
            "875",
            "876",
            "877",
            "878",
            "879",
            "880",
            "881",
            "882",
            "883",
            "884",
            "885",
            "886",
            "887",
            "888",
            "889",
            "890",
            "891",
            "892",
            "893",
            "894",
            "895",
            "896",
            "897",
            "898",
            "899",
            "900",
            "901",
            "902",
            "903",
            "904",
            "905",
            "906",
            "907",
            "908",
            "909",
            "910",
            "911",
            "912",
            "913",
            "914",
            "915",
            "916",
            "917",
            "918",
            "919",
            "920",
            "921",
            "922",
            "923",
            "924",
            "925",
            "926",
            "927",
            "928",
            "929",
            "930",
            "931",
            "932",
            "933",
            "934",
            "935",
            "936",
            "937",
            "938",
            "939",
            "940",
            "941",
            "942",
            "943",
            "944",
            "945",
            "946",
            "947",
            "948",
            "949",
            "950",
            "951",
            "952",
            "953",
            "954",
            "955",
            "956",
            "957",
            "958",
            "959",
            "960",
            "961",
            "962",
            "963",
            "964",
            "965",
            "966",
            "967",
            "968",
            "969",
            "970",
            "971",
            "972",
            "973",
            "974",
            "975",
            "976",
            "977",
            "978",
            "979",
            "980",
            "981",
            "982",
            "983",
            "984",
            "985",
            "986",
            "987",
            "988",
            "989",
            "990",
            "991",
            "992",
            "993",
            "994",
            "995",
            "996",
            "997",
            "998",
            "999",
            "1000",
            "1001",
            "1002",
            "1003",
            "1004",
            "1005",
            "1006",
            "1007",
            "1008",
            "1009",
            "1010",
            "1011",
            "1012",
            "1013",
            "1014",
            "1015",
            "1016",
            "1017",
            "1018",
            "1019",
            "1020",
            "1021",
            "1022",
            "1023",
            "1024",
            "1025",
            "1026",
            "1027",
            "1028",
            "1029",
            "1030",
            "1031",
            "1032",
            "1033",
            "1034",
            "1035",
            "1036",
            "1037",
            "1038"
          ],
          "num": 1038
        }
      ],
      "diff": "diff --git a/JodaTime/src/java/org/joda/time/TimeOfDay.java b/JodaTime/src/java/org/joda/time/TimeOfDay.java\nnew file mode 100644\nindex 0000000..47f6a5b\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n@@ -0,0 +1,1038 @@\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+import org.joda.time.base.BasePartial;\n+import org.joda.time.field.AbstractPartialFieldProperty;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * TimeOfDay is an immutable partial supporting the hour, minute, second\n+ * and millisecond fields.\n+ * \u003cp\u003e\n+ * Calculations on TimeOfDay are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * \u003cp\u003e\n+ * Each individual field can be queried in two ways:\n+ * \u003cul\u003e\n+ * \u003cli\u003e\u003ccode\u003egetHourOfDay()\u003c/code\u003e\n+ * \u003cli\u003e\u003ccode\u003ehourOfDay().get()\u003c/code\u003e\n+ * \u003c/ul\u003e\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * \u003cul\u003e\n+ * \u003cli\u003enumeric value - \u003ccode\u003ehourOfDay().get()\u003c/code\u003e\n+ * \u003cli\u003etext value - \u003ccode\u003ehourOfDay().getAsText()\u003c/code\u003e\n+ * \u003cli\u003eshort text value - \u003ccode\u003ehourOfDay().getAsShortText()\u003c/code\u003e\n+ * \u003cli\u003emaximum/minimum values - \u003ccode\u003ehourOfDay().getMaximumValue()\u003c/code\u003e\n+ * \u003cli\u003eadd/subtract - \u003ccode\u003ehourOfDay().addToCopy()\u003c/code\u003e\n+ * \u003cli\u003eset - \u003ccode\u003ehourOfDay().setCopy()\u003c/code\u003e\n+ * \u003c/ul\u003e\n+ * \u003cp\u003e\n+ * TimeOfDay is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O\u0027Neill\n+ * @since 1.0\n+ */\n+public final class TimeOfDay\n+        extends BasePartial\n+        implements ReadablePartial, Serializable {\n+    // NOTE: No toDateTime(YearMonthDay) as semantics are confusing when\n+    // different chronologies\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID \u003d 3633353405803318660L;\n+    /** The singleton set of field types */\n+    private static final DateTimeFieldType[] FIELD_TYPES \u003d new DateTimeFieldType[] {\n+        DateTimeFieldType.hourOfDay(),\n+        DateTimeFieldType.minuteOfHour(),\n+        DateTimeFieldType.secondOfMinute(),\n+        DateTimeFieldType.millisOfSecond(),\n+    };\n+\n+    /** Constant for midnight. */\n+    public static final TimeOfDay MIDNIGHT \u003d new TimeOfDay(0, 0, 0, 0);\n+\n+    /** The index of the hourOfDay field in the field array */\n+    public static final int HOUR_OF_DAY \u003d 0;\n+    /** The index of the minuteOfHour field in the field array */\n+    public static final int MINUTE_OF_HOUR \u003d 1;\n+    /** The index of the secondOfMinute field in the field array */\n+    public static final int SECOND_OF_MINUTE \u003d 2;\n+    /** The index of the millisOfSecond field in the field array */\n+    public static final int MILLIS_OF_SECOND \u003d 3;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a TimeOfDay from the specified millis of day using the\n+     * ISO chronology.\n+     * \u003cp\u003e\n+     * The millisOfDay value may exceed the number of millis in one day,\n+     * but additional days will be ignored.\n+     * This method uses the UTC time zone internally.\n+     *\n+     * @param millisOfDay  the number of milliseconds into a day to convert\n+     */\n+    public static TimeOfDay fromMillisOfDay(long millisOfDay) {\n+        return fromMillisOfDay(millisOfDay, null);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay from the specified millis of day using the\n+     * specified chronology.\n+     * \u003cp\u003e\n+     * The millisOfDay value may exceed the number of millis in one day,\n+     * but additional days will be ignored.\n+     * This method uses the UTC time zone internally.\n+     *\n+     * @param millisOfDay  the number of milliseconds into a day to convert\n+     * @param chrono  the chronology, null means ISO chronology\n+     */\n+    public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono) {\n+        chrono \u003d DateTimeUtils.getChronology(chrono);\n+        chrono \u003d chrono.withUTC();\n+        return new TimeOfDay(millisOfDay, chrono);\n+    }\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a TimeOfDay with the current time, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * \u003cp\u003e\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     */\n+    public TimeOfDay() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with the current time, using ISOChronology in\n+     * the specified zone to extract the fields.\n+     * \u003cp\u003e\n+     * The constructor uses the specified time zone to obtain the current time.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     * \n+     * @param zone  the zone to use, null means default zone\n+     * @since 1.1\n+     */\n+    public TimeOfDay(DateTimeZone zone) {\n+        super(ChronologyType.iso().getChronology(zone));\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with the current time, using the specified chronology\n+     * and zone to extract the fields.\n+     * \u003cp\u003e\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay extracting the partial fields from the specified\n+     * milliseconds using the ISOChronology in the default zone.\n+     * \u003cp\u003e\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public TimeOfDay(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay extracting the partial fields from the specified\n+     * milliseconds using the chronology provided.\n+     * \u003cp\u003e\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay from an Object that represents a time.\n+     * \u003cp\u003e\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * \u003cp\u003e\n+     * The string format must begin with a \u0027T\u0027 to be recognised, such as \u0027T10:20\u0027.\n+     * \u003cp\u003e\n+     * The chronology used will be derived from the object, defaulting to ISO.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public TimeOfDay(Object instant) {\n+        super(instant, null);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay from an Object that represents a time, using the\n+     * specified chronology.\n+     * \u003cp\u003e\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * \u003cp\u003e\n+     * The string format must begin with a \u0027T\u0027 to be recognised, such as \u0027T10:20\u0027.\n+     * \u003cp\u003e\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     * The specified chronology overrides that of the object.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @param chronology  the chronology, null means ISO default\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public TimeOfDay(Object instant, Chronology chronology) {\n+        super(instant, DateTimeUtils.getChronology(chronology));\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds\n+     * using \u003ccode\u003eISOChronology\u003c/code\u003e in the default zone.\n+     * \u003cp\u003e\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour) {\n+        this(hourOfDay, minuteOfHour, 0, 0, null);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds.\n+     * \u003cp\u003e\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology) {\n+        this(hourOfDay, minuteOfHour, 0, 0, chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified time field values and zero milliseconds\n+     * using \u003ccode\u003eISOChronology\u003c/code\u003e in the default zone.\n+     * \u003cp\u003e\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) {\n+        this(hourOfDay, minuteOfHour, secondOfMinute, 0, null);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified time field values and zero milliseconds.\n+     * \u003cp\u003e\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) {\n+        this(hourOfDay, minuteOfHour, secondOfMinute, 0, chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified time field values using\n+     * \u003ccode\u003eISOChronology\u003c/code\u003e in the default zone.\n+     * \u003cp\u003e\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n+        this(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, null);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified time field values and chronology.\n+     * \u003cp\u003e\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour,\n+            int secondOfMinute, int millisOfSecond, Chronology chronology) {\n+        super(new int[] {hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond}, chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with chronology from this instance and new values.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param values  the new set of values\n+     */\n+    TimeOfDay(TimeOfDay partial, int[] values) {\n+        super(partial, values);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with values from this instance and a new chronology.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param chrono  the new chronology\n+     */\n+    TimeOfDay(TimeOfDay partial, Chronology chrono) {\n+        super(partial, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial.\n+     * \n+     * @return the field count\n+     */\n+    public int size() {\n+        return 4;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * \u003cp\u003e\n+     * This method must not use any instance variables.\n+     * \n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        switch (index) {\n+            case HOUR_OF_DAY:\n+                return chrono.hourOfDay();\n+            case MINUTE_OF_HOUR:\n+                return chrono.minuteOfHour();\n+            case SECOND_OF_MINUTE:\n+                return chrono.secondOfMinute();\n+            case MILLIS_OF_SECOND:\n+                return chrono.millisOfSecond();\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeFieldType getFieldType(int index) {\n+        return FIELD_TYPES[index];\n+    }\n+\n+    /**\n+     * Gets an array of the field type of each of the fields that this partial supports.\n+     * \u003cp\u003e\n+     * The fields are returned largest to smallest, Hour, Minute, Second, Millis.\n+     *\n+     * @return the array of field types (cloned), largest to smallest\n+     */\n+    public DateTimeFieldType[] getFieldTypes() {\n+        return (DateTimeFieldType[]) FIELD_TYPES.clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new TimeOfDay instance with the specified chronology.\n+     * This instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * This method retains the values of the fields, thus the result will\n+     * typically refer to a different instant.\n+     * \u003cp\u003e\n+     * The time zone of the specified chronology is ignored, as TimeOfDay\n+     * operates without a time zone.\n+     *\n+     * @param newChronology  the new chronology, null means ISO\n+     * @return a copy of this datetime with a different chronology\n+     * @throws IllegalArgumentException if the values are invalid for the new chronology\n+     */\n+    public TimeOfDay withChronologyRetainFields(Chronology newChronology) {\n+        newChronology \u003d DateTimeUtils.getChronology(newChronology);\n+        newChronology \u003d newChronology.withUTC();\n+        if (newChronology \u003d\u003d getChronology()) {\n+            return this;\n+        } else {\n+            TimeOfDay newTimeOfDay \u003d new TimeOfDay(this, newChronology);\n+            newChronology.validate(newTimeOfDay, getValues());\n+            return newTimeOfDay;\n+        }\n+    }\n+\n+    /**\n+     * Gets a copy of this time with the specified field set to a new value.\n+     * \u003cp\u003e\n+     * For example, if the field type is \u003ccode\u003eminuteOfHour\u003c/code\u003e then the day\n+     * would be changed in the returned instance.\n+     * \u003cp\u003e\n+     * These three lines are equivalent:\n+     * \u003cpre\u003e\n+     * TimeOfDay updated \u003d tod.withField(DateTimeFieldType.minuteOfHour(), 6);\n+     * TimeOfDay updated \u003d tod.minuteOfHour().setCopy(6);\n+     * TimeOfDay updated \u003d tod.property(DateTimeFieldType.minuteOfHour()).setCopy(6);\n+     * \u003c/pre\u003e\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public TimeOfDay withField(DateTimeFieldType fieldType, int value) {\n+        int index \u003d indexOfSupported(fieldType);\n+        if (value \u003d\u003d getValue(index)) {\n+            return this;\n+        }\n+        int[] newValues \u003d getValues();\n+        newValues \u003d getField(index).set(this, index, newValues, value);\n+        return new TimeOfDay(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this time with the value of the specified field increased,\n+     * wrapping to what would be a new day if required.\n+     * \u003cp\u003e\n+     * If the addition is zero, then \u003ccode\u003ethis\u003c/code\u003e is returned.\n+     * \u003cp\u003e\n+     * These three lines are equivalent:\n+     * \u003cpre\u003e\n+     * TimeOfDay added \u003d tod.withFieldAdded(DurationFieldType.minutes(), 6);\n+     * TimeOfDay added \u003d tod.plusMinutes(6);\n+     * TimeOfDay added \u003d tod.minuteOfHour().addToCopy(6);\n+     * \u003c/pre\u003e\n+     * \n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount) {\n+        int index \u003d indexOfSupported(fieldType);\n+        if (amount \u003d\u003d 0) {\n+            return this;\n+        }\n+        int[] newValues \u003d getValues();\n+        newValues \u003d getField(index).addWrapPartial(this, index, newValues, amount);\n+        return new TimeOfDay(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this date with the specified period added,\n+     * wrapping to what would be a new day if required.\n+     * \u003cp\u003e\n+     * If the addition is zero, then \u003ccode\u003ethis\u003c/code\u003e is returned.\n+     * Fields in the period that aren\u0027t present in the partial are ignored.\n+     * \u003cp\u003e\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using methods\n+     * like {@link #withFieldAdded(DurationFieldType, int)}\n+     * or {@link #plusHours(int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period \u003d\u003d null || scalar \u003d\u003d 0) {\n+            return this;\n+        }\n+        int[] newValues \u003d getValues();\n+        for (int i \u003d 0; i \u003c period.size(); i++) {\n+            DurationFieldType fieldType \u003d period.getFieldType(i);\n+            int index \u003d indexOf(fieldType);\n+            if (index \u003e\u003d 0) {\n+                newValues \u003d getField(index).addWrapPartial(this, index, newValues,\n+                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n+            }\n+        }\n+        return new TimeOfDay(this, newValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this instance with the specified period added,\n+     * wrapping to what would be a new day if required.\n+     * \u003cp\u003e\n+     * If the amount is zero or null, then \u003ccode\u003ethis\u003c/code\u003e is returned.\n+     * \u003cp\u003e\n+     * This method is typically used to add complex period instances.\n+     * Adding one field is best achieved using methods\n+     * like {@link #plusHours(int)}.\n+     * \n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public TimeOfDay plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new time plus the specified number of hours.\n+     * \u003cp\u003e\n+     * This time instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * The following three lines are identical in effect:\n+     * \u003cpre\u003e\n+     * TimeOfDay added \u003d dt.plusHours(6);\n+     * TimeOfDay added \u003d dt.plus(Period.hours(6));\n+     * TimeOfDay added \u003d dt.withFieldAdded(DurationFieldType.hours(), 6);\n+     * \u003c/pre\u003e\n+     *\n+     * @param hours  the amount of hours to add, may be negative\n+     * @return the new time plus the increased hours\n+     * @since 1.1\n+     */\n+    public TimeOfDay plusHours(int hours) {\n+        return withFieldAdded(DurationFieldType.hours(), hours);\n+    }\n+\n+    /**\n+     * Returns a new time plus the specified number of minutes.\n+     * \u003cp\u003e\n+     * This time instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * The following three lines are identical in effect:\n+     * \u003cpre\u003e\n+     * TimeOfDay added \u003d dt.plusMinutes(6);\n+     * TimeOfDay added \u003d dt.plus(Period.minutes(6));\n+     * TimeOfDay added \u003d dt.withFieldAdded(DurationFieldType.minutes(), 6);\n+     * \u003c/pre\u003e\n+     *\n+     * @param minutes  the amount of minutes to add, may be negative\n+     * @return the new time plus the increased minutes\n+     * @since 1.1\n+     */\n+    public TimeOfDay plusMinutes(int minutes) {\n+        return withFieldAdded(DurationFieldType.minutes(), minutes);\n+    }\n+\n+    /**\n+     * Returns a new time plus the specified number of seconds.\n+     * \u003cp\u003e\n+     * This time instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * The following three lines are identical in effect:\n+     * \u003cpre\u003e\n+     * TimeOfDay added \u003d dt.plusSeconds(6);\n+     * TimeOfDay added \u003d dt.plus(Period.seconds(6));\n+     * TimeOfDay added \u003d dt.withFieldAdded(DurationFieldType.seconds(), 6);\n+     * \u003c/pre\u003e\n+     *\n+     * @param seconds  the amount of seconds to add, may be negative\n+     * @return the new time plus the increased seconds\n+     * @since 1.1\n+     */\n+    public TimeOfDay plusSeconds(int seconds) {\n+        return withFieldAdded(DurationFieldType.seconds(), seconds);\n+    }\n+\n+    /**\n+     * Returns a new time plus the specified number of millis.\n+     * \u003cp\u003e\n+     * This time instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * The following three lines are identical in effect:\n+     * \u003cpre\u003e\n+     * TimeOfDay added \u003d dt.plusMillis(6);\n+     * TimeOfDay added \u003d dt.plus(Period.millis(6));\n+     * TimeOfDay added \u003d dt.withFieldAdded(DurationFieldType.millis(), 6);\n+     * \u003c/pre\u003e\n+     *\n+     * @param millis  the amount of millis to add, may be negative\n+     * @return the new time plus the increased millis\n+     * @since 1.1\n+     */\n+    public TimeOfDay plusMillis(int millis) {\n+        return withFieldAdded(DurationFieldType.millis(), millis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this instance with the specified period take away,\n+     * wrapping to what would be a new day if required.\n+     * \u003cp\u003e\n+     * If the amount is zero or null, then \u003ccode\u003ethis\u003c/code\u003e is returned.\n+     * \u003cp\u003e\n+     * This method is typically used to subtract complex period instances.\n+     * Subtracting one field is best achieved using methods\n+     * like {@link #minusHours(int)}.\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this instance with the period taken away\n+     * @throws ArithmeticException if the new time exceeds capacity\n+     */\n+    public TimeOfDay minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new time minus the specified number of hours.\n+     * \u003cp\u003e\n+     * This time instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * The following three lines are identical in effect:\n+     * \u003cpre\u003e\n+     * TimeOfDay subtracted \u003d dt.minusHours(6);\n+     * TimeOfDay subtracted \u003d dt.minus(Period.hours(6));\n+     * TimeOfDay subtracted \u003d dt.withFieldAdded(DurationFieldType.hours(), -6);\n+     * \u003c/pre\u003e\n+     *\n+     * @param hours  the amount of hours to subtract, may be negative\n+     * @return the new time minus the increased hours\n+     * @since 1.1\n+     */\n+    public TimeOfDay minusHours(int hours) {\n+        return withFieldAdded(DurationFieldType.hours(), FieldUtils.safeNegate(hours));\n+    }\n+\n+    /**\n+     * Returns a new time minus the specified number of minutes.\n+     * \u003cp\u003e\n+     * This time instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * The following three lines are identical in effect:\n+     * \u003cpre\u003e\n+     * TimeOfDay subtracted \u003d dt.minusMinutes(6);\n+     * TimeOfDay subtracted \u003d dt.minus(Period.minutes(6));\n+     * TimeOfDay subtracted \u003d dt.withFieldAdded(DurationFieldType.minutes(), -6);\n+     * \u003c/pre\u003e\n+     *\n+     * @param minutes  the amount of minutes to subtract, may be negative\n+     * @return the new time minus the increased minutes\n+     * @since 1.1\n+     */\n+    public TimeOfDay minusMinutes(int minutes) {\n+        return withFieldAdded(DurationFieldType.minutes(), FieldUtils.safeNegate(minutes));\n+    }\n+\n+    /**\n+     * Returns a new time minus the specified number of seconds.\n+     * \u003cp\u003e\n+     * This time instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * The following three lines are identical in effect:\n+     * \u003cpre\u003e\n+     * TimeOfDay subtracted \u003d dt.minusSeconds(6);\n+     * TimeOfDay subtracted \u003d dt.minus(Period.seconds(6));\n+     * TimeOfDay subtracted \u003d dt.withFieldAdded(DurationFieldType.seconds(), -6);\n+     * \u003c/pre\u003e\n+     *\n+     * @param seconds  the amount of seconds to subtract, may be negative\n+     * @return the new time minus the increased seconds\n+     * @since 1.1\n+     */\n+    public TimeOfDay minusSeconds(int seconds) {\n+        return withFieldAdded(DurationFieldType.seconds(), FieldUtils.safeNegate(seconds));\n+    }\n+\n+    /**\n+     * Returns a new time minus the specified number of millis.\n+     * \u003cp\u003e\n+     * This time instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * The following three lines are identical in effect:\n+     * \u003cpre\u003e\n+     * TimeOfDay subtracted \u003d dt.minusMillis(6);\n+     * TimeOfDay subtracted \u003d dt.minus(Period.millis(6));\n+     * TimeOfDay subtracted \u003d dt.withFieldAdded(DurationFieldType.millis(), -6);\n+     * \u003c/pre\u003e\n+     *\n+     * @param millis  the amount of millis to subtract, may be negative\n+     * @return the new time minus the increased millis\n+     * @since 1.1\n+     */\n+    public TimeOfDay minusMillis(int millis) {\n+        return withFieldAdded(DurationFieldType.millis(), FieldUtils.safeNegate(millis));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains\n+     * many useful methods.\n+     *\n+     * @param type  the field type to get the property for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        return new Property(this, indexOfSupported(type));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this partial to a full datetime using the default time zone\n+     * setting the time fields from this instance and the date fields from\n+     * the current time.\n+     *\n+     * @return this date as a datetime with the time as the current time\n+     */\n+    public DateTime toDateTimeToday() {\n+        return toDateTimeToday(null);\n+    }\n+\n+    /**\n+     * Converts this partial to a full datetime using the specified time zone\n+     * setting the time fields from this instance and the date fields from\n+     * the current time.\n+     * \u003cp\u003e\n+     * This method uses the chronology from this instance plus the time zone\n+     * specified.\n+     *\n+     * @param zone  the zone to use, null means default\n+     * @return this date as a datetime with the time as the current time\n+     */\n+    public DateTime toDateTimeToday(DateTimeZone zone) {\n+        Chronology chrono \u003d getChronology().withZone(zone);\n+        long instantMillis \u003d DateTimeUtils.currentTimeMillis();\n+        long resolved \u003d chrono.set(this, instantMillis);\n+        return new DateTime(resolved, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day (0-23) field value.\n+     *\n+     * @return the hour of day\n+     */\n+    public int getHourOfDay() {\n+        return getValue(HOUR_OF_DAY);\n+    }\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @return the minute of hour\n+     */\n+    public int getMinuteOfHour() {\n+        return getValue(MINUTE_OF_HOUR);\n+    }\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @return the second of minute\n+     */\n+    public int getSecondOfMinute() {\n+        return getValue(SECOND_OF_MINUTE);\n+    }\n+\n+    /**\n+     * Get the millis of second field value.\n+     *\n+     * @return the millis of second\n+     */\n+    public int getMillisOfSecond() {\n+        return getValue(MILLIS_OF_SECOND);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day (0-23) field property\n+     * \n+     * @return the hour of day property\n+     */\n+    public Property hourOfDay() {\n+        return new Property(this, HOUR_OF_DAY);\n+    }\n+\n+    /**\n+     * Get the minute of hour field property\n+     * \n+     * @return the minute of hour property\n+     */\n+    public Property minuteOfHour() {\n+        return new Property(this, MINUTE_OF_HOUR);\n+    }\n+\n+    /**\n+     * Get the second of minute field property\n+     * \n+     * @return the second of minute property\n+     */\n+    public Property secondOfMinute() {\n+        return new Property(this, SECOND_OF_MINUTE);\n+    }\n+\n+    /**\n+     * Get the millis of second property\n+     * \n+     * @return the millis of second property\n+     */\n+    public Property millisOfSecond() {\n+        return new Property(this, MILLIS_OF_SECOND);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the time in the ISO8601 format THH:mm:ss.SSS.\n+     * \n+     * @return ISO8601 formatted string\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.tTime().print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The property class for \u003ccode\u003eTimeOfDay\u003c/code\u003e.\n+     * \u003cp\u003e\n+     * This class binds a \u003ccode\u003eTimeOfDay\u003c/code\u003e to a \u003ccode\u003eDateTimeField\u003c/code\u003e.\n+     * \n+     * @author Stephen Colebourne\n+     * @since 1.0\n+     */\n+    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID \u003d 5598459141741063833L;\n+\n+        /** The partial */\n+        private final TimeOfDay iTimeOfDay;\n+        /** The field index */\n+        private final int iFieldIndex;\n+\n+        /**\n+         * Constructs a property.\n+         * \n+         * @param partial  the partial instance\n+         * @param fieldIndex  the index in the partial\n+         */\n+        Property(TimeOfDay partial, int fieldIndex) {\n+            super();\n+            iTimeOfDay \u003d partial;\n+            iFieldIndex \u003d fieldIndex;\n+        }\n+\n+        /**\n+         * Gets the field that this property uses.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iTimeOfDay.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        protected ReadablePartial getReadablePartial() {\n+            return iTimeOfDay;\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public TimeOfDay getTimeOfDay() {\n+            return iTimeOfDay;\n+        }\n+\n+        /**\n+         * Gets the value of this field.\n+         * \n+         * @return the field value\n+         */\n+        public int get() {\n+            return iTimeOfDay.getValue(iFieldIndex);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to the value of this field in a copy of this TimeOfDay,\n+         * wrapping to what would be the next day if necessary.\n+         * \u003cp\u003e\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it will affect larger fields.\n+         * Smaller fields are unaffected.\n+         * \u003cp\u003e\n+         * If the result would be too large, beyond 23:59:59:999, then the\n+         * calculation wraps to 00:00:00.000. For the alternate strict behaviour\n+         * with no wrapping see {@link #addNoWrapToCopy(int)}.\n+         * \u003cp\u003e\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn\u0027t valid\n+         */\n+        public TimeOfDay addToCopy(int valueToAdd) {\n+            int[] newValues \u003d iTimeOfDay.getValues();\n+            newValues \u003d getField().addWrapPartial(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n+        }\n+\n+        /**\n+         * Adds to the value of this field in a copy of this TimeOfDay,\n+         * throwing an Exception if the bounds are exceeded.\n+         * \u003cp\u003e\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it will affect larger fields.\n+         * Smaller fields are unaffected.\n+         * \u003cp\u003e\n+         * If the result would be too large (beyond 23:59:59:999) or too\n+         * small (less than 00:00:00.000) then an Execption is thrown.\n+         * For the alternate behaviour which wraps to the next \u0027day\u0027,\n+         * see {@link #addToCopy(int)}.\n+         * \u003cp\u003e\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn\u0027t valid\n+         */\n+        public TimeOfDay addNoWrapToCopy(int valueToAdd) {\n+            int[] newValues \u003d iTimeOfDay.getValues();\n+            newValues \u003d getField().add(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n+        }\n+\n+        /**\n+         * Adds to the value of this field in a copy of this TimeOfDay wrapping\n+         * within this field if the maximum value is reached.\n+         * \u003cp\u003e\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it wraps within this field.\n+         * Other fields are unaffected.\n+         * \u003cp\u003e\n+         * For example,\n+         * \u003ccode\u003e12:59:37\u003c/code\u003e addWrapField one minute returns \u003ccode\u003e12:00:37\u003c/code\u003e.\n+         * \u003cp\u003e\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn\u0027t valid\n+         */\n+        public TimeOfDay addWrapFieldToCopy(int valueToAdd) {\n+            int[] newValues \u003d iTimeOfDay.getValues();\n+            newValues \u003d getField().addWrapField(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the TimeOfDay.\n+         * \u003cp\u003e\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn\u0027t valid\n+         */\n+        public TimeOfDay setCopy(int value) {\n+            int[] newValues \u003d iTimeOfDay.getValues();\n+            newValues \u003d getField().set(iTimeOfDay, iFieldIndex, newValues, value);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the TimeOfDay to a parsed text value.\n+         * \u003cp\u003e\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the text value isn\u0027t valid\n+         */\n+        public TimeOfDay setCopy(String text, Locale locale) {\n+            int[] newValues \u003d iTimeOfDay.getValues();\n+            newValues \u003d getField().set(iTimeOfDay, iFieldIndex, newValues, text, locale);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the TimeOfDay to a parsed text value.\n+         * \u003cp\u003e\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the text value isn\u0027t valid\n+         */\n+        public TimeOfDay setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+    }\n+\n+}\n",
      "operations": [
        {
          "type": "update-node",
          "from": "",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "JodaTime/src/java/org/joda/time/YearMonthDay.java",
        "JodaTime/src/java/org/joda/time/YearMonthDay.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [],
          "num": 0
        },
        {
          "qualified_names": [
            "org.joda.time.YearMonthDay:YearMonthDay:[YearMonthDay partial, int[] values]:null",
            "org.joda.time.YearMonthDay:toDateTime:[TimeOfDay time, DateTimeZone zone]:DateTime",
            "org.joda.time.YearMonthDay:toDateTimeAtCurrentTime:[DateTimeZone zone]:DateTime",
            "org.joda.time.YearMonthDay:minusYears:[int years]:YearMonthDay",
            "org.joda.time.YearMonthDay\\$Property:setCopy:[String text, Locale locale]:YearMonthDay",
            "org.joda.time.YearMonthDay:plusYears:[int years]:YearMonthDay",
            "org.joda.time.YearMonthDay:getDayOfMonth:[]:int",
            "org.joda.time.YearMonthDay:YearMonthDay:[int year, int monthOfYear, int dayOfMonth]:null",
            "org.joda.time.YearMonthDay:getFieldType:[int index]:DateTimeFieldType",
            "org.joda.time.YearMonthDay:withPeriodAdded:[ReadablePeriod period, int scalar]:YearMonthDay",
            "org.joda.time.YearMonthDay:getMonthOfYear:[]:int",
            "org.joda.time.YearMonthDay:YearMonthDay:[YearMonthDay partial, Chronology chrono]:null",
            "org.joda.time.YearMonthDay:withChronologyRetainFields:[Chronology newChronology]:YearMonthDay",
            "org.joda.time.YearMonthDay:plusMonths:[int months]:YearMonthDay",
            "org.joda.time.YearMonthDay:toInterval:[DateTimeZone zone]:Interval",
            "org.joda.time.YearMonthDay:dayOfMonth:[]:Property",
            "org.joda.time.YearMonthDay:YearMonthDay:[int year, int monthOfYear, int dayOfMonth, Chronology chronology]:null",
            "org.joda.time.YearMonthDay:YearMonthDay:[long instant, Chronology chronology]:null",
            "org.joda.time.YearMonthDay:toInterval:[]:Interval",
            "org.joda.time.YearMonthDay:toString:[]:String",
            "org.joda.time.YearMonthDay\\$Property:setCopy:[int value]:YearMonthDay",
            "org.joda.time.YearMonthDay:year:[]:Property",
            "org.joda.time.YearMonthDay:YearMonthDay:[long instant]:null",
            "org.joda.time.YearMonthDay:plus:[ReadablePeriod period]:YearMonthDay",
            "org.joda.time.YearMonthDay:YearMonthDay:[Object instant]:null",
            "org.joda.time.YearMonthDay:withField:[DateTimeFieldType fieldType, int value]:YearMonthDay",
            "org.joda.time.YearMonthDay:toDateTimeAtCurrentTime:[]:DateTime",
            "org.joda.time.YearMonthDay:YearMonthDay:[Object instant, Chronology chronology]:null",
            "org.joda.time.YearMonthDay\\$Property:getField:[]:DateTimeField",
            "org.joda.time.YearMonthDay:toDateTime:[TimeOfDay time]:DateTime",
            "org.joda.time.YearMonthDay:getYear:[]:int",
            "org.joda.time.YearMonthDay\\$Property:addWrapFieldToCopy:[int valueToAdd]:YearMonthDay",
            "org.joda.time.YearMonthDay\\$Property:setCopy:[String text]:YearMonthDay",
            "org.joda.time.YearMonthDay:withFieldAdded:[DurationFieldType fieldType, int amount]:YearMonthDay",
            "org.joda.time.YearMonthDay:minusMonths:[int months]:YearMonthDay",
            "org.joda.time.YearMonthDay:getFieldTypes:[]:DateTimeFieldType[]",
            "org.joda.time.YearMonthDay:getField:[int index, Chronology chrono]:DateTimeField",
            "org.joda.time.YearMonthDay:YearMonthDay:[DateTimeZone zone]:null",
            "org.joda.time.YearMonthDay:minus:[ReadablePeriod period]:YearMonthDay",
            "org.joda.time.YearMonthDay\\$Property:addToCopy:[int valueToAdd]:YearMonthDay",
            "org.joda.time.YearMonthDay\\$Property:getYearMonthDay:[]:YearMonthDay",
            "org.joda.time.YearMonthDay:YearMonthDay:[]:null",
            "org.joda.time.YearMonthDay:toDateTimeAtMidnight:[DateTimeZone zone]:DateTime",
            "org.joda.time.YearMonthDay:minusDays:[int days]:YearMonthDay",
            "org.joda.time.YearMonthDay\\$Property:getReadablePartial:[]:ReadablePartial",
            "org.joda.time.YearMonthDay:YearMonthDay:[Chronology chronology]:null",
            "org.joda.time.YearMonthDay:plusDays:[int days]:YearMonthDay",
            "org.joda.time.YearMonthDay:property:[DateTimeFieldType type]:Property",
            "org.joda.time.YearMonthDay:monthOfYear:[]:Property",
            "org.joda.time.YearMonthDay\\$Property:get:[]:int",
            "org.joda.time.YearMonthDay:toDateTimeAtMidnight:[]:DateTime",
            "org.joda.time.YearMonthDay:toDateMidnight:[]:DateMidnight",
            "org.joda.time.YearMonthDay:toDateMidnight:[DateTimeZone zone]:DateMidnight",
            "org.joda.time.YearMonthDay\\$Property:Property:[YearMonthDay partial, int fieldIndex]:null",
            "org.joda.time.YearMonthDay:size:[]:int"
          ],
          "num": 55
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "-1"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10",
            "11",
            "12",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "27",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "37",
            "38",
            "39",
            "40",
            "41",
            "42",
            "43",
            "44",
            "45",
            "46",
            "47",
            "48",
            "49",
            "50",
            "51",
            "52",
            "53",
            "54",
            "55",
            "56",
            "57",
            "58",
            "59",
            "60",
            "61",
            "62",
            "63",
            "64",
            "65",
            "66",
            "67",
            "68",
            "69",
            "70",
            "71",
            "72",
            "73",
            "74",
            "75",
            "76",
            "77",
            "78",
            "79",
            "80",
            "81",
            "82",
            "83",
            "84",
            "85",
            "86",
            "87",
            "88",
            "89",
            "90",
            "91",
            "92",
            "93",
            "94",
            "95",
            "96",
            "97",
            "98",
            "99",
            "100",
            "101",
            "102",
            "103",
            "104",
            "105",
            "106",
            "107",
            "108",
            "109",
            "110",
            "111",
            "112",
            "113",
            "114",
            "115",
            "116",
            "117",
            "118",
            "119",
            "120",
            "121",
            "122",
            "123",
            "124",
            "125",
            "126",
            "127",
            "128",
            "129",
            "130",
            "131",
            "132",
            "133",
            "134",
            "135",
            "136",
            "137",
            "138",
            "139",
            "140",
            "141",
            "142",
            "143",
            "144",
            "145",
            "146",
            "147",
            "148",
            "149",
            "150",
            "151",
            "152",
            "153",
            "154",
            "155",
            "156",
            "157",
            "158",
            "159",
            "160",
            "161",
            "162",
            "163",
            "164",
            "165",
            "166",
            "167",
            "168",
            "169",
            "170",
            "171",
            "172",
            "173",
            "174",
            "175",
            "176",
            "177",
            "178",
            "179",
            "180",
            "181",
            "182",
            "183",
            "184",
            "185",
            "186",
            "187",
            "188",
            "189",
            "190",
            "191",
            "192",
            "193",
            "194",
            "195",
            "196",
            "197",
            "198",
            "199",
            "200",
            "201",
            "202",
            "203",
            "204",
            "205",
            "206",
            "207",
            "208",
            "209",
            "210",
            "211",
            "212",
            "213",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "220",
            "221",
            "222",
            "223",
            "224",
            "225",
            "226",
            "227",
            "228",
            "229",
            "230",
            "231",
            "232",
            "233",
            "234",
            "235",
            "236",
            "237",
            "238",
            "239",
            "240",
            "241",
            "242",
            "243",
            "244",
            "245",
            "246",
            "247",
            "248",
            "249",
            "250",
            "251",
            "252",
            "253",
            "254",
            "255",
            "256",
            "257",
            "258",
            "259",
            "260",
            "261",
            "262",
            "263",
            "264",
            "265",
            "266",
            "267",
            "268",
            "269",
            "270",
            "271",
            "272",
            "273",
            "274",
            "275",
            "276",
            "277",
            "278",
            "279",
            "280",
            "281",
            "282",
            "283",
            "284",
            "285",
            "286",
            "287",
            "288",
            "289",
            "290",
            "291",
            "292",
            "293",
            "294",
            "295",
            "296",
            "297",
            "298",
            "299",
            "300",
            "301",
            "302",
            "303",
            "304",
            "305",
            "306",
            "307",
            "308",
            "309",
            "310",
            "311",
            "312",
            "313",
            "314",
            "315",
            "316",
            "317",
            "318",
            "319",
            "320",
            "321",
            "322",
            "323",
            "324",
            "325",
            "326",
            "327",
            "328",
            "329",
            "330",
            "331",
            "332",
            "333",
            "334",
            "335",
            "336",
            "337",
            "338",
            "339",
            "340",
            "341",
            "342",
            "343",
            "344",
            "345",
            "346",
            "347",
            "348",
            "349",
            "350",
            "351",
            "352",
            "353",
            "354",
            "355",
            "356",
            "357",
            "358",
            "359",
            "360",
            "361",
            "362",
            "363",
            "364",
            "365",
            "366",
            "367",
            "368",
            "369",
            "370",
            "371",
            "372",
            "373",
            "374",
            "375",
            "376",
            "377",
            "378",
            "379",
            "380",
            "381",
            "382",
            "383",
            "384",
            "385",
            "386",
            "387",
            "388",
            "389",
            "390",
            "391",
            "392",
            "393",
            "394",
            "395",
            "396",
            "397",
            "398",
            "399",
            "400",
            "401",
            "402",
            "403",
            "404",
            "405",
            "406",
            "407",
            "408",
            "409",
            "410",
            "411",
            "412",
            "413",
            "414",
            "415",
            "416",
            "417",
            "418",
            "419",
            "420",
            "421",
            "422",
            "423",
            "424",
            "425",
            "426",
            "427",
            "428",
            "429",
            "430",
            "431",
            "432",
            "433",
            "434",
            "435",
            "436",
            "437",
            "438",
            "439",
            "440",
            "441",
            "442",
            "443",
            "444",
            "445",
            "446",
            "447",
            "448",
            "449",
            "450",
            "451",
            "452",
            "453",
            "454",
            "455",
            "456",
            "457",
            "458",
            "459",
            "460",
            "461",
            "462",
            "463",
            "464",
            "465",
            "466",
            "467",
            "468",
            "469",
            "470",
            "471",
            "472",
            "473",
            "474",
            "475",
            "476",
            "477",
            "478",
            "479",
            "480",
            "481",
            "482",
            "483",
            "484",
            "485",
            "486",
            "487",
            "488",
            "489",
            "490",
            "491",
            "492",
            "493",
            "494",
            "495",
            "496",
            "497",
            "498",
            "499",
            "500",
            "501",
            "502",
            "503",
            "504",
            "505",
            "506",
            "507",
            "508",
            "509",
            "510",
            "511",
            "512",
            "513",
            "514",
            "515",
            "516",
            "517",
            "518",
            "519",
            "520",
            "521",
            "522",
            "523",
            "524",
            "525",
            "526",
            "527",
            "528",
            "529",
            "530",
            "531",
            "532",
            "533",
            "534",
            "535",
            "536",
            "537",
            "538",
            "539",
            "540",
            "541",
            "542",
            "543",
            "544",
            "545",
            "546",
            "547",
            "548",
            "549",
            "550",
            "551",
            "552",
            "553",
            "554",
            "555",
            "556",
            "557",
            "558",
            "559",
            "560",
            "561",
            "562",
            "563",
            "564",
            "565",
            "566",
            "567",
            "568",
            "569",
            "570",
            "571",
            "572",
            "573",
            "574",
            "575",
            "576",
            "577",
            "578",
            "579",
            "580",
            "581",
            "582",
            "583",
            "584",
            "585",
            "586",
            "587",
            "588",
            "589",
            "590",
            "591",
            "592",
            "593",
            "594",
            "595",
            "596",
            "597",
            "598",
            "599",
            "600",
            "601",
            "602",
            "603",
            "604",
            "605",
            "606",
            "607",
            "608",
            "609",
            "610",
            "611",
            "612",
            "613",
            "614",
            "615",
            "616",
            "617",
            "618",
            "619",
            "620",
            "621",
            "622",
            "623",
            "624",
            "625",
            "626",
            "627",
            "628",
            "629",
            "630",
            "631",
            "632",
            "633",
            "634",
            "635",
            "636",
            "637",
            "638",
            "639",
            "640",
            "641",
            "642",
            "643",
            "644",
            "645",
            "646",
            "647",
            "648",
            "649",
            "650",
            "651",
            "652",
            "653",
            "654",
            "655",
            "656",
            "657",
            "658",
            "659",
            "660",
            "661",
            "662",
            "663",
            "664",
            "665",
            "666",
            "667",
            "668",
            "669",
            "670",
            "671",
            "672",
            "673",
            "674",
            "675",
            "676",
            "677",
            "678",
            "679",
            "680",
            "681",
            "682",
            "683",
            "684",
            "685",
            "686",
            "687",
            "688",
            "689",
            "690",
            "691",
            "692",
            "693",
            "694",
            "695",
            "696",
            "697",
            "698",
            "699",
            "700",
            "701",
            "702",
            "703",
            "704",
            "705",
            "706",
            "707",
            "708",
            "709",
            "710",
            "711",
            "712",
            "713",
            "714",
            "715",
            "716",
            "717",
            "718",
            "719",
            "720",
            "721",
            "722",
            "723",
            "724",
            "725",
            "726",
            "727",
            "728",
            "729",
            "730",
            "731",
            "732",
            "733",
            "734",
            "735",
            "736",
            "737",
            "738",
            "739",
            "740",
            "741",
            "742",
            "743",
            "744",
            "745",
            "746",
            "747",
            "748",
            "749",
            "750",
            "751",
            "752",
            "753",
            "754",
            "755",
            "756",
            "757",
            "758",
            "759",
            "760",
            "761",
            "762",
            "763",
            "764",
            "765",
            "766",
            "767",
            "768",
            "769",
            "770",
            "771",
            "772",
            "773",
            "774",
            "775",
            "776",
            "777",
            "778",
            "779",
            "780",
            "781",
            "782",
            "783",
            "784",
            "785",
            "786",
            "787",
            "788",
            "789",
            "790",
            "791",
            "792",
            "793",
            "794",
            "795",
            "796",
            "797",
            "798",
            "799",
            "800",
            "801",
            "802",
            "803",
            "804",
            "805",
            "806",
            "807",
            "808",
            "809",
            "810",
            "811",
            "812",
            "813",
            "814",
            "815",
            "816",
            "817",
            "818",
            "819",
            "820",
            "821",
            "822",
            "823",
            "824",
            "825",
            "826",
            "827",
            "828",
            "829",
            "830",
            "831",
            "832",
            "833",
            "834",
            "835",
            "836",
            "837",
            "838",
            "839",
            "840",
            "841",
            "842",
            "843",
            "844",
            "845",
            "846",
            "847",
            "848",
            "849",
            "850",
            "851",
            "852",
            "853",
            "854",
            "855",
            "856",
            "857",
            "858",
            "859",
            "860",
            "861",
            "862",
            "863",
            "864",
            "865",
            "866",
            "867",
            "868",
            "869",
            "870",
            "871",
            "872",
            "873",
            "874",
            "875",
            "876",
            "877",
            "878",
            "879",
            "880",
            "881",
            "882",
            "883",
            "884",
            "885",
            "886",
            "887",
            "888",
            "889",
            "890",
            "891",
            "892",
            "893",
            "894",
            "895",
            "896",
            "897",
            "898",
            "899",
            "900",
            "901",
            "902",
            "903",
            "904",
            "905",
            "906",
            "907",
            "908",
            "909",
            "910",
            "911",
            "912",
            "913",
            "914",
            "915",
            "916",
            "917",
            "918",
            "919",
            "920",
            "921",
            "922",
            "923",
            "924",
            "925",
            "926",
            "927",
            "928",
            "929",
            "930",
            "931",
            "932",
            "933",
            "934",
            "935",
            "936",
            "937",
            "938",
            "939",
            "940",
            "941",
            "942",
            "943",
            "944",
            "945"
          ],
          "num": 945
        }
      ],
      "diff": "diff --git a/JodaTime/src/java/org/joda/time/YearMonthDay.java b/JodaTime/src/java/org/joda/time/YearMonthDay.java\nnew file mode 100644\nindex 0000000..96bd0e4\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/YearMonthDay.java\n@@ -0,0 +1,945 @@\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+import org.joda.time.base.BasePartial;\n+import org.joda.time.field.AbstractPartialFieldProperty;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * YearMonthDay is an immutable partial supporting the year, monthOfYear\n+ * and dayOfMonth fields.\n+ * \u003cp\u003e\n+ * Calculations on YearMonthDay are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * \u003cp\u003e\n+ * Each individual field can be queried in two ways:\n+ * \u003cul\u003e\n+ * \u003cli\u003e\u003ccode\u003egetMonthOfYear()\u003c/code\u003e\n+ * \u003cli\u003e\u003ccode\u003emonthOfYear().get()\u003c/code\u003e\n+ * \u003c/ul\u003e\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * \u003cul\u003e\n+ * \u003cli\u003enumeric value - \u003ccode\u003emonthOfYear().get()\u003c/code\u003e\n+ * \u003cli\u003etext value - \u003ccode\u003emonthOfYear().getAsText()\u003c/code\u003e\n+ * \u003cli\u003eshort text value - \u003ccode\u003emonthOfYear().getAsShortText()\u003c/code\u003e\n+ * \u003cli\u003emaximum/minimum values - \u003ccode\u003emonthOfYear().getMaximumValue()\u003c/code\u003e\n+ * \u003cli\u003eadd/subtract - \u003ccode\u003emonthOfYear().addToCopy()\u003c/code\u003e\n+ * \u003cli\u003eset - \u003ccode\u003emonthOfYear().setCopy()\u003c/code\u003e\n+ * \u003c/ul\u003e\n+ * \u003cp\u003e\n+ * YearMonthDay is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class YearMonthDay\n+        extends BasePartial\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID \u003d 797544782896179L;\n+    /** The singleton set of field types */\n+    private static final DateTimeFieldType[] FIELD_TYPES \u003d new DateTimeFieldType[] {\n+        DateTimeFieldType.year(),\n+        DateTimeFieldType.monthOfYear(),\n+        DateTimeFieldType.dayOfMonth(),\n+    };\n+\n+    /** The index of the year field in the field array */\n+    public static final int YEAR \u003d 0;\n+    /** The index of the monthOfYear field in the field array */\n+    public static final int MONTH_OF_YEAR \u003d 1;\n+    /** The index of the dayOfMonth field in the field array */\n+    public static final int DAY_OF_MONTH \u003d 2;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a YearMonthDay with the current date, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * \u003cp\u003e\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     */\n+    public YearMonthDay() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with the current date, using ISOChronology in\n+     * the specified zone to extract the fields.\n+     * \u003cp\u003e\n+     * The constructor uses the specified time zone to obtain the current date.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     * \n+     * @param zone  the zone to use, null means default zone\n+     * @since 1.1\n+     */\n+    public YearMonthDay(DateTimeZone zone) {\n+        super(ChronologyType.iso().getChronology(zone));\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with the current date, using the specified chronology\n+     * and zone to extract the fields.\n+     * \u003cp\u003e\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public YearMonthDay(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay extracting the partial fields from the specified\n+     * milliseconds using the ISOChronology in the default zone.\n+     * \u003cp\u003e\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public YearMonthDay(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay extracting the partial fields from the specified\n+     * milliseconds using the chronology provided.\n+     * \u003cp\u003e\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public YearMonthDay(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay from an Object that represents a time.\n+     * \u003cp\u003e\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * \u003cp\u003e\n+     * The chronology used will be derived from the object, defaulting to ISO.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public YearMonthDay(Object instant) {\n+        super(instant, null);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay from an Object that represents a time, using the\n+     * specified chronology.\n+     * \u003cp\u003e\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * \u003cp\u003e\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     * The specified chronology overrides that of the object.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @param chronology  the chronology, null means ISO default\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public YearMonthDay(Object instant, Chronology chronology) {\n+        super(instant, DateTimeUtils.getChronology(chronology));\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with specified time field values\n+     * using \u003ccode\u003eISOChronology\u003c/code\u003e in the default zone.\n+     * \u003cp\u003e\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     */\n+    public YearMonthDay(int year, int monthOfYear, int dayOfMonth) {\n+        this(year, monthOfYear, dayOfMonth, null);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with specified time field values.\n+     * \u003cp\u003e\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {\n+        super(new int[] {year, monthOfYear, dayOfMonth}, chronology);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with chronology from this instance and new values.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param values  the new set of values\n+     */\n+    YearMonthDay(YearMonthDay partial, int[] values) {\n+        super(partial, values);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with values from this instance and a new chronology.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param chrono  the new chronology\n+     */\n+    YearMonthDay(YearMonthDay partial, Chronology chrono) {\n+        super(partial, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial.\n+     * \n+     * @return the field count\n+     */\n+    public int size() {\n+        return 3;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * \u003cp\u003e\n+     * This method must not use any instance variables.\n+     * \n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        switch (index) {\n+            case YEAR:\n+                return chrono.year();\n+            case MONTH_OF_YEAR:\n+                return chrono.monthOfYear();\n+            case DAY_OF_MONTH:\n+                return chrono.dayOfMonth();\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeFieldType getFieldType(int index) {\n+        return FIELD_TYPES[index];\n+    }\n+\n+    /**\n+     * Gets an array of the field type of each of the fields that this partial supports.\n+     * \u003cp\u003e\n+     * The fields are returned largest to smallest, Year, Month, Day\n+     *\n+     * @return the array of field types (cloned), largest to smallest\n+     */\n+    public DateTimeFieldType[] getFieldTypes() {\n+        return (DateTimeFieldType[]) FIELD_TYPES.clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new YearMonthDay instance with the specified chronology.\n+     * This instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * This method retains the values of the fields, thus the result will\n+     * typically refer to a different instant.\n+     * \u003cp\u003e\n+     * The time zone of the specified chronology is ignored, as YearMonthDay\n+     * operates without a time zone.\n+     *\n+     * @param newChronology  the new chronology, null means ISO\n+     * @return a copy of this datetime with a different chronology\n+     * @throws IllegalArgumentException if the values are invalid for the new chronology\n+     */\n+    public YearMonthDay withChronologyRetainFields(Chronology newChronology) {\n+        newChronology \u003d DateTimeUtils.getChronology(newChronology);\n+        newChronology \u003d newChronology.withUTC();\n+        if (newChronology \u003d\u003d getChronology()) {\n+            return this;\n+        } else {\n+            YearMonthDay newYearMonthDay \u003d new YearMonthDay(this, newChronology);\n+            newChronology.validate(newYearMonthDay, getValues());\n+            return newYearMonthDay;\n+        }\n+    }\n+\n+    /**\n+     * Gets a copy of this date with the specified field set to a new value.\n+     * \u003cp\u003e\n+     * For example, if the field type is \u003ccode\u003edayOfMonth\u003c/code\u003e then the day\n+     * would be changed in the returned instance.\n+     * \u003cp\u003e\n+     * These three lines are equivalent:\n+     * \u003cpre\u003e\n+     * YearMonthDay updated \u003d ymd.withField(DateTimeFieldType.dayOfMonth(), 6);\n+     * YearMonthDay updated \u003d ymd.dayOfMonth().setCopy(6);\n+     * YearMonthDay updated \u003d ymd.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n+     * \u003c/pre\u003e\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public YearMonthDay withField(DateTimeFieldType fieldType, int value) {\n+        int index \u003d indexOfSupported(fieldType);\n+        if (value \u003d\u003d getValue(index)) {\n+            return this;\n+        }\n+        int[] newValues \u003d getValues();\n+        newValues \u003d getField(index).set(this, index, newValues, value);\n+        return new YearMonthDay(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this date with the value of the specified field increased.\n+     * \u003cp\u003e\n+     * If the addition is zero, then \u003ccode\u003ethis\u003c/code\u003e is returned.\n+     * \u003cp\u003e\n+     * These three lines are equivalent:\n+     * \u003cpre\u003e\n+     * YearMonthDay added \u003d ymd.withFieldAdded(DurationFieldType.days(), 6);\n+     * YearMonthDay added \u003d ymd.plusDays(6);\n+     * YearMonthDay added \u003d ymd.dayOfMonth().addToCopy(6);\n+     * \u003c/pre\u003e\n+     * \n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n+        int index \u003d indexOfSupported(fieldType);\n+        if (amount \u003d\u003d 0) {\n+            return this;\n+        }\n+        int[] newValues \u003d getValues();\n+        newValues \u003d getField(index).add(this, index, newValues, amount);\n+        return new YearMonthDay(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this date with the specified period added.\n+     * \u003cp\u003e\n+     * If the addition is zero, then \u003ccode\u003ethis\u003c/code\u003e is returned.\n+     * Fields in the period that aren\u0027t present in the partial are ignored.\n+     * \u003cp\u003e\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using methods\n+     * like {@link #withFieldAdded(DurationFieldType, int)}\n+     * or {@link #plusYears(int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period \u003d\u003d null || scalar \u003d\u003d 0) {\n+            return this;\n+        }\n+        int[] newValues \u003d getValues();\n+        for (int i \u003d 0; i \u003c period.size(); i++) {\n+            DurationFieldType fieldType \u003d period.getFieldType(i);\n+            int index \u003d indexOf(fieldType);\n+            if (index \u003e\u003d 0) {\n+                newValues \u003d getField(index).add(this, index, newValues,\n+                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n+            }\n+        }\n+        return new YearMonthDay(this, newValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this instance with the specified period added.\n+     * \u003cp\u003e\n+     * If the amount is zero or null, then \u003ccode\u003ethis\u003c/code\u003e is returned.\n+     * \u003cp\u003e\n+     * This method is typically used to add complex period instances.\n+     * Adding one field is best achieved using methods\n+     * like {@link #plusYears(int)}.\n+     * \n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public YearMonthDay plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new date plus the specified number of years.\n+     * \u003cp\u003e\n+     * This date instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * The following three lines are identical in effect:\n+     * \u003cpre\u003e\n+     * YearMonthDay added \u003d dt.plusYears(6);\n+     * YearMonthDay added \u003d dt.plus(Period.years(6));\n+     * YearMonthDay added \u003d dt.withFieldAdded(DurationFieldType.years(), 6);\n+     * \u003c/pre\u003e\n+     *\n+     * @param years  the amount of years to add, may be negative\n+     * @return the new date plus the increased years\n+     * @since 1.1\n+     */\n+    public YearMonthDay plusYears(int years) {\n+        return withFieldAdded(DurationFieldType.years(), years);\n+    }\n+\n+    /**\n+     * Returns a new date plus the specified number of months.\n+     * \u003cp\u003e\n+     * This date instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * The following three lines are identical in effect:\n+     * \u003cpre\u003e\n+     * YearMonthDay added \u003d dt.plusMonths(6);\n+     * YearMonthDay added \u003d dt.plus(Period.months(6));\n+     * YearMonthDay added \u003d dt.withFieldAdded(DurationFieldType.months(), 6);\n+     * \u003c/pre\u003e\n+     *\n+     * @param months  the amount of months to add, may be negative\n+     * @return the new date plus the increased months\n+     * @since 1.1\n+     */\n+    public YearMonthDay plusMonths(int months) {\n+        return withFieldAdded(DurationFieldType.months(), months);\n+    }\n+\n+    /**\n+     * Returns a new date plus the specified number of days.\n+     * \u003cp\u003e\n+     * This date instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * The following three lines are identical in effect:\n+     * \u003cpre\u003e\n+     * YearMonthDay added \u003d dt.plusDays(6);\n+     * YearMonthDay added \u003d dt.plus(Period.days(6));\n+     * YearMonthDay added \u003d dt.withFieldAdded(DurationFieldType.days(), 6);\n+     * \u003c/pre\u003e\n+     *\n+     * @param days  the amount of days to add, may be negative\n+     * @return the new date plus the increased days\n+     * @since 1.1\n+     */\n+    public YearMonthDay plusDays(int days) {\n+        return withFieldAdded(DurationFieldType.days(), days);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this instance with the specified period take away.\n+     * \u003cp\u003e\n+     * If the amount is zero or null, then \u003ccode\u003ethis\u003c/code\u003e is returned.\n+     * \u003cp\u003e\n+     * This method is typically used to subtract complex period instances.\n+     * Subtracting one field is best achieved using methods\n+     * like {@link #minusYears(int)}.\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this instance with the period taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public YearMonthDay minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new datetime minus the specified number of years.\n+     * \u003cp\u003e\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * The following three lines are identical in effect:\n+     * \u003cpre\u003e\n+     * YearMonthDay subtracted \u003d dt.minusYears(6);\n+     * YearMonthDay subtracted \u003d dt.minus(Period.years(6));\n+     * YearMonthDay subtracted \u003d dt.withFieldAdded(DurationFieldType.years(), -6);\n+     * \u003c/pre\u003e\n+     *\n+     * @param years  the amount of years to subtract, may be negative\n+     * @return the new datetime minus the increased years\n+     * @since 1.1\n+     */\n+    public YearMonthDay minusYears(int years) {\n+        return withFieldAdded(DurationFieldType.years(), FieldUtils.safeNegate(years));\n+    }\n+\n+    /**\n+     * Returns a new datetime minus the specified number of months.\n+     * \u003cp\u003e\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * The following three lines are identical in effect:\n+     * \u003cpre\u003e\n+     * YearMonthDay subtracted \u003d dt.minusMonths(6);\n+     * YearMonthDay subtracted \u003d dt.minus(Period.months(6));\n+     * YearMonthDay subtracted \u003d dt.withFieldAdded(DurationFieldType.months(), -6);\n+     * \u003c/pre\u003e\n+     *\n+     * @param months  the amount of months to subtract, may be negative\n+     * @return the new datetime minus the increased months\n+     * @since 1.1\n+     */\n+    public YearMonthDay minusMonths(int months) {\n+        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n+    }\n+\n+    /**\n+     * Returns a new datetime minus the specified number of days.\n+     * \u003cp\u003e\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * The following three lines are identical in effect:\n+     * \u003cpre\u003e\n+     * YearMonthDay subtracted \u003d dt.minusDays(6);\n+     * YearMonthDay subtracted \u003d dt.minus(Period.days(6));\n+     * YearMonthDay subtracted \u003d dt.withFieldAdded(DurationFieldType.days(), -6);\n+     * \u003c/pre\u003e\n+     *\n+     * @param days  the amount of days to subtract, may be negative\n+     * @return the new datetime minus the increased days\n+     * @since 1.1\n+     */\n+    public YearMonthDay minusDays(int days) {\n+        return withFieldAdded(DurationFieldType.days(), FieldUtils.safeNegate(days));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains\n+     * many useful methods.\n+     *\n+     * @param type  the field type to get the property for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        return new Property(this, indexOfSupported(type));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this YearMonthDay to a full datetime at midnight using the\n+     * default time zone.\n+     *\n+     * @return this date as a datetime at midnight\n+     */\n+    public DateTime toDateTimeAtMidnight() {\n+        return toDateTimeAtMidnight(null);\n+    }\n+\n+    /**\n+     * Converts this YearMonthDay to a full datetime at midnight using the\n+     * specified time zone.\n+     * \u003cp\u003e\n+     * This method uses the chronology from this instance plus the time zone\n+     * specified.\n+     *\n+     * @param zone  the zone to use, null means default\n+     * @return this date as a datetime at midnight\n+     */\n+    public DateTime toDateTimeAtMidnight(DateTimeZone zone) {\n+        Chronology chrono \u003d getChronology().withZone(zone);\n+        return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this partial to a full datetime using the default time zone\n+     * setting the date fields from this instance and the time fields from\n+     * the current time.\n+     *\n+     * @return this date as a datetime with the time as the current time\n+     */\n+    public DateTime toDateTimeAtCurrentTime() {\n+        return toDateTimeAtCurrentTime(null);\n+    }\n+\n+    /**\n+     * Converts this partial to a full datetime using the specified time zone\n+     * setting the date fields from this instance and the time fields from\n+     * the current time.\n+     * \u003cp\u003e\n+     * This method uses the chronology from this instance plus the time zone\n+     * specified.\n+     *\n+     * @param zone  the zone to use, null means default\n+     * @return this date as a datetime with the time as the current time\n+     */\n+    public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {\n+        Chronology chrono \u003d getChronology().withZone(zone);\n+        long instantMillis \u003d DateTimeUtils.currentTimeMillis();\n+        long resolved \u003d chrono.set(this, instantMillis);\n+        return new DateTime(resolved, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a DateMidnight in the default time zone.\n+     *\n+     * @return the DateMidnight instance in the default zone\n+     */\n+    public DateMidnight toDateMidnight() {\n+        return toDateMidnight(null);\n+    }\n+\n+    /**\n+     * Converts this object to a DateMidnight.\n+     *\n+     * @param zone  the zone to get the DateMidnight in, null means default\n+     * @return the DateMidnight instance\n+     */\n+    public DateMidnight toDateMidnight(DateTimeZone zone) {\n+        Chronology chrono \u003d getChronology().withZone(zone);\n+        return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a DateTime using a TimeOfDay to fill in the\n+     * missing fields and using the default time zone.\n+     * This instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * The resulting chronology is determined by the chronology of this\n+     * YearMonthDay plus the time zone.\n+     * The chronology of the time is ignored - only the field values are used.\n+     *\n+     * @param time  the time of day to use, null means current time\n+     * @return the DateTime instance\n+     */\n+    public DateTime toDateTime(TimeOfDay time) {\n+        return toDateTime(time, null);\n+    }\n+\n+    /**\n+     * Converts this object to a DateTime using a TimeOfDay to fill in the\n+     * missing fields.\n+     * This instance is immutable and unaffected by this method call.\n+     * \u003cp\u003e\n+     * The resulting chronology is determined by the chronology of this\n+     * YearMonthDay plus the time zone.\n+     * The chronology of the time is ignored - only the field values are used.\n+     *\n+     * @param time  the time of day to use, null means current time\n+     * @param zone  the zone to get the DateTime in, null means default\n+     * @return the DateTime instance\n+     */\n+    public DateTime toDateTime(TimeOfDay time, DateTimeZone zone) {\n+        Chronology chrono \u003d getChronology().withZone(zone);\n+        long instant \u003d DateTimeUtils.currentTimeMillis();\n+        instant \u003d chrono.set(this, instant);\n+        if (time !\u003d null) {\n+            instant \u003d chrono.set(time, instant);\n+        }\n+        return new DateTime(instant, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to an Interval representing the whole day\n+     * in the default time zone.\n+     *\n+     * @return a interval over the day\n+     */\n+    public Interval toInterval() {\n+        return toInterval(null);\n+    }\n+\n+    /**\n+     * Converts this object to an Interval representing the whole day.\n+     *\n+     * @param zone  the zone to get the Interval in, null means default\n+     * @return a interval over the day\n+     */\n+    public Interval toInterval(DateTimeZone zone) {\n+        zone \u003d DateTimeUtils.getZone(zone);\n+        return toDateMidnight(zone).toInterval();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the year field value.\n+     *\n+     * @return the year\n+     */\n+    public int getYear() {\n+        return getValue(YEAR);\n+    }\n+\n+    /**\n+     * Get the month of year field value.\n+     *\n+     * @return the month of year\n+     */\n+    public int getMonthOfYear() {\n+        return getValue(MONTH_OF_YEAR);\n+    }\n+\n+    /**\n+     * Get the day of month field value.\n+     *\n+     * @return the day of month\n+     */\n+    public int getDayOfMonth() {\n+        return getValue(DAY_OF_MONTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the year field property\n+     * \n+     * @return the year property\n+     */\n+    public Property year() {\n+        return new Property(this, YEAR);\n+    }\n+\n+    /**\n+     * Get the month of year field property\n+     * \n+     * @return the month of year property\n+     */\n+    public Property monthOfYear() {\n+        return new Property(this, MONTH_OF_YEAR);\n+    }\n+\n+    /**\n+     * Get the day of month field property\n+     * \n+     * @return the day of month property\n+     */\n+    public Property dayOfMonth() {\n+        return new Property(this, DAY_OF_MONTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date in the ISO8601 format YYYY-MM-DD.\n+     * \n+     * @return ISO8601 formatted string\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.yearMonthDay().print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The property class for \u003ccode\u003eYearMonthDay\u003c/code\u003e.\n+     * \u003cp\u003e\n+     * This class binds a \u003ccode\u003eYearMonthDay\u003c/code\u003e to a \u003ccode\u003eDateTimeField\u003c/code\u003e.\n+     * \n+     * @author Stephen Colebourne\n+     * @since 1.0\n+     */\n+    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID \u003d 5727734012190224363L;\n+\n+        /** The partial */\n+        private final YearMonthDay iYearMonthDay;\n+        /** The field index */\n+        private final int iFieldIndex;\n+\n+        /**\n+         * Constructs a property.\n+         * \n+         * @param partial  the partial instance\n+         * @param fieldIndex  the index in the partial\n+         */\n+        Property(YearMonthDay partial, int fieldIndex) {\n+            super();\n+            iYearMonthDay \u003d partial;\n+            iFieldIndex \u003d fieldIndex;\n+        }\n+\n+        /**\n+         * Gets the field that this property uses.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iYearMonthDay.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        protected ReadablePartial getReadablePartial() {\n+            return iYearMonthDay;\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public YearMonthDay getYearMonthDay() {\n+            return iYearMonthDay;\n+        }\n+\n+        /**\n+         * Gets the value of this field.\n+         * \n+         * @return the field value\n+         */\n+        public int get() {\n+            return iYearMonthDay.getValue(iFieldIndex);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to the value of this field in a copy of this YearMonthDay.\n+         * \u003cp\u003e\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it will affect larger fields.\n+         * Smaller fields are unaffected.\n+         * \u003cp\u003e\n+         * If the result would be too large, beyond the maximum year, then an\n+         * IllegalArgumentException is thrown.\n+         * \u003cp\u003e\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the YearMonthDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn\u0027t valid\n+         */\n+        public YearMonthDay addToCopy(int valueToAdd) {\n+            int[] newValues \u003d iYearMonthDay.getValues();\n+            newValues \u003d getField().add(iYearMonthDay, iFieldIndex, newValues, valueToAdd);\n+            return new YearMonthDay(iYearMonthDay, newValues);\n+        }\n+\n+        /**\n+         * Adds to the value of this field in a copy of this YearMonthDay wrapping\n+         * within this field if the maximum value is reached.\n+         * \u003cp\u003e\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it wraps within this field.\n+         * Other fields are unaffected.\n+         * \u003cp\u003e\n+         * For example,\n+         * \u003ccode\u003e2004-12-20\u003c/code\u003e addWrapField one month returns \u003ccode\u003e2004-01-20\u003c/code\u003e.\n+         * \u003cp\u003e\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the YearMonthDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn\u0027t valid\n+         */\n+        public YearMonthDay addWrapFieldToCopy(int valueToAdd) {\n+            int[] newValues \u003d iYearMonthDay.getValues();\n+            newValues \u003d getField().addWrapField(iYearMonthDay, iFieldIndex, newValues, valueToAdd);\n+            return new YearMonthDay(iYearMonthDay, newValues);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the YearMonthDay.\n+         * \u003cp\u003e\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the YearMonthDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn\u0027t valid\n+         */\n+        public YearMonthDay setCopy(int value) {\n+            int[] newValues \u003d iYearMonthDay.getValues();\n+            newValues \u003d getField().set(iYearMonthDay, iFieldIndex, newValues, value);\n+            return new YearMonthDay(iYearMonthDay, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the YearMonthDay to a parsed text value.\n+         * \u003cp\u003e\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the YearMonthDay with the field value changed\n+         * @throws IllegalArgumentException if the text value isn\u0027t valid\n+         */\n+        public YearMonthDay setCopy(String text, Locale locale) {\n+            int[] newValues \u003d iYearMonthDay.getValues();\n+            newValues \u003d getField().set(iYearMonthDay, iFieldIndex, newValues, text, locale);\n+            return new YearMonthDay(iYearMonthDay, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the YearMonthDay to a parsed text value.\n+         * \u003cp\u003e\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the YearMonthDay with the field value changed\n+         * @throws IllegalArgumentException if the text value isn\u0027t valid\n+         */\n+        public YearMonthDay setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+    }\n+\n+}\n",
      "operations": [
        {
          "type": "update-node",
          "from": "",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "JodaTime/src/java/org/joda/time/field/FieldUtils.java",
        "JodaTime/src/java/org/joda/time/field/FieldUtils.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [],
          "num": 0
        },
        {
          "qualified_names": [
            "org.joda.time.field.FieldUtils:getWrappedValue:[int currentValue, int wrapValue, int minValue, int maxValue]:int",
            "org.joda.time.field.FieldUtils:verifyValueBounds:[String fieldName, int value, int lowerBound, int upperBound]:void",
            "org.joda.time.field.FieldUtils:safeAdd:[long val1, long val2]:long",
            "org.joda.time.field.FieldUtils:safeMultiply:[long val1, int scalar]:long",
            "org.joda.time.field.FieldUtils:verifyValueBounds:[DateTimeFieldType fieldType, int value, int lowerBound, int upperBound]:void",
            "org.joda.time.field.FieldUtils:safeToInt:[long value]:int",
            "org.joda.time.field.FieldUtils:safeMultiply:[int val1, int val2]:int",
            "org.joda.time.field.FieldUtils:safeMultiplyToInt:[long val1, long val2]:int",
            "org.joda.time.field.FieldUtils:safeMultiply:[long val1, long val2]:long",
            "org.joda.time.field.FieldUtils:verifyValueBounds:[DateTimeField field, int value, int lowerBound, int upperBound]:void",
            "org.joda.time.field.FieldUtils:FieldUtils:[]:null",
            "org.joda.time.field.FieldUtils:safeAdd:[int val1, int val2]:int",
            "org.joda.time.field.FieldUtils:safeSubtract:[long val1, long val2]:long",
            "org.joda.time.field.FieldUtils:getWrappedValue:[int value, int minValue, int maxValue]:int",
            "org.joda.time.field.FieldUtils:safeNegate:[int value]:int"
          ],
          "num": 15
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "-1"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10",
            "11",
            "12",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "27",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "37",
            "38",
            "39",
            "40",
            "41",
            "42",
            "43",
            "44",
            "45",
            "46",
            "47",
            "48",
            "49",
            "50",
            "51",
            "52",
            "53",
            "54",
            "55",
            "56",
            "57",
            "58",
            "59",
            "60",
            "61",
            "62",
            "63",
            "64",
            "65",
            "66",
            "67",
            "68",
            "69",
            "70",
            "71",
            "72",
            "73",
            "74",
            "75",
            "76",
            "77",
            "78",
            "79",
            "80",
            "81",
            "82",
            "83",
            "84",
            "85",
            "86",
            "87",
            "88",
            "89",
            "90",
            "91",
            "92",
            "93",
            "94",
            "95",
            "96",
            "97",
            "98",
            "99",
            "100",
            "101",
            "102",
            "103",
            "104",
            "105",
            "106",
            "107",
            "108",
            "109",
            "110",
            "111",
            "112",
            "113",
            "114",
            "115",
            "116",
            "117",
            "118",
            "119",
            "120",
            "121",
            "122",
            "123",
            "124",
            "125",
            "126",
            "127",
            "128",
            "129",
            "130",
            "131",
            "132",
            "133",
            "134",
            "135",
            "136",
            "137",
            "138",
            "139",
            "140",
            "141",
            "142",
            "143",
            "144",
            "145",
            "146",
            "147",
            "148",
            "149",
            "150",
            "151",
            "152",
            "153",
            "154",
            "155",
            "156",
            "157",
            "158",
            "159",
            "160",
            "161",
            "162",
            "163",
            "164",
            "165",
            "166",
            "167",
            "168",
            "169",
            "170",
            "171",
            "172",
            "173",
            "174",
            "175",
            "176",
            "177",
            "178",
            "179",
            "180",
            "181",
            "182",
            "183",
            "184",
            "185",
            "186",
            "187",
            "188",
            "189",
            "190",
            "191",
            "192",
            "193",
            "194",
            "195",
            "196",
            "197",
            "198",
            "199",
            "200",
            "201",
            "202",
            "203",
            "204",
            "205",
            "206",
            "207",
            "208",
            "209",
            "210",
            "211",
            "212",
            "213",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "220",
            "221",
            "222",
            "223",
            "224",
            "225",
            "226",
            "227",
            "228",
            "229",
            "230",
            "231",
            "232",
            "233",
            "234",
            "235",
            "236",
            "237",
            "238",
            "239",
            "240",
            "241",
            "242",
            "243",
            "244",
            "245",
            "246",
            "247",
            "248",
            "249",
            "250",
            "251",
            "252",
            "253",
            "254",
            "255",
            "256",
            "257",
            "258",
            "259",
            "260",
            "261",
            "262",
            "263",
            "264",
            "265",
            "266",
            "267",
            "268",
            "269",
            "270",
            "271",
            "272",
            "273",
            "274",
            "275",
            "276",
            "277",
            "278",
            "279",
            "280",
            "281",
            "282",
            "283",
            "284",
            "285",
            "286",
            "287",
            "288",
            "289",
            "290",
            "291",
            "292",
            "293",
            "294",
            "295",
            "296",
            "297",
            "298",
            "299",
            "300",
            "301",
            "302",
            "303",
            "304",
            "305",
            "306",
            "307",
            "308"
          ],
          "num": 308
        }
      ],
      "diff": "diff --git a/JodaTime/src/java/org/joda/time/field/FieldUtils.java b/JodaTime/src/java/org/joda/time/field/FieldUtils.java\nnew file mode 100644\nindex 0000000..8fd0be2\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/FieldUtils.java\n@@ -0,0 +1,308 @@\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.IllegalFieldValueException;\n+\n+/**\n+ * General utilities that don\u0027t fit elsewhere.\n+ * \u003cp\u003e\n+ * FieldUtils is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public class FieldUtils {\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private FieldUtils() {\n+        super();\n+    }\n+    \n+    //------------------------------------------------------------------------\n+    /**\n+     * Negates the input throwing an exception if it can\u0027t negate it.\n+     * \n+     * @param value  the value to negate\n+     * @return the negated value\n+     * @throws ArithmeticException if the value is Integer.MIN_VALUE\n+     * @since 1.1\n+     */\n+    public static int safeNegate(int value) {\n+        if (value \u003d\u003d Integer.MIN_VALUE) {\n+            throw new ArithmeticException(\"Integer.MIN_VALUE cannoy be negated\");\n+        }\n+        return -value;\n+    }\n+    \n+    /**\n+     * Add two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param val2  the second value\n+     * @return the new total\n+     * @throws ArithmeticException if the value is too big or too small\n+     */\n+    public static int safeAdd(int val1, int val2) {\n+        int sum \u003d val1 + val2;\n+        // If there is a sign change, but the two values have the same sign...\n+        if ((val1 ^ sum) \u003c 0 \u0026\u0026 (val1 ^ val2) \u003e\u003d 0) {\n+            throw new ArithmeticException\n+                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n+        }\n+        return sum;\n+    }\n+    \n+    /**\n+     * Add two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param val2  the second value\n+     * @return the new total\n+     * @throws ArithmeticException if the value is too big or too small\n+     */\n+    public static long safeAdd(long val1, long val2) {\n+        long sum \u003d val1 + val2;\n+        // If there is a sign change, but the two values have the same sign...\n+        if ((val1 ^ sum) \u003c 0 \u0026\u0026 (val1 ^ val2) \u003e\u003d 0) {\n+            throw new ArithmeticException\n+                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n+        }\n+        return sum;\n+    }\n+    \n+    /**\n+     * Subtracts two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value, to be taken away from\n+     * @param val2  the second value, the amount to take away\n+     * @return the new total\n+     * @throws ArithmeticException if the value is too big or too small\n+     */\n+    public static long safeSubtract(long val1, long val2) {\n+        long diff \u003d val1 - val2;\n+        // If there is a sign change, but the two values have different signs...\n+        if ((val1 ^ diff) \u003c 0 \u0026\u0026 (val1 ^ val2) \u003c 0) {\n+            throw new ArithmeticException\n+                (\"The calculation caused an overflow: \" + val1 + \" - \" + val2);\n+        }\n+        return diff;\n+    }\n+    \n+    /**\n+     * Multiply two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param val2  the second value\n+     * @return the new total\n+     * @throws ArithmeticException if the value is too big or too small\n+     * @since 1.2\n+     */\n+    public static int safeMultiply(int val1, int val2) {\n+        long total \u003d (long) val1 * (long) val2;\n+        if (total \u003c Integer.MIN_VALUE || total \u003e Integer.MAX_VALUE) {\n+            throw new ArithmeticException\n+                (\"The calculation caused an overflow: \" + val1 + \" * \" + val2);\n+        }\n+        return (int) total;\n+    }\n+\n+    /**\n+     * Multiply two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param scalar  the second value\n+     * @return the new total\n+     * @throws ArithmeticException if the value is too big or too small\n+     * @since 1.2\n+     */\n+    public static long safeMultiply(long val1, int scalar) {\n+        switch (scalar) {\n+        case -1:\n+            return -val1;\n+        case 0:\n+            return 0L;\n+        case 1:\n+            return val1;\n+        }\n+        long total \u003d val1 * scalar;\n+        if (total / scalar !\u003d val1) {\n+            throw new ArithmeticException\n+                (\"The calculation caused an overflow: \" + val1 + \" * \" + scalar);\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Multiply two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param val2  the second value\n+     * @return the new total\n+     * @throws ArithmeticException if the value is too big or too small\n+     */\n+    public static long safeMultiply(long val1, long val2) {\n+        if (val2 \u003d\u003d 1) {\n+            return val1;\n+        }\n+        if (val2 \u003d\u003d 0) {\n+            return 0;\n+        }\n+        long total \u003d val1 * val2;\n+        if (total / val2 !\u003d val1) {\n+            throw new ArithmeticException\n+                (\"The calculation caused an overflow: \" + val1 + \" * \" + val2);\n+        }\n+        return total;\n+    }\n+    \n+    /**\n+     * Casts to an int throwing an exception if overflow occurs.\n+     * \n+     * @param value  the value\n+     * @return the value as an int\n+     * @throws ArithmeticException if the value is too big or too small\n+     */\n+    public static int safeToInt(long value) {\n+        if (Integer.MIN_VALUE \u003c\u003d value \u0026\u0026 value \u003c\u003d Integer.MAX_VALUE) {\n+            return (int) value;\n+        }\n+        throw new ArithmeticException(\"Value cannot fit in an int: \" + value);\n+    }\n+    \n+    /**\n+     * Multiply two values to return an int throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param val2  the second value\n+     * @return the new total\n+     * @throws ArithmeticException if the value is too big or too small\n+     */\n+    public static int safeMultiplyToInt(long val1, long val2) {\n+        long val \u003d FieldUtils.safeMultiply(val1, val2);\n+        return FieldUtils.safeToInt(val);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Verify that input values are within specified bounds.\n+     * \n+     * @param value  the value to check\n+     * @param lowerBound  the lower bound allowed for value\n+     * @param upperBound  the upper bound allowed for value\n+     * @throws IllegalFieldValueException if value is not in the specified bounds\n+     */\n+    public static void verifyValueBounds(DateTimeField field, \n+                                         int value, int lowerBound, int upperBound) {\n+        if ((value \u003c lowerBound) || (value \u003e upperBound)) {\n+            throw new IllegalFieldValueException\n+                (field.getType(), new Integer(value),\n+                 new Integer(lowerBound), new Integer(upperBound));\n+        }\n+    }\n+\n+    /**\n+     * Verify that input values are within specified bounds.\n+     * \n+     * @param value  the value to check\n+     * @param lowerBound  the lower bound allowed for value\n+     * @param upperBound  the upper bound allowed for value\n+     * @throws IllegalFieldValueException if value is not in the specified bounds\n+     * @since 1.1\n+     */\n+    public static void verifyValueBounds(DateTimeFieldType fieldType, \n+                                         int value, int lowerBound, int upperBound) {\n+        if ((value \u003c lowerBound) || (value \u003e upperBound)) {\n+            throw new IllegalFieldValueException\n+                (fieldType, new Integer(value),\n+                 new Integer(lowerBound), new Integer(upperBound));\n+        }\n+    }\n+\n+    /**\n+     * Verify that input values are within specified bounds.\n+     * \n+     * @param value  the value to check\n+     * @param lowerBound  the lower bound allowed for value\n+     * @param upperBound  the upper bound allowed for value\n+     * @throws IllegalFieldValueException if value is not in the specified bounds\n+     */\n+    public static void verifyValueBounds(String fieldName,\n+                                         int value, int lowerBound, int upperBound) {\n+        if ((value \u003c lowerBound) || (value \u003e upperBound)) {\n+            throw new IllegalFieldValueException\n+                (fieldName, new Integer(value),\n+                 new Integer(lowerBound), new Integer(upperBound));\n+        }\n+    }\n+\n+    /**\n+     * Utility method used by addWrapField implementations to ensure the new\n+     * value lies within the field\u0027s legal value range.\n+     *\n+     * @param currentValue the current value of the data, which may lie outside\n+     * the wrapped value range\n+     * @param wrapValue  the value to add to current value before\n+     *  wrapping.  This may be negative.\n+     * @param minValue the wrap range minimum value.\n+     * @param maxValue the wrap range maximum value.  This must be\n+     *  greater than minValue (checked by the method).\n+     * @return the wrapped value\n+     * @throws IllegalArgumentException if minValue is greater\n+     *  than or equal to maxValue\n+     */\n+    public static int getWrappedValue(int currentValue, int wrapValue,\n+                                      int minValue, int maxValue) {\n+        return getWrappedValue(currentValue + wrapValue, minValue, maxValue);\n+    }\n+\n+    /**\n+     * Utility method that ensures the given value lies within the field\u0027s\n+     * legal value range.\n+     * \n+     * @param value  the value to fit into the wrapped value range\n+     * @param minValue the wrap range minimum value.\n+     * @param maxValue the wrap range maximum value.  This must be\n+     *  greater than minValue (checked by the method).\n+     * @return the wrapped value\n+     * @throws IllegalArgumentException if minValue is greater\n+     *  than or equal to maxValue\n+     */\n+    public static int getWrappedValue(int value, int minValue, int maxValue) {\n+        if (minValue \u003e\u003d maxValue) {\n+            throw new IllegalArgumentException(\"MIN \u003e MAX\");\n+        }\n+\n+        int wrapRange \u003d maxValue - minValue + 1;\n+        value -\u003d minValue;\n+\n+        if (value \u003e\u003d 0) {\n+            return (value % wrapRange) + minValue;\n+        }\n+\n+        int remByRange \u003d (-value) % wrapRange;\n+\n+        if (remByRange \u003d\u003d 0) {\n+            return 0 + minValue;\n+        }\n+        return (wrapRange - remByRange) + minValue;\n+    }\n+\n+}\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [3601,4222]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [4228,4966]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [5303,5354]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "InfixExpression [3936,3945]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "INFIX_EXPRESSION_OPERATOR: || [3946,3948]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "InfixExpression [3936,3958]",
          "to": ""
        }
      ]
    }
  ],
  "inducing_type": {
    "add_classes": {
      "qualified_names": [
        "JodaTime/src/example/org/joda/example/time/Examples.java",
        "JodaTime/src/example/org/joda/example/time/TimeZoneTable.java",
        "JodaTime/src/java/org/joda/time/ChronologyType.java",
        "JodaTime/src/java/org/joda/time/DateMidnight.java",
        "JodaTime/src/java/org/joda/time/DateTimeFieldType.java",
        "JodaTime/src/java/org/joda/time/DateTimeUtils.java",
        "JodaTime/src/java/org/joda/time/DurationFieldType.java",
        "JodaTime/src/java/org/joda/time/IllegalFieldValueException.java",
        "JodaTime/src/java/org/joda/time/JodaTimePermission.java",
        "JodaTime/src/java/org/joda/time/MutablePeriod.java",
        "JodaTime/src/java/org/joda/time/Partial.java",
        "JodaTime/src/java/org/joda/time/Period.java",
        "JodaTime/src/java/org/joda/time/PeriodType.java",
        "JodaTime/src/java/org/joda/time/ReadWritablePeriod.java",
        "JodaTime/src/java/org/joda/time/ReadablePartial.java",
        "JodaTime/src/java/org/joda/time/ReadablePeriod.java",
        "JodaTime/src/java/org/joda/time/TimeOfDay.java",
        "JodaTime/src/java/org/joda/time/YearMonthDay.java",
        "JodaTime/src/java/org/joda/time/base/AbstractDateTime.java",
        "JodaTime/src/java/org/joda/time/base/AbstractDuration.java",
        "JodaTime/src/java/org/joda/time/base/AbstractInstant.java",
        "JodaTime/src/java/org/joda/time/base/AbstractInterval.java",
        "JodaTime/src/java/org/joda/time/base/AbstractPartial.java",
        "JodaTime/src/java/org/joda/time/base/AbstractPeriod.java",
        "JodaTime/src/java/org/joda/time/base/BaseDateTime.java",
        "JodaTime/src/java/org/joda/time/base/BaseDuration.java",
        "JodaTime/src/java/org/joda/time/base/BaseInterval.java",
        "JodaTime/src/java/org/joda/time/base/BasePartial.java",
        "JodaTime/src/java/org/joda/time/base/BasePeriod.java",
        "JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/BaseChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/BasicSingleEraDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/BasicWeekOfWeekyearDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/BasicYearDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/CommonGJChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/CopticChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/GJChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java",
        "JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/ISOChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/JulianChronology.java",
        "JodaTime/src/java/org/joda/time/convert/NullConverter.java",
        "JodaTime/src/java/org/joda/time/convert/PartialConverter.java",
        "JodaTime/src/java/org/joda/time/convert/PeriodConverter.java",
        "JodaTime/src/java/org/joda/time/convert/ReadablePartialConverter.java",
        "JodaTime/src/java/org/joda/time/convert/ReadablePeriodConverter.java",
        "JodaTime/src/java/org/joda/time/field/AbstractPartialFieldProperty.java",
        "JodaTime/src/java/org/joda/time/field/AbstractReadableInstantFieldProperty.java",
        "JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java",
        "JodaTime/src/java/org/joda/time/field/BaseDurationField.java",
        "JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java",
        "JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java",
        "JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java",
        "JodaTime/src/java/org/joda/time/field/DelegatedDurationField.java",
        "JodaTime/src/java/org/joda/time/field/DividedDateTimeField.java",
        "JodaTime/src/java/org/joda/time/field/FieldUtils.java",
        "JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java",
        "JodaTime/src/java/org/joda/time/field/LenientDateTimeField.java",
        "JodaTime/src/java/org/joda/time/field/MillisDurationField.java",
        "JodaTime/src/java/org/joda/time/field/OffsetDateTimeField.java",
        "JodaTime/src/java/org/joda/time/field/PreciseDateTimeField.java",
        "JodaTime/src/java/org/joda/time/field/PreciseDurationDateTimeField.java",
        "JodaTime/src/java/org/joda/time/field/PreciseDurationField.java",
        "JodaTime/src/java/org/joda/time/field/RemainderDateTimeField.java",
        "JodaTime/src/java/org/joda/time/field/ScaledDurationField.java",
        "JodaTime/src/java/org/joda/time/field/SkipDateTimeField.java",
        "JodaTime/src/java/org/joda/time/field/SkipUndoDateTimeField.java",
        "JodaTime/src/java/org/joda/time/field/StrictDateTimeField.java",
        "JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java",
        "JodaTime/src/java/org/joda/time/field/UnsupportedDurationField.java",
        "JodaTime/src/java/org/joda/time/field/ZeroIsMaxDateTimeField.java",
        "JodaTime/src/java/org/joda/time/format/ISOPeriodFormat.java",
        "JodaTime/src/java/org/joda/time/format/PeriodFormat.java",
        "JodaTime/src/java/org/joda/time/format/PeriodFormatter.java",
        "JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java",
        "JodaTime/src/java/org/joda/time/format/PeriodParser.java",
        "JodaTime/src/java/org/joda/time/format/PeriodPrinter.java",
        "JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDateTime.java",
        "JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDateTimeTZ.java",
        "JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentTimeOfDay.java",
        "JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentTimeOfDayExact.java",
        "JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentYearMonthDay.java",
        "JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/DateTimeZoneSupport.java",
        "JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/DateTimeZoneTag.java",
        "JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/FormatSupport.java",
        "JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/FormatTag.java",
        "JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/JodaTagLibraryValidator.java",
        "JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/ParseDateTimeSupport.java",
        "JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/ParseDateTimeTag.java",
        "JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/Resources.java",
        "JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/SetDateTimeZoneSupport.java",
        "JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/SetDateTimeZoneTag.java",
        "JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/Util.java"
      ],
      "num": 104
    },
    "delete_classes": {
      "qualified_names": [
        "JodaTime/src/java/org/joda/time/AbstractDateTime.java",
        "JodaTime/src/java/org/joda/time/AbstractDuration.java",
        "JodaTime/src/java/org/joda/time/AbstractInstant.java",
        "JodaTime/src/java/org/joda/time/AbstractInterval.java",
        "JodaTime/src/java/org/joda/time/AbstractPartialInstant.java",
        "JodaTime/src/java/org/joda/time/DateOnly.java",
        "JodaTime/src/java/org/joda/time/DurationType.java",
        "JodaTime/src/java/org/joda/time/MutableDateOnly.java",
        "JodaTime/src/java/org/joda/time/MutableDuration.java",
        "JodaTime/src/java/org/joda/time/MutableTimeOnly.java",
        "JodaTime/src/java/org/joda/time/PartialInstant.java",
        "JodaTime/src/java/org/joda/time/ReadWritableDuration.java",
        "JodaTime/src/java/org/joda/time/TimeOnly.java",
        "JodaTime/src/java/org/joda/time/chrono/AbstractDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/AbstractDurationField.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/DecoratedDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/DecoratedDurationField.java",
        "JodaTime/src/java/org/joda/time/chrono/DelegatedChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/DelegatedDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/DelegatedDurationField.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/LenientDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/MillisDurationField.java",
        "JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/PreciseDurationField.java",
        "JodaTime/src/java/org/joda/time/chrono/ScaledDurationField.java",
        "JodaTime/src/java/org/joda/time/chrono/StrictDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/Utils.java",
        "JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java",
        "JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java",
        "JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java",
        "JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/ImpreciseDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/UnsupportedDateTimeField.java",
        "JodaTime/src/java/org/joda/time/chrono/UnsupportedDurationField.java",
        "JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java",
        "JodaTime/src/java/org/joda/time/format/AbstractDurationFormatter.java",
        "JodaTime/src/java/org/joda/time/format/DurationFormat.java",
        "JodaTime/src/java/org/joda/time/format/DurationFormatter.java",
        "JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java",
        "JodaTime/src/java/org/joda/time/format/DurationParser.java",
        "JodaTime/src/java/org/joda/time/format/DurationPrinter.java",
        "JodaTime/src/java/org/joda/time/format/ISODurationFormat.java",
        "JodaTime/src/java/org/joda/time/property/AbstractReadableInstantFieldProperty.java",
        "JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java",
        "JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java",
        "JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java",
        "JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java",
        "JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java"
      ],
      "num": 72
    },
    "add_functions": {
      "qualified_names": [
        "org.joda.time.YearMonthDay:toDateMidnight:[]:DateMidnight",
        "org.joda.time.TimeOfDay:plusSeconds:[int seconds]:TimeOfDay",
        "org.joda.time.TimeOfDay:TimeOfDay:[int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond]:null",
        "org.joda.time.TimeOfDay:TimeOfDay:[DateTimeZone zone]:null",
        "org.joda.time.TimeOfDay:withFieldAdded:[DurationFieldType fieldType, int amount]:TimeOfDay",
        "org.joda.time.YearMonthDay\\$Property:setCopy:[String text, Locale locale]:YearMonthDay",
        "org.joda.time.field.FieldUtils:safeToInt:[long value]:int",
        "org.joda.time.field.FieldUtils:safeMultiply:[int val1, int val2]:int",
        "org.joda.time.Partial:withChronologyRetainFields:[Chronology newChronology]:Partial",
        "org.joda.time.YearMonthDay:getFieldTypes:[]:DateTimeFieldType[]",
        "org.joda.time.TimeOfDay\\$Property:addToCopy:[int valueToAdd]:TimeOfDay",
        "org.joda.time.field.FieldUtils:getWrappedValue:[int currentValue, int wrapValue, int minValue, int maxValue]:int",
        "org.joda.time.DateTimeZone:isFixed:[]:boolean",
        "org.joda.time.Partial\\$Property:setCopy:[int value]:Partial",
        "org.joda.time.TimeOfDay\\$Property:getReadablePartial:[]:ReadablePartial",
        "org.joda.time.YearMonthDay\\$Property:get:[]:int",
        "org.joda.time.YearMonthDay:minusDays:[int days]:YearMonthDay",
        "org.joda.time.YearMonthDay:getField:[int index, Chronology chrono]:DateTimeField",
        "org.joda.time.YearMonthDay:monthOfYear:[]:Property",
        "org.joda.time.Partial:toString:[]:String",
        "org.joda.time.Partial:Partial:[Chronology chronology, DateTimeFieldType[] types, int[] values]:null",
        "org.joda.time.Partial:getChronology:[]:Chronology",
        "org.joda.time.field.FieldUtils:verifyValueBounds:[DateTimeField field, int value, int lowerBound, int upperBound]:void",
        "org.joda.time.DateTimeZone:toString:[]:String",
        "org.joda.time.YearMonthDay:toDateTime:[TimeOfDay time]:DateTime",
        "org.joda.time.field.FieldUtils:getWrappedValue:[int value, int minValue, int maxValue]:int",
        "org.joda.time.TimeOfDay:getMinuteOfHour:[]:int",
        "org.joda.time.TimeOfDay\\$Property:setCopy:[int value]:TimeOfDay",
        "org.joda.time.Partial:withFieldAdded:[DurationFieldType fieldType, int amount]:Partial",
        "org.joda.time.Partial:minus:[ReadablePeriod period]:Partial",
        "org.joda.time.YearMonthDay:withChronologyRetainFields:[Chronology newChronology]:YearMonthDay",
        "org.joda.time.TimeOfDay:TimeOfDay:[TimeOfDay partial, int[] values]:null",
        "org.joda.time.DateTimeZone:DateTimeZone:[String id]:null",
        "org.joda.time.field.FieldUtils:FieldUtils:[]:null",
        "org.joda.time.Partial:toStringList:[]:String",
        "org.joda.time.TimeOfDay:hourOfDay:[]:Property",
        "org.joda.time.TimeOfDay:secondOfMinute:[]:Property",
        "org.joda.time.TimeOfDay:withChronologyRetainFields:[Chronology newChronology]:TimeOfDay",
        "org.joda.time.YearMonthDay:YearMonthDay:[int year, int monthOfYear, int dayOfMonth, Chronology chronology]:null",
        "org.joda.time.Partial:Partial:[DateTimeFieldType type, int value, Chronology chronology]:null",
        "org.joda.time.Partial:without:[DateTimeFieldType fieldType]:Partial",
        "org.joda.time.YearMonthDay:minusYears:[int years]:YearMonthDay",
        "org.joda.time.YearMonthDay:toDateTimeAtMidnight:[DateTimeZone zone]:DateTime",
        "org.joda.time.YearMonthDay\\$Property:getReadablePartial:[]:ReadablePartial",
        "org.joda.time.TimeOfDay:millisOfSecond:[]:Property",
        "org.joda.time.Partial:Partial:[Chronology chrono]:null",
        "org.joda.time.TimeOfDay\\$Property:addWrapFieldToCopy:[int valueToAdd]:TimeOfDay",
        "org.joda.time.YearMonthDay:YearMonthDay:[Object instant]:null",
        "org.joda.time.Partial:with:[DateTimeFieldType fieldType, int value]:Partial",
        "org.joda.time.YearMonthDay:toDateTime:[TimeOfDay time, DateTimeZone zone]:DateTime",
        "org.joda.time.TimeOfDay:plusMinutes:[int minutes]:TimeOfDay",
        "org.joda.time.Partial:property:[DateTimeFieldType type]:Property",
        "org.joda.time.DateTimeZone\\$Stub:Stub:[String id]:null",
        "org.joda.time.TimeOfDay:TimeOfDay:[long instant, Chronology chronology]:null",
        "org.joda.time.TimeOfDay:minuteOfHour:[]:Property",
        "org.joda.time.Partial:getFormatter:[]:DateTimeFormatter",
        "org.joda.time.YearMonthDay\\$Property:setCopy:[String text]:YearMonthDay",
        "org.joda.time.field.FieldUtils:safeNegate:[int value]:int",
        "org.joda.time.field.FieldUtils:safeMultiply:[long val1, int scalar]:long",
        "org.joda.time.TimeOfDay:minus:[ReadablePeriod period]:TimeOfDay",
        "org.joda.time.TimeOfDay:property:[DateTimeFieldType type]:Property",
        "org.joda.time.DateTimeZone:getStandardOffset:[long instant]:int",
        "org.joda.time.TimeOfDay:TimeOfDay:[]:null",
        "org.joda.time.YearMonthDay:withField:[DateTimeFieldType fieldType, int value]:YearMonthDay",
        "org.joda.time.Partial:getFieldTypes:[]:DateTimeFieldType[]",
        "org.joda.time.TimeOfDay\\$Property:setCopy:[String text]:TimeOfDay",
        "org.joda.time.Partial:withFieldAddWrapped:[DurationFieldType fieldType, int amount]:Partial",
        "org.joda.time.Partial\\$Property:getField:[]:DateTimeField",
        "org.joda.time.DateTimeZone:nextTransition:[long instant]:long",
        "org.joda.time.TimeOfDay\\$Property:getField:[]:DateTimeField",
        "org.joda.time.TimeOfDay\\$Property:get:[]:int",
        "org.joda.time.TimeOfDay:fromMillisOfDay:[long millisOfDay, Chronology chrono]:TimeOfDay",
        "org.joda.time.TimeOfDay:minusSeconds:[int seconds]:TimeOfDay",
        "org.joda.time.TimeOfDay\\$Property:Property:[TimeOfDay partial, int fieldIndex]:null",
        "org.joda.time.YearMonthDay:YearMonthDay:[YearMonthDay partial, Chronology chrono]:null",
        "org.joda.time.DateTimeZone:getMillisKeepLocal:[DateTimeZone newZone, long oldInstant]:long",
        "org.joda.time.DateTimeZone\\$Stub:readResolve:[]:Object",
        "org.joda.time.TimeOfDay:withPeriodAdded:[ReadablePeriod period, int scalar]:TimeOfDay",
        "org.joda.time.TimeOfDay:minusHours:[int hours]:TimeOfDay",
        "org.joda.time.YearMonthDay\\$Property:addWrapFieldToCopy:[int valueToAdd]:YearMonthDay",
        "org.joda.time.YearMonthDay:withFieldAdded:[DurationFieldType fieldType, int amount]:YearMonthDay",
        "org.joda.time.YearMonthDay:plusDays:[int days]:YearMonthDay",
        "org.joda.time.TimeOfDay:TimeOfDay:[int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology]:null",
        "org.joda.time.field.FieldUtils:safeAdd:[int val1, int val2]:int",
        "org.joda.time.YearMonthDay\\$Property:getField:[]:DateTimeField",
        "org.joda.time.YearMonthDay:toDateMidnight:[DateTimeZone zone]:DateMidnight",
        "org.joda.time.Partial:plus:[ReadablePeriod period]:Partial",
        "org.joda.time.TimeOfDay:TimeOfDay:[Object instant]:null",
        "org.joda.time.YearMonthDay:minus:[ReadablePeriod period]:YearMonthDay",
        "org.joda.time.DateTimeZone:setNameProvider0:[NameProvider nameProvider]:void",
        "org.joda.time.YearMonthDay:YearMonthDay:[YearMonthDay partial, int[] values]:null",
        "org.joda.time.TimeOfDay:plusHours:[int hours]:TimeOfDay",
        "org.joda.time.YearMonthDay\\$Property:setCopy:[int value]:YearMonthDay",
        "org.joda.time.YearMonthDay:toDateTimeAtCurrentTime:[]:DateTime",
        "org.joda.time.YearMonthDay:withPeriodAdded:[ReadablePeriod period, int scalar]:YearMonthDay",
        "org.joda.time.YearMonthDay:toInterval:[DateTimeZone zone]:Interval",
        "org.joda.time.DateTimeZone:getName:[long instant, Locale locale]:String",
        "org.joda.time.TimeOfDay\\$Property:addNoWrapToCopy:[int valueToAdd]:TimeOfDay",
        "org.joda.time.Partial:Partial:[Partial partial, int[] values]:null",
        "org.joda.time.YearMonthDay:YearMonthDay:[int year, int monthOfYear, int dayOfMonth]:null",
        "org.joda.time.TimeOfDay:getField:[int index, Chronology chrono]:DateTimeField",
        "org.joda.time.Partial:Partial:[ReadablePartial partial]:null",
        "org.joda.time.YearMonthDay:toDateTimeAtMidnight:[]:DateTime",
        "org.joda.time.field.FieldUtils:safeMultiply:[long val1, long val2]:long",
        "org.joda.time.DateTimeZone:previousTransition:[long instant]:long",
        "org.joda.time.TimeOfDay:TimeOfDay:[TimeOfDay partial, Chronology chrono]:null",
        "org.joda.time.YearMonthDay:toInterval:[]:Interval",
        "org.joda.time.Partial:Partial:[DateTimeFieldType[] types, int[] values, Chronology chronology]:null",
        "org.joda.time.YearMonthDay:getYear:[]:int",
        "org.joda.time.YearMonthDay\\$Property:addToCopy:[int valueToAdd]:YearMonthDay",
        "org.joda.time.YearMonthDay:plusYears:[int years]:YearMonthDay",
        "org.joda.time.Partial:getValue:[int index]:int",
        "org.joda.time.TimeOfDay:TimeOfDay:[int hourOfDay, int minuteOfHour, int secondOfMinute]:null",
        "org.joda.time.Partial:isMatch:[ReadableInstant instant]:boolean",
        "org.joda.time.TimeOfDay\\$Property:getTimeOfDay:[]:TimeOfDay",
        "org.joda.time.YearMonthDay:YearMonthDay:[Chronology chronology]:null",
        "org.joda.time.YearMonthDay:size:[]:int",
        "org.joda.time.field.FieldUtils:safeAdd:[long val1, long val2]:long",
        "org.joda.time.Partial:Partial:[DateTimeFieldType[] types, int[] values]:null",
        "org.joda.time.TimeOfDay:getFieldType:[int index]:DateTimeFieldType",
        "org.joda.time.field.FieldUtils:safeMultiplyToInt:[long val1, long val2]:int",
        "org.joda.time.YearMonthDay:YearMonthDay:[long instant]:null",
        "org.joda.time.Partial:Partial:[DateTimeFieldType type, int value]:null",
        "org.joda.time.TimeOfDay:fromMillisOfDay:[long millisOfDay]:TimeOfDay",
        "org.joda.time.Partial:Partial:[]:null",
        "org.joda.time.TimeOfDay:toString:[]:String",
        "org.joda.time.YearMonthDay\\$Property:getYearMonthDay:[]:YearMonthDay",
        "org.joda.time.TimeOfDay:getHourOfDay:[]:int",
        "org.joda.time.YearMonthDay:toString:[]:String",
        "org.joda.time.TimeOfDay:TimeOfDay:[int hourOfDay, int minuteOfHour]:null",
        "org.joda.time.Partial\\$Property:get:[]:int",
        "org.joda.time.Partial\\$Property:getPartial:[]:Partial",
        "org.joda.time.TimeOfDay:TimeOfDay:[Object instant, Chronology chronology]:null",
        "org.joda.time.DateTimeZone:getOffset:[long instant]:int",
        "org.joda.time.YearMonthDay:YearMonthDay:[DateTimeZone zone]:null",
        "org.joda.time.TimeOfDay:plus:[ReadablePeriod period]:TimeOfDay",
        "org.joda.time.Partial:toString:[String pattern, Locale locale]:String",
        "org.joda.time.TimeOfDay:minusMillis:[int millis]:TimeOfDay",
        "org.joda.time.YearMonthDay:dayOfMonth:[]:Property",
        "org.joda.time.YearMonthDay:property:[DateTimeFieldType type]:Property",
        "org.joda.time.field.FieldUtils:verifyValueBounds:[String fieldName, int value, int lowerBound, int upperBound]:void",
        "org.joda.time.TimeOfDay:getSecondOfMinute:[]:int",
        "org.joda.time.YearMonthDay:plusMonths:[int months]:YearMonthDay",
        "org.joda.time.field.FieldUtils:verifyValueBounds:[DateTimeFieldType fieldType, int value, int lowerBound, int upperBound]:void",
        "org.joda.time.YearMonthDay\\$Property:Property:[YearMonthDay partial, int fieldIndex]:null",
        "org.joda.time.YearMonthDay:YearMonthDay:[]:null",
        "org.joda.time.Partial\\$Property:addWrapFieldToCopy:[int valueToAdd]:Partial",
        "org.joda.time.TimeOfDay:getFieldTypes:[]:DateTimeFieldType[]",
        "org.joda.time.YearMonthDay:YearMonthDay:[Object instant, Chronology chronology]:null",
        "org.joda.time.TimeOfDay:minusMinutes:[int minutes]:TimeOfDay",
        "org.joda.time.DateTimeZone:getName:[long instant]:String",
        "org.joda.time.Partial\\$Property:setCopy:[String text]:Partial",
        "org.joda.time.YearMonthDay:year:[]:Property",
        "org.joda.time.YearMonthDay:getMonthOfYear:[]:int",
        "org.joda.time.YearMonthDay:YearMonthDay:[long instant, Chronology chronology]:null",
        "org.joda.time.Partial:getFieldType:[int index]:DateTimeFieldType",
        "org.joda.time.Partial:toString:[String pattern]:String",
        "org.joda.time.Partial:size:[]:int",
        "org.joda.time.YearMonthDay:getDayOfMonth:[]:int",
        "org.joda.time.TimeOfDay:TimeOfDay:[int hourOfDay, int minuteOfHour, Chronology chronology]:null",
        "org.joda.time.Partial\\$Property:setCopy:[String text, Locale locale]:Partial",
        "org.joda.time.Partial\\$Property:addToCopy:[int valueToAdd]:Partial",
        "org.joda.time.YearMonthDay:minusMonths:[int months]:YearMonthDay",
        "org.joda.time.TimeOfDay:TimeOfDay:[Chronology chronology]:null",
        "org.joda.time.Partial\\$Property:getReadablePartial:[]:ReadablePartial",
        "org.joda.time.YearMonthDay:toDateTimeAtCurrentTime:[DateTimeZone zone]:DateTime",
        "org.joda.time.YearMonthDay:plus:[ReadablePeriod period]:YearMonthDay",
        "org.joda.time.TimeOfDay:withField:[DateTimeFieldType fieldType, int value]:TimeOfDay",
        "org.joda.time.TimeOfDay:toDateTimeToday:[DateTimeZone zone]:DateTime",
        "org.joda.time.TimeOfDay:size:[]:int",
        "org.joda.time.TimeOfDay:TimeOfDay:[long instant]:null",
        "org.joda.time.YearMonthDay:getFieldType:[int index]:DateTimeFieldType",
        "org.joda.time.Partial:getField:[int index, Chronology chrono]:DateTimeField",
        "org.joda.time.Partial\\$Property:Property:[Partial partial, int fieldIndex]:null",
        "org.joda.time.Partial:getValues:[]:int[]",
        "org.joda.time.DateTimeZone:writeReplace:[]:Object",
        "org.joda.time.TimeOfDay:plusMillis:[int millis]:TimeOfDay",
        "org.joda.time.Partial:withField:[DateTimeFieldType fieldType, int value]:Partial",
        "org.joda.time.TimeOfDay:getMillisOfSecond:[]:int",
        "org.joda.time.Partial:withPeriodAdded:[ReadablePeriod period, int scalar]:Partial",
        "org.joda.time.DateTimeZone:getOffsetFromLocal:[long instantLocal]:int",
        "org.joda.time.DateTimeZone:setProvider:[Provider provider]:void",
        "org.joda.time.TimeOfDay:toDateTimeToday:[]:DateTime",
        "org.joda.time.DateTimeZone:getOffset:[ReadableInstant instant]:int",
        "org.joda.time.TimeOfDay:TimeOfDay:[int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology]:null",
        "org.joda.time.TimeOfDay\\$Property:setCopy:[String text, Locale locale]:TimeOfDay",
        "org.joda.time.field.FieldUtils:safeSubtract:[long val1, long val2]:long"
      ],
      "num": 187
    },
    "delete_functions": {
      "qualified_names": [
        "org.joda.time.DateTimeZone:getAvailableIDs:[]:Set",
        "org.joda.time.DateTimeZone:getDefault:[]:DateTimeZone"
      ],
      "num": 2
    }
  },
  "trigger_tests": [
    {
      "test_class": "org.joda.time.field.TestFieldUtils",
      "test_function": "testSafeMultiplyLongInt",
      "assertion_line": "261",
      "exception": "junit.framework.AssertionFailedError",
      "message": ""
    }
  ],
  "fixing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/main/java/org/joda/time/field/FieldUtils.java",
        "src/main/java/org/joda/time/field/FieldUtils.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "org.joda.time.field.FieldUtils:safeMultiply:[long val1, int scalar]:long",
            "org.joda.time.field.FieldUtils:safeMultiply:[int val1, int val2]:int"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "org.joda.time.field.FieldUtils:safeMultiply:[int val1, int val2]:int",
            "org.joda.time.field.FieldUtils:safeMultiply:[long val1, int val2]:long"
          ],
          "num": 2
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "121",
            "122",
            "131",
            "136",
            "137",
            "138",
            "139",
            "140",
            "141",
            "142",
            "143",
            "145",
            "146",
            "147",
            "148"
          ],
          "num": 15
        },
        {
          "qualified_names": [
            "121",
            "130",
            "135",
            "136",
            "137",
            "138",
            "139",
            "140",
            "141",
            "142",
            "143",
            "144",
            "145",
            "147",
            "148",
            "149"
          ],
          "num": 16
        }
      ],
      "diff": "diff --git a/src/main/java/org/joda/time/field/FieldUtils.java b/src/main/java/org/joda/time/field/FieldUtils.java\nindex 55ed991..1e045b2 100644\n--- a/src/main/java/org/joda/time/field/FieldUtils.java\n+++ b/src/main/java/org/joda/time/field/FieldUtils.java\n@@ -118,8 +118,7 @@\n     public static int safeMultiply(int val1, int val2) {\n         long total \u003d (long) val1 * (long) val2;\n         if (total \u003c Integer.MIN_VALUE || total \u003e Integer.MAX_VALUE) {\n-            throw new ArithmeticException\n-                (\"The calculation caused an overflow: \" + val1 + \" * \" + val2);\n+          throw new ArithmeticException(\"Multiplication overflows an int: \" + val1 + \" * \" + val2);\n         }\n         return (int) total;\n     }\n@@ -128,24 +127,26 @@\n      * Multiply two values throwing an exception if overflow occurs.\n      * \n      * @param val1  the first value\n-     * @param scalar  the second value\n+     * @param val2  the second value\n      * @return the new total\n      * @throws ArithmeticException if the value is too big or too small\n      * @since 1.2\n      */\n-    public static long safeMultiply(long val1, int scalar) {\n-        switch (scalar) {\n-        case -1:\n-            return -val1;\n-        case 0:\n-            return 0L;\n-        case 1:\n-            return val1;\n+    public static long safeMultiply(long val1, int val2) {\n+        switch (val2) {\n+            case -1:\n+                if (val1 \u003d\u003d Long.MIN_VALUE) {\n+                    throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n+                }\n+                return -val1;\n+            case 0:\n+                return 0L;\n+            case 1:\n+                return val1;\n         }\n-        long total \u003d val1 * scalar;\n-        if (total / scalar !\u003d val1) {\n-            throw new ArithmeticException\n-                (\"The calculation caused an overflow: \" + val1 + \" * \" + scalar);\n+        long total \u003d val1 * val2;\n+        if (total / val2 !\u003d val1) {\n+          throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n         }\n         return total;\n     }\n",
      "operations": [
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [4607,4764]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        }
      ]
    }
  ],
  "fixing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [],
      "num": 0
    },
    "add_functions": {
      "qualified_names": [
        "org.joda.time.field.FieldUtils:safeMultiply:[long val1, int val2]:long"
      ],
      "num": 1
    },
    "delete_functions": {
      "qualified_names": [
        "org.joda.time.field.FieldUtils:safeMultiply:[long val1, int scalar]:long"
      ],
      "num": 1
    }
  },
  "patch_changed_mths": {
    "qualified_names": [
      "org.joda.time.field.FieldUtils:safeMultiply(II)I:regression"
    ],
    "num": 1
  }
}