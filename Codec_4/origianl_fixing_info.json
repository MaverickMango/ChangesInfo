{
  "logger": {
    "currentLogLevel": 20,
    "name": "root.bean.benchmarks.Defects4JBug"
  },
  "d4jCmd": "/home/liumengjiao/Desktop/defects4j/framework/bin/defects4j",
  "dataDir": "/home/liumengjiao/Desktop/CI/Benchmark/data/changesInfo/",
  "properties": {
    "trigger.tests": "org.apache.commons.codec.binary.Base64Codec13Test::testEncoder,org.apache.commons.codec.binary.Base64Codec13Test::testBinaryEncoder",
    "test.dir": "src/test",
    "clz.modified": "org.apache.commons.codec.binary.Base64",
    "src.dir": "src/java"
  },
  "timeoutSecond": 100,
  "proj": "Codec",
  "id": "4",
  "workingDir": "../bugs/Codec_4_buggy",
  "buggyCommit": "38ba13232cb37374e3c333e2121ebad8a793935c",
  "inducingCommit": "20a88d9b49beda71ddee69af92872716fd00f13a",
  "originalCommit": "84235691b5d1ae6d4705dba63c19dc1f6450021b",
  "bug_name": "Codec_4",
  "derive": "defects4j",
  "original_fixing_commit": "bcfef8906931a7929a6db14b9d82d387fd3f17f6",
  "buildFiles_changed": false,
  "regression": true,
  "inducing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/java/org/apache/commons/codec/binary/Base64.java",
        "src/java/org/apache/commons/codec/binary/Base64.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "org.apache.commons.codec.binary.Base64:Base64:[int lineLength, byte[] lineSeparator]:null",
            "org.apache.commons.codec.binary.Base64:encodeBase64:[byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize]:byte[]",
            "org.apache.commons.codec.binary.Base64:Base64:[int lineLength, byte[] lineSeparator, boolean urlSafe]:null",
            "org.apache.commons.codec.binary.Base64:decodeBase64:[byte[] base64Data]:byte[]",
            "org.apache.commons.codec.binary.Base64:encode:[byte[] pArray]:byte[]",
            "org.apache.commons.codec.binary.Base64:decode:[Object pObject]:Object",
            "org.apache.commons.codec.binary.Base64:decode:[byte[] pArray]:byte[]",
            "org.apache.commons.codec.binary.Base64:Base64:[int lineLength]:null"
          ],
          "num": 8
        },
        {
          "qualified_names": [
            "org.apache.commons.codec.binary.Base64:Base64:[int lineLength, byte[] lineSeparator]:null",
            "org.apache.commons.codec.binary.Base64:encode:[byte[] pArray]:byte[]",
            "org.apache.commons.codec.binary.Base64:getEncodeLength:[byte[] pArray, int chunkSize, byte[] chunkSeparator]:long",
            "org.apache.commons.codec.binary.Base64:encodeBase64:[byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize]:byte[]",
            "org.apache.commons.codec.binary.Base64:Base64:[int lineLength]:null",
            "org.apache.commons.codec.binary.Base64:Base64:[int lineLength, byte[] lineSeparator, boolean urlSafe]:null",
            "org.apache.commons.codec.binary.Base64:decode:[Object pObject]:Object",
            "org.apache.commons.codec.binary.Base64:decode:[byte[] pArray]:byte[]",
            "org.apache.commons.codec.binary.Base64:decodeBase64:[byte[] base64Data]:byte[]"
          ],
          "num": 9
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "257",
            "279",
            "305",
            "317",
            "327",
            "672",
            "675",
            "686",
            "742",
            "743",
            "744",
            "745",
            "746",
            "747",
            "748",
            "749",
            "750",
            "751",
            "752",
            "753",
            "754",
            "761",
            "762",
            "763",
            "764",
            "765",
            "766",
            "767",
            "768",
            "769",
            "770",
            "771",
            "772",
            "773",
            "774",
            "775",
            "776",
            "787",
            "788",
            "789",
            "791",
            "792",
            "793",
            "794",
            "795",
            "796",
            "797",
            "798",
            "799",
            "800",
            "876"
          ],
          "num": 51
        },
        {
          "qualified_names": [
            "257",
            "279",
            "305",
            "317",
            "327",
            "672",
            "673",
            "674",
            "687",
            "688",
            "689",
            "690",
            "691",
            "692",
            "693",
            "694",
            "695",
            "696",
            "697",
            "698",
            "699",
            "700",
            "701",
            "702",
            "703",
            "704",
            "760",
            "761",
            "768",
            "769",
            "770",
            "782",
            "858",
            "859",
            "860",
            "861",
            "862",
            "863",
            "864",
            "865",
            "866",
            "867",
            "868",
            "869",
            "870",
            "871",
            "872",
            "873",
            "874",
            "875",
            "876",
            "877",
            "878",
            "879",
            "880",
            "881",
            "882",
            "883",
            "884",
            "885",
            "886",
            "887",
            "888",
            "889",
            "890",
            "891",
            "892",
            "893",
            "894",
            "895",
            "896",
            "897",
            "898",
            "899",
            "900",
            "901",
            "902",
            "903",
            "904"
          ],
          "num": 79
        }
      ],
      "diff": "diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java\nindex b85f9f4..eb09b5c 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n@@ -254,7 +254,7 @@\n      * \u003c/p\u003e\n      * \n      * @param lineLength\n-     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n      *            If lineLength \u003c\u003d 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n      * @since 1.4\n      */\n@@ -276,7 +276,7 @@\n      * \u003c/p\u003e\n      * \n      * @param lineLength\n-     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n      *            If lineLength \u003c\u003d 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n@@ -302,7 +302,7 @@\n      * \u003c/p\u003e\n      * \n      * @param lineLength\n-     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n      *            If lineLength \u003c\u003d 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n@@ -314,7 +314,7 @@\n      * @since 1.4\n      */\n     public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n-        this.lineLength \u003d lineLength;\n+        this.lineLength \u003d lineLength \u003e 0 ? (lineLength / 4) * 4 : 0;\n         this.lineSeparator \u003d new byte[lineSeparator.length];\n         System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n         if (lineLength \u003e 0) {\n@@ -324,7 +324,7 @@\n         }\n         this.decodeSize \u003d this.encodeSize - 1;\n         if (containsBase64Byte(lineSeparator)) {\n-            String sep \u003d StringBytesUtils.newStringUtf8(lineSeparator);\n+            String sep \u003d StringUtils.newStringUtf8(lineSeparator);\n             throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n         }\n         this.encodeTable \u003d urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n@@ -669,10 +669,11 @@\n      *             if the parameter supplied is not of type byte[]\n      */\n     public Object decode(Object pObject) throws DecoderException {\n-        if (!(pObject instanceof byte[])) {\n+        if (pObject instanceof byte[]) {\n+            return decode((byte[]) pObject);\n+        } else {\n             throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[]\");\n         }\n-        return decode((byte[]) pObject);\n     }\n \n     /**\n@@ -683,7 +684,24 @@\n      * @return a byte array containing binary data\n      */\n     public byte[] decode(byte[] pArray) {\n-        return decodeBase64(pArray);\n+        if (pArray \u003d\u003d null || pArray.length \u003d\u003d 0) {\n+            return pArray;\n+        }\n+        long len \u003d (pArray.length * 3) / 4;\n+        byte[] buf \u003d new byte[(int) len];\n+        setInitialBuffer(buf, 0, buf.length);\n+        decode(pArray, 0, pArray.length);\n+        decode(pArray, 0, -1); // Notify decoder of EOF.\n+\n+        // Would be nice to just return buf (like we sometimes do in the encode\n+        // logic), but we have no idea what the line-length was (could even be\n+        // variable).  So we cannot determine ahead of time exactly how big an\n+        // array is necessary.  Hence the need to construct a 2nd byte array to\n+        // hold the final result:\n+\n+        byte[] result \u003d new byte[pos];\n+        readResults(result, 0, result.length);\n+        return result;\n     }\n \n     /**\n@@ -739,41 +757,17 @@\n         if (binaryData \u003d\u003d null || binaryData.length \u003d\u003d 0) {\n             return binaryData;\n         }\n-        Base64 b64 \u003d isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n-        long len \u003d (binaryData.length * 4) / 3;\n-        long mod \u003d len % 4;\n-        if (mod !\u003d 0) {\n-            len +\u003d 4 - mod;\n-        }\n-        if (isChunked) {\n-            boolean lenChunksPerfectly \u003d len % CHUNK_SIZE \u003d\u003d 0;\n-            len +\u003d (len / CHUNK_SIZE) * CHUNK_SEPARATOR.length;\n-            if (!lenChunksPerfectly) {\n-                len +\u003d CHUNK_SEPARATOR.length;\n-            }\n-        }\n+\n+        long len \u003d getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);\n         if (len \u003e maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n         }\n-        byte[] buf \u003d new byte[(int) len];\n-        b64.setInitialBuffer(buf, 0, buf.length);\n-        b64.encode(binaryData, 0, binaryData.length);\n-        b64.encode(binaryData, 0, -1); // Notify encoder of EOF.\n-        // Encoder might have resized, even though it was unnecessary.\n-        if (b64.buffer !\u003d buf) {\n-            b64.readResults(buf, 0, buf.length);\n-        }\n-        // In URL-SAFE mode we skip the padding characters, so sometimes our\n-        // final length is a bit smaller.\n-        if (urlSafe \u0026\u0026 b64.pos \u003c buf.length) {\n-            byte[] smallerBuf \u003d new byte[b64.pos];\n-            System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);\n-            buf \u003d smallerBuf;\n-        }\n-        return buf;\n+                \n+        Base64 b64 \u003d isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n+        return b64.encode(binaryData);\n     }\n \n     /**\n@@ -784,20 +778,8 @@\n      * @return Array containing decoded data.\n      */\n     public static byte[] decodeBase64(byte[] base64Data) {\n-        if (base64Data \u003d\u003d null || base64Data.length \u003d\u003d 0) {\n-            return base64Data;\n-        }\n         Base64 b64 \u003d new Base64();\n-        long len \u003d (base64Data.length * 3) / 4;\n-        byte[] buf \u003d new byte[(int) len];\n-        b64.setInitialBuffer(buf, 0, buf.length);\n-        b64.decode(base64Data, 0, base64Data.length);\n-        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.\n-        // We have no idea what the line-length was, so we\n-        // cannot know how much of our array wasn\u0027t used.\n-        byte[] result \u003d new byte[b64.pos];\n-        b64.readResults(result, 0, result.length);\n-        return result;\n+        return b64.decode(base64Data);\n     }\n \n     /**\n@@ -873,7 +855,53 @@\n      * @return A byte array containing only Base64 character data\n      */\n     public byte[] encode(byte[] pArray) {\n-        return encodeBase64(pArray, false, isUrlSafe());\n+        long len \u003d getEncodeLength(pArray, lineLength, lineSeparator);\n+        byte[] buf \u003d new byte[(int) len];\n+        setInitialBuffer(buf, 0, buf.length);\n+        encode(pArray, 0, pArray.length);\n+        encode(pArray, 0, -1); // Notify encoder of EOF.\n+        // Encoder might have resized, even though it was unnecessary.\n+        if (buffer !\u003d buf) {\n+            readResults(buf, 0, buf.length);\n+        }\n+        // In URL-SAFE mode we skip the padding characters, so sometimes our\n+        // final length is a bit smaller.\n+        if (isUrlSafe() \u0026\u0026 pos \u003c buf.length) {\n+            byte[] smallerBuf \u003d new byte[pos];\n+            System.arraycopy(buf, 0, smallerBuf, 0, pos);\n+            buf \u003d smallerBuf;\n+        }\n+        return buf;        \n+    }\n+\n+    /**\n+     * Pre-calculates the amount of space needed to base64-encode the supplied array.\n+     *\n+     * @param pArray byte[] array which will later be encoded\n+     * @param chunkSize line-length of the output (\u003c\u003d 0 means no chunking) between each\n+     *        chunkSeparator (e.g. CRLF).\n+     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n+     *\n+     * @return amount of space needed to encoded the supplied array.  Returns\n+     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n+     */\n+    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n+        // base64 always encodes to multiples of 4.\n+        chunkSize \u003d (chunkSize / 4) * 4;\n+\n+        long len \u003d (pArray.length * 4) / 3;\n+        long mod \u003d len % 4;\n+        if (mod !\u003d 0) {\n+            len +\u003d 4 - mod;\n+        }\n+        if (chunkSize \u003e 0 \u0026\u0026 chunkSeparator !\u003d null) {\n+            boolean lenChunksPerfectly \u003d len % chunkSize \u003d\u003d 0;\n+            len +\u003d (len / chunkSize) * chunkSeparator.length;\n+            if (!lenChunksPerfectly) {\n+                len +\u003d chunkSeparator.length;\n+            }\n+        }\n+        return len;\n     }\n \n     // Implementation of integer encoding used for crypto\n",
      "operations": [
        {
          "type": "insert-node",
          "from": "",
          "to": "MethodDeclaration [34430,35629]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Javadoc [34430,34991]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Modifier: private [34996,35003]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Modifier: static [35004,35010]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "PrimitiveType: long [35011,35015]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: getEncodeLength [35016,35031]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SingleVariableDeclaration [35047,35060]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SingleVariableDeclaration [35062,35083]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [35085,35629]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [12877,12937]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [27017,27097]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [27106,27141]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [27150,27183]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [27192,27229]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [27238,27271]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [27280,27302]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [27691,27721]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [27730,27768]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ReturnStatement [27777,27791]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "VariableDeclarationStatement [30316,30384]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "ReturnStatement [30769,30799]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "ReturnStatement [31095,31125]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [33675,33737]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [33746,33779]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [33788,33825]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "ExpressionStatement [33834,33867]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [33876,33898]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [34004,34079]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [34207,34390]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ReturnStatement [34399,34410]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [35147,35179]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ReturnStatement [35612,35623]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [26550,26606]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [27021,27057]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [27059,27097]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "PrimitiveType: long [30316,30320]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "VariableDeclarationFragment [30321,30383]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [35327,35366]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: len [30321,30324]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "MethodInvocation [30327,30383]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: getEncodeLength [30327,30342]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "METHOD_INVOCATION_ARGUMENTS [30343,30382]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "NumberLiteral: 0 [33849,33850]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "QualifiedName: pArray.length [33852,33865]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: binaryData [30343,30353]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: CHUNK_SEPARATOR [30367,30382]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: chunkSize [35417,35426]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: chunkSize [35459,35468]"
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [12871,12900]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "PREFIX_EXPRESSION_OPERATOR: ! [26491,26492]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "ParenthesizedExpression [26492,26519]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "PrefixExpression [26491,26519]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "SimpleName: decodeBase64 [26974,26986]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "METHOD_INVOCATION_ARGUMENTS [26987,26993]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "MethodInvocation [26974,26994]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "NumberLiteral: 0 [30448,30449]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "PrefixExpression [30451,30453]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [30279,30312]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [30321,30362]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [30371,30416]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "ExpressionStatement [30425,30455]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [30561,30644]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [30772,30963]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ReturnStatement [30972,30983]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [31244,31336]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "NumberLiteral: 0 [31597,31598]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "PrefixExpression [31600,31602]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [31380,31419]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [31428,31461]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [31470,31511]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [31520,31565]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "ExpressionStatement [31574,31604]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [31756,31790]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [31799,31841]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ReturnStatement [31850,31864]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "BooleanLiteral: false [34442,34447]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodInvocation [34449,34460]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "ReturnStatement [34414,34462]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "SimpleName: isChunked [29757,29766]",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/java/org/apache/commons/codec/binary/Base64InputStream.java",
        "src/java/org/apache/commons/codec/binary/Base64InputStream.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "org.apache.commons.codec.binary.Base64InputStream:Base64InputStream:[InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator]:null",
            "org.apache.commons.codec.binary.Base64InputStream:read:[byte b[], int offset, int len]:int",
            "org.apache.commons.codec.binary.Base64InputStream:markSupported:[]:boolean",
            "org.apache.commons.codec.binary.Base64InputStream:Base64InputStream:[InputStream in, boolean doEncode]:null",
            "org.apache.commons.codec.binary.Base64InputStream:read:[]:int",
            "org.apache.commons.codec.binary.Base64InputStream:Base64InputStream:[InputStream in]:null"
          ],
          "num": 6
        },
        {
          "qualified_names": [
            "org.apache.commons.codec.binary.Base64InputStream:Base64InputStream:[InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator]:null",
            "org.apache.commons.codec.binary.Base64InputStream:read:[]:int",
            "org.apache.commons.codec.binary.Base64InputStream:Base64InputStream:[InputStream in, boolean doEncode]:null",
            "org.apache.commons.codec.binary.Base64InputStream:markSupported:[]:boolean",
            "org.apache.commons.codec.binary.Base64InputStream:Base64InputStream:[InputStream in]:null",
            "org.apache.commons.codec.binary.Base64InputStream:read:[byte b[], int offset, int len]:int"
          ],
          "num": 6
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "25",
            "26",
            "27",
            "30",
            "31",
            "32",
            "33",
            "36",
            "37",
            "38",
            "52",
            "53",
            "54",
            "55",
            "62",
            "63",
            "64",
            "65",
            "66",
            "67",
            "76",
            "77",
            "78",
            "79",
            "80",
            "81",
            "82",
            "83",
            "84",
            "85",
            "86",
            "87",
            "88",
            "89",
            "100",
            "101",
            "115",
            "116",
            "117",
            "119",
            "120",
            "121",
            "124",
            "125",
            "126",
            "141",
            "147",
            "159"
          ],
          "num": 48
        },
        {
          "qualified_names": [
            "25",
            "26",
            "29",
            "30",
            "31",
            "32",
            "36",
            "37",
            "38",
            "39",
            "40",
            "49",
            "51",
            "55",
            "56",
            "57",
            "58",
            "65",
            "66",
            "67",
            "68",
            "69",
            "70",
            "71",
            "80",
            "81",
            "82",
            "83",
            "84",
            "85",
            "86",
            "87",
            "88",
            "89",
            "90",
            "91",
            "92",
            "93",
            "104",
            "105",
            "106",
            "120",
            "121",
            "123",
            "124",
            "125",
            "126",
            "127",
            "128",
            "130",
            "131",
            "132",
            "133",
            "134",
            "135",
            "136",
            "168"
          ],
          "num": 57
        }
      ],
      "diff": "diff --git a/src/java/org/apache/commons/codec/binary/Base64InputStream.java b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\nindex ce9a5d2..87bae71 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n@@ -22,21 +22,22 @@\n import java.io.InputStream;\n \n /**\n- * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).\n- * When encoding the default lineLength is 76 characters and the default\n- * lineEnding is CRLF, but these can be overridden by using the appropriate\n+ * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n+ * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n  * constructor.\n  * \u003cp\u003e\n- * The default behaviour of the Base64InputStream is to DECODE, whereas the\n- * default behaviour of the Base64OutputStream is to ENCODE, but this\n- * behaviour can be overridden by using a different constructor.\n- * \u003c/p\u003e\u003cp\u003e\n+ * The default behaviour of the Base64InputStream is to DECODE, whereas the default behaviour of the Base64OutputStream\n+ * is to ENCODE, but this behaviour can be overridden by using a different constructor.\n+ * \u003c/p\u003e\n+ * \u003cp\u003e\n  * This class implements section \u003ccite\u003e6.8. Base64 Content-Transfer-Encoding\u003c/cite\u003e from RFC 2045 \u003ccite\u003eMultipurpose\n  * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\u003c/cite\u003e by Freed and Borenstein.\n- * \u003c/p\u003e\u003cp\u003e\n- * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n- * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). \n  * \u003c/p\u003e\n+ * \u003cp\u003e\n+ * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n+ * \u003c/p\u003e\n+ * \n  * @author Apache Software Foundation\n  * @version $Id $\n  * @see \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2045.txt\"\u003eRFC 2045\u003c/a\u003e\n@@ -45,26 +46,29 @@\n public class Base64InputStream extends FilterInputStream {\n \n     private final boolean doEncode;\n+\n     private final Base64 base64;\n+\n     private final byte[] singleByte \u003d new byte[1];\n \n     /**\n-     * Creates a Base64InputStream such that all data read is Base64-decoded\n-     * from the original provided InputStream.\n-     *\n-     * @param in InputStream to wrap.\n+     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\n+     * \n+     * @param in\n+     *            InputStream to wrap.\n      */\n     public Base64InputStream(InputStream in) {\n         this(in, false);\n     }\n \n     /**\n-     * Creates a Base64InputStream such that all data read is either\n-     * Base64-encoded or Base64-decoded from the original provided InputStream.\n-     *\n-     * @param in       InputStream to wrap.\n-     * @param doEncode true if we should encode all data read from us,\n-     *                 false if we should decode.\n+     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n+     * provided InputStream.\n+     * \n+     * @param in\n+     *            InputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data read from us, false if we should decode.\n      */\n     public Base64InputStream(InputStream in, boolean doEncode) {\n         super(in);\n@@ -73,20 +77,20 @@\n     }\n \n     /**\n-     * Creates a Base64InputStream such that all data read is either\n-     * Base64-encoded or Base64-decoded from the original provided InputStream.\n-     *\n-     * @param in            InputStream to wrap.\n-     * @param doEncode      true if we should encode all data read from us,\n-     *                      false if we should decode.\n-     * @param lineLength    If doEncode is true, each line of encoded\n-     *                      data will contain lineLength characters.\n-     *                      If lineLength \u003c\u003d0, the encoded data is not divided into lines.\n-     *                      If doEncode is false, lineLength is ignored.\n-     * @param lineSeparator If doEncode is true, each line of encoded\n-     *                      data will be terminated with this byte sequence (e.g. \\r\\n).\n-     *                      If lineLength \u003c\u003d 0, the lineSeparator is not used.  \n-     *                      If doEncode is false lineSeparator is ignored.\n+     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n+     * provided InputStream.\n+     * \n+     * @param in\n+     *            InputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data read from us, false if we should decode.\n+     * @param lineLength\n+     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n+     *            nearest multiple of 4). If lineLength \u003c\u003d0, the encoded data is not divided into lines. If doEncode is\n+     *            false, lineLength is ignored.\n+     * @param lineSeparator\n+     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n+     *            If lineLength \u003c\u003d 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n     public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n         super(in);\n@@ -97,8 +101,9 @@\n     /**\n      * Reads one \u003ccode\u003ebyte\u003c/code\u003e from this input stream.\n      * \n-     * @return the byte as an integer in the range 0 to 255\n-     * Returns -1 if EOF has been reached.\n+     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\n+     * @throws IOException\n+     *             if an I/O error occurs.\n      */\n     public int read() throws IOException {\n         int r \u003d read(singleByte, 0, 1);\n@@ -112,18 +117,23 @@\n     }\n \n     /**\n-     * Attempts to read \u003ccode\u003elen\u003c/code\u003e bytes into the specified\n-     * \u003ccode\u003eb\u003c/code\u003e array starting at \u003ccode\u003eoffset\u003c/code\u003e from\n-     * this InputStream.\n+     * Attempts to read \u003ccode\u003elen\u003c/code\u003e bytes into the specified \u003ccode\u003eb\u003c/code\u003e array starting at \u003ccode\u003eoffset\u003c/code\u003e\n+     * from this InputStream.\n      * \n-     * @param b destination byte array\n-     * @param offset where to start writing the bytes\n-     * @param len maximum number of bytes to read\n+     * @param b\n+     *            destination byte array\n+     * @param offset\n+     *            where to start writing the bytes\n+     * @param len\n+     *            maximum number of bytes to read\n      * \n      * @return number of bytes read\n-     * @throws IOException if an I/O error occurs.\n-     * @throws NullPointerException if the byte array parameter is null\n-     * @throws IndexOutOfBoundsException if offset, len or buffer size are invalid\n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     * @throws NullPointerException\n+     *             if the byte array parameter is null\n+     * @throws IndexOutOfBoundsException\n+     *             if offset, len or buffer size are invalid\n      */\n     public int read(byte b[], int offset, int len) throws IOException {\n         if (b \u003d\u003d null) {\n@@ -138,13 +148,11 @@\n             if (!base64.hasData()) {\n                 byte[] buf \u003d new byte[doEncode ? 4096 : 8192];\n                 int c \u003d in.read(buf);\n-\n                 // A little optimization to avoid System.arraycopy()\n                 // when possible.\n                 if (c \u003e 0 \u0026\u0026 b.length \u003d\u003d len) {\n                     base64.setInitialBuffer(b, offset, len);\n                 }\n-\n                 if (doEncode) {\n                     base64.encode(buf, 0, c);\n                 } else {\n@@ -157,6 +165,7 @@\n \n     /**\n      * {@inheritDoc}\n+     * \n      * @return false\n      */\n     public boolean markSupported() {\n",
      "operations": [
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Javadoc [2512,2852]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Javadoc [3018,3933]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Javadoc [4162,4407]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [2523,2664]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TagElement [2736,2844]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [3029,3170]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TagElement [3242,3350]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TagElement [3358,3660]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TagElement [3668,3925]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [4240,4329]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [4337,4399]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: true if we should encode all data read from us, false if we should decode. [2770,2844]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: true if we should encode all data read from us, false if we should decode. [3276,3350]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to [3394,3492]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: nearest multiple of 4). If lineLength \u003c\u003d0, the encoded data is not divided into lines. If doEncode is [3511,3612]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: false, lineLength is ignored. [3631,3660]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n). [3707,3809]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: If lineLength \u003c\u003d 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored. [3828,3925]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: from the original provided InputStream. [2317,2356]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TagElement [2504,2645]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement:  true if we should encode all data read from us, [2719,2767]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: false if we should decode. [2791,2817]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TagElement [2704,2817]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Javadoc [2493,2825]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TagElement [3002,3143]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement:       true if we should encode all data read from us, [3222,3275]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: false if we should decode. [3304,3330]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TagElement [3207,3330]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement:     If doEncode is true, each line of encoded [3355,3400]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: data will contain lineLength characters. [3429,3469]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: If lineLength \u003c\u003d0, the encoded data is not divided into lines. [3498,3560]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: If doEncode is false, lineLength is ignored. [3589,3633]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TagElement [3338,3633]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement:  If doEncode is true, each line of encoded [3661,3703]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: data will be terminated with this byte sequence (e.g. \\r\\n). [3732,3792]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: If lineLength \u003c\u003d 0, the lineSeparator is not used.   [3821,3873]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: If doEncode is false lineSeparator is ignored. [3902,3948]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TagElement [3641,3948]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Javadoc [2991,3956]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TagElement [4263,4358]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Javadoc [4185,4366]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: this InputStream. [4804,4821]",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/java/org/apache/commons/codec/binary/Base64OutputStream.java",
        "src/java/org/apache/commons/codec/binary/Base64OutputStream.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "org.apache.commons.codec.binary.Base64OutputStream:flush:[boolean propogate]:void",
            "org.apache.commons.codec.binary.Base64OutputStream:Base64OutputStream:[OutputStream out, boolean doEncode]:null",
            "org.apache.commons.codec.binary.Base64OutputStream:Base64OutputStream:[OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator]:null",
            "org.apache.commons.codec.binary.Base64OutputStream:close:[]:void",
            "org.apache.commons.codec.binary.Base64OutputStream:Base64OutputStream:[OutputStream out]:null",
            "org.apache.commons.codec.binary.Base64OutputStream:flush:[]:void",
            "org.apache.commons.codec.binary.Base64OutputStream:write:[byte b[], int offset, int len]:void",
            "org.apache.commons.codec.binary.Base64OutputStream:write:[int i]:void"
          ],
          "num": 8
        },
        {
          "qualified_names": [
            "org.apache.commons.codec.binary.Base64OutputStream:flush:[]:void",
            "org.apache.commons.codec.binary.Base64OutputStream:write:[int i]:void",
            "org.apache.commons.codec.binary.Base64OutputStream:Base64OutputStream:[OutputStream out]:null",
            "org.apache.commons.codec.binary.Base64OutputStream:close:[]:void",
            "org.apache.commons.codec.binary.Base64OutputStream:write:[byte b[], int offset, int len]:void",
            "org.apache.commons.codec.binary.Base64OutputStream:flush:[boolean propogate]:void",
            "org.apache.commons.codec.binary.Base64OutputStream:Base64OutputStream:[OutputStream out, boolean doEncode]:null",
            "org.apache.commons.codec.binary.Base64OutputStream:Base64OutputStream:[OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator]:null"
          ],
          "num": 8
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "25",
            "26",
            "27",
            "30",
            "31",
            "32",
            "33",
            "36",
            "39",
            "51",
            "52",
            "53",
            "54",
            "61",
            "62",
            "63",
            "64",
            "65",
            "66",
            "75",
            "76",
            "77",
            "78",
            "79",
            "80",
            "81",
            "82",
            "83",
            "84",
            "85",
            "86",
            "87",
            "88",
            "97",
            "105",
            "106",
            "107",
            "108",
            "109",
            "110",
            "111",
            "113",
            "114",
            "115",
            "135",
            "136",
            "137",
            "138",
            "139",
            "140",
            "141",
            "158",
            "159",
            "160",
            "161",
            "164",
            "168",
            "169"
          ],
          "num": 58
        },
        {
          "qualified_names": [
            "25",
            "26",
            "29",
            "30",
            "31",
            "32",
            "35",
            "36",
            "39",
            "40",
            "48",
            "50",
            "54",
            "55",
            "56",
            "57",
            "64",
            "65",
            "66",
            "67",
            "68",
            "69",
            "70",
            "79",
            "80",
            "81",
            "82",
            "83",
            "84",
            "85",
            "86",
            "87",
            "88",
            "89",
            "90",
            "91",
            "92",
            "102",
            "103",
            "104",
            "105",
            "106",
            "114",
            "115",
            "117",
            "118",
            "119",
            "120",
            "121",
            "122",
            "123",
            "124",
            "125",
            "126",
            "127",
            "128",
            "129",
            "149",
            "150",
            "151",
            "152",
            "153",
            "154",
            "155",
            "172",
            "173",
            "174",
            "175",
            "178",
            "182",
            "183",
            "184",
            "185"
          ],
          "num": 73
        }
      ],
      "diff": "diff --git a/src/java/org/apache/commons/codec/binary/Base64OutputStream.java b/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\nindex 5069095..349c642 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n@@ -22,21 +22,22 @@\n import java.io.OutputStream;\n \n /**\n- * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).\n- * When encoding the default lineLength is 76 characters and the default\n- * lineEnding is CRLF, but these can be overridden by using the appropriate\n+ * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n+ * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n  * constructor.\n  * \u003cp\u003e\n- * The default behaviour of the Base64OutputStream is to ENCODE, whereas the\n- * default behaviour of the Base64InputStream is to DECODE.  But this behaviour\n- * can be overridden by using a different constructor.\n- * \u003c/p\u003e\u003cp\u003e\n+ * The default behaviour of the Base64OutputStream is to ENCODE, whereas the default behaviour of the Base64InputStream\n+ * is to DECODE. But this behaviour can be overridden by using a different constructor.\n+ * \u003c/p\u003e\n+ * \u003cp\u003e\n  * This class implements section \u003ccite\u003e6.8. Base64 Content-Transfer-Encoding\u003c/cite\u003e from RFC 2045 \u003ccite\u003eMultipurpose\n  * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\u003c/cite\u003e by Freed and Borenstein.\n- * \u003c/p\u003e\u003cp\u003e\n+ * \u003c/p\u003e\n+ * \u003cp\u003e\n  * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n  * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n- * \u003c/p\u003e \n+ * \u003c/p\u003e\n+ * \n  * @author Apache Software Foundation\n  * @version $Id $\n  * @see \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2045.txt\"\u003eRFC 2045\u003c/a\u003e\n@@ -44,26 +45,29 @@\n  */\n public class Base64OutputStream extends FilterOutputStream {\n     private final boolean doEncode;\n+\n     private final Base64 base64;\n+\n     private final byte[] singleByte \u003d new byte[1];\n \n     /**\n-     * Creates a Base64OutputStream such that all data written is Base64-encoded\n-     * to the original provided OutputStream.\n-     *\n-     * @param out OutputStream to wrap.\n+     * Creates a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.\n+     * \n+     * @param out\n+     *            OutputStream to wrap.\n      */\n     public Base64OutputStream(OutputStream out) {\n         this(out, true);\n     }\n \n     /**\n-     * Creates a Base64OutputStream such that all data written is either\n-     * Base64-encoded or Base64-decoded to the original provided OutputStream.\n-     *\n-     * @param out      OutputStream to wrap.\n-     * @param doEncode true if we should encode all data written to us,\n-     *                 false if we should decode.\n+     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n+     * original provided OutputStream.\n+     * \n+     * @param out\n+     *            OutputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data written to us, false if we should decode.\n      */\n     public Base64OutputStream(OutputStream out, boolean doEncode) {\n         super(out);\n@@ -72,20 +76,20 @@\n     }\n \n     /**\n-     * Creates a Base64OutputStream such that all data written is either\n-     * Base64-encoded or Base64-decoded to the original provided OutputStream.\n-     *\n-     * @param out           OutputStream to wrap.\n-     * @param doEncode      true if we should encode all data written to us,\n-     *                      false if we should decode.\n-     * @param lineLength    If doEncode is true, each line of encoded\n-     *                      data will contain lineLength characters.  \n-     *                      If lineLength \u003c\u003d0, the encoded data is not divided into lines.\n-     *                      If doEncode is false, lineLength is ignored.\n-     * @param lineSeparator If doEncode is true, each line of encoded\n-     *                      data will be terminated with this byte sequence (e.g. \\r\\n).  \n-     *                      If lineLength \u003c\u003d 0, the lineSeparator is not used.\n-     *                      If doEncode is false lineSeparator is ignored.\n+     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n+     * original provided OutputStream.\n+     * \n+     * @param out\n+     *            OutputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data written to us, false if we should decode.\n+     * @param lineLength\n+     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n+     *            nearest multiple of 4). If lineLength \u003c\u003d0, the encoded data is not divided into lines. If doEncode is\n+     *            false, lineLength is ignored.\n+     * @param lineSeparator\n+     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n+     *            If lineLength \u003c\u003d 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n     public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {\n         super(out);\n@@ -95,6 +99,11 @@\n \n     /**\n      * Writes the specified \u003ccode\u003ebyte\u003c/code\u003e to this output stream.\n+     * \n+     * @param i\n+     *            source byte\n+     * @throws IOException\n+     *             if an I/O error occurs.\n      */\n     public void write(int i) throws IOException {\n         singleByte[0] \u003d (byte) i;\n@@ -102,17 +111,22 @@\n     }\n \n     /**\n-     * Writes \u003ccode\u003elen\u003c/code\u003e bytes from the specified\n-     * \u003ccode\u003eb\u003c/code\u003e array starting at \u003ccode\u003eoffset\u003c/code\u003e to\n-     * this output stream.\n-     *\n-     * @param b source byte array\n-     * @param offset where to start reading the bytes\n-     * @param len maximum number of bytes to write\n+     * Writes \u003ccode\u003elen\u003c/code\u003e bytes from the specified \u003ccode\u003eb\u003c/code\u003e array starting at \u003ccode\u003eoffset\u003c/code\u003e to this\n+     * output stream.\n      * \n-     * @throws IOException if an I/O error occurs.\n-     * @throws NullPointerException if the byte array parameter is null\n-     * @throws IndexOutOfBoundsException if offset, len or buffer size are invalid\n+     * @param b\n+     *            source byte array\n+     * @param offset\n+     *            where to start reading the bytes\n+     * @param len\n+     *            maximum number of bytes to write\n+     * \n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     * @throws NullPointerException\n+     *             if the byte array parameter is null\n+     * @throws IndexOutOfBoundsException\n+     *             if offset, len or buffer size are invalid\n      */\n     public void write(byte b[], int offset, int len) throws IOException {\n         if (b \u003d\u003d null) {\n@@ -132,13 +146,13 @@\n     }\n \n     /**\n-     * Flushes this output stream and forces any buffered output bytes\n-     * to be written out to the stream.  If propogate is true, the wrapped\n-     * stream will also be flushed.\n-     *\n-     * @param propogate boolean flag to indicate whether the wrapped\n-     *                  OutputStream should also be flushed.\n-     * @throws IOException if an I/O error occurs.\n+     * Flushes this output stream and forces any buffered output bytes to be written out to the stream. If propogate is\n+     * true, the wrapped stream will also be flushed.\n+     * \n+     * @param propogate\n+     *            boolean flag to indicate whether the wrapped OutputStream should also be flushed.\n+     * @throws IOException\n+     *             if an I/O error occurs.\n      */\n     private void flush(boolean propogate) throws IOException {\n         int avail \u003d base64.avail();\n@@ -155,18 +169,20 @@\n     }\n \n     /**\n-     * Flushes this output stream and forces any buffered output bytes\n-     * to be written out to the stream.\n-     *\n-     * @throws IOException if an I/O error occurs.\n+     * Flushes this output stream and forces any buffered output bytes to be written out to the stream.\n+     * \n+     * @throws IOException\n+     *             if an I/O error occurs.\n      */\n     public void flush() throws IOException {\n-        flush(true); \n+        flush(true);\n     }\n \n     /**\n-     * Closes this output stream and releases any system resources\n-     * associated with the stream.\n+     * Closes this output stream and releases any system resources associated with the stream.\n+     * \n+     * @throws IOException\n+     *             if an I/O error occurs.\n      */\n     public void close() throws IOException {\n         // Notify encoder of EOF (-1).\n",
      "operations": [
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Javadoc [2523,2869]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Javadoc [3039,3960]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Javadoc [4193,4397]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Javadoc [5741,6128]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Javadoc [6779,6963]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [2534,2678]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TagElement [2752,2861]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [3050,3194]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TagElement [3268,3377]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TagElement [3385,3687]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TagElement [3695,3952]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [4281,4319]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [4327,4389]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [5752,5918]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TagElement [5934,6050]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: true if we should encode all data written to us, false if we should decode. [2786,2861]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: true if we should encode all data written to us, false if we should decode. [3302,3377]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to [3421,3519]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: nearest multiple of 4). If lineLength \u003c\u003d0, the encoded data is not divided into lines. If doEncode is [3538,3639]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: false, lineLength is ignored. [3658,3687]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n). [3734,3836]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: If lineLength \u003c\u003d 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored. [3855,3952]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: boolean flag to indicate whether the wrapped OutputStream should also be flushed. [5969,6050]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: to the original provided OutputStream. [2325,2363]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TagElement [2516,2660]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement:  true if we should encode all data written to us, [2735,2784]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: false if we should decode. [2808,2834]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TagElement [2720,2834]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Javadoc [2505,2842]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TagElement [3023,3167]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement:       true if we should encode all data written to us, [3247,3301]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: false if we should decode. [3330,3356]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TagElement [3232,3356]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement:     If doEncode is true, each line of encoded [3381,3426]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: data will contain lineLength characters.   [3455,3497]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: If lineLength \u003c\u003d0, the encoded data is not divided into lines. [3526,3588]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: If doEncode is false, lineLength is ignored. [3617,3661]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TagElement [3364,3661]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement:  If doEncode is true, each line of encoded [3689,3731]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: data will be terminated with this byte sequence (e.g. \\r\\n).   [3760,3822]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: If lineLength \u003c\u003d 0, the lineSeparator is not used. [3851,3901]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: If doEncode is false lineSeparator is ignored. [3930,3976]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TagElement [3669,3976]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Javadoc [3012,3984]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Javadoc [4217,4297]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: this output stream. [4556,4575]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TagElement [5547,5721]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement:  boolean flag to indicate whether the wrapped [5752,5797]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: OutputStream should also be flushed. [5822,5858]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TagElement [5736,5858]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Javadoc [5536,5917]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: to be written out to the stream. [6379,6411]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "Javadoc [6556,6669]",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "org.apache.commons.codec.net.QuotedPrintableCodec:encode:[String pString, String charset]:String",
            "org.apache.commons.codec.net.QuotedPrintableCodec:decode:[String pString, String charset]:String"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "org.apache.commons.codec.net.QuotedPrintableCodec:decode:[String pString, String charset]:String",
            "org.apache.commons.codec.net.QuotedPrintableCodec:encode:[String pString, String charset]:String"
          ],
          "num": 2
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "31",
            "280",
            "385"
          ],
          "num": 3
        },
        {
          "qualified_names": [
            "31",
            "280",
            "385"
          ],
          "num": 3
        }
      ],
      "diff": "diff --git a/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java b/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\nindex ab34516..9c546f5 100644\n--- a/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n+++ b/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n@@ -28,7 +28,7 @@\n import org.apache.commons.codec.CharEncoding;\n import org.apache.commons.codec.StringDecoder;\n import org.apache.commons.codec.StringEncoder;\n-import org.apache.commons.codec.binary.StringBytesUtils;\n+import org.apache.commons.codec.binary.StringUtils;\n \n /**\n  * \u003cp\u003e\n@@ -277,7 +277,7 @@\n         if (pString \u003d\u003d null) {\n             return null;\n         }\n-        return new String(decode(StringBytesUtils.getBytesUsAscii(pString)), charset);\n+        return new String(decode(StringUtils.getBytesUsAscii(pString)), charset);\n     }\n \n     /**\n@@ -382,6 +382,6 @@\n         if (pString \u003d\u003d null) {\n             return null;\n         }\n-        return StringBytesUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n+        return StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n     }\n }\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [1288,1339]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ImportDeclaration [1288,1344]",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/java/org/apache/commons/codec/net/RFC1522Codec.java",
        "src/java/org/apache/commons/codec/net/RFC1522Codec.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "org.apache.commons.codec.net.RFC1522Codec:decodeText:[final String text]:String",
            "org.apache.commons.codec.net.RFC1522Codec:encodeText:[final String text, final String charset]:String"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "org.apache.commons.codec.net.RFC1522Codec:encodeText:[final String text, final String charset]:String",
            "org.apache.commons.codec.net.RFC1522Codec:decodeText:[final String text]:String"
          ],
          "num": 2
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "24",
            "79",
            "128"
          ],
          "num": 3
        },
        {
          "qualified_names": [
            "24",
            "79",
            "128"
          ],
          "num": 3
        }
      ],
      "diff": "diff --git a/src/java/org/apache/commons/codec/net/RFC1522Codec.java b/src/java/org/apache/commons/codec/net/RFC1522Codec.java\nindex ac0be48..a33b573 100644\n--- a/src/java/org/apache/commons/codec/net/RFC1522Codec.java\n+++ b/src/java/org/apache/commons/codec/net/RFC1522Codec.java\n@@ -21,7 +21,7 @@\n \n import org.apache.commons.codec.DecoderException;\n import org.apache.commons.codec.EncoderException;\n-import org.apache.commons.codec.binary.StringBytesUtils;\n+import org.apache.commons.codec.binary.StringUtils;\n \n /**\n  * \u003cp\u003e\n@@ -76,7 +76,7 @@\n         buffer.append(getEncoding()); \n         buffer.append(\u0027?\u0027);\n         byte [] rawdata \u003d doEncoding(text.getBytes(charset)); \n-        buffer.append(StringBytesUtils.newStringUsAscii(rawdata));\n+        buffer.append(StringUtils.newStringUsAscii(rawdata));\n         buffer.append(\"?\u003d\"); \n         return buffer.toString();\n     }\n@@ -125,7 +125,7 @@\n         }\n         from \u003d to + 1;\n         to \u003d text.indexOf(\"?\", from);\n-        byte[] data \u003d StringBytesUtils.getBytesUsAscii(text.substring(from, to));\n+        byte[] data \u003d StringUtils.getBytesUsAscii(text.substring(from, to));\n         data \u003d doDecoding(data); \n         return new String(data, charset);\n     }\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [991,1042]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ImportDeclaration [991,1047]",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/java/org/apache/commons/codec/net/URLCodec.java",
        "src/java/org/apache/commons/codec/net/URLCodec.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "org.apache.commons.codec.net.URLCodec:decode:[String pString, String charset]:String",
            "org.apache.commons.codec.net.URLCodec:encode:[String pString, String charset]:String"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "org.apache.commons.codec.net.URLCodec:encode:[String pString, String charset]:String",
            "org.apache.commons.codec.net.URLCodec:decode:[String pString, String charset]:String"
          ],
          "num": 2
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "31",
            "227",
            "268"
          ],
          "num": 3
        },
        {
          "qualified_names": [
            "31",
            "227",
            "268"
          ],
          "num": 3
        }
      ],
      "diff": "diff --git a/src/java/org/apache/commons/codec/net/URLCodec.java b/src/java/org/apache/commons/codec/net/URLCodec.java\nindex 4842003..a8599c0 100644\n--- a/src/java/org/apache/commons/codec/net/URLCodec.java\n+++ b/src/java/org/apache/commons/codec/net/URLCodec.java\n@@ -28,7 +28,7 @@\n import org.apache.commons.codec.CharEncoding;\n import org.apache.commons.codec.StringDecoder;\n import org.apache.commons.codec.StringEncoder;\n-import org.apache.commons.codec.binary.StringBytesUtils;\n+import org.apache.commons.codec.binary.StringUtils;\n \n /**\n  * \u003cp\u003eImplements the \u0027www-form-urlencoded\u0027 encoding scheme, \n@@ -224,7 +224,7 @@\n         if (pString \u003d\u003d null) {\n             return null;\n         }\n-        return StringBytesUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n+        return StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n     }\n \n     /**\n@@ -265,7 +265,7 @@\n         if (pString \u003d\u003d null) {\n             return null;\n         }\n-        return new String(decode(StringBytesUtils.getBytesUsAscii(pString)), charset);\n+        return new String(decode(StringUtils.getBytesUsAscii(pString)), charset);\n     }\n \n     /**\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [1288,1339]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ImportDeclaration [1288,1344]",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/java/org/apache/commons/codec/binary/StringBytesUtils.java",
        "src/java/org/apache/commons/codec/binary/StringUtils.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [],
          "num": 0
        },
        {
          "qualified_names": [
            "org.apache.commons.codec.binary.StringUtils:newStringIso8859_1:[byte[] bytes]:String",
            "org.apache.commons.codec.binary.StringUtils:newStringUtf16Le:[byte[] bytes]:String",
            "org.apache.commons.codec.binary.StringUtils:getSupportedBytes:[String string, String charsetName]:byte[]",
            "org.apache.commons.codec.binary.StringUtils:getBytesIso8859_1:[String string]:byte[]",
            "org.apache.commons.codec.binary.StringUtils:getBytesUtf16Be:[String string]:byte[]",
            "org.apache.commons.codec.binary.StringUtils:getBytesUtf16Le:[String string]:byte[]",
            "org.apache.commons.codec.binary.StringUtils:newStringUtf16:[byte[] bytes]:String",
            "org.apache.commons.codec.binary.StringUtils:getBytesUtf8:[String string]:byte[]",
            "org.apache.commons.codec.binary.StringUtils:getBytesUtf16:[String string]:byte[]",
            "org.apache.commons.codec.binary.StringUtils:newStringUtf16Be:[byte[] bytes]:String",
            "org.apache.commons.codec.binary.StringUtils:newStringUsAscii:[byte[] bytes]:String",
            "org.apache.commons.codec.binary.StringUtils:newString:[byte[] bytes, String charsetName]:String",
            "org.apache.commons.codec.binary.StringUtils:getBytesUsAscii:[String string]:byte[]",
            "org.apache.commons.codec.binary.StringUtils:newIllegalStateException:[String charsetName, UnsupportedEncodingException e]:IllegalStateException",
            "org.apache.commons.codec.binary.StringUtils:newStringUtf8:[byte[] bytes]:String",
            "org.apache.commons.codec.binary.StringUtils:StringUtils:[]:null"
          ],
          "num": 16
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "-1"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10",
            "11",
            "12",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "27",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "37",
            "38",
            "39",
            "40",
            "41",
            "42",
            "43",
            "44",
            "45",
            "46",
            "47",
            "48",
            "49",
            "50",
            "51",
            "52",
            "53",
            "54",
            "55",
            "56",
            "57",
            "58",
            "59",
            "60",
            "61",
            "62",
            "63",
            "64",
            "65",
            "66",
            "67",
            "68",
            "69",
            "70",
            "71",
            "72",
            "73",
            "74",
            "75",
            "76",
            "77",
            "78",
            "79",
            "80",
            "81",
            "82",
            "83",
            "84",
            "85",
            "86",
            "87",
            "88",
            "89",
            "90",
            "91",
            "92",
            "93",
            "94",
            "95",
            "96",
            "97",
            "98",
            "99",
            "100",
            "101",
            "102",
            "103",
            "104",
            "105",
            "106",
            "107",
            "108",
            "109",
            "110",
            "111",
            "112",
            "113",
            "114",
            "115",
            "116",
            "117",
            "118",
            "119",
            "120",
            "121",
            "122",
            "123",
            "124",
            "125",
            "126",
            "127",
            "128",
            "129",
            "130",
            "131",
            "132",
            "133",
            "134",
            "135",
            "136",
            "137",
            "138",
            "139",
            "140",
            "141",
            "142",
            "143",
            "144",
            "145",
            "146",
            "147",
            "148",
            "149",
            "150",
            "151",
            "152",
            "153",
            "154",
            "155",
            "156",
            "157",
            "158",
            "159",
            "160",
            "161",
            "162",
            "163",
            "164",
            "165",
            "166",
            "167",
            "168",
            "169",
            "170",
            "171",
            "172",
            "173",
            "174",
            "175",
            "176",
            "177",
            "178",
            "179",
            "180",
            "181",
            "182",
            "183",
            "184",
            "185",
            "186",
            "187",
            "188",
            "189",
            "190",
            "191",
            "192",
            "193",
            "194",
            "195",
            "196",
            "197",
            "198",
            "199",
            "200",
            "201",
            "202",
            "203",
            "204",
            "205",
            "206",
            "207",
            "208",
            "209",
            "210",
            "211",
            "212",
            "213",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "220",
            "221",
            "222",
            "223",
            "224",
            "225",
            "226",
            "227",
            "228",
            "229",
            "230",
            "231",
            "232",
            "233",
            "234",
            "235",
            "236",
            "237",
            "238",
            "239",
            "240",
            "241",
            "242",
            "243",
            "244",
            "245",
            "246",
            "247",
            "248",
            "249",
            "250",
            "251",
            "252",
            "253",
            "254",
            "255",
            "256",
            "257",
            "258",
            "259",
            "260",
            "261",
            "262",
            "263",
            "264",
            "265",
            "266",
            "267",
            "268",
            "269",
            "270",
            "271",
            "272",
            "273",
            "274",
            "275",
            "276"
          ],
          "num": 276
        }
      ],
      "diff": "diff --git a/src/java/org/apache/commons/codec/binary/StringUtils.java b/src/java/org/apache/commons/codec/binary/StringUtils.java\nnew file mode 100644\nindex 0000000..eb8d2e0\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/binary/StringUtils.java\n@@ -0,0 +1,276 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.UnsupportedEncodingException;\n+\n+import org.apache.commons.codec.CharEncoding;\n+\n+/**\n+ * Converts String to bytes using the encodings required by the Java specification. These encodings are specified in \u003ca\n+ * href\u003d\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\"\u003eStandard charsets\u003c/a\u003e\n+ * \n+ * @see CharEncoding\n+ * @see \u003ca href\u003d\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\"\u003eStandard charsets\u003c/a\u003e\n+ * @author \u003ca href\u003d\"mailto:ggregory@seagullsw.com\"\u003eGary Gregory\u003c/a\u003e\n+ * @version $Id: $\n+ * @since 1.4\n+ */\n+public class StringUtils {\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n+     * byte array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see \u003ca href\u003d\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\"\u003eStandard charsets\u003c/a\u003e\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesIso8859_1(String string) {\n+        return StringUtils.getSupportedBytes(string, CharEncoding.ISO_8859_1);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see \u003ca href\u003d\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\"\u003eStandard charsets\u003c/a\u003e\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesUsAscii(String string) {\n+        return StringUtils.getSupportedBytes(string, CharEncoding.US_ASCII);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see \u003ca href\u003d\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\"\u003eStandard charsets\u003c/a\u003e\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesUtf16(String string) {\n+        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see \u003ca href\u003d\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\"\u003eStandard charsets\u003c/a\u003e\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesUtf16Be(String string) {\n+        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16BE);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see \u003ca href\u003d\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\"\u003eStandard charsets\u003c/a\u003e\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesUtf16Le(String string) {\n+        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16LE);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see \u003ca href\u003d\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\"\u003eStandard charsets\u003c/a\u003e\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesUtf8(String string) {\n+        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_8);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n+     * array.\n+     * \u003cp\u003e\n+     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n+     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n+     * \u003c/p\u003e\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @param charsetName\n+     *            The name of a required {@link java.nio.charset.Charset}\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n+     *             required charset name.\n+     * @see CharEncoding\n+     * @see String#getBytes(String)\n+     */\n+    public static byte[] getSupportedBytes(String string, String charsetName) {\n+        try {\n+            return string.getBytes(charsetName);\n+        } catch (UnsupportedEncodingException e) {\n+            throw StringUtils.newIllegalStateException(charsetName, e);\n+        }\n+    }\n+\n+    private static IllegalStateException newIllegalStateException(String charsetName, UnsupportedEncodingException e) {\n+        return new IllegalStateException(charsetName + \": \" + e);\n+    }\n+\n+    /**\n+     * Constructs a new \u003ccode\u003eString\u003c/code\u003e by decoding the specified array of bytes using the given charset.\n+     * \u003cp\u003e\n+     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n+     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n+     * \u003c/p\u003e\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @param charsetName\n+     *            The name of a required {@link java.nio.charset.Charset}\n+     * @return A new \u003ccode\u003eString\u003c/code\u003e decoded from the specified array of bytes using the given charset.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n+     *             required charset name.\n+     * @see CharEncoding\n+     * @see String#String(byte[], String)\n+     */\n+    public static String newString(byte[] bytes, String charsetName) {\n+        try {\n+            return new String(bytes, charsetName);\n+        } catch (UnsupportedEncodingException e) {\n+            throw StringUtils.newIllegalStateException(charsetName, e);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a new \u003ccode\u003eString\u003c/code\u003e by decoding the specified array of bytes using the ISO-8859-1 charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new \u003ccode\u003eString\u003c/code\u003e decoded from the specified array of bytes using the given charset.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringIso8859_1(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.ISO_8859_1);\n+    }\n+\n+    /**\n+     * Constructs a new \u003ccode\u003eString\u003c/code\u003e by decoding the specified array of bytes using the US-ASCII charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new \u003ccode\u003eString\u003c/code\u003e decoded from the specified array of bytes using the given charset.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUsAscii(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.US_ASCII);\n+    }\n+\n+    /**\n+     * Constructs a new \u003ccode\u003eString\u003c/code\u003e by decoding the specified array of bytes using the UTF-16 charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new \u003ccode\u003eString\u003c/code\u003e decoded from the specified array of bytes using the given charset.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUtf16(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.UTF_16);\n+    }\n+\n+    /**\n+     * Constructs a new \u003ccode\u003eString\u003c/code\u003e by decoding the specified array of bytes using the UTF-16BE charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new \u003ccode\u003eString\u003c/code\u003e decoded from the specified array of bytes using the given charset.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUtf16Be(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.UTF_16BE);\n+    }\n+\n+    /**\n+     * Constructs a new \u003ccode\u003eString\u003c/code\u003e by decoding the specified array of bytes using the UTF-16LE charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new \u003ccode\u003eString\u003c/code\u003e decoded from the specified array of bytes using the given charset.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUtf16Le(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.UTF_16LE);\n+    }\n+\n+    /**\n+     * Constructs a new \u003ccode\u003eString\u003c/code\u003e by decoding the specified array of bytes using the UTF-8 charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new \u003ccode\u003eString\u003c/code\u003e decoded from the specified array of bytes using the given charset.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUtf8(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.UTF_8);\n+    }\n+\n+    private StringUtils() {\n+        // noop, cannot instantiate. Can always relax later.\n+    }\n+}\n",
      "operations": [
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [7549,7649]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [8409,8509]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [9063,9163]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [9711,9811]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [10357,10457]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [11007,11107]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [11654,11754]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        }
      ]
    }
  ],
  "inducing_type": {
    "add_classes": {
      "qualified_names": [
        "src/java/org/apache/commons/codec/binary/StringUtils.java"
      ],
      "num": 1
    },
    "delete_classes": {
      "qualified_names": [
        "src/java/org/apache/commons/codec/binary/StringBytesUtils.java"
      ],
      "num": 1
    },
    "add_functions": {
      "qualified_names": [
        "org.apache.commons.codec.binary.StringUtils:newIllegalStateException:[String charsetName, UnsupportedEncodingException e]:IllegalStateException",
        "org.apache.commons.codec.binary.StringUtils:getBytesUtf16Be:[String string]:byte[]",
        "org.apache.commons.codec.binary.StringUtils:newStringUtf16:[byte[] bytes]:String",
        "org.apache.commons.codec.binary.StringUtils:newStringIso8859_1:[byte[] bytes]:String",
        "org.apache.commons.codec.binary.StringUtils:getSupportedBytes:[String string, String charsetName]:byte[]",
        "org.apache.commons.codec.binary.StringUtils:getBytesUtf16Le:[String string]:byte[]",
        "org.apache.commons.codec.binary.StringUtils:newStringUsAscii:[byte[] bytes]:String",
        "org.apache.commons.codec.binary.StringUtils:getBytesIso8859_1:[String string]:byte[]",
        "org.apache.commons.codec.binary.StringUtils:newStringUtf16Le:[byte[] bytes]:String",
        "org.apache.commons.codec.binary.StringUtils:getBytesUsAscii:[String string]:byte[]",
        "org.apache.commons.codec.binary.StringUtils:newStringUtf16Be:[byte[] bytes]:String",
        "org.apache.commons.codec.binary.StringUtils:getBytesUtf16:[String string]:byte[]",
        "org.apache.commons.codec.binary.StringUtils:StringUtils:[]:null",
        "org.apache.commons.codec.binary.Base64:getEncodeLength:[byte[] pArray, int chunkSize, byte[] chunkSeparator]:long",
        "org.apache.commons.codec.binary.StringUtils:newString:[byte[] bytes, String charsetName]:String",
        "org.apache.commons.codec.binary.StringUtils:getBytesUtf8:[String string]:byte[]",
        "org.apache.commons.codec.binary.StringUtils:newStringUtf8:[byte[] bytes]:String"
      ],
      "num": 17
    },
    "delete_functions": {
      "qualified_names": [],
      "num": 0
    }
  },
  "trigger_tests": [
    {
      "test_class": "org.apache.commons.codec.binary.Base64Codec13Test",
      "test_function": "testEncoder",
      "assertion_line": "378",
      "exception": "junit.framework.AssertionFailedError",
      "message": "Encoder test-1"
    },
    {
      "test_class": "org.apache.commons.codec.binary.Base64Codec13Test",
      "test_function": "testBinaryEncoder",
      "assertion_line": "414",
      "exception": "junit.framework.AssertionFailedError",
      "message": "BinaryEncoder test-1"
    }
  ],
  "fixing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/java/org/apache/commons/codec/binary/Base64.java",
        "src/java/org/apache/commons/codec/binary/Base64.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "org.apache.commons.codec.binary.Base64:Base64:[]:null"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "org.apache.commons.codec.binary.Base64:Base64:[]:null"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "217",
            "225"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "217",
            "225"
          ],
          "num": 2
        }
      ],
      "diff": "diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java\nindex cf9d592..31671e6 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n@@ -214,7 +214,7 @@\n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n      * \u003cp\u003e\n-     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n+     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n      * \u003c/p\u003e\n      * \n      * \u003cp\u003e\n@@ -222,7 +222,7 @@\n      * \u003c/p\u003e\n      */\n     public Base64() {\n-        this(false);\n+        this(0);\n     }\n \n     /**\n",
      "operations": [
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "NumberLiteral: 0 [9005,9006]"
        },
        {
          "type": "delete-node",
          "from": "BooleanLiteral: false [9020,9025]",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/java/org/apache/commons/codec/binary/Base64InputStream.java",
        "src/java/org/apache/commons/codec/binary/Base64InputStream.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "org.apache.commons.codec.binary.Base64InputStream:Base64InputStream:[InputStream in, boolean doEncode]:null"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "org.apache.commons.codec.binary.Base64InputStream:Base64InputStream:[InputStream in, boolean doEncode]:null"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "76"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "76"
          ],
          "num": 1
        }
      ],
      "diff": "diff --git a/src/java/org/apache/commons/codec/binary/Base64InputStream.java b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\nindex 6fd27a9..d6c05a6 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n@@ -73,7 +73,7 @@\n     public Base64InputStream(InputStream in, boolean doEncode) {\n         super(in);\n         this.doEncode \u003d doEncode;\n-        this.base64 \u003d new Base64();\n+        this.base64 \u003d new Base64(false);\n     }\n \n     /**\n",
      "operations": [
        {
          "type": "insert-node",
          "from": "",
          "to": "BooleanLiteral: false [3004,3009]"
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/java/org/apache/commons/codec/binary/Base64OutputStream.java",
        "src/java/org/apache/commons/codec/binary/Base64OutputStream.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "org.apache.commons.codec.binary.Base64OutputStream:Base64OutputStream:[OutputStream out, boolean doEncode]:null"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "org.apache.commons.codec.binary.Base64OutputStream:Base64OutputStream:[OutputStream out, boolean doEncode]:null"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "75"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "75"
          ],
          "num": 1
        }
      ],
      "diff": "diff --git a/src/java/org/apache/commons/codec/binary/Base64OutputStream.java b/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\nindex e5ebcb3..2dc26b0 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n@@ -72,7 +72,7 @@\n     public Base64OutputStream(OutputStream out, boolean doEncode) {\n         super(out);\n         this.doEncode \u003d doEncode;\n-        this.base64 \u003d new Base64();\n+        this.base64 \u003d new Base64(false);\n     }\n \n     /**\n",
      "operations": [
        {
          "type": "insert-node",
          "from": "",
          "to": "BooleanLiteral: false [3024,3029]"
        }
      ]
    }
  ],
  "fixing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [],
      "num": 0
    },
    "add_functions": {
      "qualified_names": [],
      "num": 0
    },
    "delete_functions": {
      "qualified_names": [],
      "num": 0
    }
  },
  "patch_changed_mths": {
    "qualified_names": [
      "org.apache.commons.codec.binary.Base64:Base64()V:regression",
      "org.apache.commons.codec.binary.Base64:Base64(Z)V:regression",
      "org.apache.commons.codec.binary.Base64:Base64(I)V:regression",
      "org.apache.commons.codec.binary.Base64:Base64()Z:regression",
      "org.apache.commons.codec.binary.Base64:Base64()Z:regression",
      "org.apache.commons.codec.binary.Base64:Base64()I:regression",
      "org.apache.commons.codec.binary.Base64:Base64()V:regression",
      "org.apache.commons.codec.binary.Base64:Base64(B)Z:regression",
      "org.apache.commons.codec.binary.Base64:Base64([B)Z:regression",
      "org.apache.commons.codec.binary.Base64:Base64([B)Z:regression",
      "org.apache.commons.codec.binary.Base64:Base64([B)[B:regression",
      "org.apache.commons.codec.binary.Base64:Base64([B)Ljava/lang/String;:regression",
      "org.apache.commons.codec.binary.Base64:Base64([B)[B:regression",
      "org.apache.commons.codec.binary.Base64:Base64([B)Ljava/lang/String;:regression",
      "org.apache.commons.codec.binary.Base64:Base64([B)[B:regression",
      "org.apache.commons.codec.binary.Base64:Base64(Ljava/lang/Object;)Ljava/lang/Object;:regression",
      "org.apache.commons.codec.binary.Base64:Base64(Ljava/lang/String;)[B:regression",
      "org.apache.commons.codec.binary.Base64:Base64([B)[B:regression",
      "org.apache.commons.codec.binary.Base64:Base64(Ljava/lang/String;)[B:regression",
      "org.apache.commons.codec.binary.Base64:Base64([B)[B:regression",
      "org.apache.commons.codec.binary.Base64:Base64([B)[B:regression",
      "org.apache.commons.codec.binary.Base64:Base64(B)Z:regression",
      "org.apache.commons.codec.binary.Base64:Base64(Ljava/lang/Object;)Ljava/lang/Object;:regression",
      "org.apache.commons.codec.binary.Base64:Base64([B)Ljava/lang/String;:regression",
      "org.apache.commons.codec.binary.Base64:Base64([B)[B:regression",
      "org.apache.commons.codec.binary.Base64:Base64([B)Ljava/math/BigInteger;:regression",
      "org.apache.commons.codec.binary.Base64:Base64(Ljava/math/BigInteger;)[B:regression",
      "org.apache.commons.codec.binary.Base64:Base64(Ljava/math/BigInteger;)[B:regression",
      "org.apache.commons.codec.binary.Base64:Base64()V:regression",
      "org.apache.commons.codec.binary.Base64InputStream:Base64InputStream(Ljava/io/InputStream;Z)V:regression",
      "org.apache.commons.codec.binary.Base64OutputStream:Base64OutputStream(Ljava/io/OutputStream;Z)V:regression"
    ],
    "num": 31
  }
}