diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java
index b85f9f4..eb09b5c 100644
--- a/src/java/org/apache/commons/codec/binary/Base64.java
+++ b/src/java/org/apache/commons/codec/binary/Base64.java
@@ -254,7 +254,7 @@
      * </p>
      * 
      * @param lineLength
-     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).
+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
      *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
      * @since 1.4
      */
@@ -276,7 +276,7 @@
      * </p>
      * 
      * @param lineLength
-     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).
+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
      *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
      * @param lineSeparator
      *            Each line of encoded data will end with this sequence of bytes.
@@ -302,7 +302,7 @@
      * </p>
      * 
      * @param lineLength
-     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).
+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
      *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
      * @param lineSeparator
      *            Each line of encoded data will end with this sequence of bytes.
@@ -314,7 +314,7 @@
      * @since 1.4
      */
     public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {
-        this.lineLength = lineLength;
+        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;
         this.lineSeparator = new byte[lineSeparator.length];
         System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
         if (lineLength > 0) {
@@ -324,7 +324,7 @@
         }
         this.decodeSize = this.encodeSize - 1;
         if (containsBase64Byte(lineSeparator)) {
-            String sep = StringBytesUtils.newStringUtf8(lineSeparator);
+            String sep = StringUtils.newStringUtf8(lineSeparator);
             throw new IllegalArgumentException("lineSeperator must not contain base64 characters: [" + sep + "]");
         }
         this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;
@@ -669,10 +669,11 @@
      *             if the parameter supplied is not of type byte[]
      */
     public Object decode(Object pObject) throws DecoderException {
-        if (!(pObject instanceof byte[])) {
+        if (pObject instanceof byte[]) {
+            return decode((byte[]) pObject);
+        } else {
             throw new DecoderException("Parameter supplied to Base64 decode is not a byte[]");
         }
-        return decode((byte[]) pObject);
     }
 
     /**
@@ -683,7 +684,24 @@
      * @return a byte array containing binary data
      */
     public byte[] decode(byte[] pArray) {
-        return decodeBase64(pArray);
+        if (pArray == null || pArray.length == 0) {
+            return pArray;
+        }
+        long len = (pArray.length * 3) / 4;
+        byte[] buf = new byte[(int) len];
+        setInitialBuffer(buf, 0, buf.length);
+        decode(pArray, 0, pArray.length);
+        decode(pArray, 0, -1); // Notify decoder of EOF.
+
+        // Would be nice to just return buf (like we sometimes do in the encode
+        // logic), but we have no idea what the line-length was (could even be
+        // variable).  So we cannot determine ahead of time exactly how big an
+        // array is necessary.  Hence the need to construct a 2nd byte array to
+        // hold the final result:
+
+        byte[] result = new byte[pos];
+        readResults(result, 0, result.length);
+        return result;
     }
 
     /**
@@ -739,41 +757,17 @@
         if (binaryData == null || binaryData.length == 0) {
             return binaryData;
         }
-        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
-        long len = (binaryData.length * 4) / 3;
-        long mod = len % 4;
-        if (mod != 0) {
-            len += 4 - mod;
-        }
-        if (isChunked) {
-            boolean lenChunksPerfectly = len % CHUNK_SIZE == 0;
-            len += (len / CHUNK_SIZE) * CHUNK_SEPARATOR.length;
-            if (!lenChunksPerfectly) {
-                len += CHUNK_SEPARATOR.length;
-            }
-        }
+
+        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
         if (len > maxResultSize) {
             throw new IllegalArgumentException("Input array too big, the output array would be bigger (" +
                 len +
                 ") than the specified maxium size of " +
                 maxResultSize);
         }
-        byte[] buf = new byte[(int) len];
-        b64.setInitialBuffer(buf, 0, buf.length);
-        b64.encode(binaryData, 0, binaryData.length);
-        b64.encode(binaryData, 0, -1); // Notify encoder of EOF.
-        // Encoder might have resized, even though it was unnecessary.
-        if (b64.buffer != buf) {
-            b64.readResults(buf, 0, buf.length);
-        }
-        // In URL-SAFE mode we skip the padding characters, so sometimes our
-        // final length is a bit smaller.
-        if (urlSafe && b64.pos < buf.length) {
-            byte[] smallerBuf = new byte[b64.pos];
-            System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);
-            buf = smallerBuf;
-        }
-        return buf;
+                
+        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
+        return b64.encode(binaryData);
     }
 
     /**
@@ -784,20 +778,8 @@
      * @return Array containing decoded data.
      */
     public static byte[] decodeBase64(byte[] base64Data) {
-        if (base64Data == null || base64Data.length == 0) {
-            return base64Data;
-        }
         Base64 b64 = new Base64();
-        long len = (base64Data.length * 3) / 4;
-        byte[] buf = new byte[(int) len];
-        b64.setInitialBuffer(buf, 0, buf.length);
-        b64.decode(base64Data, 0, base64Data.length);
-        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.
-        // We have no idea what the line-length was, so we
-        // cannot know how much of our array wasn't used.
-        byte[] result = new byte[b64.pos];
-        b64.readResults(result, 0, result.length);
-        return result;
+        return b64.decode(base64Data);
     }
 
     /**
@@ -873,7 +855,53 @@
      * @return A byte array containing only Base64 character data
      */
     public byte[] encode(byte[] pArray) {
-        return encodeBase64(pArray, false, isUrlSafe());
+        long len = getEncodeLength(pArray, lineLength, lineSeparator);
+        byte[] buf = new byte[(int) len];
+        setInitialBuffer(buf, 0, buf.length);
+        encode(pArray, 0, pArray.length);
+        encode(pArray, 0, -1); // Notify encoder of EOF.
+        // Encoder might have resized, even though it was unnecessary.
+        if (buffer != buf) {
+            readResults(buf, 0, buf.length);
+        }
+        // In URL-SAFE mode we skip the padding characters, so sometimes our
+        // final length is a bit smaller.
+        if (isUrlSafe() && pos < buf.length) {
+            byte[] smallerBuf = new byte[pos];
+            System.arraycopy(buf, 0, smallerBuf, 0, pos);
+            buf = smallerBuf;
+        }
+        return buf;        
+    }
+
+    /**
+     * Pre-calculates the amount of space needed to base64-encode the supplied array.
+     *
+     * @param pArray byte[] array which will later be encoded
+     * @param chunkSize line-length of the output (<= 0 means no chunking) between each
+     *        chunkSeparator (e.g. CRLF).
+     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).
+     *
+     * @return amount of space needed to encoded the supplied array.  Returns
+     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.
+     */
+    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
+        // base64 always encodes to multiples of 4.
+        chunkSize = (chunkSize / 4) * 4;
+
+        long len = (pArray.length * 4) / 3;
+        long mod = len % 4;
+        if (mod != 0) {
+            len += 4 - mod;
+        }
+        if (chunkSize > 0 && chunkSeparator != null) {
+            boolean lenChunksPerfectly = len % chunkSize == 0;
+            len += (len / chunkSize) * chunkSeparator.length;
+            if (!lenChunksPerfectly) {
+                len += chunkSeparator.length;
+            }
+        }
+        return len;
     }
 
     // Implementation of integer encoding used for crypto
diff --git a/src/java/org/apache/commons/codec/binary/Base64InputStream.java b/src/java/org/apache/commons/codec/binary/Base64InputStream.java
index ce9a5d2..87bae71 100644
--- a/src/java/org/apache/commons/codec/binary/Base64InputStream.java
+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java
@@ -22,21 +22,22 @@
 import java.io.InputStream;
 
 /**
- * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).
- * When encoding the default lineLength is 76 characters and the default
- * lineEnding is CRLF, but these can be overridden by using the appropriate
+ * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength
+ * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate
  * constructor.
  * <p>
- * The default behaviour of the Base64InputStream is to DECODE, whereas the
- * default behaviour of the Base64OutputStream is to ENCODE, but this
- * behaviour can be overridden by using a different constructor.
- * </p><p>
+ * The default behaviour of the Base64InputStream is to DECODE, whereas the default behaviour of the Base64OutputStream
+ * is to ENCODE, but this behaviour can be overridden by using a different constructor.
+ * </p>
+ * <p>
  * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose
  * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
- * </p><p>
- * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode
- * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). 
  * </p>
+ * <p>
+ * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode
+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).
+ * </p>
+ * 
  * @author Apache Software Foundation
  * @version $Id $
  * @see <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>
@@ -45,26 +46,29 @@
 public class Base64InputStream extends FilterInputStream {
 
     private final boolean doEncode;
+
     private final Base64 base64;
+
     private final byte[] singleByte = new byte[1];
 
     /**
-     * Creates a Base64InputStream such that all data read is Base64-decoded
-     * from the original provided InputStream.
-     *
-     * @param in InputStream to wrap.
+     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.
+     * 
+     * @param in
+     *            InputStream to wrap.
      */
     public Base64InputStream(InputStream in) {
         this(in, false);
     }
 
     /**
-     * Creates a Base64InputStream such that all data read is either
-     * Base64-encoded or Base64-decoded from the original provided InputStream.
-     *
-     * @param in       InputStream to wrap.
-     * @param doEncode true if we should encode all data read from us,
-     *                 false if we should decode.
+     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original
+     * provided InputStream.
+     * 
+     * @param in
+     *            InputStream to wrap.
+     * @param doEncode
+     *            true if we should encode all data read from us, false if we should decode.
      */
     public Base64InputStream(InputStream in, boolean doEncode) {
         super(in);
@@ -73,20 +77,20 @@
     }
 
     /**
-     * Creates a Base64InputStream such that all data read is either
-     * Base64-encoded or Base64-decoded from the original provided InputStream.
-     *
-     * @param in            InputStream to wrap.
-     * @param doEncode      true if we should encode all data read from us,
-     *                      false if we should decode.
-     * @param lineLength    If doEncode is true, each line of encoded
-     *                      data will contain lineLength characters.
-     *                      If lineLength <=0, the encoded data is not divided into lines.
-     *                      If doEncode is false, lineLength is ignored.
-     * @param lineSeparator If doEncode is true, each line of encoded
-     *                      data will be terminated with this byte sequence (e.g. \r\n).
-     *                      If lineLength <= 0, the lineSeparator is not used.  
-     *                      If doEncode is false lineSeparator is ignored.
+     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original
+     * provided InputStream.
+     * 
+     * @param in
+     *            InputStream to wrap.
+     * @param doEncode
+     *            true if we should encode all data read from us, false if we should decode.
+     * @param lineLength
+     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to
+     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is
+     *            false, lineLength is ignored.
+     * @param lineSeparator
+     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \r\n).
+     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.
      */
     public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {
         super(in);
@@ -97,8 +101,9 @@
     /**
      * Reads one <code>byte</code> from this input stream.
      * 
-     * @return the byte as an integer in the range 0 to 255
-     * Returns -1 if EOF has been reached.
+     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.
+     * @throws IOException
+     *             if an I/O error occurs.
      */
     public int read() throws IOException {
         int r = read(singleByte, 0, 1);
@@ -112,18 +117,23 @@
     }
 
     /**
-     * Attempts to read <code>len</code> bytes into the specified
-     * <code>b</code> array starting at <code>offset</code> from
-     * this InputStream.
+     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
+     * from this InputStream.
      * 
-     * @param b destination byte array
-     * @param offset where to start writing the bytes
-     * @param len maximum number of bytes to read
+     * @param b
+     *            destination byte array
+     * @param offset
+     *            where to start writing the bytes
+     * @param len
+     *            maximum number of bytes to read
      * 
      * @return number of bytes read
-     * @throws IOException if an I/O error occurs.
-     * @throws NullPointerException if the byte array parameter is null
-     * @throws IndexOutOfBoundsException if offset, len or buffer size are invalid
+     * @throws IOException
+     *             if an I/O error occurs.
+     * @throws NullPointerException
+     *             if the byte array parameter is null
+     * @throws IndexOutOfBoundsException
+     *             if offset, len or buffer size are invalid
      */
     public int read(byte b[], int offset, int len) throws IOException {
         if (b == null) {
@@ -138,13 +148,11 @@
             if (!base64.hasData()) {
                 byte[] buf = new byte[doEncode ? 4096 : 8192];
                 int c = in.read(buf);
-
                 // A little optimization to avoid System.arraycopy()
                 // when possible.
                 if (c > 0 && b.length == len) {
                     base64.setInitialBuffer(b, offset, len);
                 }
-
                 if (doEncode) {
                     base64.encode(buf, 0, c);
                 } else {
@@ -157,6 +165,7 @@
 
     /**
      * {@inheritDoc}
+     * 
      * @return false
      */
     public boolean markSupported() {
diff --git a/src/java/org/apache/commons/codec/binary/Base64OutputStream.java b/src/java/org/apache/commons/codec/binary/Base64OutputStream.java
index 5069095..349c642 100644
--- a/src/java/org/apache/commons/codec/binary/Base64OutputStream.java
+++ b/src/java/org/apache/commons/codec/binary/Base64OutputStream.java
@@ -22,21 +22,22 @@
 import java.io.OutputStream;
 
 /**
- * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).
- * When encoding the default lineLength is 76 characters and the default
- * lineEnding is CRLF, but these can be overridden by using the appropriate
+ * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength
+ * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate
  * constructor.
  * <p>
- * The default behaviour of the Base64OutputStream is to ENCODE, whereas the
- * default behaviour of the Base64InputStream is to DECODE.  But this behaviour
- * can be overridden by using a different constructor.
- * </p><p>
+ * The default behaviour of the Base64OutputStream is to ENCODE, whereas the default behaviour of the Base64InputStream
+ * is to DECODE. But this behaviour can be overridden by using a different constructor.
+ * </p>
+ * <p>
  * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose
  * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
- * </p><p>
+ * </p>
+ * <p>
  * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode
  * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).
- * </p> 
+ * </p>
+ * 
  * @author Apache Software Foundation
  * @version $Id $
  * @see <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>
@@ -44,26 +45,29 @@
  */
 public class Base64OutputStream extends FilterOutputStream {
     private final boolean doEncode;
+
     private final Base64 base64;
+
     private final byte[] singleByte = new byte[1];
 
     /**
-     * Creates a Base64OutputStream such that all data written is Base64-encoded
-     * to the original provided OutputStream.
-     *
-     * @param out OutputStream to wrap.
+     * Creates a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.
+     * 
+     * @param out
+     *            OutputStream to wrap.
      */
     public Base64OutputStream(OutputStream out) {
         this(out, true);
     }
 
     /**
-     * Creates a Base64OutputStream such that all data written is either
-     * Base64-encoded or Base64-decoded to the original provided OutputStream.
-     *
-     * @param out      OutputStream to wrap.
-     * @param doEncode true if we should encode all data written to us,
-     *                 false if we should decode.
+     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the
+     * original provided OutputStream.
+     * 
+     * @param out
+     *            OutputStream to wrap.
+     * @param doEncode
+     *            true if we should encode all data written to us, false if we should decode.
      */
     public Base64OutputStream(OutputStream out, boolean doEncode) {
         super(out);
@@ -72,20 +76,20 @@
     }
 
     /**
-     * Creates a Base64OutputStream such that all data written is either
-     * Base64-encoded or Base64-decoded to the original provided OutputStream.
-     *
-     * @param out           OutputStream to wrap.
-     * @param doEncode      true if we should encode all data written to us,
-     *                      false if we should decode.
-     * @param lineLength    If doEncode is true, each line of encoded
-     *                      data will contain lineLength characters.  
-     *                      If lineLength <=0, the encoded data is not divided into lines.
-     *                      If doEncode is false, lineLength is ignored.
-     * @param lineSeparator If doEncode is true, each line of encoded
-     *                      data will be terminated with this byte sequence (e.g. \r\n).  
-     *                      If lineLength <= 0, the lineSeparator is not used.
-     *                      If doEncode is false lineSeparator is ignored.
+     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the
+     * original provided OutputStream.
+     * 
+     * @param out
+     *            OutputStream to wrap.
+     * @param doEncode
+     *            true if we should encode all data written to us, false if we should decode.
+     * @param lineLength
+     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to
+     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is
+     *            false, lineLength is ignored.
+     * @param lineSeparator
+     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \r\n).
+     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.
      */
     public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {
         super(out);
@@ -95,6 +99,11 @@
 
     /**
      * Writes the specified <code>byte</code> to this output stream.
+     * 
+     * @param i
+     *            source byte
+     * @throws IOException
+     *             if an I/O error occurs.
      */
     public void write(int i) throws IOException {
         singleByte[0] = (byte) i;
@@ -102,17 +111,22 @@
     }
 
     /**
-     * Writes <code>len</code> bytes from the specified
-     * <code>b</code> array starting at <code>offset</code> to
-     * this output stream.
-     *
-     * @param b source byte array
-     * @param offset where to start reading the bytes
-     * @param len maximum number of bytes to write
+     * Writes <code>len</code> bytes from the specified <code>b</code> array starting at <code>offset</code> to this
+     * output stream.
      * 
-     * @throws IOException if an I/O error occurs.
-     * @throws NullPointerException if the byte array parameter is null
-     * @throws IndexOutOfBoundsException if offset, len or buffer size are invalid
+     * @param b
+     *            source byte array
+     * @param offset
+     *            where to start reading the bytes
+     * @param len
+     *            maximum number of bytes to write
+     * 
+     * @throws IOException
+     *             if an I/O error occurs.
+     * @throws NullPointerException
+     *             if the byte array parameter is null
+     * @throws IndexOutOfBoundsException
+     *             if offset, len or buffer size are invalid
      */
     public void write(byte b[], int offset, int len) throws IOException {
         if (b == null) {
@@ -132,13 +146,13 @@
     }
 
     /**
-     * Flushes this output stream and forces any buffered output bytes
-     * to be written out to the stream.  If propogate is true, the wrapped
-     * stream will also be flushed.
-     *
-     * @param propogate boolean flag to indicate whether the wrapped
-     *                  OutputStream should also be flushed.
-     * @throws IOException if an I/O error occurs.
+     * Flushes this output stream and forces any buffered output bytes to be written out to the stream. If propogate is
+     * true, the wrapped stream will also be flushed.
+     * 
+     * @param propogate
+     *            boolean flag to indicate whether the wrapped OutputStream should also be flushed.
+     * @throws IOException
+     *             if an I/O error occurs.
      */
     private void flush(boolean propogate) throws IOException {
         int avail = base64.avail();
@@ -155,18 +169,20 @@
     }
 
     /**
-     * Flushes this output stream and forces any buffered output bytes
-     * to be written out to the stream.
-     *
-     * @throws IOException if an I/O error occurs.
+     * Flushes this output stream and forces any buffered output bytes to be written out to the stream.
+     * 
+     * @throws IOException
+     *             if an I/O error occurs.
      */
     public void flush() throws IOException {
-        flush(true); 
+        flush(true);
     }
 
     /**
-     * Closes this output stream and releases any system resources
-     * associated with the stream.
+     * Closes this output stream and releases any system resources associated with the stream.
+     * 
+     * @throws IOException
+     *             if an I/O error occurs.
      */
     public void close() throws IOException {
         // Notify encoder of EOF (-1).
diff --git a/src/java/org/apache/commons/codec/binary/StringBytesUtils.java b/src/java/org/apache/commons/codec/binary/StringBytesUtils.java
deleted file mode 100644
index 18d0a19..0000000
--- a/src/java/org/apache/commons/codec/binary/StringBytesUtils.java
+++ /dev/null
@@ -1,269 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.binary;
-
-import java.io.UnsupportedEncodingException;
-
-import org.apache.commons.codec.CharEncoding;
-
-/**
- * Converts String to bytes using the encodings required by the Java specification. These encodings are specified in <a
- * href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
- * 
- * @see CharEncoding
- * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
- * @author <a href="mailto:ggregory@seagullsw.com">Gary Gregory</a>
- * @version $Id: $
- * @since 1.4
- */
-public class StringBytesUtils {
-
-    /**
-     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new
-     * byte array.
-     * 
-     * @param string
-     *            the String to encode
-     * @return encoded bytes
-     * @throws IllegalStateException
-     *             Thrown when the charset is missing, which should be never according the the Java specification.
-     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
-     * @see #getSupportedBytes(String, String)
-     */
-    public static byte[] getBytesIso8859_1(String string) {
-        return StringBytesUtils.getSupportedBytes(string, CharEncoding.ISO_8859_1);
-    }
-
-    /**
-     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte
-     * array.
-     * 
-     * @param string
-     *            the String to encode
-     * @return encoded bytes
-     * @throws IllegalStateException
-     *             Thrown when the charset is missing, which should be never according the the Java specification.
-     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
-     * @see #getSupportedBytes(String, String)
-     */
-    public static byte[] getBytesUsAscii(String string) {
-        return StringBytesUtils.getSupportedBytes(string, CharEncoding.US_ASCII);
-    }
-
-    /**
-     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte
-     * array.
-     * 
-     * @param string
-     *            the String to encode
-     * @return encoded bytes
-     * @throws IllegalStateException
-     *             Thrown when the charset is missing, which should be never according the the Java specification.
-     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
-     * @see #getSupportedBytes(String, String)
-     */
-    public static byte[] getBytesUtf16(String string) {
-        return StringBytesUtils.getSupportedBytes(string, CharEncoding.UTF_16);
-    }
-
-    /**
-     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte
-     * array.
-     * 
-     * @param string
-     *            the String to encode
-     * @return encoded bytes
-     * @throws IllegalStateException
-     *             Thrown when the charset is missing, which should be never according the the Java specification.
-     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
-     * @see #getSupportedBytes(String, String)
-     */
-    public static byte[] getBytesUtf16Be(String string) {
-        return StringBytesUtils.getSupportedBytes(string, CharEncoding.UTF_16BE);
-    }
-
-    /**
-     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte
-     * array.
-     * 
-     * @param string
-     *            the String to encode
-     * @return encoded bytes
-     * @throws IllegalStateException
-     *             Thrown when the charset is missing, which should be never according the the Java specification.
-     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
-     * @see #getSupportedBytes(String, String)
-     */
-    public static byte[] getBytesUtf16Le(String string) {
-        return StringBytesUtils.getSupportedBytes(string, CharEncoding.UTF_16LE);
-    }
-
-    /**
-     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte
-     * array.
-     * 
-     * @param string
-     *            the String to encode
-     * @return encoded bytes
-     * @throws IllegalStateException
-     *             Thrown when the charset is missing, which should be never according the the Java specification.
-     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
-     * @see #getSupportedBytes(String, String)
-     */
-    public static byte[] getBytesUtf8(String string) {
-        return StringBytesUtils.getSupportedBytes(string, CharEncoding.UTF_8);
-    }
-
-    /**
-     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte
-     * array.
-     * <p>
-     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which
-     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.
-     * </p>
-     * 
-     * @param string
-     *            the String to encode
-     * @param charsetName
-     *            The name of a required {@link java.nio.charset.Charset}
-     * @return encoded bytes
-     * @throws IllegalStateException
-     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a
-     *             required charset name.
-     * @see CharEncoding
-     * @see String#getBytes(String)
-     */
-    public static byte[] getSupportedBytes(String string, String charsetName) {
-        try {
-            return string.getBytes(charsetName);
-        } catch (UnsupportedEncodingException e) {
-            throw StringBytesUtils.newIllegalStateException(charsetName, e);
-        }
-    }
-
-    private static IllegalStateException newIllegalStateException(String charsetName, UnsupportedEncodingException e) {
-        return new IllegalStateException(charsetName + ": " + e);
-    }
-
-    /**
-     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.
-     * <p>
-     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which
-     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.
-     * </p>
-     * 
-     * @param bytes
-     *            The bytes to be decoded into characters
-     * @param charsetName
-     *            The name of a required {@link java.nio.charset.Charset}
-     * @throws IllegalStateException
-     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a
-     *             required charset name.
-     * @see CharEncoding
-     * @see String#String(byte[], String)
-     */
-    public static String newString(byte[] bytes, String charsetName) {
-        try {
-            return new String(bytes, charsetName);
-        } catch (UnsupportedEncodingException e) {
-            throw StringBytesUtils.newIllegalStateException(charsetName, e);
-        }
-    }
-
-    /**
-     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.
-     * 
-     * @param bytes
-     *            The bytes to be decoded into characters
-     * @throws IllegalStateException
-     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
-     *             charset is required.
-     */
-    public static String newStringIso8859_1(byte[] bytes) {
-        return StringBytesUtils.newString(bytes, CharEncoding.ISO_8859_1);
-    }
-
-    /**
-     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.
-     * 
-     * @param bytes
-     *            The bytes to be decoded into characters
-     * @throws IllegalStateException
-     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
-     *             charset is required.
-     */
-    public static String newStringUsAscii(byte[] bytes) {
-        return StringBytesUtils.newString(bytes, CharEncoding.US_ASCII);
-    }
-
-    /**
-     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.
-     * 
-     * @param bytes
-     *            The bytes to be decoded into characters
-     * @throws IllegalStateException
-     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
-     *             charset is required.
-     */
-    public static String newStringUtf16(byte[] bytes) {
-        return StringBytesUtils.newString(bytes, CharEncoding.UTF_16);
-    }
-
-    /**
-     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.
-     * 
-     * @param bytes
-     *            The bytes to be decoded into characters
-     * @throws IllegalStateException
-     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
-     *             charset is required.
-     */
-    public static String newStringUtf16Be(byte[] bytes) {
-        return StringBytesUtils.newString(bytes, CharEncoding.UTF_16BE);
-    }
-
-    /**
-     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.
-     * 
-     * @param bytes
-     *            The bytes to be decoded into characters
-     * @throws IllegalStateException
-     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
-     *             charset is required.
-     */
-    public static String newStringUtf16Le(byte[] bytes) {
-        return StringBytesUtils.newString(bytes, CharEncoding.UTF_16LE);
-    }
-
-    /**
-     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.
-     * 
-     * @param bytes
-     *            The bytes to be decoded into characters
-     * @throws IllegalStateException
-     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
-     *             charset is required.
-     */
-    public static String newStringUtf8(byte[] bytes) {
-        return StringBytesUtils.newString(bytes, CharEncoding.UTF_8);
-    }
-
-    private StringBytesUtils() {
-        // noop, cannot instantiate.
-    }
-}
diff --git a/src/java/org/apache/commons/codec/binary/StringUtils.java b/src/java/org/apache/commons/codec/binary/StringUtils.java
new file mode 100644
index 0000000..eb8d2e0
--- /dev/null
+++ b/src/java/org/apache/commons/codec/binary/StringUtils.java
@@ -0,0 +1,276 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.binary;
+
+import java.io.UnsupportedEncodingException;
+
+import org.apache.commons.codec.CharEncoding;
+
+/**
+ * Converts String to bytes using the encodings required by the Java specification. These encodings are specified in <a
+ * href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+ * 
+ * @see CharEncoding
+ * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+ * @author <a href="mailto:ggregory@seagullsw.com">Gary Gregory</a>
+ * @version $Id: $
+ * @since 1.4
+ */
+public class StringUtils {
+
+    /**
+     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new
+     * byte array.
+     * 
+     * @param string
+     *            the String to encode
+     * @return encoded bytes
+     * @throws IllegalStateException
+     *             Thrown when the charset is missing, which should be never according the the Java specification.
+     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @see #getSupportedBytes(String, String)
+     */
+    public static byte[] getBytesIso8859_1(String string) {
+        return StringUtils.getSupportedBytes(string, CharEncoding.ISO_8859_1);
+    }
+
+    /**
+     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte
+     * array.
+     * 
+     * @param string
+     *            the String to encode
+     * @return encoded bytes
+     * @throws IllegalStateException
+     *             Thrown when the charset is missing, which should be never according the the Java specification.
+     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @see #getSupportedBytes(String, String)
+     */
+    public static byte[] getBytesUsAscii(String string) {
+        return StringUtils.getSupportedBytes(string, CharEncoding.US_ASCII);
+    }
+
+    /**
+     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte
+     * array.
+     * 
+     * @param string
+     *            the String to encode
+     * @return encoded bytes
+     * @throws IllegalStateException
+     *             Thrown when the charset is missing, which should be never according the the Java specification.
+     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @see #getSupportedBytes(String, String)
+     */
+    public static byte[] getBytesUtf16(String string) {
+        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16);
+    }
+
+    /**
+     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte
+     * array.
+     * 
+     * @param string
+     *            the String to encode
+     * @return encoded bytes
+     * @throws IllegalStateException
+     *             Thrown when the charset is missing, which should be never according the the Java specification.
+     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @see #getSupportedBytes(String, String)
+     */
+    public static byte[] getBytesUtf16Be(String string) {
+        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16BE);
+    }
+
+    /**
+     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte
+     * array.
+     * 
+     * @param string
+     *            the String to encode
+     * @return encoded bytes
+     * @throws IllegalStateException
+     *             Thrown when the charset is missing, which should be never according the the Java specification.
+     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @see #getSupportedBytes(String, String)
+     */
+    public static byte[] getBytesUtf16Le(String string) {
+        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16LE);
+    }
+
+    /**
+     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte
+     * array.
+     * 
+     * @param string
+     *            the String to encode
+     * @return encoded bytes
+     * @throws IllegalStateException
+     *             Thrown when the charset is missing, which should be never according the the Java specification.
+     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
+     * @see #getSupportedBytes(String, String)
+     */
+    public static byte[] getBytesUtf8(String string) {
+        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_8);
+    }
+
+    /**
+     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte
+     * array.
+     * <p>
+     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which
+     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.
+     * </p>
+     * 
+     * @param string
+     *            the String to encode
+     * @param charsetName
+     *            The name of a required {@link java.nio.charset.Charset}
+     * @return encoded bytes
+     * @throws IllegalStateException
+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a
+     *             required charset name.
+     * @see CharEncoding
+     * @see String#getBytes(String)
+     */
+    public static byte[] getSupportedBytes(String string, String charsetName) {
+        try {
+            return string.getBytes(charsetName);
+        } catch (UnsupportedEncodingException e) {
+            throw StringUtils.newIllegalStateException(charsetName, e);
+        }
+    }
+
+    private static IllegalStateException newIllegalStateException(String charsetName, UnsupportedEncodingException e) {
+        return new IllegalStateException(charsetName + ": " + e);
+    }
+
+    /**
+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.
+     * <p>
+     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which
+     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.
+     * </p>
+     * 
+     * @param bytes
+     *            The bytes to be decoded into characters
+     * @param charsetName
+     *            The name of a required {@link java.nio.charset.Charset}
+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.
+     * @throws IllegalStateException
+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a
+     *             required charset name.
+     * @see CharEncoding
+     * @see String#String(byte[], String)
+     */
+    public static String newString(byte[] bytes, String charsetName) {
+        try {
+            return new String(bytes, charsetName);
+        } catch (UnsupportedEncodingException e) {
+            throw StringUtils.newIllegalStateException(charsetName, e);
+        }
+    }
+
+    /**
+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.
+     * 
+     * @param bytes
+     *            The bytes to be decoded into characters
+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.
+     * @throws IllegalStateException
+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
+     *             charset is required.
+     */
+    public static String newStringIso8859_1(byte[] bytes) {
+        return StringUtils.newString(bytes, CharEncoding.ISO_8859_1);
+    }
+
+    /**
+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.
+     * 
+     * @param bytes
+     *            The bytes to be decoded into characters
+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.
+     * @throws IllegalStateException
+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
+     *             charset is required.
+     */
+    public static String newStringUsAscii(byte[] bytes) {
+        return StringUtils.newString(bytes, CharEncoding.US_ASCII);
+    }
+
+    /**
+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.
+     * 
+     * @param bytes
+     *            The bytes to be decoded into characters
+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.
+     * @throws IllegalStateException
+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
+     *             charset is required.
+     */
+    public static String newStringUtf16(byte[] bytes) {
+        return StringUtils.newString(bytes, CharEncoding.UTF_16);
+    }
+
+    /**
+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.
+     * 
+     * @param bytes
+     *            The bytes to be decoded into characters
+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.
+     * @throws IllegalStateException
+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
+     *             charset is required.
+     */
+    public static String newStringUtf16Be(byte[] bytes) {
+        return StringUtils.newString(bytes, CharEncoding.UTF_16BE);
+    }
+
+    /**
+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.
+     * 
+     * @param bytes
+     *            The bytes to be decoded into characters
+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.
+     * @throws IllegalStateException
+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
+     *             charset is required.
+     */
+    public static String newStringUtf16Le(byte[] bytes) {
+        return StringUtils.newString(bytes, CharEncoding.UTF_16LE);
+    }
+
+    /**
+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.
+     * 
+     * @param bytes
+     *            The bytes to be decoded into characters
+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.
+     * @throws IllegalStateException
+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
+     *             charset is required.
+     */
+    public static String newStringUtf8(byte[] bytes) {
+        return StringUtils.newString(bytes, CharEncoding.UTF_8);
+    }
+
+    private StringUtils() {
+        // noop, cannot instantiate. Can always relax later.
+    }
+}
diff --git a/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java b/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
index ab34516..9c546f5 100644
--- a/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
+++ b/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
@@ -28,7 +28,7 @@
 import org.apache.commons.codec.CharEncoding;
 import org.apache.commons.codec.StringDecoder;
 import org.apache.commons.codec.StringEncoder;
-import org.apache.commons.codec.binary.StringBytesUtils;
+import org.apache.commons.codec.binary.StringUtils;
 
 /**
  * <p>
@@ -277,7 +277,7 @@
         if (pString == null) {
             return null;
         }
-        return new String(decode(StringBytesUtils.getBytesUsAscii(pString)), charset);
+        return new String(decode(StringUtils.getBytesUsAscii(pString)), charset);
     }
 
     /**
@@ -382,6 +382,6 @@
         if (pString == null) {
             return null;
         }
-        return StringBytesUtils.newStringUsAscii(encode(pString.getBytes(charset)));
+        return StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));
     }
 }
diff --git a/src/java/org/apache/commons/codec/net/RFC1522Codec.java b/src/java/org/apache/commons/codec/net/RFC1522Codec.java
index ac0be48..a33b573 100644
--- a/src/java/org/apache/commons/codec/net/RFC1522Codec.java
+++ b/src/java/org/apache/commons/codec/net/RFC1522Codec.java
@@ -21,7 +21,7 @@
 
 import org.apache.commons.codec.DecoderException;
 import org.apache.commons.codec.EncoderException;
-import org.apache.commons.codec.binary.StringBytesUtils;
+import org.apache.commons.codec.binary.StringUtils;
 
 /**
  * <p>
@@ -76,7 +76,7 @@
         buffer.append(getEncoding()); 
         buffer.append('?');
         byte [] rawdata = doEncoding(text.getBytes(charset)); 
-        buffer.append(StringBytesUtils.newStringUsAscii(rawdata));
+        buffer.append(StringUtils.newStringUsAscii(rawdata));
         buffer.append("?="); 
         return buffer.toString();
     }
@@ -125,7 +125,7 @@
         }
         from = to + 1;
         to = text.indexOf("?", from);
-        byte[] data = StringBytesUtils.getBytesUsAscii(text.substring(from, to));
+        byte[] data = StringUtils.getBytesUsAscii(text.substring(from, to));
         data = doDecoding(data); 
         return new String(data, charset);
     }
diff --git a/src/java/org/apache/commons/codec/net/URLCodec.java b/src/java/org/apache/commons/codec/net/URLCodec.java
index 4842003..a8599c0 100644
--- a/src/java/org/apache/commons/codec/net/URLCodec.java
+++ b/src/java/org/apache/commons/codec/net/URLCodec.java
@@ -28,7 +28,7 @@
 import org.apache.commons.codec.CharEncoding;
 import org.apache.commons.codec.StringDecoder;
 import org.apache.commons.codec.StringEncoder;
-import org.apache.commons.codec.binary.StringBytesUtils;
+import org.apache.commons.codec.binary.StringUtils;
 
 /**
  * <p>Implements the 'www-form-urlencoded' encoding scheme, 
@@ -224,7 +224,7 @@
         if (pString == null) {
             return null;
         }
-        return StringBytesUtils.newStringUsAscii(encode(pString.getBytes(charset)));
+        return StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));
     }
 
     /**
@@ -265,7 +265,7 @@
         if (pString == null) {
             return null;
         }
-        return new String(decode(StringBytesUtils.getBytesUsAscii(pString)), charset);
+        return new String(decode(StringUtils.getBytesUsAscii(pString)), charset);
     }
 
     /**
diff --git a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
index 72a147d..b96416f 100644
--- a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
@@ -67,23 +67,23 @@
      */
     public void testBase64InputStreamByChunk() throws Exception {
         // Hello World test.
-        byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);
         testByChunk(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
-        encoded = StringBytesUtils.getBytesUtf8("AA==\r\n");
+        encoded = StringUtils.getBytesUtf8("AA==\r\n");
         decoded = new byte[]{(byte) 0};
         testByChunk(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);
+        encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("\n", "");
-        encoded = StringBytesUtils.getBytesUtf8(singleLine);
+        encoded = StringUtils.getBytesUtf8(singleLine);
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 0, LF);
 
@@ -104,23 +104,23 @@
      */
     public void testBase64InputStreamByteByByte() throws Exception {
         // Hello World test.
-        byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
-        encoded = StringBytesUtils.getBytesUtf8("AA==\r\n");
+        encoded = StringUtils.getBytesUtf8("AA==\r\n");
         decoded = new byte[]{(byte) 0};
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);
+        encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("\n", "");
-        encoded = StringBytesUtils.getBytesUtf8(singleLine);
+        encoded = StringUtils.getBytesUtf8(singleLine);
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 0, LF);
 
@@ -250,7 +250,7 @@
      * @throws Exception
      */
     public void testMarkSupported() throws Exception {
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
         // Always returns false for now.
@@ -263,7 +263,7 @@
      * @throws Exception
      */
     public void testRead0() throws Exception {
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);
         byte[] buf = new byte[1024];
         int bytesRead = 0;
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
@@ -279,7 +279,7 @@
      *             for some failure scenarios.
      */
     public void testReadNull() throws Exception {
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
         try {
@@ -296,7 +296,7 @@
      * @throws Exception
      */
     public void testReadOutOfBounds() throws Exception {
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);
         byte[] buf = new byte[1024];
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
diff --git a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
index 83db86e..d0c9200 100644
--- a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
@@ -67,23 +67,23 @@
      */
     public void testBase64OutputStreamByChunk() throws Exception {
         // Hello World test.
-        byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);
         testByChunk(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
-        encoded = StringBytesUtils.getBytesUtf8("AA==\r\n");
+        encoded = StringUtils.getBytesUtf8("AA==\r\n");
         decoded = new byte[]{(byte) 0};
         testByChunk(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);
+        encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("\n", "");
-        encoded = StringBytesUtils.getBytesUtf8(singleLine);
+        encoded = StringUtils.getBytesUtf8(singleLine);
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 0, LF);
 
@@ -104,23 +104,23 @@
      */
     public void testBase64OutputStreamByteByByte() throws Exception {
         // Hello World test.
-        byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
-        encoded = StringBytesUtils.getBytesUtf8("AA==\r\n");
+        encoded = StringUtils.getBytesUtf8("AA==\r\n");
         decoded = new byte[]{(byte) 0};
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);
+        encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("\n", "");
-        encoded = StringBytesUtils.getBytesUtf8(singleLine);
+        encoded = StringUtils.getBytesUtf8(singleLine);
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 0, LF);
 
diff --git a/src/test/org/apache/commons/codec/binary/Base64Test.java b/src/test/org/apache/commons/codec/binary/Base64Test.java
index ed61c8d..43a248f 100644
--- a/src/test/org/apache/commons/codec/binary/Base64Test.java
+++ b/src/test/org/apache/commons/codec/binary/Base64Test.java
@@ -17,7 +17,6 @@
 
 package org.apache.commons.codec.binary;
 
-import java.io.UnsupportedEncodingException;
 import java.math.BigInteger;
 import java.util.Arrays;
 import java.util.Random;
@@ -30,6 +29,7 @@
 /**
  * Test cases for Base64 class.
  * 
+ * @see <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>
  * @author Apache Software Foundation
  * @version $Id$
  */
@@ -66,15 +66,13 @@
 
     /**
      * Tests Base64.encodeBase64().
-     * 
-     * @throws Exception
      */
-    public void testChunkedEncodeMultipleOf76() throws Exception {
+    public void testChunkedEncodeMultipleOf76() {
         byte[] expectedEncode = Base64.encodeBase64(Base64TestData.DECODED, true);
         // convert to "\r\n" so we're equal to the old openssl encoding test stored
         // in Base64TestData.ENCODED_76_CHARS_PER_LINE:
         String actualResult = Base64TestData.ENCODED_76_CHARS_PER_LINE.replaceAll("\n", "\r\n");
-        byte[] actualEncode = actualResult.getBytes("UTF-8");
+        byte[] actualEncode = StringUtils.getBytesUtf8(actualResult);
         assertTrue("chunkedEncodeMultipleOf76", Arrays.equals(expectedEncode, actualEncode));
     }
 
@@ -177,6 +175,28 @@
         base64 = new Base64(64, new byte[]{' ', '$', '\n', '\r', '\t'}); // OK
     }
 
+    public void testConstructor_Int_ByteArray_Boolean() {
+        Base64 base64 = new Base64(65, new byte[]{'\t'}, false);
+        byte[] encoded = base64.encode(Base64TestData.DECODED);
+        String expectedResult = Base64TestData.ENCODED_64_CHARS_PER_LINE;
+        expectedResult = expectedResult.replace('\n', '\t');
+        String result = StringUtils.newStringUtf8(encoded);
+        assertEquals("new Base64(65, \\t, false)", expectedResult, result);
+    }
+
+    public void testConstructor_Int_ByteArray_Boolean_UrlSafe() {
+        // url-safe variation
+        Base64 base64 = new Base64(64, new byte[]{'\t'}, true);
+        byte[] encoded = base64.encode(Base64TestData.DECODED);
+        String expectedResult = Base64TestData.ENCODED_64_CHARS_PER_LINE;
+        expectedResult = expectedResult.replaceAll("=", ""); // url-safe has no == padding.
+        expectedResult = expectedResult.replace('\n', '\t');
+        expectedResult = expectedResult.replace('+', '-');
+        expectedResult = expectedResult.replace('/', '_');
+        String result = StringUtils.newStringUtf8(encoded);
+        assertEquals("new Base64(64, \\t, true)", result, expectedResult);
+    }
+
     /**
      * Tests conditional true branch for "marker0" test.
      */
@@ -414,8 +434,7 @@
     public void testObjectDecodeWithValidParameter() throws Exception {
 
         String original = "Hello World!";
-        byte[] bArray = Base64.encodeBase64(original.getBytes());
-        Object o = bArray;
+        Object o = Base64.encodeBase64(original.getBytes());
 
         Base64 b64 = new Base64();
         Object oDecoded = b64.decode(o);
@@ -438,8 +457,7 @@
     public void testObjectEncodeWithValidParameter() throws Exception {
 
         String original = "Hello World!";
-        byte[] origBytes = original.getBytes();
-        Object origObj = origBytes;
+        Object origObj = original.getBytes();
 
         Base64 b64 = new Base64();
         Object oEncoded = b64.encode(origObj);
@@ -849,8 +867,6 @@
      * 
      * @throws DecoderException
      *             if Hex.decode() fails - a serious problem since Hex comes from our own commons-codec!
-     * @throws UnsupportedEncodingException
-     *             Thrown if "UTF-8" character set is not available, not possible according to Java documentation.
      */
     public void testUUID() throws DecoderException {
         // The 4 UUID's below contains mixtures of + and / to help us test the
@@ -871,31 +887,31 @@
         ids[3] = Hex.decodeHex("ff7f8fc01cdb471a8c8b5a9306183fe8".toCharArray());
 
         byte[][] standard = new byte[4][];
-        standard[0] = StringBytesUtils.getBytesUtf8("lO2NAxnkSTOZVg+2dATTcA==");
-        standard[1] = StringBytesUtils.getBytesUtf8("K/fMJwH+Q5e0nr7tWsxwkA==");
-        standard[2] = StringBytesUtils.getBytesUtf8("ZL4VS2/6QCWNGgEojnwxyg==");
-        standard[3] = StringBytesUtils.getBytesUtf8("/3+PwBzbRxqMi1qTBhg/6A==");
+        standard[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg+2dATTcA==");
+        standard[1] = StringUtils.getBytesUtf8("K/fMJwH+Q5e0nr7tWsxwkA==");
+        standard[2] = StringUtils.getBytesUtf8("ZL4VS2/6QCWNGgEojnwxyg==");
+        standard[3] = StringUtils.getBytesUtf8("/3+PwBzbRxqMi1qTBhg/6A==");
 
         byte[][] urlSafe1 = new byte[4][];
         // regular padding (two '==' signs).
-        urlSafe1[0] = StringBytesUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA==");
-        urlSafe1[1] = StringBytesUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA==");
-        urlSafe1[2] = StringBytesUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg==");
-        urlSafe1[3] = StringBytesUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A==");
+        urlSafe1[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA==");
+        urlSafe1[1] = StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA==");
+        urlSafe1[2] = StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg==");
+        urlSafe1[3] = StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A==");
 
         byte[][] urlSafe2 = new byte[4][];
         // single padding (only one '=' sign).
-        urlSafe2[0] = StringBytesUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA=");
-        urlSafe2[1] = StringBytesUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA=");
-        urlSafe2[2] = StringBytesUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg=");
-        urlSafe2[3] = StringBytesUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A=");
+        urlSafe2[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA=");
+        urlSafe2[1] = StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA=");
+        urlSafe2[2] = StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg=");
+        urlSafe2[3] = StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A=");
 
         byte[][] urlSafe3 = new byte[4][];
         // no padding (no '=' signs).
-        urlSafe3[0] = StringBytesUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA");
-        urlSafe3[1] = StringBytesUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA");
-        urlSafe3[2] = StringBytesUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg");
-        urlSafe3[3] = StringBytesUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A");
+        urlSafe3[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA");
+        urlSafe3[1] = StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA");
+        urlSafe3[2] = StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg");
+        urlSafe3[3] = StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A");
 
         for (int i = 0; i < 4; i++) {
             byte[] encodedStandard = Base64.encodeBase64(ids[i]);
@@ -909,26 +925,26 @@
             // ever need to delve closely into this stuff.
             if (false) {
                 System.out.println("reference: [" + new String(Hex.encodeHex(ids[i])) + "]");
-                System.out.println("standard:  ["
-                    + new String(Hex.encodeHex(decodedStandard))
-                    + "] From: ["
-                    + StringBytesUtils.newStringUtf8(standard[i])
-                    + "]");
-                System.out.println("safe1:     ["
-                    + new String(Hex.encodeHex(decodedUrlSafe1))
-                    + "] From: ["
-                    + StringBytesUtils.newStringUtf8(urlSafe1[i])
-                    + "]");
-                System.out.println("safe2:     ["
-                    + new String(Hex.encodeHex(decodedUrlSafe2))
-                    + "] From: ["
-                    + StringBytesUtils.newStringUtf8(urlSafe2[i])
-                    + "]");
-                System.out.println("safe3:     ["
-                    + new String(Hex.encodeHex(decodedUrlSafe3))
-                    + "] From: ["
-                    + StringBytesUtils.newStringUtf8(urlSafe3[i])
-                    + "]");
+                System.out.println("standard:  [" +
+                    new String(Hex.encodeHex(decodedStandard)) +
+                    "] From: [" +
+                    StringUtils.newStringUtf8(standard[i]) +
+                    "]");
+                System.out.println("safe1:     [" +
+                    new String(Hex.encodeHex(decodedUrlSafe1)) +
+                    "] From: [" +
+                    StringUtils.newStringUtf8(urlSafe1[i]) +
+                    "]");
+                System.out.println("safe2:     [" +
+                    new String(Hex.encodeHex(decodedUrlSafe2)) +
+                    "] From: [" +
+                    StringUtils.newStringUtf8(urlSafe2[i]) +
+                    "]");
+                System.out.println("safe3:     [" +
+                    new String(Hex.encodeHex(decodedUrlSafe3)) +
+                    "] From: [" +
+                    StringUtils.newStringUtf8(urlSafe3[i]) +
+                    "]");
             }
 
             assertTrue("standard encode uuid", Arrays.equals(encodedStandard, standard[i]));
diff --git a/src/test/org/apache/commons/codec/binary/Base64TestData.java b/src/test/org/apache/commons/codec/binary/Base64TestData.java
index 200077b..f4be0f4 100644
--- a/src/test/org/apache/commons/codec/binary/Base64TestData.java
+++ b/src/test/org/apache/commons/codec/binary/Base64TestData.java
@@ -25,6 +25,7 @@
  * This random data was encoded by OpenSSL. Java had nothing to do with it. This data helps us test interop between
  * Commons-Codec and OpenSSL. Notice that OpenSSL creates 64 character lines instead of the 76 of Commons-Codec.
  * 
+ * @see <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>
  * @author Apache Software Foundation
  * @version $Id $
  * @since 1.4
diff --git a/src/test/org/apache/commons/codec/binary/StringBytesUtilsTest.java b/src/test/org/apache/commons/codec/binary/StringBytesUtilsTest.java
deleted file mode 100644
index c9af364..0000000
--- a/src/test/org/apache/commons/codec/binary/StringBytesUtilsTest.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.binary;
-
-import java.io.UnsupportedEncodingException;
-import java.util.Arrays;
-
-import junit.framework.Assert;
-import junit.framework.TestCase;
-
-/**
- * @author <a href="mailto:ggregory@seagullsw.com">Gary Gregory</a>
- * @version $Id: $
- */
-public class StringBytesUtilsTest extends TestCase {
-
-    private static byte[] BYTES_FIXTURE;
-
-    private static final String STRING_FIXTURE = "ABC";
-    {
-        try {
-            BYTES_FIXTURE = "abc".getBytes("US-ASCII");
-        } catch (UnsupportedEncodingException e) {
-            throw new IllegalArgumentException(e.toString());
-        }
-    }
-
-    public void testGetBytesIso8859_1() throws UnsupportedEncodingException {
-        String charsetName = "ISO-8859-1";
-        testGetSupportedBytes(charsetName);
-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);
-        byte[] actual = StringBytesUtils.getBytesIso8859_1(STRING_FIXTURE);
-        Assert.assertTrue(Arrays.equals(expected, actual));
-    }
-
-    public void testGetBytesUsAscii() throws UnsupportedEncodingException {
-        String charsetName = "US-ASCII";
-        testGetSupportedBytes(charsetName);
-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);
-        byte[] actual = StringBytesUtils.getBytesUsAscii(STRING_FIXTURE);
-        Assert.assertTrue(Arrays.equals(expected, actual));
-    }
-
-    public void testGetBytesUtf16() throws UnsupportedEncodingException {
-        String charsetName = "UTF-16";
-        testGetSupportedBytes(charsetName);
-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);
-        byte[] actual = StringBytesUtils.getBytesUtf16(STRING_FIXTURE);
-        Assert.assertTrue(Arrays.equals(expected, actual));
-    }
-
-    public void testGetBytesUtf16Be() throws UnsupportedEncodingException {
-        String charsetName = "UTF-16BE";
-        testGetSupportedBytes(charsetName);
-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);
-        byte[] actual = StringBytesUtils.getBytesUtf16Be(STRING_FIXTURE);
-        Assert.assertTrue(Arrays.equals(expected, actual));
-    }
-
-    public void testGetBytesUtf16Le() throws UnsupportedEncodingException {
-        String charsetName = "UTF-16LE";
-        testGetSupportedBytes(charsetName);
-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);
-        byte[] actual = StringBytesUtils.getBytesUtf16Le(STRING_FIXTURE);
-        Assert.assertTrue(Arrays.equals(expected, actual));
-    }
-
-    public void testGetBytesUtf8() throws UnsupportedEncodingException {
-        String charsetName = "UTF-8";
-        testGetSupportedBytes(charsetName);
-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);
-        byte[] actual = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
-        Assert.assertTrue(Arrays.equals(expected, actual));
-    }
-
-    private void testGetSupportedBytes(String charsetName) throws UnsupportedEncodingException {
-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);
-        byte[] actual = StringBytesUtils.getSupportedBytes(STRING_FIXTURE, charsetName);
-        Assert.assertTrue(Arrays.equals(expected, actual));
-    }
-
-    public void testGetSupportedBytesBadEnc() {
-        try {
-            StringBytesUtils.getSupportedBytes(STRING_FIXTURE, "UNKNOWN");
-            Assert.fail("Expected " + IllegalStateException.class.getName());
-        } catch (IllegalStateException e) {
-            // Expected
-        }
-    }
-
-    private void testNewString(String charsetName) throws UnsupportedEncodingException {
-        String expected = new String(BYTES_FIXTURE, charsetName);
-        String actual = StringBytesUtils.newString(BYTES_FIXTURE, charsetName);
-        Assert.assertEquals(expected, actual);
-    }
-
-    public void testNewStringBadEnc() {
-        try {
-            StringBytesUtils.newString(BYTES_FIXTURE, "UNKNOWN");
-            Assert.fail("Expected " + IllegalStateException.class.getName());
-        } catch (IllegalStateException e) {
-            // Expected
-        }
-    }
-
-    public void testNewStringIso8859_1() throws UnsupportedEncodingException {
-        String charsetName = "ISO-8859-1";
-        testNewString(charsetName);
-        String expected = new String(BYTES_FIXTURE, charsetName);
-        String actual = StringBytesUtils.newStringIso8859_1(BYTES_FIXTURE);
-        Assert.assertEquals(expected, actual);
-    }
-
-    public void testNewStringUsAscii() throws UnsupportedEncodingException {
-        String charsetName = "US-ASCII";
-        testNewString(charsetName);
-        String expected = new String(BYTES_FIXTURE, charsetName);
-        String actual = StringBytesUtils.newStringUsAscii(BYTES_FIXTURE);
-        Assert.assertEquals(expected, actual);
-    }
-
-    public void testNewStringUtf16() throws UnsupportedEncodingException {
-        String charsetName = "UTF-16";
-        testNewString(charsetName);
-        String expected = new String(BYTES_FIXTURE, charsetName);
-        String actual = StringBytesUtils.newStringUtf16(BYTES_FIXTURE);
-        Assert.assertEquals(expected, actual);
-    }
-
-    public void testNewStringUtf16Be() throws UnsupportedEncodingException {
-        String charsetName = "UTF-16BE";
-        testNewString(charsetName);
-        String expected = new String(BYTES_FIXTURE, charsetName);
-        String actual = StringBytesUtils.newStringUtf16Be(BYTES_FIXTURE);
-        Assert.assertEquals(expected, actual);
-    }
-
-    public void testNewStringUtf16Le() throws UnsupportedEncodingException {
-        String charsetName = "UTF-16LE";
-        testNewString(charsetName);
-        String expected = new String(BYTES_FIXTURE, charsetName);
-        String actual = StringBytesUtils.newStringUtf16Le(BYTES_FIXTURE);
-        Assert.assertEquals(expected, actual);
-    }
-
-    public void testNewStringUtf8() throws UnsupportedEncodingException {
-        String charsetName = "UTF-8";
-        testNewString(charsetName);
-        String expected = new String(BYTES_FIXTURE, charsetName);
-        String actual = StringBytesUtils.newStringUtf8(BYTES_FIXTURE);
-        Assert.assertEquals(expected, actual);
-    }
-
-}
diff --git a/src/test/org/apache/commons/codec/binary/StringUtilsTest.java b/src/test/org/apache/commons/codec/binary/StringUtilsTest.java
new file mode 100644
index 0000000..e7a48dd
--- /dev/null
+++ b/src/test/org/apache/commons/codec/binary/StringUtilsTest.java
@@ -0,0 +1,169 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.binary;
+
+import java.io.UnsupportedEncodingException;
+import java.util.Arrays;
+
+import junit.framework.Assert;
+import junit.framework.TestCase;
+
+/**
+ * @author <a href="mailto:ggregory@seagullsw.com">Gary Gregory</a>
+ * @version $Id: $
+ */
+public class StringUtilsTest extends TestCase {
+
+    private static byte[] BYTES_FIXTURE;
+
+    private static final String STRING_FIXTURE = "ABC";
+    {
+        try {
+            BYTES_FIXTURE = "abc".getBytes("US-ASCII");
+        } catch (UnsupportedEncodingException e) {
+            throw new IllegalArgumentException(e.toString());
+        }
+    }
+
+    public void testGetBytesIso8859_1() throws UnsupportedEncodingException {
+        String charsetName = "ISO-8859-1";
+        testGetSupportedBytes(charsetName);
+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);
+        byte[] actual = StringUtils.getBytesIso8859_1(STRING_FIXTURE);
+        Assert.assertTrue(Arrays.equals(expected, actual));
+    }
+
+    public void testGetBytesUsAscii() throws UnsupportedEncodingException {
+        String charsetName = "US-ASCII";
+        testGetSupportedBytes(charsetName);
+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);
+        byte[] actual = StringUtils.getBytesUsAscii(STRING_FIXTURE);
+        Assert.assertTrue(Arrays.equals(expected, actual));
+    }
+
+    public void testGetBytesUtf16() throws UnsupportedEncodingException {
+        String charsetName = "UTF-16";
+        testGetSupportedBytes(charsetName);
+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);
+        byte[] actual = StringUtils.getBytesUtf16(STRING_FIXTURE);
+        Assert.assertTrue(Arrays.equals(expected, actual));
+    }
+
+    public void testGetBytesUtf16Be() throws UnsupportedEncodingException {
+        String charsetName = "UTF-16BE";
+        testGetSupportedBytes(charsetName);
+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);
+        byte[] actual = StringUtils.getBytesUtf16Be(STRING_FIXTURE);
+        Assert.assertTrue(Arrays.equals(expected, actual));
+    }
+
+    public void testGetBytesUtf16Le() throws UnsupportedEncodingException {
+        String charsetName = "UTF-16LE";
+        testGetSupportedBytes(charsetName);
+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);
+        byte[] actual = StringUtils.getBytesUtf16Le(STRING_FIXTURE);
+        Assert.assertTrue(Arrays.equals(expected, actual));
+    }
+
+    public void testGetBytesUtf8() throws UnsupportedEncodingException {
+        String charsetName = "UTF-8";
+        testGetSupportedBytes(charsetName);
+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);
+        byte[] actual = StringUtils.getBytesUtf8(STRING_FIXTURE);
+        Assert.assertTrue(Arrays.equals(expected, actual));
+    }
+
+    private void testGetSupportedBytes(String charsetName) throws UnsupportedEncodingException {
+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);
+        byte[] actual = StringUtils.getSupportedBytes(STRING_FIXTURE, charsetName);
+        Assert.assertTrue(Arrays.equals(expected, actual));
+    }
+
+    public void testGetSupportedBytesBadEnc() {
+        try {
+            StringUtils.getSupportedBytes(STRING_FIXTURE, "UNKNOWN");
+            Assert.fail("Expected " + IllegalStateException.class.getName());
+        } catch (IllegalStateException e) {
+            // Expected
+        }
+    }
+
+    private void testNewString(String charsetName) throws UnsupportedEncodingException {
+        String expected = new String(BYTES_FIXTURE, charsetName);
+        String actual = StringUtils.newString(BYTES_FIXTURE, charsetName);
+        Assert.assertEquals(expected, actual);
+    }
+
+    public void testNewStringBadEnc() {
+        try {
+            StringUtils.newString(BYTES_FIXTURE, "UNKNOWN");
+            Assert.fail("Expected " + IllegalStateException.class.getName());
+        } catch (IllegalStateException e) {
+            // Expected
+        }
+    }
+
+    public void testNewStringIso8859_1() throws UnsupportedEncodingException {
+        String charsetName = "ISO-8859-1";
+        testNewString(charsetName);
+        String expected = new String(BYTES_FIXTURE, charsetName);
+        String actual = StringUtils.newStringIso8859_1(BYTES_FIXTURE);
+        Assert.assertEquals(expected, actual);
+    }
+
+    public void testNewStringUsAscii() throws UnsupportedEncodingException {
+        String charsetName = "US-ASCII";
+        testNewString(charsetName);
+        String expected = new String(BYTES_FIXTURE, charsetName);
+        String actual = StringUtils.newStringUsAscii(BYTES_FIXTURE);
+        Assert.assertEquals(expected, actual);
+    }
+
+    public void testNewStringUtf16() throws UnsupportedEncodingException {
+        String charsetName = "UTF-16";
+        testNewString(charsetName);
+        String expected = new String(BYTES_FIXTURE, charsetName);
+        String actual = StringUtils.newStringUtf16(BYTES_FIXTURE);
+        Assert.assertEquals(expected, actual);
+    }
+
+    public void testNewStringUtf16Be() throws UnsupportedEncodingException {
+        String charsetName = "UTF-16BE";
+        testNewString(charsetName);
+        String expected = new String(BYTES_FIXTURE, charsetName);
+        String actual = StringUtils.newStringUtf16Be(BYTES_FIXTURE);
+        Assert.assertEquals(expected, actual);
+    }
+
+    public void testNewStringUtf16Le() throws UnsupportedEncodingException {
+        String charsetName = "UTF-16LE";
+        testNewString(charsetName);
+        String expected = new String(BYTES_FIXTURE, charsetName);
+        String actual = StringUtils.newStringUtf16Le(BYTES_FIXTURE);
+        Assert.assertEquals(expected, actual);
+    }
+
+    public void testNewStringUtf8() throws UnsupportedEncodingException {
+        String charsetName = "UTF-8";
+        testNewString(charsetName);
+        String expected = new String(BYTES_FIXTURE, charsetName);
+        String actual = StringUtils.newStringUtf8(BYTES_FIXTURE);
+        Assert.assertEquals(expected, actual);
+    }
+
+}
