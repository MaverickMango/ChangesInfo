diff --git a/build.xml b/build.xml
index a247ffc..1bf60a9 100644
--- a/build.xml
+++ b/build.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<!--build.xml generated by maven from project.xml version 1.1-RC2
-  on date August 8 2005, time 2359-->
+<!--build.xml generated by maven from project.xml version 1.2-SNAPSHOT
+  on date December 22 2005, time 1344-->
 
 <project default="jar" name="commons-math" basedir=".">
   <!--Load local and user build preferences-->
@@ -26,7 +26,7 @@
   </property>
   <property name="javadocdir" value="${basedir}/dist/docs/api">
   </property>
-  <property name="final.name" value="commons-math-1.1-RC2">
+  <property name="final.name" value="commons-math-1.2-SNAPSHOT">
   </property>
   <property name="proxy.host" value="">
   </property>
@@ -176,7 +176,7 @@
     </tstamp>
     <property name="copyright" value="Copyright &amp;copy;  The Apache Software Foundation. All Rights Reserved.">
     </property>
-    <property name="title" value="Math 1.1-RC2 API">
+    <property name="title" value="Math 1.2-SNAPSHOT API">
     </property>
     <javadoc use="true" private="true" destdir="${javadocdir}" author="true" version="true" sourcepath="${basedir}/src/java" packagenames="org.apache.commons.math.*">
       <classpath>
diff --git a/project.xml b/project.xml
index 5608c8d..4f23e81 100644
--- a/project.xml
+++ b/project.xml
@@ -105,6 +105,11 @@
       <name>1.1</name>
       <tag>MATH_1_1</tag>
     </version>
+    <version>
+      <id>1.2-SNAPSHOT</id>
+      <name>1.1</name>
+      <tag>trunk</tag>
+    </version>
   </versions>
   <developers>
     <developer>
diff --git a/src/conf/MANIFEST.MF b/src/conf/MANIFEST.MF
deleted file mode 100644
index 85b37d4..0000000
--- a/src/conf/MANIFEST.MF
+++ /dev/null
@@ -1,7 +0,0 @@
-Extension-Name: org.apache.commons.math
-Specification-Title: Jakarta Commons Math
-Specification-Vendor: Apache Software Foundation
-Specification-Version: 0.1
-Implementation-Title: org.apache.commons.math
-Implementation-Vendor: Apache Software Foundation
-Implementation-Version: 0.1
diff --git a/src/conf/manifestMods.txt b/src/conf/manifestMods.txt
new file mode 100644
index 0000000..27f159b
--- /dev/null
+++ b/src/conf/manifestMods.txt
@@ -0,0 +1,3 @@
+Build-Jdk: 1.3.1_16
+Specification-Version: 1.1
+Implementation-Vendor-Id: org.apache
diff --git a/src/java/org/apache/commons/math/ConvergenceException.java b/src/java/org/apache/commons/math/ConvergenceException.java
index 2933e59..a352db0 100644
--- a/src/java/org/apache/commons/math/ConvergenceException.java
+++ b/src/java/org/apache/commons/math/ConvergenceException.java
@@ -26,7 +26,7 @@
 public class ConvergenceException extends MathException implements Serializable{
     
     /** Serializable version identifier */
-    static final long serialVersionUID = -3657394299929217890L;
+    private static final long serialVersionUID = -3657394299929217890L;
     
     /**
      * Default constructor.
diff --git a/src/java/org/apache/commons/math/FunctionEvaluationException.java b/src/java/org/apache/commons/math/FunctionEvaluationException.java
index 0510859..c20d0ba 100644
--- a/src/java/org/apache/commons/math/FunctionEvaluationException.java
+++ b/src/java/org/apache/commons/math/FunctionEvaluationException.java
@@ -26,7 +26,7 @@
 public class FunctionEvaluationException extends MathException  {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = -317289374378977972L;
+    private static final long serialVersionUID = -317289374378977972L;
     
     /** Argument causing function evaluation failure */
     private double argument = Double.NaN;
diff --git a/src/java/org/apache/commons/math/MathConfigurationException.java b/src/java/org/apache/commons/math/MathConfigurationException.java
index 53c1fc2..dd63dee 100644
--- a/src/java/org/apache/commons/math/MathConfigurationException.java
+++ b/src/java/org/apache/commons/math/MathConfigurationException.java
@@ -24,7 +24,7 @@
 public class MathConfigurationException extends MathException implements Serializable {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = -7958299004965931723L;
+    private static final long serialVersionUID = -7958299004965931723L;
 
     /**
      * Default constructor.
diff --git a/src/java/org/apache/commons/math/MathException.java b/src/java/org/apache/commons/math/MathException.java
index 1c24528..07a6f94 100644
--- a/src/java/org/apache/commons/math/MathException.java
+++ b/src/java/org/apache/commons/math/MathException.java
@@ -31,7 +31,7 @@
 public class MathException extends Exception {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = -8594613561393443827L;
+    private static final long serialVersionUID = -8594613561393443827L;
     
     /**
      * Does JDK support nested exceptions?
diff --git a/src/java/org/apache/commons/math/analysis/BisectionSolver.java b/src/java/org/apache/commons/math/analysis/BisectionSolver.java
index 7ff28c3..dad06bd 100644
--- a/src/java/org/apache/commons/math/analysis/BisectionSolver.java
+++ b/src/java/org/apache/commons/math/analysis/BisectionSolver.java
@@ -29,7 +29,7 @@
 public class BisectionSolver extends UnivariateRealSolverImpl {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = 7137520585963699578L;
+    private static final long serialVersionUID = 7137520585963699578L;
     
     /**
      * Construct a solver for the given function.
diff --git a/src/java/org/apache/commons/math/analysis/BrentSolver.java b/src/java/org/apache/commons/math/analysis/BrentSolver.java
index 2becdbf..7e67370 100644
--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java
+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java
@@ -30,7 +30,7 @@
 public class BrentSolver extends UnivariateRealSolverImpl {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = 3350616277306882875L;
+    private static final long serialVersionUID = 3350616277306882875L;
 
     /**
      * Construct a solver for the given function.
diff --git a/src/java/org/apache/commons/math/analysis/NewtonSolver.java b/src/java/org/apache/commons/math/analysis/NewtonSolver.java
index 619417e..309f9e9 100644
--- a/src/java/org/apache/commons/math/analysis/NewtonSolver.java
+++ b/src/java/org/apache/commons/math/analysis/NewtonSolver.java
@@ -16,6 +16,7 @@
 
 package org.apache.commons.math.analysis;
 
+import java.io.IOException;
 import org.apache.commons.math.ConvergenceException;
 import org.apache.commons.math.FunctionEvaluationException; 
 
@@ -30,10 +31,10 @@
 public class NewtonSolver extends UnivariateRealSolverImpl {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = 2606474895443431607L;
+    private static final long serialVersionUID = 2606474895443431607L;
     
     /** The first derivative of the target function. */
-    private UnivariateRealFunction derivative;
+    private transient UnivariateRealFunction derivative;
     
     /**
      * Construct a solver for the given function.
@@ -97,5 +98,17 @@
         throw new ConvergenceException
             ("Maximum number of iterations exceeded " + i);
     }
-
+    
+    /**
+     * Custom deserialization to initialize transient deriviate field.
+     * 
+     * @param in serialized object input stream
+     * @throws IOException if IO error occurs 
+     * @throws ClassNotFoundException if instantiation error occurs
+     */
+    private void readObject(java.io.ObjectInputStream in)
+    throws IOException, ClassNotFoundException {
+        in.defaultReadObject();
+        derivative = ((DifferentiableUnivariateRealFunction) f).derivative();
+    }    
 }
diff --git a/src/java/org/apache/commons/math/analysis/PolynomialFunction.java b/src/java/org/apache/commons/math/analysis/PolynomialFunction.java
index 7184147..649ec18 100644
--- a/src/java/org/apache/commons/math/analysis/PolynomialFunction.java
+++ b/src/java/org/apache/commons/math/analysis/PolynomialFunction.java
@@ -28,7 +28,7 @@
 public class PolynomialFunction implements DifferentiableUnivariateRealFunction, Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = 3322454535052136809L;
+    private static final long serialVersionUID = 3322454535052136809L;
     
     /**
      * The coefficients of the polynomial, ordered by degree -- i.e.,  
diff --git a/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java b/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java
index d4f0547..e37b875 100644
--- a/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java
+++ b/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java
@@ -52,10 +52,11 @@
  *
  * @version $Revision$ $Date$
  */
-public class PolynomialSplineFunction implements UnivariateRealFunction, Serializable {
+public class PolynomialSplineFunction 
+    implements DifferentiableUnivariateRealFunction, Serializable {
    
     /** Serializable version identifier */
-    static final long serialVersionUID = 7011031166416885789L;
+    private static final long serialVersionUID = 7011031166416885789L;
     
     /** Spline segment interval delimiters (knots).   Size is n+1 for n segments. */
     private double knots[];
diff --git a/src/java/org/apache/commons/math/analysis/SecantSolver.java b/src/java/org/apache/commons/math/analysis/SecantSolver.java
index 030ce12..085dd9c 100644
--- a/src/java/org/apache/commons/math/analysis/SecantSolver.java
+++ b/src/java/org/apache/commons/math/analysis/SecantSolver.java
@@ -40,7 +40,7 @@
 public class SecantSolver extends UnivariateRealSolverImpl implements Serializable {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = 1984971194738974867L;
+    private static final long serialVersionUID = 1984971194738974867L;
     
     /**
      * Construct a solver for the given function.
diff --git a/src/java/org/apache/commons/math/analysis/SplineInterpolator.java b/src/java/org/apache/commons/math/analysis/SplineInterpolator.java
index aa2b491..8487f3d 100644
--- a/src/java/org/apache/commons/math/analysis/SplineInterpolator.java
+++ b/src/java/org/apache/commons/math/analysis/SplineInterpolator.java
@@ -16,7 +16,7 @@
 package org.apache.commons.math.analysis;
 
 /**
- * Computes a natural (a.k.a. "free", "unclamped") cubic spline interpolation for the data set.
+ * Computes a natural (also known as "free", "unclamped") cubic spline interpolation for the data set.
  * <p>
  * The {@link #interpolate(double[], double[])} method returns a {@link PolynomialSplineFunction}
  * consisting of n cubic polynomials, defined over the subintervals determined by the x values,  
diff --git a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java
index d0d24f3..ec27e1b 100644
--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java
+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java
@@ -30,7 +30,7 @@
     Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = 1112491292565386596L;
+    private static final long serialVersionUID = 1112491292565386596L;
     
     /** Maximum absolute error. */
     protected double absoluteAccuracy;
@@ -265,9 +265,9 @@
      */
     protected boolean isBracketing(double lower, double upper, 
             UnivariateRealFunction f) throws FunctionEvaluationException {
-    	double f1 = f.value(lower);
-    	double f2 = f.value(upper);
-    	return ((f1 > 0 && f2 < 0) || (f1 < 0 && f2 > 0));
+        double f1 = f.value(lower);
+        double f2 = f.value(upper);
+        return ((f1 > 0 && f2 < 0) || (f1 < 0 && f2 > 0));
     }
     
     /**
diff --git a/src/java/org/apache/commons/math/complex/Complex.java b/src/java/org/apache/commons/math/complex/Complex.java
index 83eb19d..a3bdb3a 100644
--- a/src/java/org/apache/commons/math/complex/Complex.java
+++ b/src/java/org/apache/commons/math/complex/Complex.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2004 The Apache Software Foundation.
+ * Copyright 2003-2005 The Apache Software Foundation.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,6 +22,16 @@
 /**
  * Representation of a Complex number - a number which has both a 
  * real and imaginary part.
+ * <p>
+ * Implementations of arithmetic operations handle <code>NaN</code> and
+ * infinite values according to the rules for {@link java.lang.Double}
+ * arithmetic, applying definitional formulas and returning <code>NaN</code> or
+ * infinite values in real or imaginary parts as these arise in computation. 
+ * See individual method javadocs for details.
+ * <p>
+ * {@link #equals} identifies all values with <code>NaN</code> in either real 
+ * or imaginary part - e.g., <pre>
+ * <code>1 + NaNi  == NaN + i == NaN + NaNi.</code></pre>
  *
  * @author Apache Software Foundation
  * @version $Revision$ $Date$
@@ -29,28 +39,31 @@
 public class Complex implements Serializable  {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -6530173849413811929L;
+    private static final long serialVersionUID = -6530173849413811929L;
     
-    /** The square root of -1. A number representing "0.0 + 1.0i".*/    
+    /** The square root of -1. A number representing "0.0 + 1.0i" */    
     public static final Complex I = new Complex(0.0, 1.0);
     
-    /** A complex number analogous to {@link java.lang.Double#NaN} */
+    /** A complex number representing "NaN + NaNi" */
     public static final Complex NaN = new Complex(Double.NaN, Double.NaN);
 
     /** A complex number representing "1.0 + 0.0i" */    
     public static final Complex ONE = new Complex(1.0, 0.0);
     
-    /** The imaginary part. */
+    /** A complex number representing "0.0 + 0.0i" */    
+    public static final Complex ZERO = new Complex(0.0, 0.0);
+    
+    /** The imaginary part */
     protected double imaginary;
     
-    /** The real part. */
+    /** The real part */
     protected double real;
     
     /**
      * Create a complex number given the real and imaginary parts.
      *
-     * @param real the real part.
-     * @param imaginary the imaginary part.
+     * @param real the real part
+     * @param imaginary the imaginary part
      */
     public Complex(double real, double imaginary) {
         super();
@@ -60,13 +73,23 @@
 
     /**
      * Return the absolute value of this complex number.
+     * <p>
+     * Returns <code>NaN</code> if either real or imaginary part is
+     * <code>NaN</code> and <code>Double.POSITIVE_INFINITY</code> if
+     * neither part is <code>NaN</code>, but at least one part takes an infinite
+     * value.
      *
-     * @return the absolute value.
+     * @return the absolute value
      */
     public double abs() {
         if (isNaN()) {
             return Double.NaN;
         }
+        
+        if (isInfinite()) {
+            return Double.POSITIVE_INFINITY;
+        }
+        
         if (Math.abs(real) < Math.abs(imaginary)) {
             if (imaginary == 0.0) {
                 return Math.abs(real);
@@ -84,38 +107,81 @@
     
     /**
      * Return the sum of this complex number and the given complex number.
+     * <p>
+     * Uses the definitional formula 
+     * <pre>
+     * (a + bi) + (c + di) = (a+c) + (b+d)i
+     * </pre>
+     * <p>
+     * If either this or <code>rhs</code> has a NaN value in either part,
+     * {@link #NaN} is returned; otherwise Inifinite and NaN values are
+     * returned in the parts of the result according to the rules for
+     * {@link java.lang.Double} arithmetic. 
      *
-     * @param rhs the other complex number.
-     * @return the complex number sum.
+     * @param rhs the other complex number
+     * @return the complex number sum
+     * @throws NullPointerException if <code>rhs</code> is null
      */
-    public Complex add(Complex rhs) {
-        if (isNaN() || rhs.isNaN()) {
-            return NaN;
-        }
-        
+    public Complex add(Complex rhs) {   
         return new Complex(real + rhs.getReal(),
             imaginary + rhs.getImaginary());
     }
     
     /**
-     * Return the conjugate of this complex number.  The conjugate of
-     * "A + Bi" is "A - Bi".  Complex.NaN is returned if either the real or imaginary part of 
-     * this Complex number equals Double.NaN.
+     * Return the conjugate of this complex number. The conjugate of
+     * "A + Bi" is "A - Bi". 
+     * <p>
+     * {@link #NaN} is returned if either the real or imaginary
+     * part of this Complex number equals <code>Double.NaN</code>.
+     * <p>
+     * If the imaginary part is infinite, and the real part is not NaN, 
+     * the returned value has infinite imaginary part of the opposite
+     * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code>
+     * is <code>1 - NEGATIVE_INFINITY i</code>
      *
      * @return the conjugate of this Complex object
      */
     public Complex conjugate() {
         if (isNaN()) {
             return NaN;
-        }
-        
+        }   
         return new Complex(real, -imaginary);
     }
     
     /**
      * Return the quotient of this complex number and the given complex number.
-     * @param rhs the other complex number.
-     * @return the complex number quotient.
+     * <p>
+     * Implements the definitional formula
+     * <pre><code>
+     *    a + bi          ac + bd + (bc - ad)i
+     *    ----------- = -------------------------
+     *    c + di               c<sup>2</sup> + d<sup>2</sup>
+     * </code></pre>
+     * but uses 
+     * <a href="http://doi.acm.org/10.1145/1039813.1039814">
+     * prescaling of operands</a> to limit the effects of overflows and
+     * underflows in the computation.
+     * <p>
+     * Infinite and NaN values are handled / returned according to the
+     * following rules, applied in the order presented:
+     * <ul>
+     * <li>If either this or <code>rhs</code> has a NaN value in either part,
+     *  {@link #NaN} is returned.</li>
+     * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.
+     * </li>
+     * <li>If this and <code>rhs</code> are both infinite,
+     * {@link #NaN} is returned.</li>
+     * <li>If this is finite (i.e., has no infinite or NaN parts) and
+     *  <code>rhs</code> is infinite (one or both parts infinite), 
+     * {@link #ZERO} is returned.</li>
+     * <li>If this is infinite and <code>rhs</code> is finite, NaN values are
+     * returned in the parts of the result if the {@link java.lang.Double}
+     * rules applied to the definitional formula force NaN results.</li>
+     * </ul>
+     * 
+     * @param rhs the other complex number
+     * @return the complex number quotient
+     * @throws NullPointerException if <code>rhs</code> is null
      */
     public Complex divide(Complex rhs) {
         if (isNaN() || rhs.isNaN()) {
@@ -125,7 +191,11 @@
         double c = rhs.getReal();
         double d = rhs.getImaginary();
         if (c == 0.0 && d == 0.0) {
-            throw new ArithmeticException("Error: division by zero.");
+            return NaN;
+        }
+        
+        if (rhs.isInfinite() && !isInfinite()) {
+            return ZERO;
         }
 
         if (Math.abs(c) < Math.abs(d)) {
@@ -156,13 +226,13 @@
      * <p>
      * All <code>NaN</code> values are considered to be equal - i.e, if either
      * (or both) real and imaginary parts of the complex number are equal
-     * to Double.NaN, the complex number is equal to 
+     * to <code>Double.NaN</code>, the complex number is equal to 
      * <code>Complex.NaN</code>.
      *
      * @param other Object to test for equality to this
      * @return true if two Complex objects are equal, false if
      *         object is null, not an instance of Complex, or
-     *         not equal to this Complex instance.
+     *         not equal to this Complex instance
      * 
      */
     public boolean equals(Object other) {
@@ -210,7 +280,7 @@
     /**
      * Access the imaginary part.
      *
-     * @return the imaginary part.
+     * @return the imaginary part
      */
     public double getImaginary() {
         return imaginary;
@@ -219,44 +289,76 @@
     /**
      * Access the real part.
      *
-     * @return the real part.
+     * @return the real part
      */
     public double getReal() {
         return real;
     }
     
     /**
-     * Returns true if this complex number is the special Not-a-Number (NaN)
-     * value.
+     * Returns true if either or both parts of this complex number is NaN;
+     * false otherwise
      *
-     * @return true if the value represented by this object is NaN; false
-     *         otherwise.
+     * @return  true if either or both parts of this complex number is NaN;
+     * false otherwise
      */
     public boolean isNaN() {
         return Double.isNaN(real) || Double.isNaN(imaginary);        
     }
     
     /**
+     * Returns true if either the real or imaginary part of this complex number
+     * takes an infinite value (either <code>Double.POSITIVE_INFINITY</code> or 
+     * <code>Double.NEGATIVE_INFINITY</code>) and neither part
+     * is <code>NaN</code>.
+     * 
+     * @return true if one or both parts of this complex number are infinite
+     * and neither part is <code>NaN</code>
+     */
+    public boolean isInfinite() {
+        return !isNaN() && 
+        (Double.isInfinite(real) || Double.isInfinite(imaginary));        
+    }
+    
+    /**
      * Return the product of this complex number and the given complex number.
-     *
-     * @param rhs the other complex number.
-     * @return the complex number product.
+     * <p>
+     * Implements the definitional formula:
+     * <pre><code>
+     * (a + bi)(c + di) = (ac - bd) + (ad + bc)i
+     * </code></pre>
+     * <p>
+     * Returns {@link #NaN} if either this or <code>rhs</code> has one or more
+     * NaN parts.
+     * <p>
+     * Returns NaN or infinite values in components of the result per the
+     * definitional formula and and the rules for {@link java.lang.Double}
+     * arithmetic.  Examples:
+     * <pre><code>
+     *  (1 + i) (INF + i)  =  INF + INFi
+     *  (1 + INFi) (1 - INFi) = INF + NaNi
+     *  (-INF + -INFi)(1 + NaNi) = NaN + NaNi
+     *  </code></pre>
+     * 
+     * @param rhs the other complex number
+     * @return the complex number product
+     * @throws NullPointerException if <code>rhs</code> is null
      */
     public Complex multiply(Complex rhs) {
         if (isNaN() || rhs.isNaN()) {
             return NaN;
         }
-        
-        double p = (real + imaginary) * (rhs.getReal() + rhs.getImaginary());
-        double ac = real * rhs.getReal();
-        double bd = imaginary * rhs.getImaginary();
-        return new Complex(ac - bd, p - ac - bd);
+        return new Complex(real * rhs.real - imaginary * rhs.imaginary,
+                real * rhs.imaginary + imaginary * rhs.real);
     }
     
     /**
      * Return the additive inverse of this complex number.
+     * <p>
+     * Returns <code>Complex.NaN</code> if either real or imaginary
+     * part of this Complex number equals <code>Double.NaN</code>.
      *
-     * @return the negation of this complex number.
+     * @return the negation of this complex number
      */
     public Complex negate() {
         if (isNaN()) {
@@ -269,9 +371,20 @@
     /**
      * Return the difference between this complex number and the given complex
      * number.
-     *
-     * @param rhs the other complex number.
-     * @return the complex number difference.
+      * <p>
+     * Uses the definitional formula 
+     * <pre>
+     * (a + bi) - (c + di) = (a-c) + (b-d)i
+     * </pre>
+     * <p>
+     * If either this or <code>rhs</code> has a NaN value in either part,
+     * {@link #NaN} is returned; otherwise inifinite and NaN values are
+     * returned in the parts of the result according to the rules for
+     * {@link java.lang.Double} arithmetic. 
+     * 
+     * @param rhs the other complex number
+     * @return the complex number difference
+     * @throws NullPointerException if <code>rhs</code> is null
      */
     public Complex subtract(Complex rhs) {
         if (isNaN() || rhs.isNaN()) {
diff --git a/src/java/org/apache/commons/math/complex/ComplexFormat.java b/src/java/org/apache/commons/math/complex/ComplexFormat.java
index b28b391..af9d378 100644
--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java
+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java
@@ -35,7 +35,7 @@
 public class ComplexFormat extends Format implements Serializable {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = -6337346779577272306L;
+    private static final long serialVersionUID = -6337346779577272306L;
     
     /** The default imaginary character. */
     private static final String DEFAULT_IMAGINARY_CHARACTER = "i";
diff --git a/src/java/org/apache/commons/math/complex/ComplexUtils.java b/src/java/org/apache/commons/math/complex/ComplexUtils.java
index a736d36..1c6e6a5 100644
--- a/src/java/org/apache/commons/math/complex/ComplexUtils.java
+++ b/src/java/org/apache/commons/math/complex/ComplexUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2004 The Apache Software Foundation.
+ * Copyright 2003-2005 The Apache Software Foundation.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,14 +19,20 @@
 import org.apache.commons.math.util.MathUtils;
 
 /**
- * Implementations of various transcendental functions for
- * {@link org.apache.commons.math.complex.Complex} arguments.
- *
+ * Static implementations of common 
+ * {@link org.apache.commons.math.complex.Complex}-valued functions.  Included
+ * are trigonometric, exponential, log, power and square root functions.
+ *<p>
  * Reference:
  * <ul>
  * <li><a href="http://myweb.lmu.edu/dmsmith/ZMLIB.pdf">
  * Multiple Precision Complex Arithmetic and Functions</a></li>
  * </ul>
+ * See individual method javadocs for the computational formulas used.
+ * In general, NaN values in either real or imaginary parts of input arguments
+ * result in {@link Complex#NaN} returned.  Otherwise, infinite or NaN values
+ * are returned as they arise in computing the real functions specified in the
+ * computational formulas.  Null arguments result in NullPointerExceptions.
  *
  * @version $Revision$ $Date$
  */
@@ -40,10 +46,19 @@
     }
     
     /**
-     * Compute the <a href="http://mathworld.wolfram.com/InverseCosine.html">
+     * Compute the 
+     * <a href="http://mathworld.wolfram.com/InverseCosine.html" TARGET="_top">
      * inverse cosine</a> for the given complex argument.
-     * @param z the value whose inverse cosine is to be returned.
-     * @return the inverse cosine of <code>z</code>.
+     * <p>
+     * Implements the formula: <pre>
+     * <code> acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))</code></pre>
+     * <p>
+     * Returns {@link Complex#NaN} if either real or imaginary part of the 
+     * input argument is <code>NaN</code> or infinite.
+     * 
+     * @param z the value whose inverse cosine is to be returned
+     * @return the inverse cosine of <code>z</code>
+     * @throws NullPointerException if <code>z</code> is null
      */
     public static Complex acos(Complex z) {
         if (z.isNaN()) {
@@ -55,10 +70,19 @@
     }
     
     /**
-     * Compute the <a href="http://mathworld.wolfram.com/InverseSine.html">
+     * Compute the 
+     * <a href="http://mathworld.wolfram.com/InverseSine.html" TARGET="_top">
      * inverse sine</a> for the given complex argument.
+     * <p>
+     * Implements the formula: <pre>
+     * <code> asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz)) </code></pre>
+     * <p>
+     * Returns {@link Complex#NaN} if either real or imaginary part of the 
+     * input argument is <code>NaN</code> or infinite.
+     * 
      * @param z the value whose inverse sine is to be returned.
      * @return the inverse sine of <code>z</code>.
+     * @throws NullPointerException if <code>z</code> is null
      */
     public static Complex asin(Complex z) {
         if (z.isNaN()) {
@@ -70,27 +94,56 @@
     }
     
     /**
-     * Compute the <a href="http://mathworld.wolfram.com/InverseTangent.html">
+     * Compute the 
+     * <a href="http://mathworld.wolfram.com/InverseTangent.html" TARGET="_top">
      * inverse tangent</a> for the given complex argument.
-     * @param z the value whose inverse tangent is to be returned.
-     * @return the inverse tangent of <code>z</code>.
+     * <p>
+     * Implements the formula: <pre>
+     * <code> atan(z) = (i/2) log((i + z)/(i - z)) </code></pre>
+     * <p>
+     * Returns {@link Complex#NaN} if either real or imaginary part of the 
+     * input argument is <code>NaN</code> or infinite. 
+     * 
+     * @param z the value whose inverse tangent is to be returned
+     * @return the inverse tangent of <code>z</code>
+     * @throws NullPointerException if <code>z</code> is null
      */
     public static Complex atan(Complex z) {
         if (z.isNaN()) {
             return Complex.NaN;
         }
         
-        
         return Complex.I.multiply(
             log(Complex.I.add(z).divide(Complex.I.subtract(z))))
             .divide(new Complex(2.0, 0.0));
     }
     
     /**
-     * Compute the <a href="http://mathworld.wolfram.com/Cosine.html">cosine</a>
+     * Compute the 
+     * <a href="http://mathworld.wolfram.com/Cosine.html" TARGET="_top">
+     * cosine</a>
      * for the given complex argument.
-     * @param z the value whose cosine is to be returned.
-     * @return the cosine of <code>z</code>.
+     * <p>
+     * Implements the formula: <pre>
+     * <code> cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i</code></pre>
+     * where the (real) functions on the right-hand side are
+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, 
+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
+     * <p>
+     * Returns {@link Complex#NaN} if either real or imaginary part of the 
+     * input argument is <code>NaN</code>.
+     * <p>
+     * Infinite values in real or imaginary parts of the input may result in
+     * infinite or NaN values returned in parts of the result.<pre>
+     * Examples: 
+     * <code>
+     * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i
+     * cos(&plusmn;INFINITY + i) = NaN + NaN i
+     * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>
+     * 
+     * @param z the value whose cosine is to be returned
+     * @return the cosine of <code>z</code>
+     * @throws NullPointerException if <code>z</code> is null
      */
     public static Complex cos(Complex z) {
         if (z.isNaN()) {
@@ -105,8 +158,29 @@
     }
     
     /**
-     * Compute the <a href="http://mathworld.wolfram.com/HyperbolicCosine.html">
+     * Compute the 
+     * <a href="http://mathworld.wolfram.com/HyperbolicCosine.html" TARGET="_top">
      * hyperbolic cosine</a> for the given complex argument.
+     * <p>
+     * Implements the formula: <pre>
+     * <code> cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i</code></pre>
+     * where the (real) functions on the right-hand side are
+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, 
+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
+     * <p>
+     * Returns {@link Complex#NaN} if either real or imaginary part of the 
+     * input argument is <code>NaN</code>.
+     * <p>
+     * Infinite values in real or imaginary parts of the input may result in
+     * infinite or NaN values returned in parts of the result.<pre>
+     * Examples: 
+     * <code>
+     * cosh(1 &plusmn; INFINITY i) = NaN + NaN i
+     * cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i
+     * cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>
+     * <p>
+     * Throws <code>NullPointerException</code> if z is null.
+     * 
      * @param z the value whose hyperbolic cosine is to be returned.
      * @return the hyperbolic cosine of <code>z</code>.
      */
@@ -124,10 +198,31 @@
     
     /**
      * Compute the
-     * <a href="http://mathworld.wolfram.com/ExponentialFunction.html">
+     * <a href="http://mathworld.wolfram.com/ExponentialFunction.html" TARGET="_top">
      * exponential function</a> for the given complex argument.
-     * @param z the value.
-     * @return <i>e</i><sup><code>z</code></sup>.
+     * <p>
+     * Implements the formula: <pre>
+     * <code> exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i</code></pre>
+     * where the (real) functions on the right-hand side are
+     * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and
+     * {@link java.lang.Math#sin}.
+     * <p>
+     * Returns {@link Complex#NaN} if either real or imaginary part of the 
+     * input argument is <code>NaN</code>.
+     * <p>
+     * Infinite values in real or imaginary parts of the input may result in
+     * infinite or NaN values returned in parts of the result.<pre>
+     * Examples: 
+     * <code>
+     * exp(1 &plusmn; INFINITY i) = NaN + NaN i
+     * exp(INFINITY + i) = INFINITY + INFINITY i
+     * exp(-INFINITY + i) = 0 + 0i
+     * exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>
+     * <p>
+     * Throws <code>NullPointerException</code> if z is null.
+     * 
+     * @param z the value
+     * @return <i>e</i><sup><code>z</code></sup>
      */
     public static Complex exp(Complex z) {
         if (z.isNaN()) {
@@ -136,14 +231,36 @@
         
         double b = z.getImaginary();
         double expA = Math.exp(z.getReal());
-        double sinB = Math.sin(b);
-        double cosB = Math.cos(b);
-        return new Complex(expA * cosB, expA * sinB);
+        return new Complex(expA *  Math.cos(b), expA * Math.sin(b));
     }
     
     /**
-     * Compute the <a href="http://mathworld.wolfram.com/NaturalLogarithm.html">
+     * Compute the 
+     * <a href="http://mathworld.wolfram.com/NaturalLogarithm.html" TARGET="_top">
      * natural logarithm</a> for the given complex argument.
+     * <p>
+     * Implements the formula: <pre>
+     * <code> log(a + bi) = ln(|a + bi|) + arg(a + bi)i</code></pre>
+     * where ln on the right hand side is {@link java.lang.Math#log},
+     * <code>|a + bi|</code> is the modulus, {@link Complex#abs},  and
+     * <code>arg(a + bi) = {@link java.lang.Math#atan2}(b, a)</code>
+     * <p>
+     * Returns {@link Complex#NaN} if either real or imaginary part of the 
+     * input argument is <code>NaN</code>.
+     * <p>
+     * Infinite (or critical) values in real or imaginary parts of the input may
+     * result in infinite or NaN values returned in parts of the result.<pre>
+     * Examples: 
+     * <code>
+     * log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i
+     * log(INFINITY + i) = INFINITY + 0i
+     * log(-INFINITY + i) = INFINITY + &pi;i
+     * log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i
+     * log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i
+     * log(0 + 0i) = -INFINITY + 0i
+     * </code></pre>
+     * Throws <code>NullPointerException</code> if z is null.
+     * 
      * @param z the value.
      * @return ln <code>z</code>.
      */
@@ -156,20 +273,85 @@
             Math.atan2(z.getImaginary(), z.getReal()));        
     }
     
+    /**
+     * Creates a complex number from the given polar representation.
+     * <p>
+     * The value returned is <code>r&middot;e<sup>i&middot;theta</sup></code>,
+     * computed as <code>r&middot;cos(theta) + r&middot;sin(theta)i</code>
+     * <p>
+     * If either <code>r</code> or <code>theta</code> is NaN, or 
+     * <code>theta</code> is infinite, {@link Complex#NaN} is returned.
+     * <p>
+     * If <code>r</code> is infinite and <code>theta</code> is finite, 
+     * infinite or NaN values may be returned in parts of the result, following
+     * the rules for double arithmetic.<pre>
+     * Examples: 
+     * <code>
+     * polar2Complex(INFINITY, &pi;/4) = INFINITY + INFINITY i
+     * polar2Complex(INFINITY, 0) = INFINITY + NaN i
+     * polar2Complex(INFINITY, -&pi;/4) = INFINITY - INFINITY i
+     * polar2Complex(INFINITY, 5&pi;/4) = -INFINITY - INFINITY i </code></pre>
+     * 
+     * @param r the modulus of the complex number to create
+     * @param theta  the argument of the complex number to create
+     * @return <code>r&middot;e<sup>i&middot;theta</sup></code>
+     * @throws IllegalArgumentException  if r is negative
+     * @since 1.1
+     */
+    public static Complex polar2Complex(double r, double theta) {
+        if (r < 0) {
+            throw new IllegalArgumentException
+                ("Complex modulus must not be negative");
+        }
+        return new Complex(r * Math.cos(theta), r * Math.sin(theta));
+    }
     
     /**
      * Returns of value of <code>y</code> raised to the power of <code>x</code>.
+     * <p>
+     * Implements the formula: <pre>
+     * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre> 
+     * where <code>exp</code> and <code>log</code> are {@link #exp} and
+     * {@link #log}, respectively.
+     * <p>
+     * Returns {@link Complex#NaN} if either real or imaginary part of the 
+     * input argument is <code>NaN</code> or infinite, or if <code>y</code>
+     * equals {@link Complex#ZERO}.
+     * 
      * @param y the base.
      * @param x the exponent.
-     * @return <code>y</code><sup><code>z</code></sup>.
+     * @return <code>y</code><sup><code>x</code></sup>
+     * @throws NullPointerException if either x or y is null
      */
     public static Complex pow(Complex y, Complex x) {
         return exp(x.multiply(log(y)));
     }
     
     /**
-     * Compute the <a href="http://mathworld.wolfram.com/Sine.html">sine</a>
+     * Compute the 
+     * <a href="http://mathworld.wolfram.com/Sine.html" TARGET="_top">
+     * sine</a>
      * for the given complex argument.
+     * <p>
+      * Implements the formula: <pre>
+     * <code> sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i</code></pre>
+     * where the (real) functions on the right-hand side are
+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, 
+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
+     * <p>
+     * Returns {@link Complex#NaN} if either real or imaginary part of the 
+     * input argument is <code>NaN</code>.
+     * <p>
+     * Infinite values in real or imaginary parts of the input may result in
+     * infinite or NaN values returned in parts of the result.<pre>
+     * Examples: 
+     * <code>
+     * sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i
+     * sin(&plusmn;INFINITY + i) = NaN + NaN i
+     * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>
+     * 
+     * Throws <code>NullPointerException</code> if z is null. 
+     * 
      * @param z the value whose sine is to be returned.
      * @return the sine of <code>z</code>.
      */
@@ -186,10 +368,30 @@
     }
     
     /**
-     * Compute the <a href="http://mathworld.wolfram.com/HyperbolicSine.html">
+     * Compute the 
+     * <a href="http://mathworld.wolfram.com/HyperbolicSine.html" TARGET="_top">
      * hyperbolic sine</a> for the given complex argument.
-     * @param z the value whose hyperbolic sine is to be returned.
-     * @return the hyperbolic sine of <code>z</code>.
+     * <p>
+     * Implements the formula: <pre>
+     * <code> sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i</code></pre>
+     * where the (real) functions on the right-hand side are
+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, 
+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
+     * <p>
+     * Returns {@link Complex#NaN} if either real or imaginary part of the 
+     * input argument is <code>NaN</code>.
+     * <p>
+     * Infinite values in real or imaginary parts of the input may result in
+     * infinite or NaN values returned in parts of the result.<pre>
+     * Examples: 
+     * <code>
+     * sinh(1 &plusmn; INFINITY i) = NaN + NaN i
+     * sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i
+     * sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre
+     * 
+     * @param z the value whose hyperbolic sine is to be returned
+     * @return the hyperbolic sine of <code>z</code>
+     * @throws NullPointerException if <code>z</code> is null
      */
     public static Complex sinh(Complex z) {
         if (z.isNaN()) {
@@ -204,10 +406,38 @@
     }
     
     /**
-     * Compute the <a href="http://mathworld.wolfram.com/SquareRoot.html">squre
-     * root</a> for the given complex argument.
-     * @param z the value whose square root is to be returned.
-     * @return the square root of <code>z</code>.
+     * Compute the 
+     * <a href="http://mathworld.wolfram.com/SquareRoot.html" TARGET="_top">
+     * square root</a> for the given complex argument.
+     * <p>
+     * Implements the following algorithm to compute <code>sqrt(a + bi)</code>: 
+     * <ol><li>Let <code>t = sqrt((|a| + |a + bi|) / 2)</code></li>
+     * <li><pre>if <code> a &#8805; 0</code> return <code>t + (b/2t)i</code>
+     *  else return <code>|b|/2t + sign(b)t i </code></pre></li>
+     * </ol>
+     * where <ul>
+     * <li><code>|a| = {@link Math#abs}(a)</code></li>
+     * <li><code>|a + bi| = {@link Complex#abs}(a + bi) </code></li>
+     * <li><code>sign(b) =  {@link MathUtils#indicator}(b) </code>
+     * </ul>
+     * <p>
+     * Returns {@link Complex#NaN} if either real or imaginary part of the 
+     * input argument is <code>NaN</code>.
+     * <p>
+     * Infinite values in real or imaginary parts of the input may result in
+     * infinite or NaN values returned in parts of the result.<pre>
+     * Examples: 
+     * <code>
+     * sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i
+     * sqrt(INFINITY + i) = INFINITY + 0i
+     * sqrt(-INFINITY + i) = 0 + INFINITY i
+     * sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i
+     * sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i
+     * </code></pre>
+     * 
+     * @param z the value whose square root is to be returned
+     * @return the square root of <code>z</code>
+     * @throws NullPointerException if <code>z</code> is null
      */
     public static Complex sqrt(Complex z) {
         if (z.isNaN()) {
@@ -230,20 +460,54 @@
     }
     
     /**
-     * Compute the <a href="http://mathworld.wolfram.com/SquareRoot.html">squre
-     * root of 1 - <code>z</code><sup>2</sup> for the given complex argument.
-     * @param z the value.
-     * @return the square root of 1 - <code>z</code><sup>2</sup>.
+     * Compute the 
+     * <a href="http://mathworld.wolfram.com/SquareRoot.html" TARGET="_top">
+     * square root</a> of 1 - <code>z</code><sup>2</sup> for the given complex
+     * argument.
+     * <p>
+     * Computes the result directly as 
+     * <code>sqrt(Complex.ONE.subtract(z.multiply(z)))</code>.
+     * <p>
+     * Returns {@link Complex#NaN} if either real or imaginary part of the 
+     * input argument is <code>NaN</code>.
+     * <p>
+     * Infinite values in real or imaginary parts of the input may result in
+     * infinite or NaN values returned in parts of the result. 
+     * 
+     * @param z the value
+     * @return the square root of 1 - <code>z</code><sup>2</sup>
+     * @throws NullPointerException if <code>z</code> is null
      */
     public static Complex sqrt1z(Complex z) {
         return sqrt(Complex.ONE.subtract(z.multiply(z)));
     }
     
     /**
-     * Compute the <a href="http://mathworld.wolfram.com/Tangent.html">
+     * Compute the 
+     * <a href="http://mathworld.wolfram.com/Tangent.html" TARGET="_top">
      * tangent</a> for the given complex argument.
-     * @param z the value whose tangent is to be returned.
-     * @return the tangent of <code>z</code>.
+     * <p>
+     * Implements the formula: <pre>
+     * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>
+     * where the (real) functions on the right-hand side are
+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, 
+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
+     * <p>
+     * Returns {@link Complex#NaN} if either real or imaginary part of the 
+     * input argument is <code>NaN</code>.
+     * <p>
+     * Infinite (or critical) values in real or imaginary parts of the input may
+     * result in infinite or NaN values returned in parts of the result.<pre>
+     * Examples: 
+     * <code>
+     * tan(1 &plusmn; INFINITY i) = 0 + NaN i
+     * tan(&plusmn;INFINITY + i) = NaN + NaN i
+     * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
+     * tan(&plusmn;&pi/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre>
+     * 
+     * @param z the value whose tangent is to be returned
+     * @return the tangent of <code>z</code>
+     * @throws NullPointerException if <code>z</code> is null
      */
     public static Complex tan(Complex z) {
         if (z.isNaN()) {
@@ -259,10 +523,30 @@
     
     /**
      * Compute the
-     * <a href="http://mathworld.wolfram.com/HyperbolicTangent.html">
+     * <a href="http://mathworld.wolfram.com/HyperbolicTangent.html" TARGET="_top">
      * hyperbolic tangent</a> for the given complex argument.
-     * @param z the value whose hyperbolic tangent is to be returned.
-     * @return the hyperbolic tangent of <code>z</code>.
+    * <p>
+     * Implements the formula: <pre>
+     * <code>tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i</code></pre>
+     * where the (real) functions on the right-hand side are
+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, 
+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
+     * <p>
+     * Returns {@link Complex#NaN} if either real or imaginary part of the 
+     * input argument is <code>NaN</code>.
+     * <p>
+     * Infinite values in real or imaginary parts of the input may result in
+     * infinite or NaN values returned in parts of the result.<pre>
+     * Examples: 
+     * <code>
+     * tanh(1 &plusmn; INFINITY i) = NaN + NaN i
+     * tanh(&plusmn;INFINITY + i) = NaN + 0 i
+     * tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
+     * tanh(0 + (&pi/2)i) = NaN + INFINITY i</code></pre>
+     *
+     * @param z the value whose hyperbolic tangent is to be returned
+     * @return the hyperbolic tangent of <code>z</code>
+     * @throws NullPointerException if <code>z</code> is null
      */
     public static Complex tanh(Complex z) {
         if (z.isNaN()) {
diff --git a/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java b/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java
index da86854..33b5a69 100644
--- a/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java
+++ b/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java
@@ -35,7 +35,7 @@
     implements ContinuousDistribution, Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -38038050983108802L;
+    private static final long serialVersionUID = -38038050983108802L;
     
     /**
      * Default constructor.
diff --git a/src/java/org/apache/commons/math/distribution/AbstractDistribution.java b/src/java/org/apache/commons/math/distribution/AbstractDistribution.java
index 04ff276..4e40401 100644
--- a/src/java/org/apache/commons/math/distribution/AbstractDistribution.java
+++ b/src/java/org/apache/commons/math/distribution/AbstractDistribution.java
@@ -28,7 +28,7 @@
     implements Distribution, Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -38038050983108802L;
+    private static final long serialVersionUID = -38038050983108802L;
     
     /**
      * Default constructor.
diff --git a/src/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java b/src/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java
index eff49ae..02ce01f 100644
--- a/src/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java
+++ b/src/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java
@@ -31,7 +31,7 @@
     implements IntegerDistribution, Serializable {
         
     /** Serializable version identifier */
-    static final long serialVersionUID = -1146319659338487221L;
+    private static final long serialVersionUID = -1146319659338487221L;
     
     /**
      * Default constructor.
diff --git a/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java b/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java
index ce7f04b..db0c7f1 100644
--- a/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java
+++ b/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java
@@ -31,7 +31,7 @@
     implements BinomialDistribution, Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = 6751309484392813623L;
+    private static final long serialVersionUID = 6751309484392813623L;
 
     /** The number of trials. */
     private int numberOfTrials;
diff --git a/src/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java b/src/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java
index 2633809..df04780 100644
--- a/src/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java
+++ b/src/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java
@@ -29,7 +29,7 @@
         implements CauchyDistribution, Serializable {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = 8589540077390120676L;
+    private static final long serialVersionUID = 8589540077390120676L;
 
     /** The median of this distribution. */
     private double median = 0;
diff --git a/src/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java b/src/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java
index 0b1db5b..fa9dfc6 100644
--- a/src/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java
+++ b/src/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java
@@ -29,7 +29,7 @@
     implements ChiSquaredDistribution, Serializable  {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = -8352658048349159782L;
+    private static final long serialVersionUID = -8352658048349159782L;
 
     /** Internal Gamma distribution. */    
     private GammaDistribution gamma;
diff --git a/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java b/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java
index c8d1fa4..1b271bb 100644
--- a/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java
+++ b/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java
@@ -20,7 +20,7 @@
 import org.apache.commons.math.MathException;
 
 /**
- * The default implementation of {@link ExponentialDistribution}
+ * The default implementation of {@link ExponentialDistribution}.
  *
  * @version $Revision$ $Date$
  */
@@ -28,7 +28,7 @@
     implements ExponentialDistribution, Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = 2401296428283614780L;
+    private static final long serialVersionUID = 2401296428283614780L;
     
     /** The mean of this distribution. */
     private double mean;
diff --git a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java
index c47f954..a9a1de4 100644
--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java
+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java
@@ -31,7 +31,7 @@
     implements FDistribution, Serializable  {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -8516354193418641566L;
+    private static final long serialVersionUID = -8516354193418641566L;
 
     /** The numerator degrees of freedom*/
     private double numeratorDegreesOfFreedom;
diff --git a/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java b/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java
index d635870..9fc7659 100644
--- a/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java
+++ b/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java
@@ -21,7 +21,7 @@
 import org.apache.commons.math.special.Gamma;
 
 /**
- * The default implementation of {@link GammaDistribution}
+ * The default implementation of {@link GammaDistribution}.
  *
  * @version $Revision$ $Date$
  */
@@ -29,7 +29,7 @@
     implements GammaDistribution, Serializable  {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -3239549463135430361L;
+    private static final long serialVersionUID = -3239549463135430361L;
 
     /** The shape parameter. */
     private double alpha;
diff --git a/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java b/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java
index 822329f..4c27422 100644
--- a/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java
+++ b/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java
@@ -30,7 +30,7 @@
 {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -436928820673516179L;
+    private static final long serialVersionUID = -436928820673516179L;
 
     /** The number of successes in the population. */
     private int numberOfSuccesses;
@@ -53,8 +53,8 @@
         super();
         if (numberOfSuccesses > populationSize) {
             throw new IllegalArgumentException(
-            	"number of successes must be less than or equal to " +
-            	"population size");
+                "number of successes must be less than or equal to " +
+                "population size");
         }
         if (sampleSize > populationSize) {
             throw new IllegalArgumentException(
@@ -241,7 +241,7 @@
         populationSize = size;
     }
     
-	/**
+    /**
      * Modify the sample size.
      * @param size the new sample size.
      * @throws IllegalArgumentException if <code>size</code> is negative.
@@ -260,9 +260,9 @@
      * @return upper tail CDF for this distribution.
      * @since 1.1
      */
-	public double upperCumulativeProbability(int x) {
-    	double ret;
-    	
+    public double upperCumulativeProbability(int x) {
+        double ret;
+        
         int n = getPopulationSize();
         int m = getNumberOfSuccesses();
         int k = getSampleSize();
@@ -273,12 +273,12 @@
         } else if(x > domain[1]) {
             ret = 0.0;
         } else {
-        	ret = innerCumulativeProbability(domain[1], x, -1, n, m, k);
+            ret = innerCumulativeProbability(domain[1], x, -1, n, m, k);
         }
         
         return ret;
     }
-	
+    
     /**
      * For this disbution, X, this method returns P(x0 &le; X &le; x1).  This
      * probability is computed by summing the point probabilities for the values
@@ -293,13 +293,13 @@
      * @return P(x0 &le; X &le; x1). 
      */
     private double innerCumulativeProbability(
-    	int x0, int x1, int dx, int n, int m, int k)
+        int x0, int x1, int dx, int n, int m, int k)
     {
-    	double ret = probability(n, m, k, x0);
-    	while (x0 != x1) {
-    		x0 += dx;
-    		ret += probability(n, m, k, x0);
-    	}
-		return ret;
-	}
+        double ret = probability(n, m, k, x0);
+        while (x0 != x1) {
+            x0 += dx;
+            ret += probability(n, m, k, x0);
+        }
+        return ret;
+    }
 }
diff --git a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java
index b5fec0b..2ccf813 100644
--- a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java
+++ b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java
@@ -31,7 +31,7 @@
         implements NormalDistribution, Serializable {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = 8589540077390120676L;
+    private static final long serialVersionUID = 8589540077390120676L;
 
     /** The mean of this distribution. */
     private double mean = 0;
diff --git a/src/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java b/src/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java
index 0756a7c..d3694d8 100644
--- a/src/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java
+++ b/src/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java
@@ -22,7 +22,7 @@
 import org.apache.commons.math.util.MathUtils;
 
 /**
- * Implementation for the {@link PoissonDistribution}
+ * Implementation for the {@link PoissonDistribution}.
  * 
  * @version $Revision$ $Date$
  */
@@ -30,7 +30,7 @@
         implements PoissonDistribution, Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -3349935121172596109L;
+    private static final long serialVersionUID = -3349935121172596109L;
     
     /**
      * Holds the Poisson mean for the distribution.
diff --git a/src/java/org/apache/commons/math/distribution/TDistributionImpl.java b/src/java/org/apache/commons/math/distribution/TDistributionImpl.java
index 2bc528c..62a2f51 100644
--- a/src/java/org/apache/commons/math/distribution/TDistributionImpl.java
+++ b/src/java/org/apache/commons/math/distribution/TDistributionImpl.java
@@ -31,7 +31,7 @@
     implements TDistribution, Serializable  {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -5852615386664158222L;
+    private static final long serialVersionUID = -5852615386664158222L;
     
     /** The degrees of freedom*/
     private double degreesOfFreedom;
diff --git a/src/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java b/src/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java
index 2d397be..46d3109 100644
--- a/src/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java
+++ b/src/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java
@@ -29,7 +29,7 @@
         implements WeibullDistribution, Serializable {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = 8589540077390120676L;
+    private static final long serialVersionUID = 8589540077390120676L;
     
     /** The shape parameter. */
     private double alpha;
diff --git a/src/java/org/apache/commons/math/fraction/Fraction.java b/src/java/org/apache/commons/math/fraction/Fraction.java
index ab6e89d..351f1f3 100644
--- a/src/java/org/apache/commons/math/fraction/Fraction.java
+++ b/src/java/org/apache/commons/math/fraction/Fraction.java
@@ -34,7 +34,7 @@
     public static final Fraction ZERO = new Fraction(0, 1);
     
     /** Serializable version identifier */
-    static final long serialVersionUID = 65382027393090L;
+    private static final long serialVersionUID = 65382027393090L;
     
     /** The denominator. */
     private int denominator;
diff --git a/src/java/org/apache/commons/math/fraction/FractionFormat.java b/src/java/org/apache/commons/math/fraction/FractionFormat.java
index 755b385..25fd71c 100644
--- a/src/java/org/apache/commons/math/fraction/FractionFormat.java
+++ b/src/java/org/apache/commons/math/fraction/FractionFormat.java
@@ -37,7 +37,7 @@
 public class FractionFormat extends Format implements Serializable {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = -6337346779577272306L;
+    private static final long serialVersionUID = -6337346779577272306L;
 
     /** The format used for the denominator. */
     private NumberFormat denominatorFormat;
diff --git a/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java b/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java
index 0da7f82..5dfa386 100644
--- a/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java
+++ b/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java
@@ -31,7 +31,7 @@
 public class ProperFractionFormat extends FractionFormat {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = -6337346779577272307L;
+    private static final long serialVersionUID = -6337346779577272307L;
     
     /** The format used for the whole number. */
     private NumberFormat wholeFormat;
diff --git a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java
index 8da271a..451dc3a 100644
--- a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java
+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java
@@ -19,7 +19,7 @@
 import java.math.BigDecimal;
 
 /**
- * Implementation for {@link BigMatrix} using a BigDecimal[][] array to store entries
+ * Implementation of {@link BigMatrix} using a BigDecimal[][] array to store entries
  * and <a href="http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf">
  * LU decompostion</a> to support linear system 
  * solution and inverse.
@@ -48,7 +48,7 @@
 public class BigMatrixImpl implements BigMatrix, Serializable {
     
     /** Serialization id */
-    static final long serialVersionUID = -1011428905656140431L;
+    private static final long serialVersionUID = -1011428905656140431L;
     
     /** Entries of the matrix */
     private BigDecimal data[][] = null;
diff --git a/src/java/org/apache/commons/math/linear/InvalidMatrixException.java b/src/java/org/apache/commons/math/linear/InvalidMatrixException.java
index f02c6d8..ff538ae 100644
--- a/src/java/org/apache/commons/math/linear/InvalidMatrixException.java
+++ b/src/java/org/apache/commons/math/linear/InvalidMatrixException.java
@@ -25,7 +25,7 @@
 public class InvalidMatrixException extends RuntimeException {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = 5318837237354354107L;
+    private static final long serialVersionUID = 5318837237354354107L;
 
     /**
      * Default constructor.
diff --git a/src/java/org/apache/commons/math/linear/MatrixIndexException.java b/src/java/org/apache/commons/math/linear/MatrixIndexException.java
index 24732d0..74afb58 100644
--- a/src/java/org/apache/commons/math/linear/MatrixIndexException.java
+++ b/src/java/org/apache/commons/math/linear/MatrixIndexException.java
@@ -24,7 +24,7 @@
 public class MatrixIndexException extends RuntimeException {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -1341109412864309526L;
+    private static final long serialVersionUID = -1341109412864309526L;
 
     /**
      * Default constructor.
diff --git a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java
index b3c8f4d..b31ac66 100644
--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java
+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java
@@ -21,7 +21,7 @@
 
 
 /**
- * Implementation for RealMatrix using a double[][] array to store entries and
+ * Implementation of RealMatrix using a double[][] array to store entries and
  * <a href="http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf">
  * LU decompostion</a> to support linear system
  * solution and inverse.
@@ -50,7 +50,7 @@
 public class RealMatrixImpl implements RealMatrix, Serializable {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = 4237564493130426188L;
+    private static final long serialVersionUID = 4237564493130426188L;
 
     /** Entries of the matrix */
     private double data[][] = null;
diff --git a/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java b/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java
index b375e6b..12eed6a 100644
--- a/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java
+++ b/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java
@@ -59,13 +59,13 @@
 public class EmpiricalDistributionImpl implements Serializable, EmpiricalDistribution {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -6773236347582113490L;
+    private static final long serialVersionUID = -6773236347582113490L;
 
     /** List of SummaryStatistics objects characterizing the bins */
     private ArrayList binStats = null;
 
     /** Sample statistics */
-    SummaryStatistics sampleStats = null;
+    private SummaryStatistics sampleStats = null;
 
     /** number of bins */
     private int binCount = 1000;
@@ -225,7 +225,7 @@
     private class StreamDataAdapter extends DataAdapter{
         
         /** Input stream providng access to the data */
-        BufferedReader inputStream;
+        private BufferedReader inputStream;
         
         /**
          * Create a StreamDataAdapter from a BufferedReader
@@ -380,7 +380,7 @@
      * @param min  the minimum value
      * @param value  the value whose bin we are trying to find
      * @param delta  the grid size
-     * @return
+     * @return the index of the bin containing the value
      */
     private int findBin(double min, double value, double delta) {
         return Math.min(
@@ -453,14 +453,18 @@
     }
 
     /**
-     * Returns the array of upper bounds for the bins.  Bins are: <br/>
+     * Returns (a fresh copy of) the array of upper bounds for the bins.
+       Bins are: <br/>
      * [min,upperBounds[0]],(upperBounds[0],upperBounds[1]],...,
      *  (upperBounds[binCount-1],max]
      * 
      * @return array of bin upper bounds
      */
     public double[] getUpperBounds() {
-        return upperBounds;
+        int len = upperBounds.length;
+        double[] out = new double[len];
+        System.arraycopy(upperBounds, 0, out, 0, len);
+        return out;
     }
 
     /**
diff --git a/src/java/org/apache/commons/math/random/RandomData.java b/src/java/org/apache/commons/math/random/RandomData.java
index b274c0d..ffc5d78 100644
--- a/src/java/org/apache/commons/math/random/RandomData.java
+++ b/src/java/org/apache/commons/math/random/RandomData.java
@@ -18,7 +18,7 @@
 import java.util.Collection;
 
 /**
- * Random data generation utilities
+ * Random data generation utilities.
  * @version $Revision$ $Date$
  */
 public interface RandomData {
diff --git a/src/java/org/apache/commons/math/random/RandomDataImpl.java b/src/java/org/apache/commons/math/random/RandomDataImpl.java
index 42d92f3..4c73248 100644
--- a/src/java/org/apache/commons/math/random/RandomDataImpl.java
+++ b/src/java/org/apache/commons/math/random/RandomDataImpl.java
@@ -81,7 +81,7 @@
 public class RandomDataImpl implements RandomData, Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -626730818244969716L;
+    private static final long serialVersionUID = -626730818244969716L;
 
     /** underlying random number generator */
     private RandomGenerator rand = null;
diff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java
index c9e1f6e..8a99b2c 100644
--- a/src/java/org/apache/commons/math/stat/Frequency.java
+++ b/src/java/org/apache/commons/math/stat/Frequency.java
@@ -40,7 +40,7 @@
 public class Frequency implements Serializable {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = -3845586908418844111L;
+    private static final long serialVersionUID = -3845586908418844111L;
 
     /** underlying collection */
     private TreeMap freqTable = null;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java b/src/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java
index 31382d1..cb83f66 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java
@@ -20,7 +20,7 @@
 
 /**
  *
- * Abstract Implementation for the {@link StorelessUnivariateStatistic} interface.
+ * Abstract implementation of the {@link StorelessUnivariateStatistic} interface.
  * <p>
  * Provides default <code>evaluate()</code> and <code>incrementAll(double[])<code>
  * implementations. 
@@ -34,7 +34,7 @@
     implements StorelessUnivariateStatistic, Serializable {
 
     /** Serialization UID */
-    static final long serialVersionUID = -44915725420072521L;
+    private static final long serialVersionUID = -44915725420072521L;
     
     /**
      * This default implementation calls {@link #clear}, then invokes 
diff --git a/src/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java b/src/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java
index a2dd988..22b4d61 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java
@@ -34,7 +34,7 @@
     implements UnivariateStatistic, Serializable {
     
     /** Serialization UID */
-    static final long serialVersionUID = -8007759382851708045L;
+    private static final long serialVersionUID = -8007759382851708045L;
 
     /**
      * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[])
diff --git a/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java b/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java
index 3297f67..672eacc 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java
@@ -39,7 +39,7 @@
 public abstract class DescriptiveStatistics implements StatisticalSummary, Serializable {
     
     /** Serialization UID */
-    static final long serialVersionUID = 5188298269533339922L;
+    private static final long serialVersionUID = 5188298269533339922L;
     
     /**
      * Create an instance of a <code>DescriptiveStatistics</code>
diff --git a/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsImpl.java b/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsImpl.java
index bc1d4cc..c3649cf 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsImpl.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsImpl.java
@@ -28,7 +28,7 @@
 public class DescriptiveStatisticsImpl extends DescriptiveStatistics implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -1868088725461221010L;
+    private static final long serialVersionUID = -1868088725461221010L;
     
     /** hold the window size **/
     protected int windowSize;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java b/src/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java
index e0239fa..c05f193 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java
@@ -27,7 +27,7 @@
     StatisticalSummary {
    
     /** Serialization id */
-    static final long serialVersionUID = -5108854841843722536L;
+    private static final long serialVersionUID = -5108854841843722536L;
 
     /** The sample mean */
     private final double mean;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java b/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java
index aac31da..d4ae8c8 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java
@@ -28,7 +28,7 @@
 public abstract class SummaryStatistics implements StatisticalSummary, Serializable {
 
     /** Serialization UID */
-    static final long serialVersionUID = -6400596334135654825L;
+    private static final long serialVersionUID = -6400596334135654825L;
      
     /**
      * Create an instance of a <code>SummaryStatistics</code>
diff --git a/src/java/org/apache/commons/math/stat/descriptive/SummaryStatisticsImpl.java b/src/java/org/apache/commons/math/stat/descriptive/SummaryStatisticsImpl.java
index 3a9d41a..2c2b10c 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/SummaryStatisticsImpl.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/SummaryStatisticsImpl.java
@@ -34,7 +34,7 @@
 public class SummaryStatisticsImpl extends SummaryStatistics implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = 8787174276883311692L;
+    private static final long serialVersionUID = 8787174276883311692L;
 
     /** count of values that have been added */
     protected long n = 0;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java b/src/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java
index 090a584..e94d2ed 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java
@@ -48,7 +48,7 @@
     implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -803343206421984070L; 
+    private static final long serialVersionUID = -803343206421984070L; 
     
     /** Count of values that have been added */
     protected long n;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java b/src/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java
index feb202d..cc9f8fc 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java
@@ -52,7 +52,7 @@
 public class FourthMoment extends ThirdMoment implements Serializable{
 
     /** Serializable version identifier */
-    static final long serialVersionUID = 4763990447117157611L;
+    private static final long serialVersionUID = 4763990447117157611L;
         
     /** fourth moment of values that have been added */
     protected double m4;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java b/src/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java
index c5aaa30..bf601f9 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java
@@ -45,7 +45,7 @@
 public class GeometricMean extends AbstractStorelessUnivariateStatistic {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -8178734905303459453L;  
+    private static final long serialVersionUID = -8178734905303459453L;  
     
     /** Wrapped SumOfLogs instance */
     private SumOfLogs sumOfLogs;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java b/src/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java
index 3e46078..f027cb3 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java
@@ -40,7 +40,7 @@
 public class Kurtosis extends AbstractStorelessUnivariateStatistic  {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = 2784465764798260919L;  
+    private static final long serialVersionUID = 2784465764798260919L;  
       
     /**Fourth Moment on which this statistic is based */
     protected FourthMoment moment;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java b/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java
index a1ffeaa..792718a 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java
@@ -50,7 +50,7 @@
     implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -1296043746617791564L;    
+    private static final long serialVersionUID = -1296043746617791564L;    
     
     /** First moment on which this statistic is based. */
     protected FirstMoment moment;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/moment/SecondMoment.java b/src/java/org/apache/commons/math/stat/descriptive/moment/SecondMoment.java
index e4e2407..dc1415e 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/moment/SecondMoment.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/SecondMoment.java
@@ -44,7 +44,7 @@
 public class SecondMoment extends FirstMoment implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = 3942403127395076445L;  
+    private static final long serialVersionUID = 3942403127395076445L;  
       
     /** second moment of values that have been added */
     protected double m2;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java b/src/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java
index 67c00d1..f9b46fa 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java
@@ -39,7 +39,7 @@
 public class Skewness extends AbstractStorelessUnivariateStatistic implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = 7101857578996691352L;    
+    private static final long serialVersionUID = 7101857578996691352L;    
     
     /** Third moment on which this statistic is based */
     protected ThirdMoment moment = null;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java b/src/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java
index e9d8a43..420a06b 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java
@@ -40,7 +40,7 @@
     implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = 5728716329662425188L;  
+    private static final long serialVersionUID = 5728716329662425188L;  
     
     /** Wrapped Variance instance */
     private Variance variance = null;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java b/src/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java
index 07472ef..acd90c7 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java
@@ -45,7 +45,7 @@
 public class ThirdMoment extends SecondMoment implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -7818711964045118679L;  
+    private static final long serialVersionUID = -7818711964045118679L;  
       
     /** third moment of values that have been added */
     protected double m3;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java b/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java
index c7cf112..e549de9 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java
@@ -50,7 +50,7 @@
 public class Variance extends AbstractStorelessUnivariateStatistic implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -9111962718267217978L;  
+    private static final long serialVersionUID = -9111962718267217978L;  
       
     /** SecondMoment is used in incremental calculation of Variance*/
     protected SecondMoment moment = null;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/rank/Max.java b/src/java/org/apache/commons/math/stat/descriptive/rank/Max.java
index 5a6a6be..8f7b926 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Max.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Max.java
@@ -37,7 +37,7 @@
 public class Max extends AbstractStorelessUnivariateStatistic {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -5593383832225844641L;    
+    private static final long serialVersionUID = -5593383832225844641L;    
     
     /** Number of values that have been added */
     private long n;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/rank/Median.java b/src/java/org/apache/commons/math/stat/descriptive/rank/Median.java
index b7cfa79..3bced2f 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Median.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Median.java
@@ -32,7 +32,7 @@
 public class Median extends Percentile implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -3961477041290915687L;    
+    private static final long serialVersionUID = -3961477041290915687L;    
 
     /**
      * Default constructor.
diff --git a/src/java/org/apache/commons/math/stat/descriptive/rank/Min.java b/src/java/org/apache/commons/math/stat/descriptive/rank/Min.java
index 7ece3f5..fca1f60 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Min.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Min.java
@@ -39,7 +39,7 @@
 public class Min extends AbstractStorelessUnivariateStatistic implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -2941995784909003131L;  
+    private static final long serialVersionUID = -2941995784909003131L;  
       
     /**Number of values that have been added */
     private long n;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java b/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java
index 0c304de..496130e 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java
@@ -65,7 +65,7 @@
 public class Percentile extends AbstractUnivariateStatistic implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -8091216485095130416L; 
+    private static final long serialVersionUID = -8091216485095130416L; 
        
     /** Determines what percentile is computed when evaluate() is activated 
      * with no quantile argument */
diff --git a/src/java/org/apache/commons/math/stat/descriptive/summary/Product.java b/src/java/org/apache/commons/math/stat/descriptive/summary/Product.java
index e7d14fb..5e6dc34 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/summary/Product.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/Product.java
@@ -35,7 +35,7 @@
 public class Product extends AbstractStorelessUnivariateStatistic implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = 2824226005990582538L;   
+    private static final long serialVersionUID = 2824226005990582538L;   
      
     /**The number of values that have been added */
     private long n;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/summary/Sum.java b/src/java/org/apache/commons/math/stat/descriptive/summary/Sum.java
index 08e9019..19fdc38 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/summary/Sum.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/Sum.java
@@ -35,7 +35,7 @@
 public class Sum extends AbstractStorelessUnivariateStatistic implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -8231831954703408316L;  
+    private static final long serialVersionUID = -8231831954703408316L;  
       
     /** */
     private long n;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java b/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java
index 30cdd8a..50a813f 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java
@@ -43,7 +43,7 @@
 public class SumOfLogs extends AbstractStorelessUnivariateStatistic implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -370076995648386763L;    
+    private static final long serialVersionUID = -370076995648386763L;    
 
     /**Number of values that have been added */
     private int n;
diff --git a/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java b/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java
index f182eb2..ffe853b 100644
--- a/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java
+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java
@@ -35,7 +35,7 @@
 public class SumOfSquares extends AbstractStorelessUnivariateStatistic implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = 1460986908574398008L;  
+    private static final long serialVersionUID = 1460986908574398008L;  
       
     /** */
     private long n;
diff --git a/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java b/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java
index 569fad2..552b300 100644
--- a/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java
+++ b/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java
@@ -54,7 +54,7 @@
 public class SimpleRegression implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -3004689053607543335L;
+    private static final long serialVersionUID = -3004689053607543335L;
 
     /** sum of x values */
     private double sumX = 0d;
diff --git a/src/java/org/apache/commons/math/util/ContinuedFraction.java b/src/java/org/apache/commons/math/util/ContinuedFraction.java
index 5804d95..4e75927 100644
--- a/src/java/org/apache/commons/math/util/ContinuedFraction.java
+++ b/src/java/org/apache/commons/math/util/ContinuedFraction.java
@@ -37,7 +37,7 @@
 public abstract class ContinuedFraction implements Serializable {
     
     /** Serialization UID */
-    static final long serialVersionUID = 1768555336266158242L;
+    private static final long serialVersionUID = 1768555336266158242L;
     
     /** Maximum allowed numerical error. */
     private static final double DEFAULT_EPSILON = 10e-9;
@@ -128,46 +128,46 @@
     public double evaluate(double x, double epsilon, int maxIterations)
         throws MathException
     {
-    	double p0 = 1.0;
-    	double p1 = getA(0, x);
-    	double q0 = 0.0;
-    	double q1 = 1.0;
-    	double c = p1 / q1;
-    	int n = 0;
-    	double relativeError = Double.MAX_VALUE;
-    	while (n < maxIterations && relativeError > epsilon) {
-    		++n;
-    		double a = getA(n, x);
-    		double b = getB(n, x);
-  			double p2 = a * p1 + b * p0;
-   			double q2 = a * q1 + b * q0;
-   			if (Double.isInfinite(p2) || Double.isInfinite(q2)) {
-   				// need to scale
-   				if (a != 0.0) {
-   					p2 = p1 + (b / a * p0);
-   					q2 = q1 + (b / a * q0);
-   				} else if (b != 0) {
-   					p2 = (a / b * p1) + p0;
-   					q2 = (a / b * q1) + q0;
-   				} else {
-   					// can not scale an convergent is unbounded.
-   		            throw new ConvergenceException(
-   	                	"Continued fraction convergents diverged to +/- " +
-   	                	"infinity.");
-   				}
-   			}
-   			double r = p2 / q2;
-   			relativeError = Math.abs(r / c - 1.0);
-    			
-   			// prepare for next iteration
-   			c = p2 / q2;
-   			p0 = p1;
-   			p1 = p2;
-   			q0 = q1;
-   			q1 = q2;
-    	}
+        double p0 = 1.0;
+        double p1 = getA(0, x);
+        double q0 = 0.0;
+        double q1 = 1.0;
+        double c = p1 / q1;
+        int n = 0;
+        double relativeError = Double.MAX_VALUE;
+        while (n < maxIterations && relativeError > epsilon) {
+            ++n;
+            double a = getA(n, x);
+            double b = getB(n, x);
+            double p2 = a * p1 + b * p0;
+            double q2 = a * q1 + b * q0;
+            if (Double.isInfinite(p2) || Double.isInfinite(q2)) {
+                // need to scale
+                if (a != 0.0) {
+                    p2 = p1 + (b / a * p0);
+                    q2 = q1 + (b / a * q0);
+                } else if (b != 0) {
+                    p2 = (a / b * p1) + p0;
+                    q2 = (a / b * q1) + q0;
+                } else {
+                    // can not scale an convergent is unbounded.
+                    throw new ConvergenceException(
+                        "Continued fraction convergents diverged to +/- " +
+                        "infinity.");
+                }
+            }
+            double r = p2 / q2;
+            relativeError = Math.abs(r / c - 1.0);
+                
+            // prepare for next iteration
+            c = p2 / q2;
+            p0 = p1;
+            p1 = p2;
+            q0 = q1;
+            q1 = q2;
+        }
 
-    	if (n >= maxIterations) {
+        if (n >= maxIterations) {
             throw new ConvergenceException(
                 "Continued fraction convergents failed to converge.");
         }
diff --git a/src/java/org/apache/commons/math/util/DefaultTransformer.java b/src/java/org/apache/commons/math/util/DefaultTransformer.java
index 040e2e7..5cf5e05 100644
--- a/src/java/org/apache/commons/math/util/DefaultTransformer.java
+++ b/src/java/org/apache/commons/math/util/DefaultTransformer.java
@@ -31,7 +31,7 @@
 public class DefaultTransformer implements NumberTransformer, Serializable {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = 4019938025047800455L;
+    private static final long serialVersionUID = 4019938025047800455L;
     
     /**
      * @param o  the object that gets transformed.
diff --git a/src/java/org/apache/commons/math/util/ResizableDoubleArray.java b/src/java/org/apache/commons/math/util/ResizableDoubleArray.java
index ed0f945..97da2f1 100644
--- a/src/java/org/apache/commons/math/util/ResizableDoubleArray.java
+++ b/src/java/org/apache/commons/math/util/ResizableDoubleArray.java
@@ -71,7 +71,7 @@
 public class ResizableDoubleArray implements DoubleArray, Serializable {
     
     /** Serializable version identifier */
-    static final long serialVersionUID = -3485529955529426875L; 
+    private static final long serialVersionUID = -3485529955529426875L; 
     
     /** additive expansion mode */
     public static final int ADDITIVE_MODE = 1;
diff --git a/src/java/org/apache/commons/math/util/TransformerMap.java b/src/java/org/apache/commons/math/util/TransformerMap.java
index 90d5d9a..0b1547d 100644
--- a/src/java/org/apache/commons/math/util/TransformerMap.java
+++ b/src/java/org/apache/commons/math/util/TransformerMap.java
@@ -33,7 +33,7 @@
 public class TransformerMap implements NumberTransformer, Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -942772950698439883L;
+    private static final long serialVersionUID = -942772950698439883L;
     
     /**
      * A default Number Transformer for Numbers and numeric Strings.
diff --git a/src/java/org/apache/commons/math/util/package.html b/src/java/org/apache/commons/math/util/package.html
index f95a194..622e1d8 100644
--- a/src/java/org/apache/commons/math/util/package.html
+++ b/src/java/org/apache/commons/math/util/package.html
@@ -15,5 +15,5 @@
    limitations under the License.
   -->
     <!-- $Revision$ $Date$ -->
-    <body>Convience routines and common data structure used throughout the commons-math library.</body>
+    <body>Convenience routines and common data structures used throughout the commons-math library.</body>
 </html>
diff --git a/src/test/org/apache/commons/math/TestUtils.java b/src/test/org/apache/commons/math/TestUtils.java
index aec7a02..75f82ab 100644
--- a/src/test/org/apache/commons/math/TestUtils.java
+++ b/src/test/org/apache/commons/math/TestUtils.java
@@ -42,6 +42,10 @@
         assertEquals(null, expected, actual, delta);
     }
 
+    /**
+     * Verifies that expected and actual are within delta, or are both NaN or
+     * infinities of the same sign.
+     */
     public static void assertEquals(String msg, double expected, double actual, double delta) {
         // check for NaN
         if(Double.isNaN(expected)){
@@ -52,8 +56,26 @@
         }
     }
     
+    /*
+     * Verifies that the two arguments are exactly the same, either
+     * both NaN or infinities of same sign, or identical floating point values.
+     */
+    public static void assertSame(double expected, double actual) {
+     assertEquals(expected, actual, 0);
+    }
+    
     /**
-     * 
+     * Verifies that real and imaginary parts of the two complex arguments
+     * are exactly the same.  Also ensures that NaN / infinite components match.
+     */
+    public static void assertSame(Complex expected, Complex actual) {
+        assertSame(expected.getReal(), actual.getReal());
+        assertSame(expected.getImaginary(), actual.getImaginary());
+    }
+    
+    /**
+     * Verifies that real and imaginary parts of the two complex arguments
+     * differ by at most delta.  Also ensures that NaN / infinite components match.
      */
     public static void assertEquals(Complex expected, Complex actual, double delta) {
         assertEquals(expected.getReal(), actual.getReal(), delta);
@@ -92,26 +114,26 @@
             ObjectInputStream si = new ObjectInputStream(fi);  
             result = si.readObject();
         } catch (Exception ex) {
-        	
+            
         } finally {
-        	if (fo != null) {
-        		try {
-        			fo.close();
-        		} catch (IOException ex) {
-        		}
-        	}
+            if (fo != null) {
+                try {
+                    fo.close();
+                } catch (IOException ex) {
+                }
+            }
 
-        	if (fi != null) {
-        		try {
-            		fi.close();
-        		} catch (IOException ex) {
-        		}
-        	}
+            if (fi != null) {
+                try {
+                    fi.close();
+                } catch (IOException ex) {
+                }
+            }
         }
         
         
         if (tmp != null) {
-        	tmp.delete();
+            tmp.delete();
         }
         
         return result;
@@ -128,15 +150,15 @@
         Assert.assertEquals("HashCode check", object.hashCode(), object2.hashCode());
     }
 
-	public static void assertRelativelyEquals(double expected, double actual, double relativeError) {
-		assertRelativelyEquals(null, expected, actual, relativeError);
-	}
-	
-	public static void assertRelativelyEquals(String msg, double expected, double actual, double relativeError) {
+    public static void assertRelativelyEquals(double expected, double actual, double relativeError) {
+        assertRelativelyEquals(null, expected, actual, relativeError);
+    }
+    
+    public static void assertRelativelyEquals(String msg, double expected, double actual, double relativeError) {
         if (Double.isNaN(expected)) {
             Assert.assertTrue(msg, Double.isNaN(actual));
         } else if (Double.isNaN(actual)) {
-        	Assert.assertTrue(msg, Double.isNaN(expected));
+            Assert.assertTrue(msg, Double.isNaN(expected));
         } else if (Double.isInfinite(actual) || Double.isInfinite(expected)) {
             Assert.assertEquals(expected, actual, relativeError);
         } else if (expected == 0.0) {
@@ -145,5 +167,5 @@
             double x = Math.abs((expected - actual) / expected);
             Assert.assertEquals(msg, 0.0, x, relativeError);
         }
-	}
+    }
 }
diff --git a/src/test/org/apache/commons/math/analysis/LaguerreSolverTest.java b/src/test/org/apache/commons/math/analysis/LaguerreSolverTest.java
index 741aa97..97b7a68 100755
--- a/src/test/org/apache/commons/math/analysis/LaguerreSolverTest.java
+++ b/src/test/org/apache/commons/math/analysis/LaguerreSolverTest.java
@@ -131,17 +131,17 @@
         expected = new Complex(0.5, 0.5 * Math.sqrt(3.0));
         tolerance = Math.max(solver.getAbsoluteAccuracy(),
                     Math.abs(expected.abs() * solver.getRelativeAccuracy()));
-        assertEquals(0.0, (expected.subtract(result[2])).abs(), tolerance);
+        assertEquals(0.0, (expected.subtract(result[3])).abs(), tolerance);
 
         expected = new Complex(-1.0, 0.0);
         tolerance = Math.max(solver.getAbsoluteAccuracy(),
                     Math.abs(expected.abs() * solver.getRelativeAccuracy()));
-        assertEquals(0.0, (expected.subtract(result[3])).abs(), tolerance);
+        assertEquals(0.0, (expected.subtract(result[4])).abs(), tolerance);
 
         expected = new Complex(0.5, -0.5 * Math.sqrt(3.0));
         tolerance = Math.max(solver.getAbsoluteAccuracy(),
                     Math.abs(expected.abs() * solver.getRelativeAccuracy()));
-        assertEquals(0.0, (expected.subtract(result[4])).abs(), tolerance);
+        assertEquals(0.0, (expected.subtract(result[2])).abs(), tolerance);
     }
 
     /**
diff --git a/src/test/org/apache/commons/math/analysis/NewtonSolverTest.java b/src/test/org/apache/commons/math/analysis/NewtonSolverTest.java
index 97b1ad5..4d3def1 100644
--- a/src/test/org/apache/commons/math/analysis/NewtonSolverTest.java
+++ b/src/test/org/apache/commons/math/analysis/NewtonSolverTest.java
@@ -18,6 +18,8 @@
 package org.apache.commons.math.analysis;
 
 import org.apache.commons.math.MathException;
+import org.apache.commons.math.TestUtils;
+
 
 import junit.framework.TestCase;
 
@@ -85,4 +87,79 @@
         result = solver.solve(0.85, 5);
         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
     }
+    
+    /**
+     * Test Serialization and Recovery
+     */
+    public void testSerialization() throws MathException {
+        DifferentiableUnivariateRealFunction f = new QuinticFunction();
+        double result;
+        
+        NewtonSolver solver = new NewtonSolver(f);
+        NewtonSolver solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver);
+        
+        result = solver.solve(-0.2, 0.2);
+        assertEquals(result, 0, solver.getAbsoluteAccuracy());
+        assertEquals(solver2.solve(-0.2, 0.2), result, solver2.getAbsoluteAccuracy());
+        
+        result = solver.solve(-0.1, 0.3);
+        assertEquals(result, 0, solver.getAbsoluteAccuracy());
+        assertEquals(solver2.solve(-0.1, 0.3), result, solver2.getAbsoluteAccuracy());
+        
+        result = solver.solve(-0.3, 0.45);
+        assertEquals(result, 0, solver.getAbsoluteAccuracy());
+        assertEquals(solver2.solve(-0.3, 0.45), result, solver2.getAbsoluteAccuracy());
+        
+        result = solver.solve(0.3, 0.7);
+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
+        assertEquals(solver2.solve(0.3, 0.7), result, solver2.getAbsoluteAccuracy());
+        
+        result = solver.solve(0.2, 0.6);
+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
+        assertEquals(solver2.solve(0.2, 0.6), result, solver2.getAbsoluteAccuracy());
+        
+        result = solver.solve(0.05, 0.95);
+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
+        assertEquals(solver2.solve(0.05, 0.95), result, solver2.getAbsoluteAccuracy());
+        
+        result = solver.solve(0.85, 1.25);
+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
+        assertEquals(solver2.solve(0.85, 1.25), result, solver2.getAbsoluteAccuracy());
+        
+        result = solver.solve(0.8, 1.2);
+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
+        assertEquals(solver2.solve(0.8, 1.2), result, solver2.getAbsoluteAccuracy());
+        
+        result = solver.solve(0.85, 1.75);
+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
+        assertEquals(solver2.solve(0.85, 1.75), result, solver2.getAbsoluteAccuracy());
+        
+        result = solver.solve(0.55, 1.45);
+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
+        assertEquals(solver2.solve(0.55, 1.45), result, solver2.getAbsoluteAccuracy());
+        
+        result = solver.solve(0.85, 5);
+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
+        assertEquals(solver2.solve(0.85, 5), result, solver2.getAbsoluteAccuracy());
+        
+        /* Test Reset */
+        double newValue = 1.0e-2;
+        f = new QuinticFunction();
+        solver = new NewtonSolver(f);
+        
+        double oldValue = solver.getRelativeAccuracy();
+        solver.setRelativeAccuracy(newValue);
+        solver.resetRelativeAccuracy();
+        assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);
+        
+        solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver); 
+        
+        assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);
+        
+        solver2.setRelativeAccuracy(newValue);
+        solver2.resetRelativeAccuracy();
+        
+        assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);
+        
+    }
 }
diff --git a/src/test/org/apache/commons/math/analysis/QuinticFunction.java b/src/test/org/apache/commons/math/analysis/QuinticFunction.java
index e577d85..80919e4 100644
--- a/src/test/org/apache/commons/math/analysis/QuinticFunction.java
+++ b/src/test/org/apache/commons/math/analysis/QuinticFunction.java
@@ -26,7 +26,7 @@
  */
 public class QuinticFunction implements DifferentiableUnivariateRealFunction, Serializable {
 
-    static final long serialVersionUID = -8866263034920607152L;
+    private static final long serialVersionUID = -8866263034920607152L;
 
     /* Evaluate quintic.
      * @see org.apache.commons.math.UnivariateRealFunction#value(double)
diff --git a/src/test/org/apache/commons/math/complex/ComplexTest.java b/src/test/org/apache/commons/math/complex/ComplexTest.java
index d1ee016..0aa1f0b 100644
--- a/src/test/org/apache/commons/math/complex/ComplexTest.java
+++ b/src/test/org/apache/commons/math/complex/ComplexTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2004 The Apache Software Foundation.
+ * Copyright 2003-2005 The Apache Software Foundation.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,6 +23,16 @@
  */
 public class ComplexTest extends TestCase {
     
+    private double inf = Double.POSITIVE_INFINITY;
+    private double neginf = Double.NEGATIVE_INFINITY;
+    private double nan = Double.NaN;
+    private Complex oneInf = new Complex(1, inf);
+    private Complex oneNegInf = new Complex(1, neginf);
+    private Complex infOne = new Complex(inf, 1);
+    private Complex negInfInf = new Complex(neginf, inf);
+    private Complex negInfNegInf = new Complex(neginf, neginf);
+    private Complex oneNaN = new Complex(1, nan);
+    
     public void testConstructor() {
         Complex z = new Complex(3.0, 4.0);
         assertEquals(3.0, z.getReal(), 1.0e-5);
@@ -33,7 +43,7 @@
         Complex z = new Complex(3.0, Double.NaN);
         assertTrue(z.isNaN());
 
-        z = new Complex(Double.NaN, 4.0);
+        z = new Complex(nan, 4.0);
         assertTrue(z.isNaN());
 
         z = new Complex(3.0, 4.0);
@@ -47,6 +57,17 @@
     
     public void testAbsNaN() {
         assertTrue(Double.isNaN(Complex.NaN.abs()));
+        Complex z = new Complex(inf, nan);
+        assertTrue(Double.isNaN(z.abs()));
+    }
+    
+    public void testAbsInfinite() {
+        Complex z = new Complex(inf, 0);
+        assertEquals(inf, z.abs(), 0);
+        z = new Complex(0, neginf);
+        assertEquals(inf, z.abs(), 0);
+        z = new Complex(inf, neginf);
+        assertEquals(inf, z.abs(), 0);     
     }
     
     public void testAdd() {
@@ -61,6 +82,21 @@
         Complex x = new Complex(3.0, 4.0);
         Complex z = x.add(Complex.NaN);
         assertTrue(z.isNaN());
+        z = new Complex(1, nan);
+        Complex w = x.add(z);
+        assertEquals(w.real, 4.0, 0);
+        assertTrue(Double.isNaN(w.imaginary));
+    }
+    
+    public void testAddInfinite() {
+        Complex x = new Complex(1, 1);
+        Complex z = new Complex(inf, 0);
+        Complex w = x.add(z);
+        assertEquals(w.imaginary, 1, 0);
+        assertEquals(inf, w.real, 0);
+        
+        x = new Complex(neginf, 0);
+        assertTrue(Double.isNaN(x.add(z).real));
     }
     
     public void testConjugate() {
@@ -75,6 +111,13 @@
         assertTrue(z.isNaN());
     }
     
+    public void testConjugateInfiinite() {
+        Complex z = new Complex(0, inf);
+        assertEquals(neginf, z.conjugate().imaginary, 0);
+        z = new Complex(0, neginf);
+        assertEquals(inf, z.conjugate().imaginary, 0);
+    }
+    
     public void testDivide() {
         Complex x = new Complex(3.0, 4.0);
         Complex y = new Complex(5.0, 6.0);
@@ -83,12 +126,46 @@
         assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5);
     }
     
+    public void testDivideInfinite() {
+        Complex x = new Complex(3, 4);
+        Complex w = new Complex(neginf, inf);
+        assertTrue(x.divide(w).equals(Complex.ZERO));
+        
+        Complex z = w.divide(x);
+        assertTrue(Double.isNaN(z.real));
+        assertEquals(inf, z.imaginary, 0);
+        
+        w = new Complex(inf, inf);
+        z = w.divide(x);
+        assertTrue(Double.isNaN(z.imaginary));
+        assertEquals(inf, z.real, 0);
+        
+        w = new Complex(1, inf);
+        z = w.divide(w);
+        assertTrue(Double.isNaN(z.real));
+        assertTrue(Double.isNaN(z.imaginary));
+    }
+    
     public void testDivideNaN() {
         Complex x = new Complex(3.0, 4.0);
         Complex z = x.divide(Complex.NaN);
         assertTrue(z.isNaN());
     }
     
+    public void testDivideNaNInf() {  
+       Complex z = oneInf.divide(Complex.ONE);
+       assertTrue(Double.isNaN(z.real));
+       assertEquals(inf, z.imaginary, 0);
+       
+       z = negInfNegInf.divide(oneNaN);
+       assertTrue(Double.isNaN(z.real));
+       assertTrue(Double.isNaN(z.imaginary));
+       
+       z = negInfInf.divide(Complex.ONE);
+       assertTrue(Double.isNaN(z.real));
+       assertTrue(Double.isNaN(z.imaginary));
+    }
+    
     public void testMultiply() {
         Complex x = new Complex(3.0, 4.0);
         Complex y = new Complex(5.0, 6.0);
@@ -103,6 +180,21 @@
         assertTrue(z.isNaN());
     }
     
+    public void testMultiplyNaNInf() {
+        Complex z = new Complex(1,1);
+        Complex w = z.multiply(infOne);
+        assertEquals(w.real, inf, 0);
+        assertEquals(w.imaginary, inf, 0);
+        
+        w = oneInf.multiply(oneNegInf);
+        assertEquals(w.real, inf, 0);
+        assertTrue(Double.isNaN(w.imaginary));
+        
+        w = negInfNegInf.multiply(oneNaN);
+        assertTrue(Double.isNaN(w.real));
+        assertTrue(Double.isNaN(w.imaginary));  
+    }
+    
     public void testNegate() {
         Complex x = new Complex(3.0, 4.0);
         Complex z = x.negate();
diff --git a/src/test/org/apache/commons/math/complex/ComplexUtilsTest.java b/src/test/org/apache/commons/math/complex/ComplexUtilsTest.java
index 6116eee..a431564 100644
--- a/src/test/org/apache/commons/math/complex/ComplexUtilsTest.java
+++ b/src/test/org/apache/commons/math/complex/ComplexUtilsTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2004 The Apache Software Foundation.
+ * Copyright 2003-2005 The Apache Software Foundation.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,16 +25,65 @@
  */
 public class ComplexUtilsTest extends TestCase {
     
+    private double inf = Double.POSITIVE_INFINITY;
+    private double negInf = Double.NEGATIVE_INFINITY;
+    private double nan = Double.NaN;
+    private double pi = Math.PI;
+    
+    private Complex oneInf = new Complex(1, inf);
+    private Complex oneNegInf = new Complex(1, negInf);
+    private Complex infOne = new Complex(inf, 1);
+    private Complex negInfOne = new Complex(negInf, 1);
+    private Complex negInfInf = new Complex(negInf, inf);
+    private Complex infNegInf = new Complex(inf, negInf);
+    private Complex infInf = new Complex(inf, inf);
+    private Complex negInfNegInf = new Complex(negInf, negInf);
+    private Complex oneNaN = new Complex(1, nan);
+    private Complex infNaN = new Complex(inf, nan);
+    private Complex negInfNaN = new Complex(negInf, nan);
+    private Complex nanInf = new Complex(nan, inf);
+    private Complex nanNegInf = new Complex(nan, negInf);
+    private Complex zeroNaN = new Complex(0, nan);
+    private Complex nanZero = new Complex(nan, 0);
+    private Complex infZero = new Complex(inf, 0);
+    private Complex zeroInf = new Complex(0, inf);
+    private Complex zeroNegInf = new Complex(0, negInf);
+    private Complex negInfZero = new Complex(negInf, 0);
+    
+    private ComplexFormat fmt = new ComplexFormat();
+    
     public void testAcos() {
         Complex z = new Complex(3, 4);
         Complex expected = new Complex(0.936812, -2.30551);
         TestUtils.assertEquals(expected, ComplexUtils.acos(z), 1.0e-5);
+        TestUtils.assertEquals(new Complex(Math.acos(0), 0), 
+                ComplexUtils.acos(Complex.ZERO), 1.0e-12);
+    }
+    
+    public void testAcosInf() {
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneNegInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infOne));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfOne));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infNegInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfNegInf));
     }
     
     public void testAcosNaN() {
         assertTrue(ComplexUtils.acos(Complex.NaN).isNaN());
     }
     
+    public void testAcosNull() {
+        try {
+            Complex z = ComplexUtils.acos(null); 
+            fail("Expecting NullPointerException");
+        } catch (NullPointerException ex) {
+            // expected
+        }
+    }
+    
     public void testAsin() {
         Complex z = new Complex(3, 4);
         Complex expected = new Complex(0.633984, 2.30551);
@@ -45,14 +94,55 @@
         assertTrue(ComplexUtils.asin(Complex.NaN).isNaN());
     }
     
+    public void testAsinInf() {
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneNegInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infOne));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfOne));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infNegInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfNegInf));
+    }
+    
+    public void testAsinNull() {
+        try {
+            Complex z = ComplexUtils.asin(null); 
+            fail("Expecting NullPointerException");
+        } catch (NullPointerException ex) {
+            // expected
+        }
+    }
+    
     public void testAtan() {
         Complex z = new Complex(3, 4);
         Complex expected = new Complex(1.44831, 0.158997);
         TestUtils.assertEquals(expected, ComplexUtils.atan(z), 1.0e-5);
     }
     
+    public void testAtanInf() {
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneNegInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infOne));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfOne));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infNegInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfNegInf));
+    } 
+    
     public void testAtanNaN() {
         assertTrue(ComplexUtils.atan(Complex.NaN).isNaN());
+        assertTrue(ComplexUtils.atan(Complex.I).isNaN());
+    }
+    
+    public void testAtanNull() {
+        try {
+            Complex z = ComplexUtils.atan(null); 
+            fail("Expecting NullPointerException");
+        } catch (NullPointerException ex) {
+            // expected
+        }
     }
     
     public void testCos() {
@@ -61,6 +151,30 @@
         TestUtils.assertEquals(expected, ComplexUtils.cos(z), 1.0e-5);
     }
     
+    public void testCosNaN() {
+        assertTrue(ComplexUtils.cos(Complex.NaN).isNaN());
+    }
+    
+    public void testCosInf() {
+        TestUtils.assertSame(infNegInf, ComplexUtils.cos(oneInf));
+        TestUtils.assertSame(infInf, ComplexUtils.cos(oneNegInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infOne));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfOne));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infNegInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfNegInf));
+    } 
+    
+    public void testCosNull() {
+        try {
+            Complex z = ComplexUtils.cos(null); 
+            fail("Expecting NullPointerException");
+        } catch (NullPointerException ex) {
+            // expected
+        }
+    }
+    
     public void testCosh() {
         Complex z = new Complex(3, 4);
         Complex expected = new Complex(-6.58066, -7.58155);
@@ -71,20 +185,61 @@
         assertTrue(ComplexUtils.cosh(Complex.NaN).isNaN());
     }
     
-    public void testCosNaN() {
-        assertTrue(ComplexUtils.cos(Complex.NaN).isNaN());
+    public void testCoshInf() {  
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneNegInf));
+        TestUtils.assertSame(infInf, ComplexUtils.cosh(infOne));
+        TestUtils.assertSame(infNegInf, ComplexUtils.cosh(negInfOne));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infNegInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfNegInf));
+    } 
+    
+    public void testCoshNull() {
+        try {
+            Complex z = ComplexUtils.cosh(null); 
+            fail("Expecting NullPointerException");
+        } catch (NullPointerException ex) {
+            // expected
+        }
     }
     
     public void testExp() {
         Complex z = new Complex(3, 4);
         Complex expected = new Complex(-13.12878, -15.20078);
         TestUtils.assertEquals(expected, ComplexUtils.exp(z), 1.0e-5);
+        TestUtils.assertEquals(Complex.ONE, 
+                ComplexUtils.exp(Complex.ZERO), 10e-12);
+        Complex iPi = Complex.I.multiply(new Complex(pi,0));
+        TestUtils.assertEquals(Complex.ONE.negate(), 
+                ComplexUtils.exp(iPi), 10e-12);
     }
     
     public void testExpNaN() {
         assertTrue(ComplexUtils.exp(Complex.NaN).isNaN());
     }
     
+    public void testExpInf() {
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneNegInf));
+        TestUtils.assertSame(infInf, ComplexUtils.exp(infOne));
+        TestUtils.assertSame(Complex.ZERO, ComplexUtils.exp(negInfOne));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infNegInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfNegInf));
+    }
+    
+    public void testExpNull() {
+        try {
+            Complex z = ComplexUtils.exp(null); 
+            fail("Expecting NullPointerException");
+        } catch (NullPointerException ex) {
+            // expected
+        }
+    }
+    
     public void testLog() {
         Complex z = new Complex(3, 4);
         Complex expected = new Complex(1.60944, 0.927295);
@@ -95,6 +250,101 @@
         assertTrue(ComplexUtils.log(Complex.NaN).isNaN());
     }
     
+    public void testLogInf() {
+        TestUtils.assertEquals(new Complex(inf, pi / 2),
+                ComplexUtils.log(oneInf), 10e-12);
+        TestUtils.assertEquals(new Complex(inf, -pi / 2),
+                ComplexUtils.log(oneNegInf), 10e-12);
+        TestUtils.assertEquals(infZero, ComplexUtils.log(infOne), 10e-12);
+        TestUtils.assertEquals(new Complex(inf, pi),
+                ComplexUtils.log(negInfOne), 10e-12);
+        TestUtils.assertEquals(new Complex(inf, pi / 4),
+                ComplexUtils.log(infInf), 10e-12);
+        TestUtils.assertEquals(new Complex(inf, -pi / 4),
+                ComplexUtils.log(infNegInf), 10e-12);
+        TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),
+                ComplexUtils.log(negInfInf), 10e-12);
+        TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),
+                ComplexUtils.log(negInfNegInf), 10e-12);
+    }
+    
+    public void testLogZero() {
+        TestUtils.assertSame(negInfZero, ComplexUtils.log(Complex.ZERO));
+    }
+    
+    public void testlogNull() {
+        try {
+            Complex z = ComplexUtils.log(null); 
+            fail("Expecting NullPointerException");
+        } catch (NullPointerException ex) {
+            // expected
+        }
+    }
+    
+    public void testPolar2Complex() {
+        TestUtils.assertEquals(Complex.ONE, 
+                ComplexUtils.polar2Complex(1, 0), 10e-12);
+        TestUtils.assertEquals(Complex.ZERO, 
+                ComplexUtils.polar2Complex(0, 1), 10e-12);
+        TestUtils.assertEquals(Complex.ZERO, 
+                ComplexUtils.polar2Complex(0, -1), 10e-12);
+        TestUtils.assertEquals(Complex.I, 
+                ComplexUtils.polar2Complex(1, pi/2), 10e-12);
+        TestUtils.assertEquals(Complex.I.negate(), 
+                ComplexUtils.polar2Complex(1, -pi/2), 10e-12);
+        double r = 0;
+        for (int i = 0; i < 5; i++) {
+          r += i;
+          double theta = 0;
+          for (int j =0; j < 20; j++) {
+              theta += pi / 6;
+              TestUtils.assertEquals(altPolar(r, theta), 
+                      ComplexUtils.polar2Complex(r, theta), 10e-12);
+          }
+          theta = -2 * pi;
+          for (int j =0; j < 20; j++) {
+              theta -= pi / 6;
+              TestUtils.assertEquals(altPolar(r, theta), 
+                      ComplexUtils.polar2Complex(r, theta), 10e-12);
+          }
+        }   
+    }
+    
+    protected Complex altPolar(double r, double theta) {
+        return ComplexUtils.exp(Complex.I.multiply
+                (new Complex(theta, 0))).multiply(new Complex(r, 0));
+    }
+    
+    public void testPolar2ComplexIllegalModulus() {
+        try {
+            Complex z = ComplexUtils.polar2Complex(-1, 0);
+            fail("Expecting IllegalArgumentException");
+        } catch (IllegalArgumentException ex) {
+            // expected
+        }       
+    }
+    
+    public void testPolar2ComplexNaN() {
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, 1));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, nan));
+        TestUtils.assertSame(Complex.NaN, 
+                ComplexUtils.polar2Complex(nan, nan));     
+    }
+    
+    public void testPolar2ComplexInf() {
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, inf));
+        TestUtils.assertSame(Complex.NaN,
+                ComplexUtils.polar2Complex(1, negInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(inf, inf));
+        TestUtils.assertSame(Complex.NaN,
+                ComplexUtils.polar2Complex(inf, negInf));
+        TestUtils.assertSame(infInf, ComplexUtils.polar2Complex(inf, pi/4));
+        TestUtils.assertSame(infNaN, ComplexUtils.polar2Complex(inf, 0));
+        TestUtils.assertSame(infNegInf, ComplexUtils.polar2Complex(inf, -pi/4));
+        TestUtils.assertSame(negInfInf, ComplexUtils.polar2Complex(inf, 3*pi/4));
+        TestUtils.assertSame(negInfNegInf, ComplexUtils.polar2Complex(inf, 5*pi/4));
+    }
+    
     public void testPow() {
         Complex x = new Complex(3, 4);
         Complex y = new Complex(5, 6);
@@ -112,12 +362,91 @@
         assertTrue(ComplexUtils.pow(x, Complex.NaN).isNaN());
     }
     
+   public void testPowInf() {
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneInf));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneNegInf));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infOne));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infInf));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infNegInf));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfInf));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfNegInf));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infOne, Complex.ONE));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfOne, Complex.ONE));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, Complex.ONE));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, Complex.ONE));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfInf, Complex.ONE));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, Complex.ONE));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infNegInf));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, negInfNegInf));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infInf));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infNegInf));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, negInfNegInf));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infInf));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infNegInf));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, negInfNegInf));
+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infInf));   
+   }
+   
+   public void testPowZero() {
+       TestUtils.assertSame(Complex.NaN, 
+               ComplexUtils.pow(Complex.ZERO, Complex.ONE));
+       TestUtils.assertSame(Complex.NaN, 
+               ComplexUtils.pow(Complex.ZERO, Complex.ZERO));
+       TestUtils.assertSame(Complex.NaN, 
+               ComplexUtils.pow(Complex.ZERO, Complex.I));
+       TestUtils.assertEquals(Complex.ONE,
+               ComplexUtils.pow(Complex.ONE, Complex.ZERO), 10e-12);
+       TestUtils.assertEquals(Complex.ONE,
+               ComplexUtils.pow(Complex.I, Complex.ZERO), 10e-12);
+       TestUtils.assertEquals(Complex.ONE,
+               ComplexUtils.pow(new Complex(-1, 3), Complex.ZERO), 10e-12);
+   }
+    
+    public void testpowNull() {
+        try {
+            Complex z = ComplexUtils.pow(null, Complex.ONE); 
+            fail("Expecting NullPointerException");
+        } catch (NullPointerException ex) {
+            // expected
+        }
+        try {
+            Complex z = ComplexUtils.pow(Complex.ONE, null); 
+            fail("Expecting NullPointerException");
+        } catch (NullPointerException ex) {
+            // expected
+        }
+    }
+    
     public void testSin() {
         Complex z = new Complex(3, 4);
         Complex expected = new Complex(3.853738, -27.01681);
         TestUtils.assertEquals(expected, ComplexUtils.sin(z), 1.0e-5);
     }
     
+    public void testSinInf() {
+        TestUtils.assertSame(infInf, ComplexUtils.sin(oneInf));
+        TestUtils.assertSame(infNegInf, ComplexUtils.sin(oneNegInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infOne));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfOne));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infNegInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfNegInf));
+    }
+    
+    public void testSinNaN() {
+        assertTrue(ComplexUtils.sin(Complex.NaN).isNaN());
+    }
+    
+    public void testSinNull() {
+        try {
+            Complex z = ComplexUtils.sin(null); 
+            fail("Expecting NullPointerException");
+        } catch (NullPointerException ex) {
+            // expected
+        }
+    }
+     
     public void testSinh() {
         Complex z = new Complex(3, 4);
         Complex expected = new Complex(-6.54812, -7.61923);
@@ -128,8 +457,24 @@
         assertTrue(ComplexUtils.sinh(Complex.NaN).isNaN());
     }
     
-    public void testSinNaN() {
-        assertTrue(ComplexUtils.sin(Complex.NaN).isNaN());
+    public void testSinhInf() {
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneNegInf));
+        TestUtils.assertSame(infInf, ComplexUtils.sinh(infOne));
+        TestUtils.assertSame(negInfInf, ComplexUtils.sinh(negInfOne));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infNegInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfNegInf));
+    }
+    
+    public void testsinhNull() {
+        try {
+            Complex z = ComplexUtils.sinh(null); 
+            fail("Expecting NullPointerException");
+        } catch (NullPointerException ex) {
+            // expected
+        }
     }
     
     public void testSqrtRealPositive() {
@@ -161,6 +506,44 @@
         Complex expected = new Complex(1.0, -2.0);
         TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
     }
+    
+    public void testSqrtPolar() {
+        double r = 1;
+        for (int i = 0; i < 5; i++) {
+            r += i;
+            double theta = 0;
+            for (int j =0; j < 11; j++) {
+                theta += pi /12;
+                Complex z = ComplexUtils.polar2Complex(r, theta);
+                Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);
+                TestUtils.assertEquals(sqrtz, ComplexUtils.sqrt(z), 10e-12);
+            }
+        }       
+    }
+    
+    public void testSqrtNaN() {
+        assertTrue(ComplexUtils.sqrt(Complex.NaN).isNaN());
+    }
+      
+    public void testSqrtInf() {
+        TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneInf));
+        TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneNegInf));
+        TestUtils.assertSame(infZero, ComplexUtils.sqrt(infOne));
+        TestUtils.assertSame(zeroInf, ComplexUtils.sqrt(negInfOne));
+        TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infInf));
+        TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infNegInf));
+        TestUtils.assertSame(nanInf, ComplexUtils.sqrt(negInfInf));
+        TestUtils.assertSame(nanNegInf, ComplexUtils.sqrt(negInfNegInf));
+    }
+    
+    public void testSqrtNull() {
+        try {
+            Complex z = ComplexUtils.sqrt(null); 
+            fail("Expecting NullPointerException");
+        } catch (NullPointerException ex) {
+            // expected
+        }
+    }
 
     public void testSqrt1z() {
         Complex z = new Complex(3, 4);
@@ -172,8 +555,13 @@
         assertTrue(ComplexUtils.sqrt1z(Complex.NaN).isNaN());
     }
     
-    public void testSqrtNaN() {
-        assertTrue(ComplexUtils.sqrt(Complex.NaN).isNaN());
+    public void testSqrt1zNull() {
+        try {
+            Complex z = ComplexUtils.sqrt1z(null); 
+            fail("Expecting NullPointerException");
+        } catch (NullPointerException ex) {
+            // expected
+        }
     }
     
     public void testTan() {
@@ -182,6 +570,35 @@
         TestUtils.assertEquals(expected, ComplexUtils.tan(z), 1.0e-5);
     }
     
+    public void testTanNaN() {
+        assertTrue(ComplexUtils.tan(Complex.NaN).isNaN());
+    }
+    
+    public void testTanInf() {
+        TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneInf));
+        TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneNegInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infOne));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfOne));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infNegInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfNegInf));
+    }
+    
+   public void testTanCritical() {
+        TestUtils.assertSame(infNaN, ComplexUtils.tan(new Complex(pi/2, 0)));
+        TestUtils.assertSame(negInfNaN, ComplexUtils.tan(new Complex(-pi/2, 0)));
+    }
+    
+    public void testTanNull() {
+        try {
+            Complex z = ComplexUtils.tan(null); 
+            fail("Expecting NullPointerException");
+        } catch (NullPointerException ex) {
+            // expected
+        }
+    }
+    
     public void testTanh() {
         Complex z = new Complex(3, 4);
         Complex expected = new Complex(1.00071, 0.00490826);
@@ -192,7 +609,27 @@
         assertTrue(ComplexUtils.tanh(Complex.NaN).isNaN());
     }
     
-    public void testTanNaN() {
-        assertTrue(ComplexUtils.tan(Complex.NaN).isNaN());
+    public void testTanhInf() {
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneNegInf));
+        TestUtils.assertSame(nanZero, ComplexUtils.tanh(infOne));
+        TestUtils.assertSame(nanZero, ComplexUtils.tanh(negInfOne));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infNegInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfInf));
+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfNegInf));
+    }
+    
+    public void testTanhCritical() {
+        TestUtils.assertSame(nanInf, ComplexUtils.tanh(new Complex(0, pi/2)));
+    }
+    
+    public void testTanhNull() {
+        try {
+            Complex z = ComplexUtils.tanh(null); 
+            fail("Expecting NullPointerException");
+        } catch (NullPointerException ex) {
+            // expected
+        }
     }
 }
diff --git a/src/test/org/apache/commons/math/distribution/HypergeometricDistributionTest.java b/src/test/org/apache/commons/math/distribution/HypergeometricDistributionTest.java
index 3ada104..5ef6f8d 100644
--- a/src/test/org/apache/commons/math/distribution/HypergeometricDistributionTest.java
+++ b/src/test/org/apache/commons/math/distribution/HypergeometricDistributionTest.java
@@ -132,17 +132,17 @@
     }
     
     public void testLargeValues() {
-    	int populationSize = 3456;
-    	int sampleSize = 789;
-    	int numberOfSucceses = 101;
-    	double[][] data = {
-    	    {0.0, 2.75646034603961e-12, 2.75646034603961e-12, 1.0},
-    	    {1.0, 8.55705370142386e-11, 8.83269973602783e-11, 0.999999999997244},
-    	    {2.0, 1.31288129219665e-9, 1.40120828955693e-9, 0.999999999911673},
-    	    {3.0, 1.32724172984193e-8, 1.46736255879763e-8, 0.999999998598792},
-    	    {4.0, 9.94501711734089e-8, 1.14123796761385e-7, 0.999999985326375},
-    	    {5.0, 5.89080768883643e-7, 7.03204565645028e-7, 0.999999885876203},
-        	{20.0, 0.0760051397707708, 0.27349758476299, 0.802507555007781}, 
+        int populationSize = 3456;
+        int sampleSize = 789;
+        int numberOfSucceses = 101;
+        double[][] data = {
+            {0.0, 2.75646034603961e-12, 2.75646034603961e-12, 1.0},
+            {1.0, 8.55705370142386e-11, 8.83269973602783e-11, 0.999999999997244},
+            {2.0, 1.31288129219665e-9, 1.40120828955693e-9, 0.999999999911673},
+            {3.0, 1.32724172984193e-8, 1.46736255879763e-8, 0.999999998598792},
+            {4.0, 9.94501711734089e-8, 1.14123796761385e-7, 0.999999985326375},
+            {5.0, 5.89080768883643e-7, 7.03204565645028e-7, 0.999999885876203},
+            {20.0, 0.0760051397707708, 0.27349758476299, 0.802507555007781}, 
             {21.0, 0.087144222047629, 0.360641806810619, 0.72650241523701}, 
             {22.0, 0.0940378846881819, 0.454679691498801, 0.639358193189381}, 
             {23.0, 0.0956897500614809, 0.550369441560282, 0.545320308501199}, 
@@ -154,40 +154,40 @@
             {99.0, 6.63604297068222e-63, 1.0, 6.670480942963e-63}, 
             {100.0, 3.43501099007557e-65, 1.0, 3.4437972280786e-65},
             {101.0, 8.78623800302957e-68, 1.0, 8.78623800302957e-68},
-    	};
+        };
         
-    	testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);
+        testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);
     }
 
-	private void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) {
-		HypergeometricDistributionImpl dist = new HypergeometricDistributionImpl(populationSize, numberOfSucceses, sampleSize);
-    	for (int i = 0; i < data.length; ++i) {
-    		int x = (int)data[i][0];
-    		double pdf = data[i][1];
-    		double actualPdf = dist.probability(x);
-    		TestUtils.assertRelativelyEquals(pdf, actualPdf, 1.0e-9);
+    private void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) {
+        HypergeometricDistributionImpl dist = new HypergeometricDistributionImpl(populationSize, numberOfSucceses, sampleSize);
+        for (int i = 0; i < data.length; ++i) {
+            int x = (int)data[i][0];
+            double pdf = data[i][1];
+            double actualPdf = dist.probability(x);
+            TestUtils.assertRelativelyEquals(pdf, actualPdf, 1.0e-9);
 
-    		double cdf = data[i][2];
-    		double actualCdf = dist.cumulativeProbability(x);
-			TestUtils.assertRelativelyEquals(cdf, actualCdf, 1.0e-9);
+            double cdf = data[i][2];
+            double actualCdf = dist.cumulativeProbability(x);
+            TestUtils.assertRelativelyEquals(cdf, actualCdf, 1.0e-9);
 
-			double cdf1 = data[i][3];
-    		double actualCdf1 = dist.upperCumulativeProbability(x);
-			TestUtils.assertRelativelyEquals(cdf1, actualCdf1, 1.0e-9);
-    	}
-	}
+            double cdf1 = data[i][3];
+            double actualCdf1 = dist.upperCumulativeProbability(x);
+            TestUtils.assertRelativelyEquals(cdf1, actualCdf1, 1.0e-9);
+        }
+    }
     
     public void testMoreLargeValues() {
-    	int populationSize = 26896;
-    	int sampleSize = 895;
-    	int numberOfSucceses = 55;
-    	double[][] data = {
-    	    {0.0, 0.155168304750504, 0.155168304750504, 1.0}, 
+        int populationSize = 26896;
+        int sampleSize = 895;
+        int numberOfSucceses = 55;
+        double[][] data = {
+            {0.0, 0.155168304750504, 0.155168304750504, 1.0}, 
             {1.0, 0.29437545000746, 0.449543754757964, 0.844831695249496}, 
-    	    {2.0, 0.273841321577003, 0.723385076334967, 0.550456245242036}, 
-    	    {3.0, 0.166488572570786, 0.889873648905753, 0.276614923665033}, 
-    	    {4.0, 0.0743969744713231, 0.964270623377076, 0.110126351094247}, 
-    	    {5.0, 0.0260542785784855, 0.990324901955562, 0.0357293766229237}, 
+            {2.0, 0.273841321577003, 0.723385076334967, 0.550456245242036}, 
+            {3.0, 0.166488572570786, 0.889873648905753, 0.276614923665033}, 
+            {4.0, 0.0743969744713231, 0.964270623377076, 0.110126351094247}, 
+            {5.0, 0.0260542785784855, 0.990324901955562, 0.0357293766229237}, 
             {20.0, 3.57101101678792e-16, 1.0, 3.78252101622096e-16}, 
             {21.0, 2.00551638598312e-17, 1.0, 2.11509999433041e-17}, 
             {22.0, 1.04317070180562e-18, 1.0, 1.09583608347287e-18}, 
@@ -200,7 +200,7 @@
             {53.0, 1.43662126065532e-76, 1.0, 1.43834540093295e-76}, 
             {54.0, 1.72312692517348e-79, 1.0, 1.7241402776278e-79}, 
             {55.0, 1.01335245432581e-82, 1.0, 1.01335245432581e-82},        
-    	};
-    	testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);
+        };
+        testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);
     }
 }
diff --git a/src/test/org/apache/commons/math/distribution/PoissonDistributionTest.java b/src/test/org/apache/commons/math/distribution/PoissonDistributionTest.java
index 8cf79ae..88628a1 100644
--- a/src/test/org/apache/commons/math/distribution/PoissonDistributionTest.java
+++ b/src/test/org/apache/commons/math/distribution/PoissonDistributionTest.java
@@ -137,44 +137,44 @@
     }
     
     public void testLargeMeanCumulativeProbability() {
-    	PoissonDistribution dist = DistributionFactory.newInstance().createPoissonDistribution(1.0);
-    	double mean = 1.0;
-    	while (mean <= 10000000.0) {
-    		dist.setMean(mean);
-    		
-    		double x = mean * 2.0;
-    		double dx = x / 10.0;
-    		while (x >= 0) {
-    			try {
-    				dist.cumulativeProbability(x);
-    			} catch (MathException ex) {
-    				fail("mean of " + mean + " and x of " + x + " caused " + ex.getMessage());
-    			}
-				x -= dx;
-    		}
-    		
-    		mean *= 10.0;
-    	}
+        PoissonDistribution dist = DistributionFactory.newInstance().createPoissonDistribution(1.0);
+        double mean = 1.0;
+        while (mean <= 10000000.0) {
+            dist.setMean(mean);
+            
+            double x = mean * 2.0;
+            double dx = x / 10.0;
+            while (x >= 0) {
+                try {
+                    dist.cumulativeProbability(x);
+                } catch (MathException ex) {
+                    fail("mean of " + mean + " and x of " + x + " caused " + ex.getMessage());
+                }
+                x -= dx;
+            }
+            
+            mean *= 10.0;
+        }
     }
     
     public void testLargeMeanInverseCumulativeProbability() {
-    	PoissonDistribution dist = DistributionFactory.newInstance().createPoissonDistribution(1.0);
-    	double mean = 1.0;
-    	while (mean <= 10000000.0) {
-    		dist.setMean(mean);
-    		
-    		double p = 0.1;
-    		double dp = p;
-    		while (p < 1.0) {
-    			try {
-    				dist.inverseCumulativeProbability(p);
-    			} catch (MathException ex) {
-    				fail("mean of " + mean + " and p of " + p + " caused " + ex.getMessage());
-    			}
-				p += dp;
-    		}
-    		
-    		mean *= 10.0;
-    	}
+        PoissonDistribution dist = DistributionFactory.newInstance().createPoissonDistribution(1.0);
+        double mean = 1.0;
+        while (mean <= 10000000.0) {
+            dist.setMean(mean);
+            
+            double p = 0.1;
+            double dp = p;
+            while (p < 1.0) {
+                try {
+                    dist.inverseCumulativeProbability(p);
+                } catch (MathException ex) {
+                    fail("mean of " + mean + " and p of " + p + " caused " + ex.getMessage());
+                }
+                p += dp;
+            }
+            
+            mean *= 10.0;
+        }
     }
 }
\ No newline at end of file
diff --git a/src/test/org/apache/commons/math/random/EmpiricalDistributionTest.java b/src/test/org/apache/commons/math/random/EmpiricalDistributionTest.java
index 8eae516..c768776 100644
--- a/src/test/org/apache/commons/math/random/EmpiricalDistributionTest.java
+++ b/src/test/org/apache/commons/math/random/EmpiricalDistributionTest.java
@@ -115,6 +115,11 @@
         assertEquals
           (empiricalDistribution2.getSampleStats().getStandardDeviation(),
                 1.0173699343977738,10E-7);
+        
+        double[] bounds = empiricalDistribution2.getUpperBounds();
+        assertEquals(bounds.length, 100);
+        assertEquals(bounds[99], 1.0, 10e-12);
+          
     }
    
     /** 
diff --git a/src/test/org/apache/commons/math/random/RandomDataTest.java b/src/test/org/apache/commons/math/random/RandomDataTest.java
index 0a775e8..e0aa4f7 100644
--- a/src/test/org/apache/commons/math/random/RandomDataTest.java
+++ b/src/test/org/apache/commons/math/random/RandomDataTest.java
@@ -420,13 +420,19 @@
         
         /* remove this test back soon,
          * since it takes about 4 seconds */
-         
-        randomData.setSecureAlgorithm("SHA1PRNG","SUN");
+
+        try {
+            randomData.setSecureAlgorithm("SHA1PRNG","SUN");
+        } catch (NoSuchProviderException ex) {
+            ;
+        }
         assertTrue("different seeds",
             !hex.equals(randomData.nextSecureHexString(40)));
         try {
             randomData.setSecureAlgorithm("NOSUCHTHING","SUN");
             fail("expecting NoSuchAlgorithmException");
+        } catch (NoSuchProviderException ex) {
+            ;
         } catch (NoSuchAlgorithmException ex) {
             ;
         }
diff --git a/src/test/org/apache/commons/math/stat/StatUtilsTest.java b/src/test/org/apache/commons/math/stat/StatUtilsTest.java
index a9cffd8..63471dc 100644
--- a/src/test/org/apache/commons/math/stat/StatUtilsTest.java
+++ b/src/test/org/apache/commons/math/stat/StatUtilsTest.java
@@ -411,7 +411,7 @@
             // expected
         }
         try {
-        	double[] single = {1.0};
+            double[] single = {1.0};
             StatUtils.varianceDifference(single, single, meanDifference);
             fail("Expecting IllegalArgumentException");
         } catch (IllegalArgumentException ex) {
diff --git a/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java b/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java
index 6f1736d..18d03e6 100644
--- a/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java
+++ b/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java
@@ -31,7 +31,7 @@
 public class ListUnivariateImpl extends DescriptiveStatistics implements Serializable {
 
     /** Serializable version identifier */
-    static final long serialVersionUID = -8837442489133392138L;
+    private static final long serialVersionUID = -8837442489133392138L;
     
     /**
      * Holds a reference to a list - GENERICs are going to make
diff --git a/src/test/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java b/src/test/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java
index 59e8364..4bfeed0 100644
--- a/src/test/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java
+++ b/src/test/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java
@@ -75,16 +75,16 @@
         
         // invalid percentiles
         try {
-        	p.evaluate(d, 0, d.length, -1.0);
-        	fail();
+            p.evaluate(d, 0, d.length, -1.0);
+            fail();
         } catch (IllegalArgumentException ex) {
-        	// success
+            // success
         }
         try {
-        	p.evaluate(d, 0, d.length, 101.0);
-        	fail();
+            p.evaluate(d, 0, d.length, 101.0);
+            fail();
         } catch (IllegalArgumentException ex) {
-        	// success
+            // success
         }
     }
     
diff --git a/xdocs/changes.xml b/xdocs/changes.xml
index 200ac15..e02e986 100644
--- a/xdocs/changes.xml
+++ b/xdocs/changes.xml
@@ -38,7 +38,7 @@
 Commons Math Release Notes</title>
   </properties>
   <body>
-    <release version="1.2" date="TBD">
+    <release version="1.2-SNAPSHOT" date="TBD">
     </release>
     <release version="1.1" date="2005-12-17"  
  description="This is a maintenance release containing bug fixes and enhancements.
