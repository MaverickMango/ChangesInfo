{
  "logger": {
    "currentLogLevel": 20,
    "name": "root.bean.benchmarks.Defects4JBug"
  },
  "d4jCmd": "/home/liumengjiao/Desktop/defects4j/framework/bin/defects4j",
  "dataDir": "data/changesInfo/",
  "timeoutSecond": 300,
  "proj": "Lang",
  "id": "43",
  "workingDir": "../bugs/Lang_43_buggy",
  "inducingCommit": "695289c466e51ff7f211867dccbc755fd515fc43",
  "originalCommit": "b737ab7625da23aebe14846eacb2b3ec0e8da1c3",
  "bug_name": "Lang_43",
  "derive": "defects4j",
  "original_fixing_commit": "eb3e2ae1f3734986a9f0225c661888baac3cb13b",
  "buildFiles_changed": false,
  "inducing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java",
        "src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "eatFormat",
            "applyPattern",
            "getMetaFormat",
            "next",
            "ExtendedMessageFormat",
            "appendQuotedString",
            "createDefaultMetaFormat",
            "stripFormats",
            "setMetaFormat",
            "applyPatternPre",
            "applyPatternPost",
            "parseFormats",
            "toPattern",
            "seekNonWs",
            "insertFormats",
            "readArgumentIndex",
            "createDefaultMetaFormat",
            "getQuotedString",
            "ExtendedMessageFormat"
          ],
          "num": 19
        },
        {
          "qualified_names": [
            "ExtendedMessageFormat",
            "setFormatByArgumentIndex",
            "toPattern",
            "ExtendedMessageFormat",
            "insertFormats",
            "getQuotedString",
            "containsElements",
            "ExtendedMessageFormat",
            "parseFormatDescription",
            "setFormat",
            "setFormatsByArgumentIndex",
            "getFormat",
            "seekNonWs",
            "ExtendedMessageFormat",
            "applyPattern",
            "setFormats",
            "appendQuotedString",
            "readArgumentIndex",
            "next"
          ],
          "num": 19
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "25",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "37",
            "38",
            "39",
            "40",
            "41",
            "50",
            "51",
            "52",
            "53",
            "54",
            "55",
            "56",
            "57",
            "58",
            "59",
            "61",
            "62",
            "63",
            "64",
            "65",
            "66",
            "67",
            "68",
            "69",
            "70",
            "71",
            "72",
            "73",
            "74",
            "75",
            "76",
            "77",
            "78",
            "79",
            "80",
            "81",
            "82",
            "83",
            "84",
            "85",
            "86",
            "87",
            "88",
            "89",
            "90",
            "91",
            "92",
            "93",
            "94",
            "95",
            "96",
            "97",
            "98",
            "99",
            "100",
            "101",
            "102",
            "103",
            "104",
            "105",
            "106",
            "107",
            "108",
            "109",
            "110",
            "111",
            "112",
            "113",
            "114",
            "115",
            "116",
            "117",
            "118",
            "119",
            "120",
            "121",
            "122",
            "123",
            "124",
            "125",
            "126",
            "127",
            "128",
            "129",
            "130",
            "131",
            "132",
            "133",
            "134",
            "135",
            "136",
            "137",
            "138",
            "139",
            "140",
            "141",
            "142",
            "143",
            "144",
            "145",
            "146",
            "147",
            "148",
            "149",
            "150",
            "151",
            "152",
            "153",
            "154",
            "155",
            "156",
            "157",
            "158",
            "159",
            "160",
            "161",
            "162",
            "163",
            "164",
            "165",
            "166",
            "167",
            "168",
            "169",
            "170",
            "171",
            "172",
            "173",
            "174",
            "175",
            "176",
            "177",
            "178",
            "179",
            "180",
            "181",
            "182",
            "183",
            "184",
            "185",
            "186",
            "187",
            "188",
            "189",
            "190",
            "191",
            "192",
            "193",
            "194",
            "195",
            "196",
            "197",
            "198",
            "199",
            "200",
            "201",
            "202",
            "203",
            "204",
            "205",
            "206",
            "207",
            "208",
            "209",
            "210",
            "211",
            "212",
            "213",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "220",
            "221",
            "222",
            "223",
            "224",
            "225",
            "226",
            "227",
            "228",
            "229",
            "230",
            "231",
            "232",
            "233",
            "234",
            "235",
            "236",
            "237",
            "238",
            "239",
            "240",
            "241",
            "242",
            "243",
            "244",
            "245",
            "246",
            "247",
            "248",
            "249",
            "250",
            "251",
            "252",
            "253",
            "254",
            "255",
            "256",
            "257",
            "258",
            "259",
            "260",
            "261",
            "262",
            "263",
            "264",
            "265",
            "266",
            "267",
            "268",
            "269",
            "270",
            "271",
            "272",
            "273",
            "274",
            "275",
            "276",
            "277",
            "278",
            "279",
            "280",
            "281",
            "282",
            "283",
            "284",
            "285",
            "286",
            "287",
            "288",
            "289",
            "290",
            "291",
            "292",
            "293",
            "294",
            "295",
            "296",
            "297",
            "298",
            "299",
            "300",
            "301",
            "302",
            "303",
            "304",
            "305",
            "306",
            "307",
            "308",
            "309",
            "310",
            "311",
            "312",
            "313",
            "314",
            "315",
            "316",
            "317",
            "318",
            "319",
            "320",
            "321",
            "322",
            "323",
            "324",
            "325",
            "326",
            "327",
            "328",
            "329",
            "330",
            "331",
            "337",
            "338",
            "339",
            "341",
            "342",
            "350",
            "351",
            "352",
            "354",
            "355",
            "356",
            "357",
            "358",
            "359",
            "360",
            "361",
            "362",
            "363",
            "364",
            "365",
            "375",
            "378",
            "379",
            "380",
            "381",
            "382",
            "386",
            "387",
            "388",
            "389",
            "391",
            "392",
            "396",
            "397",
            "398",
            "399",
            "401",
            "402",
            "406",
            "407",
            "408",
            "409",
            "411",
            "412",
            "416",
            "417",
            "418",
            "420",
            "421",
            "425",
            "426",
            "428",
            "430",
            "431",
            "432"
          ],
          "num": 349
        },
        {
          "qualified_names": [
            "23",
            "24",
            "26",
            "32",
            "33",
            "34",
            "35",
            "44",
            "45",
            "46",
            "47",
            "48",
            "49",
            "51",
            "52",
            "58",
            "60",
            "61",
            "69",
            "71",
            "72",
            "73",
            "74",
            "75",
            "76",
            "77",
            "78",
            "79",
            "80",
            "81",
            "82",
            "83",
            "84",
            "85",
            "86",
            "87",
            "88",
            "89",
            "90",
            "91",
            "92",
            "93",
            "94",
            "95",
            "96",
            "101",
            "102",
            "103",
            "104",
            "105",
            "106",
            "107",
            "113",
            "114",
            "115",
            "118",
            "119",
            "120",
            "121",
            "122",
            "123",
            "124",
            "125",
            "126",
            "127",
            "128",
            "129",
            "130",
            "131",
            "132",
            "133",
            "134",
            "135",
            "136",
            "137",
            "138",
            "139",
            "140",
            "141",
            "142",
            "143",
            "144",
            "145",
            "146",
            "147",
            "148",
            "149",
            "150",
            "151",
            "152",
            "153",
            "154",
            "155",
            "156",
            "157",
            "158",
            "159",
            "160",
            "161",
            "162",
            "163",
            "164",
            "165",
            "166",
            "167",
            "168",
            "169",
            "170",
            "171",
            "172",
            "176",
            "177",
            "179",
            "180",
            "184",
            "185",
            "187",
            "188",
            "192",
            "193",
            "195",
            "196",
            "200",
            "201",
            "203",
            "204",
            "208",
            "210",
            "211",
            "213",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "220",
            "221",
            "222",
            "223",
            "224",
            "225",
            "226",
            "227",
            "230",
            "231",
            "232",
            "233",
            "234",
            "235",
            "236",
            "237",
            "238",
            "239",
            "240",
            "241",
            "242",
            "243",
            "244",
            "245",
            "246",
            "247",
            "248",
            "249",
            "250",
            "251",
            "252",
            "253",
            "254",
            "255",
            "256",
            "257",
            "258",
            "259",
            "260",
            "261",
            "262",
            "263",
            "264",
            "265",
            "266",
            "267",
            "268",
            "269",
            "270",
            "271",
            "272",
            "273",
            "274",
            "275",
            "276",
            "277",
            "278",
            "279",
            "280",
            "281",
            "282",
            "283",
            "284",
            "285",
            "286",
            "287",
            "288",
            "289",
            "290",
            "291",
            "292",
            "293",
            "294",
            "295",
            "296",
            "297",
            "298",
            "299",
            "300",
            "301",
            "302",
            "303",
            "304",
            "305",
            "306",
            "307",
            "308",
            "309",
            "310",
            "311",
            "312",
            "313",
            "314",
            "315",
            "316",
            "317",
            "318",
            "319",
            "320",
            "321",
            "322",
            "323",
            "324",
            "325",
            "326",
            "327",
            "328",
            "329",
            "330",
            "331",
            "332",
            "333",
            "334",
            "335",
            "336",
            "337",
            "338",
            "339",
            "340",
            "341",
            "342",
            "343",
            "344",
            "345",
            "346",
            "347",
            "348",
            "349",
            "350",
            "351",
            "352",
            "353",
            "354",
            "355",
            "356",
            "357",
            "358",
            "359",
            "360",
            "361",
            "362",
            "363",
            "364",
            "365",
            "366",
            "367",
            "368",
            "369",
            "370",
            "371",
            "372",
            "373",
            "374",
            "375",
            "376",
            "377",
            "378",
            "379",
            "380",
            "381",
            "382",
            "383",
            "384",
            "385",
            "386",
            "387",
            "388",
            "389",
            "390",
            "391",
            "392",
            "393",
            "394",
            "395",
            "396",
            "397",
            "398",
            "399",
            "400",
            "401",
            "402",
            "403",
            "404",
            "405",
            "406",
            "407",
            "408",
            "409",
            "410",
            "411",
            "412",
            "413",
            "414",
            "415",
            "416",
            "417",
            "418",
            "419",
            "420",
            "421",
            "422",
            "423",
            "424",
            "425",
            "426",
            "427",
            "428",
            "429",
            "430",
            "431",
            "432",
            "433",
            "434",
            "435",
            "436",
            "437",
            "438",
            "439",
            "440"
          ],
          "num": 355
        }
      ],
      "diff": "diff --git a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\nindex 4c75c75..d0cf6ed 100644\n--- a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n+++ b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n@@ -20,25 +20,19 @@\n import java.text.MessageFormat;\n import java.text.ParsePosition;\n import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n import java.util.Locale;\n+import java.util.Map;\n \n-import org.apache.commons.lang.StringUtils;\n import org.apache.commons.lang.Validate;\n \n /**\n  * Extends \u003ccode\u003eMessageFormat\u003c/code\u003e to allow pluggable/additional formatting\n- * options for embedded format elements; requires a \"meta-format\", that is a\n- * \u003ccode\u003eFormat\u003c/code\u003e capable of parsing and formatting other\n- * \u003ccode\u003eFormat\u003c/code\u003es.\n- * \n- * Limitations:\n- * \u003cul\u003e\n- * \u003cli\u003e\u003ccode\u003etoPattern()\u003c/code\u003e results are tailored to JDK 1.4+ output and\n- * will produce fairly drastically different results on earlier JDKs.\u003c/li\u003e\n- * \u003cli\u003eRecursive choice formats do not inherit knowledge of the extended\n- * formatters and are limited to those available with\n- * \u003ccode\u003ejava.text.MessageFormat\u003c/code\u003e.\u003c/li\u003e\n- * \u003c/ul\u003e\n+ * options for embedded format elements; requires elaboration.\n+ *\n+ * Note that the mutator methods for the replacement Formats are to be considered\n+ * unnecessary and thus have been disabled (UnsupportedOperationException).\n  * \n  * @author Matt Benson\n  * @since 2.4\n@@ -47,299 +41,24 @@\n public class ExtendedMessageFormat extends MessageFormat {\n     private static final long serialVersionUID \u003d -2362048321261811743L;\n \n-    /**\n-     * Get a default meta-format for the default Locale. This will produce\n-     * behavior identical to a \u003ccode\u003ejava.lang.MessageFormat\u003c/code\u003e using the\n-     * default locale.\n-     * \n-     * @return Format\n-     */\n-    public static Format createDefaultMetaFormat() {\n-        return createDefaultMetaFormat(Locale.getDefault());\n-    }\n+    private static final String DUMMY_PATTERN \u003d \"\";\n+    private static final String ESCAPED_QUOTE \u003d \"\u0027\u0027\";\n+    private static final char START_FMT \u003d \u0027,\u0027;\n+    private static final char END_FE \u003d \u0027}\u0027;\n+    private static final char START_FE \u003d \u0027{\u0027;\n+    private static final char QUOTE \u003d \u0027\\\u0027\u0027;\n \n-    /**\n-     * Get a default meta-format for the specified Locale. This will produce\n-     * behavior identical to a \u003ccode\u003ejava.lang.MessageFormat\u003c/code\u003e using\n-     * \u003ccode\u003elocale\u003c/code\u003e.\n-     * \n-     * @param locale the Locale for the resulting Format instance.\n-     * @return Format\n-     */\n-    public static Format createDefaultMetaFormat(Locale locale) {\n-        return DefaultMetaFormatFactory.getFormat(locale);\n-    }\n-\n-    /**\n-     * Conceptual demarcation of methods to parse the pattern.\n-     */\n-    private static class Parser {\n-        private static final String ESCAPED_QUOTE \u003d \"\u0027\u0027\";\n-        private static final char START_FMT \u003d \u0027,\u0027;\n-        private static final char END_FE \u003d \u0027}\u0027;\n-        private static final char START_FE \u003d \u0027{\u0027;\n-        private static final char QUOTE \u003d \u0027\\\u0027\u0027;\n-\n-        /**\n-         * Strip all formats from the pattern.\n-         * \n-         * @param pattern String to strip\n-         * @return stripped pattern\n-         */\n-        private String stripFormats(String pattern) {\n-            StringBuffer sb \u003d new StringBuffer(pattern.length());\n-            ParsePosition pos \u003d new ParsePosition(0);\n-            char[] c \u003d pattern.toCharArray();\n-            while (pos.getIndex() \u003c pattern.length()) {\n-                switch (c[pos.getIndex()]) {\n-                case QUOTE:\n-                    appendQuotedString(pattern, pos, sb, true);\n-                    break;\n-                case START_FE:\n-                    int start \u003d pos.getIndex();\n-                    readArgumentIndex(pattern, next(pos));\n-                    sb.append(c, start, pos.getIndex() - start);\n-                    if (c[pos.getIndex()] \u003d\u003d START_FMT) {\n-                        eatFormat(pattern, next(pos));\n-                    }\n-                    if (c[pos.getIndex()] !\u003d END_FE) {\n-                        throw new IllegalArgumentException(\n-                                \"Unreadable format element at position \"\n-                                        + start);\n-                    }\n-                    // fall through\n-                default:\n-                    sb.append(c[pos.getIndex()]);\n-                    next(pos);\n-                }\n-            }\n-            return sb.toString();\n-        }\n-\n-        /**\n-         * Insert formats back into the pattern for toPattern() support.\n-         * \n-         * @param pattern source\n-         * @param formats the Formats to insert\n-         * @param metaFormat Format to format the Formats\n-         * @return full pattern\n-         */\n-        private String insertFormats(String pattern, Format[] formats,\n-                Format metaFormat) {\n-            if (formats \u003d\u003d null || formats.length \u003d\u003d 0) {\n-                return pattern;\n-            }\n-            StringBuffer sb \u003d new StringBuffer(pattern.length() * 2);\n-            ParsePosition pos \u003d new ParsePosition(0);\n-            int fe \u003d -1;\n-            while (pos.getIndex() \u003c pattern.length()) {\n-                char c \u003d pattern.charAt(pos.getIndex());\n-                switch (c) {\n-                case QUOTE:\n-                    appendQuotedString(pattern, pos, sb, false);\n-                    break;\n-                case START_FE:\n-                    fe++;\n-                    sb.append(START_FE).append(\n-                            readArgumentIndex(pattern, next(pos)));\n-                    if (formats[fe] !\u003d null) {\n-                        String formatName \u003d metaFormat.format(formats[fe]);\n-                        if (StringUtils.isNotEmpty(formatName)) {\n-                            sb.append(START_FMT).append(formatName);\n-                        }\n-                    }\n-                    break;\n-                default:\n-                    sb.append(pattern.charAt(pos.getIndex()));\n-                    next(pos);\n-                }\n-            }\n-            return sb.toString();\n-        }\n-\n-        /**\n-         * Parse the formats from the given pattern.\n-         * \n-         * @param pattern String to parse\n-         * @param metaFormat Format to parse the Formats\n-         * @return array of parsed Formats\n-         */\n-        private Format[] parseFormats(String pattern, Format metaFormat) {\n-            ArrayList result \u003d new ArrayList();\n-            ParsePosition pos \u003d new ParsePosition(0);\n-            while (pos.getIndex() \u003c pattern.length()) {\n-                switch (pattern.charAt(pos.getIndex())) {\n-                case QUOTE:\n-                    getQuotedString(pattern, next(pos), true);\n-                    break;\n-                case START_FE:\n-                    int start \u003d pos.getIndex();\n-                    readArgumentIndex(pattern, next(pos));\n-                    if (pattern.charAt(pos.getIndex()) \u003d\u003d START_FMT) {\n-                        seekNonWs(pattern, next(pos));\n-                    }\n-                    result.add(metaFormat.parseObject(pattern, pos));\n-                    seekNonWs(pattern, pos);\n-                    if (pattern.charAt(pos.getIndex()) !\u003d END_FE) {\n-                        throw new IllegalArgumentException(\n-                                \"Unreadable format element at position \"\n-                                        + start);\n-                    }\n-                    // fall through\n-                default:\n-                    next(pos);\n-                }\n-            }\n-            return (Format[]) result.toArray(new Format[result.size()]);\n-        }\n-\n-        /**\n-         * Consume whitespace from the current parse position.\n-         * \n-         * @param pattern String to read\n-         * @param pos current position\n-         */\n-        private void seekNonWs(String pattern, ParsePosition pos) {\n-            int len \u003d 0;\n-            char[] buffer \u003d pattern.toCharArray();\n-            do {\n-                len \u003d StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n-                pos.setIndex(pos.getIndex() + len);\n-            } while (len \u003e 0 \u0026\u0026 pos.getIndex() \u003c pattern.length());\n-        }\n-\n-        /**\n-         * Convenience method to advance parse position by 1\n-         * \n-         * @param pos ParsePosition\n-         * @return \u003ccode\u003epos\u003c/code\u003e\n-         */\n-        private ParsePosition next(ParsePosition pos) {\n-            pos.setIndex(pos.getIndex() + 1);\n-            return pos;\n-        }\n-\n-        /**\n-         * Read the argument index from the current format element\n-         * \n-         * @param pattern pattern to parse\n-         * @param pos current parse position\n-         * @return argument index as string\n-         */\n-        private String readArgumentIndex(String pattern, ParsePosition pos) {\n-            int start \u003d pos.getIndex();\n-            for (; pos.getIndex() \u003c pattern.length(); next(pos)) {\n-                char c \u003d pattern.charAt(pos.getIndex());\n-                if (c \u003d\u003d START_FMT || c \u003d\u003d END_FE) {\n-                    return pattern.substring(start, pos.getIndex());\n-                }\n-                if (!Character.isDigit(c)) {\n-                    throw new IllegalArgumentException(\n-                            \"Invalid format argument index at position \"\n-                                    + start);\n-                }\n-            }\n-            throw new IllegalArgumentException(\n-                    \"Unterminated format element at position \" + start);\n-        }\n-\n-        /**\n-         * Consume a quoted string, adding it to \u003ccode\u003eappendTo\u003c/code\u003e if\n-         * specified.\n-         * \n-         * @param pattern pattern to parse\n-         * @param pos current parse position\n-         * @param appendTo optional StringBuffer to append\n-         * @param escapingOn whether to process escaped quotes\n-         * @return \u003ccode\u003eappendTo\u003c/code\u003e\n-         */\n-        private StringBuffer appendQuotedString(String pattern,\n-                ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {\n-            int start \u003d pos.getIndex();\n-            char[] c \u003d pattern.toCharArray();\n-            if (escapingOn \u0026\u0026 c[start] \u003d\u003d QUOTE) {\n-                return appendTo \u003d\u003d null ? null : appendTo.append(QUOTE);\n-            }\n-            int lastHold \u003d start;\n-            for (int i \u003d pos.getIndex(); i \u003c pattern.length(); i++) {\n-                if (escapingOn\n-                        \u0026\u0026 pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n-                    appendTo.append(c, lastHold, pos.getIndex() - lastHold)\n-                            .append(QUOTE);\n-                    pos.setIndex(i + ESCAPED_QUOTE.length());\n-                    lastHold \u003d pos.getIndex();\n-                    continue;\n-                }\n-                switch (c[pos.getIndex()]) {\n-                case QUOTE:\n-                    next(pos);\n-                    return appendTo \u003d\u003d null ? null : appendTo.append(c,\n-                            lastHold, pos.getIndex() - lastHold);\n-                default:\n-                    next(pos);\n-                }\n-            }\n-            throw new IllegalArgumentException(\n-                    \"Unterminated quoted string at position \" + start);\n-        }\n-\n-        /**\n-         * Consume quoted string only\n-         * \n-         * @param pattern pattern to parse\n-         * @param pos current parse position\n-         * @param escapingOn whether to process escaped quotes\n-         */\n-        private void getQuotedString(String pattern, ParsePosition pos,\n-                boolean escapingOn) {\n-            appendQuotedString(pattern, pos, null, escapingOn);\n-        }\n-\n-        /**\n-         * Consume the entire format found at the current position.\n-         * \n-         * @param pattern string to parse\n-         * @param pos current parse position\n-         */\n-        private void eatFormat(String pattern, ParsePosition pos) {\n-            int start \u003d pos.getIndex();\n-            int depth \u003d 1;\n-            for (; pos.getIndex() \u003c pattern.length(); next(pos)) {\n-                switch (pattern.charAt(pos.getIndex())) {\n-                case START_FE:\n-                    depth++;\n-                    break;\n-                case END_FE:\n-                    depth--;\n-                    if (depth \u003d\u003d 0) {\n-                        return;\n-                    }\n-                    break;\n-                case QUOTE:\n-                    getQuotedString(pattern, pos, false);\n-                    break;\n-                }\n-            }\n-            throw new IllegalArgumentException(\n-                    \"Unterminated format element at position \" + start);\n-        }\n-    }\n-\n-    private static final Parser PARSER \u003d new Parser();\n-\n-    private Format metaFormat;\n-    private String strippedPattern;\n+    private String toPattern;\n+    private Map registry;\n \n     /**\n      * Create a new ExtendedMessageFormat for the default locale.\n      * \n      * @param pattern String\n-     * @param metaFormat Format\n-     * @throws IllegalArgumentException if \u003ccode\u003emetaFormat\u003c/code\u003e is\n-     *             \u003ccode\u003enull\u003c/code\u003e or in case of a bad pattern.\n+     * @throws IllegalArgumentException in case of a bad pattern.\n      */\n-    public ExtendedMessageFormat(String pattern, Format metaFormat) {\n-        this(pattern, Locale.getDefault(), metaFormat);\n+    public ExtendedMessageFormat(String pattern) {\n+        this(pattern, Locale.getDefault());\n     }\n \n     /**\n@@ -347,89 +66,376 @@\n      * \n      * @param pattern String\n      * @param locale Locale\n-     * @param metaFormat Format\n-     * @throws IllegalArgumentException if \u003ccode\u003emetaFormat\u003c/code\u003e is\n-     *             \u003ccode\u003enull\u003c/code\u003e or in case of a bad pattern.\n+     * @throws IllegalArgumentException in case of a bad pattern.\n      */\n-    public ExtendedMessageFormat(String pattern, Locale locale,\n-            Format metaFormat) {\n-        /*\n-         * We have to do some acrobatics here: the call to the super constructor\n-         * will invoke applyPattern(), but we don\u0027t want to apply the pattern\n-         * until we\u0027ve installed our custom metaformat. So we check for that in\n-         * our (final) applyPattern implementation, and re-call at the end of\n-         * this constructor.\n-         */\n-        super(pattern);\n-        setLocale(locale);\n-        setMetaFormat(metaFormat);\n+    public ExtendedMessageFormat(String pattern, Locale locale) {\n+        this(pattern, locale, null);\n+    }\n+\n+    /**\n+     * Create a new ExtendedMessageFormat for the default locale.\n+     * \n+     * @param pattern String\n+     * @param registry Registry of format factories:  Map\u003cString, FormatFactory\u003e\n+     * @throws IllegalArgumentException in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern, Map registry) {\n+        this(pattern, Locale.getDefault(), registry);\n+    }\n+\n+    /**\n+     * Create a new ExtendedMessageFormat.\n+     * \n+     * @param pattern String\n+     * @param locale Locale\n+     * @param registry Registry of format factories:  Map\u003cString, FormatFactory\u003e\n+     * @throws IllegalArgumentException in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern, Locale locale, Map registry) {\n+        super(DUMMY_PATTERN, locale);\n+        this.registry \u003d registry;\n         applyPattern(pattern);\n     }\n \n     /**\n+     * {@inheritDoc}\n+     */\n+    public String toPattern() {\n+        return toPattern;\n+    }\n+\n+    /**\n      * Apply the specified pattern.\n      * \n      * @param pattern String\n      */\n     public final void applyPattern(String pattern) {\n-        if (metaFormat \u003d\u003d null) {\n+        if (registry \u003d\u003d null) {\n+            super.applyPattern(pattern);\n+            toPattern \u003d super.toPattern();\n             return;\n         }\n-        applyPatternPre(pattern);\n-        strippedPattern \u003d PARSER.stripFormats(pattern);\n-        super.applyPattern(strippedPattern);\n-        setFormats(PARSER.parseFormats(pattern, metaFormat));\n-        applyPatternPost(pattern);\n+        ArrayList foundFormats \u003d new ArrayList();\n+        ArrayList foundDescriptions \u003d new ArrayList();\n+        StringBuffer stripCustom \u003d new StringBuffer(pattern.length());\n+\n+        ParsePosition pos \u003d new ParsePosition(0);\n+        char[] c \u003d pattern.toCharArray();\n+        int fmtCount \u003d 0;\n+        while (pos.getIndex() \u003c pattern.length()) {\n+            switch (c[pos.getIndex()]) {\n+            case QUOTE:\n+                appendQuotedString(pattern, pos, stripCustom, true);\n+                break;\n+            case START_FE:\n+                fmtCount++;\n+                seekNonWs(pattern, pos);\n+                int start \u003d pos.getIndex();\n+                int index \u003d readArgumentIndex(pattern, next(pos));\n+                stripCustom.append(START_FE).append(index);\n+                seekNonWs(pattern, pos);\n+                Format format \u003d null;\n+                String formatDescription \u003d null;\n+                if (c[pos.getIndex()] \u003d\u003d START_FMT) {\n+                    formatDescription \u003d parseFormatDescription(pattern,\n+                            next(pos));\n+                    format \u003d getFormat(formatDescription);\n+                    if (format \u003d\u003d null) {\n+                        stripCustom.append(START_FMT).append(formatDescription);\n+                    }\n+                }\n+                foundFormats.add(format);\n+                foundDescriptions.add(format \u003d\u003d null ? null : formatDescription);\n+                Validate.isTrue(foundFormats.size() \u003d\u003d fmtCount);\n+                Validate.isTrue(foundDescriptions.size() \u003d\u003d fmtCount);\n+                if (c[pos.getIndex()] !\u003d END_FE) {\n+                    throw new IllegalArgumentException(\n+                            \"Unreadable format element at position \" + start);\n+                }\n+                // fall through\n+            default:\n+                stripCustom.append(c[pos.getIndex()]);\n+                next(pos);\n+            }\n+        }\n+        super.applyPattern(stripCustom.toString());\n+        toPattern \u003d insertFormats(super.toPattern(), foundDescriptions);\n+        if (containsElements(foundFormats)) {\n+            Format[] origFormats \u003d getFormats();\n+            for (int i \u003d 0; i \u003c origFormats.length; i++) {\n+                Format f \u003d (Format) foundFormats.get(i);\n+                if (f !\u003d null) {\n+                    origFormats[i] \u003d f;\n+                }\n+            }\n+            super.setFormats(origFormats);\n+        }\n     }\n \n     /**\n-     * Pre-execution hook by means of which a subclass can customize the\n-     * behavior of the final applyPattern implementation.\n-     * \n-     * @param pattern String\n+     * {@inheritDoc}\n+     * UNSUPPORTED\n      */\n-    protected void applyPatternPre(String pattern) {\n-        // noop\n+    public void setFormat(int formatElementIndex, Format newFormat) {\n+        throw new UnsupportedOperationException();\n     }\n \n     /**\n-     * Post-execution hook by means of which a subclass can customize the\n-     * behavior of the final applyPattern implementation.\n-     * \n-     * @param pattern String\n+     * {@inheritDoc}\n+     * UNSUPPORTED\n      */\n-    protected void applyPatternPost(String pattern) {\n-        // noop\n+    public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {\n+        throw new UnsupportedOperationException();\n     }\n \n     /**\n-     * Render the pattern from the current state of the\n-     * \u003ccode\u003eExtendedMessageFormat\u003c/code\u003e.\n-     * \n-     * @return pattern String\n+     * {@inheritDoc}\n+     * UNSUPPORTED\n      */\n-    public String toPattern() {\n-        return PARSER.insertFormats(strippedPattern, getFormats(), metaFormat);\n+    public void setFormats(Format[] newFormats) {\n+        throw new UnsupportedOperationException();\n     }\n \n     /**\n-     * Get the meta-format currently configured.\n-     * \n-     * @return Format.\n+     * {@inheritDoc}\n+     * UNSUPPORTED\n      */\n-    public synchronized Format getMetaFormat() {\n-        return metaFormat;\n+    public void setFormatsByArgumentIndex(Format[] newFormats) {\n+        throw new UnsupportedOperationException();\n     }\n \n     /**\n-     * Set the meta-format. Has no effect until a subsequent call to\n-     * {@link #applyPattern(String)}.\n+     * Get a custom format from a format description.\n      * \n-     * @param metaFormat the Format metaFormat to set.\n+     * @param desc String\n+     * @return Format\n      */\n-    public synchronized void setMetaFormat(Format metaFormat) {\n-        Validate.notNull(metaFormat, \"metaFormat is null\");\n-        this.metaFormat \u003d metaFormat;\n+    private Format getFormat(String desc) {\n+        if (registry !\u003d null) {\n+            String name \u003d desc;\n+            String args \u003d null;\n+            int i \u003d desc.indexOf(START_FMT);\n+            if (i \u003e 0) {\n+                name \u003d desc.substring(0, i).trim();\n+                args \u003d desc.substring(i + 1).trim();\n+            }\n+            FormatFactory factory \u003d (FormatFactory) registry.get(name);\n+            if (factory !\u003d null) {\n+                return factory.getFormat(name, args, getLocale());\n+            }\n+        }\n+        return null;\n     }\n \n+    /**\n+     * Read the argument index from the current format element\n+     * \n+     * @param pattern pattern to parse\n+     * @param pos current parse position\n+     * @return argument index\n+     */\n+    private int readArgumentIndex(String pattern, ParsePosition pos) {\n+        int start \u003d pos.getIndex();\n+        seekNonWs(pattern, pos);\n+        StringBuffer result \u003d new StringBuffer();\n+        boolean error \u003d false;\n+        for (; !error \u0026\u0026 pos.getIndex() \u003c pattern.length(); next(pos)) {\n+            char c \u003d pattern.charAt(pos.getIndex());\n+            if (Character.isWhitespace(c)) {\n+                seekNonWs(pattern, pos);\n+                c \u003d pattern.charAt(pos.getIndex());\n+                if (c !\u003d START_FMT \u0026\u0026 c !\u003d END_FE) {\n+                    error \u003d true;\n+                    continue;\n+                }\n+            }\n+            if ((c \u003d\u003d START_FMT || c \u003d\u003d END_FE) \u0026\u0026 result.length() \u003e 0) {\n+                try {\n+                    return Integer.parseInt(result.toString());\n+                } catch (NumberFormatException e) {\n+                    //we\u0027ve already ensured only digits, so unless something outlandishly large was specified we should be okay.\n+                }\n+            }\n+            error \u003d !Character.isDigit(c);\n+            result.append(c);\n+        }\n+        if (error) {\n+            throw new IllegalArgumentException(\n+                    \"Invalid format argument index at position \" + start + \": \"\n+                            + pattern.substring(start, pos.getIndex()));\n+        }\n+        throw new IllegalArgumentException(\n+                \"Unterminated format element at position \" + start);\n+    }\n+\n+    /**\n+     * Parse the format component of a format element.\n+     * \n+     * @param pattern string to parse\n+     * @param pos current parse position\n+     * @return Format description String\n+     */\n+    private String parseFormatDescription(String pattern, ParsePosition pos) {\n+        int start \u003d pos.getIndex();\n+        seekNonWs(pattern, pos);\n+        int text \u003d pos.getIndex();\n+        int depth \u003d 1;\n+        for (; pos.getIndex() \u003c pattern.length(); next(pos)) {\n+            switch (pattern.charAt(pos.getIndex())) {\n+            case START_FE:\n+                depth++;\n+                break;\n+            case END_FE:\n+                depth--;\n+                if (depth \u003d\u003d 0) {\n+                    return pattern.substring(text, pos.getIndex());\n+                }\n+                break;\n+            case QUOTE:\n+                getQuotedString(pattern, pos, false);\n+                break;\n+            }\n+        }\n+        throw new IllegalArgumentException(\n+                \"Unterminated format element at position \" + start);\n+    }\n+\n+    /**\n+     * Insert formats back into the pattern for toPattern() support.\n+     *\n+     * @param pattern source\n+     * @param formats the Formats to insert\n+     * @param metaFormat Format to format the Formats\n+     * @return full pattern\n+     */\n+    private String insertFormats(String pattern, ArrayList customPatterns) {\n+        if (!containsElements(customPatterns)) {\n+            return pattern;\n+        }\n+        StringBuffer sb \u003d new StringBuffer(pattern.length() * 2);\n+        ParsePosition pos \u003d new ParsePosition(0);\n+        int fe \u003d -1;\n+        int depth \u003d 0;\n+        while (pos.getIndex() \u003c pattern.length()) {\n+            char c \u003d pattern.charAt(pos.getIndex());\n+            switch (c) {\n+            case QUOTE:\n+                appendQuotedString(pattern, pos, sb, false);\n+                break;\n+            case START_FE:\n+                depth++;\n+                if (depth \u003d\u003d 1) {\n+                    fe++;\n+                    sb.append(START_FE).append(\n+                            readArgumentIndex(pattern, next(pos)));\n+                    String customPattern \u003d (String) customPatterns.get(fe);\n+                    if (customPattern !\u003d null) {\n+                        sb.append(START_FMT).append(customPattern);\n+                    }\n+                }\n+                break;\n+            case END_FE:\n+                depth--;\n+                //fall through:\n+            default:\n+                sb.append(c);\n+                next(pos);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Consume whitespace from the current parse position.\n+     * \n+     * @param pattern String to read\n+     * @param pos current position\n+     */\n+    private void seekNonWs(String pattern, ParsePosition pos) {\n+        int len \u003d 0;\n+        char[] buffer \u003d pattern.toCharArray();\n+        do {\n+            len \u003d StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n+            pos.setIndex(pos.getIndex() + len);\n+        } while (len \u003e 0 \u0026\u0026 pos.getIndex() \u003c pattern.length());\n+    }\n+\n+    /**\n+     * Convenience method to advance parse position by 1\n+     * \n+     * @param pos ParsePosition\n+     * @return \u003ccode\u003epos\u003c/code\u003e\n+     */\n+    private ParsePosition next(ParsePosition pos) {\n+        pos.setIndex(pos.getIndex() + 1);\n+        return pos;\n+    }\n+\n+    /**\n+     * Consume a quoted string, adding it to \u003ccode\u003eappendTo\u003c/code\u003e if\n+     * specified.\n+     * \n+     * @param pattern pattern to parse\n+     * @param pos current parse position\n+     * @param appendTo optional StringBuffer to append\n+     * @param escapingOn whether to process escaped quotes\n+     * @return \u003ccode\u003eappendTo\u003c/code\u003e\n+     */\n+    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n+            StringBuffer appendTo, boolean escapingOn) {\n+        int start \u003d pos.getIndex();\n+        char[] c \u003d pattern.toCharArray();\n+        if (escapingOn \u0026\u0026 c[start] \u003d\u003d QUOTE) {\n+            return appendTo \u003d\u003d null ? null : appendTo.append(QUOTE);\n+        }\n+        int lastHold \u003d start;\n+        for (int i \u003d pos.getIndex(); i \u003c pattern.length(); i++) {\n+            if (escapingOn \u0026\u0026 pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n+                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n+                        QUOTE);\n+                pos.setIndex(i + ESCAPED_QUOTE.length());\n+                lastHold \u003d pos.getIndex();\n+                continue;\n+            }\n+            switch (c[pos.getIndex()]) {\n+            case QUOTE:\n+                next(pos);\n+                return appendTo \u003d\u003d null ? null : appendTo.append(c, lastHold,\n+                        pos.getIndex() - lastHold);\n+            default:\n+                next(pos);\n+            }\n+        }\n+        throw new IllegalArgumentException(\n+                \"Unterminated quoted string at position \" + start);\n+    }\n+\n+    /**\n+     * Consume quoted string only\n+     * \n+     * @param pattern pattern to parse\n+     * @param pos current parse position\n+     * @param escapingOn whether to process escaped quotes\n+     */\n+    private void getQuotedString(String pattern, ParsePosition pos,\n+            boolean escapingOn) {\n+        appendQuotedString(pattern, pos, null, escapingOn);\n+    }\n+\n+    /**\n+     * Learn whether the specified Collection contains non-null elements.\n+     * @param coll to check\n+     * @return \u003ccode\u003etrue\u003c/code\u003e if some Object was found, \u003ccode\u003efalse\u003c/code\u003e otherwise.\n+     */\n+    private boolean containsElements(Collection coll) {\n+        if (coll \u003d\u003d null || coll.size() \u003d\u003d 0) {\n+            return false;\n+        }\n+        for (Iterator iter \u003d coll.iterator(); iter.hasNext();) {\n+            if (iter.next() !\u003d null) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n }\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [961,989]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [990,1016]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [1042,1063]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Javadoc [1107,1475]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "FieldDeclaration [1612,1659]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "FieldDeclaration [1900,1925]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [1957,2238]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [2244,2538]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [2936,3391]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [6199,6377]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [6383,6571]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [6577,6735]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [6741,6914]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [6920,7595]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [14442,14969]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TagElement [1114,1413]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Javadoc [3397,3429]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "PrimitiveType: int [7806,7809]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SimpleType [9447,9453]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SingleVariableDeclaration [10567,10591]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: options for embedded format elements; requires elaboration. [1193,1252]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: Note that the mutator methods for the replacement Formats are to be considered [1259,1337]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: unnecessary and thus have been disabled (UnsupportedOperationException). [1341,1413]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ReturnStatement [3470,3487]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [3791,3832]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [3841,3887]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [3896,3958]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [3968,4009]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [4018,4051]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [4060,4077]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "WhileStatement [4086,5693]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [5702,5745]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [5754,5818]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [5827,6187]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [7909,7933]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [7942,7983]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [7992,8014]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "ForStatement [8023,8883]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [9393,9426]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [9558,9582]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [9591,9617]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [10827,10841]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [4093,4126]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [4128,5693]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [8030,8073]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodInvocation [8075,8084]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: error [8896,8901]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "PrefixExpression [10607,10640]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [3722,3752]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SwitchStatement [4142,5683]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [8153,8427]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [8440,8800]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [8813,8843]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [8856,8873]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ArrayAccess [4150,4167]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SwitchCase [4183,4194]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [4211,4263]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "BreakStatement [4280,4286]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SwitchCase [4299,4313]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [4330,4341]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [4358,4382]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [4399,4426]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [4443,4493]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [4510,4553]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [4570,4594]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [4611,4632]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [4649,4681]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [4698,5069]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [5086,5111]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [5128,5193]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [5210,5259]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [5276,5330]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [5347,5534]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SwitchCase [5579,5587]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [5604,5642]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [5659,5669]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [11123,11131]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [11148,11540]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SwitchCase [11576,11588]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [11605,11613]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [4702,4732]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [4734,5069]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [11152,11162]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [4868,4906]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [4927,5051]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "StringLiteral: \": \" [9028,9032]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodInvocation [9063,9103]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ReturnStatement [9937,9984]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [11328,11383]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [11408,11429]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: c [11693,11694]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodInvocation [4836,4845]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ImportDeclaration [987,1030]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: options for embedded format elements; requires a \"meta-format\", that is a [1159,1232]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: \u003ccode\u003eFormat\u003c/code\u003e capable of parsing and formatting other [1236,1295]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: \u003ccode\u003eFormat\u003c/code\u003es. [1299,1320]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: Limitations: [1328,1340]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: \u003cul\u003e [1344,1348]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: \u003cli\u003e\u003ccode\u003etoPattern()\u003c/code\u003e results are tailored to JDK 1.4+ output and [1352,1424]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: will produce fairly drastically different results on earlier JDKs.\u003c/li\u003e [1428,1499]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: \u003cli\u003eRecursive choice formats do not inherit knowledge of the extended [1503,1572]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: formatters and are limited to those available with [1576,1626]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: \u003ccode\u003ejava.text.MessageFormat\u003c/code\u003e.\u003c/li\u003e [1630,1672]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: \u003c/ul\u003e [1676,1681]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TagElement [1080,1681]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Javadoc [1073,1743]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [1880,2217]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [2223,2641]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "Javadoc [2647,2721]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Modifier: private [2726,2733]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Modifier: static [2734,2740]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TYPE_DECLARATION_KIND: class [2741,2746]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "SimpleName: Parser [2747,2753]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [3020,4428]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [6043,7555]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TypeDeclaration [2647,12523]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "FieldDeclaration [12529,12579]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "FieldDeclaration [12616,12647]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: \u003ccode\u003enull\u003c/code\u003e or in case of a bad pattern. [12881,12927]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [13073,13949]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [14400,14654]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [14660,14916]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "Javadoc [14922,15070]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ReturnStatement [15111,15182]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "METHOD_INVOCATION_RECEIVER [14217,14223]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [14165,14190]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [14300,14353]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [14362,14388]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SimpleType [8666,8672]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [8908,9031]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "PrefixExpression [9052,9073]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "InfixExpression [8787,8820]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodInvocation [8822,8831]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "ForStatement [8780,9283]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "PrimitiveType: void [11734,11738]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "ReturnStatement [12185,12192]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SingleVariableDeclaration [4763,4779]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SingleVariableDeclaration [4797,4814]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "InfixExpression [4834,4872]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [5577,5628]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodInvocation [5657,5691]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "InfixExpression [5530,5549]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "IfStatement [5526,5811]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodInvocation [5894,5924]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [15194,15367]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [15373,15722]",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        }
      ]
    }
  ],
  "inducing_type": {
    "add_classes": {
      "qualified_names": [
        "src/java/org/apache/commons/lang/text/FormatFactory.java"
      ],
      "num": 1
    },
    "delete_classes": {
      "qualified_names": [
        "src/java/org/apache/commons/lang/text/ChoiceMetaFormat.java",
        "src/java/org/apache/commons/lang/text/DateMetaFormat.java",
        "src/java/org/apache/commons/lang/text/DateMetaFormatSupport.java",
        "src/java/org/apache/commons/lang/text/DefaultMetaFormatFactory.java",
        "src/java/org/apache/commons/lang/text/MetaFormatSupport.java",
        "src/java/org/apache/commons/lang/text/NameKeyedMetaFormat.java",
        "src/java/org/apache/commons/lang/text/NumberMetaFormat.java",
        "src/java/org/apache/commons/lang/text/TimeMetaFormat.java"
      ],
      "num": 8
    },
    "add_functions": {
      "qualified_names": [
        "setFormat",
        "setFormats",
        "setFormatsByArgumentIndex",
        "containsElements",
        "getFormat",
        "parseFormatDescription",
        "setFormatByArgumentIndex"
      ],
      "num": 7
    },
    "delete_functions": {
      "qualified_names": [
        "applyPatternPost",
        "eatFormat",
        "parseFormats",
        "applyPatternPre",
        "stripFormats",
        "setMetaFormat",
        "getMetaFormat",
        "createDefaultMetaFormat"
      ],
      "num": 8
    }
  },
  "trigger_tests": [],
  "fixing_changes": [],
  "fixing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [],
      "num": 0
    },
    "add_functions": {
      "qualified_names": [],
      "num": 0
    },
    "delete_functions": {
      "qualified_names": [],
      "num": 0
    }
  }
}