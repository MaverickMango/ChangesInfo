diff --git a/javadoc/com/google/javascript/jscomp/ClosureCodingConvention.html b/javadoc/com/google/javascript/jscomp/ClosureCodingConvention.html
index d5f01e1..0c176f4 100644
--- a/javadoc/com/google/javascript/jscomp/ClosureCodingConvention.html
+++ b/javadoc/com/google/javascript/jscomp/ClosureCodingConvention.html
@@ -307,7 +307,7 @@
 <TH ALIGN="left"><B>Methods inherited from class com.google.javascript.jscomp.<A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html" title="class in com.google.javascript.jscomp">DefaultCodingConvention</A></B></TH>
 </TR>
 <TR BGCOLOR="white" CLASS="TableRowColor">
-<TD><CODE><A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#applyDelegateRelationship(com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.jstype.FunctionType, com.google.javascript.rhino.jstype.FunctionType)">applyDelegateRelationship</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#defineDelegateProxyProperties(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.jscomp.Scope, java.util.Map)">defineDelegateProxyProperties</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#getDelegateRelationship(com.google.javascript.rhino.Node)">getDelegateRelationship</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#getDelegateSuperclassName()">getDelegateSuperclassName</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isConstant(java.lang.String)">isConstant</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isExported(java.lang.String)">isExported</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isOptionalParameter(com.google.javascript.rhino.Node)">isOptionalParameter</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isPrivate(java.lang.String)">isPrivate</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isValidEnumKey(java.lang.String)">isValidEnumKey</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isVarArgsParameter(com.google.javascript.rhino.Node)">isVarArgsParameter</A></CODE></TD>
+<TD><CODE><A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#applyDelegateRelationship(com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.jstype.FunctionType, com.google.javascript.rhino.jstype.FunctionType)">applyDelegateRelationship</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#defineDelegateProxyProperties(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.jscomp.Scope, java.util.Map)">defineDelegateProxyProperties</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#getDelegateRelationship(com.google.javascript.rhino.Node)">getDelegateRelationship</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#getDelegateSuperclassName()">getDelegateSuperclassName</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isConstant(java.lang.String)">isConstant</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isExported(java.lang.String)">isExported</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isExported(java.lang.String, boolean)">isExported</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isOptionalParameter(com.google.javascript.rhino.Node)">isOptionalParameter</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isPrivate(java.lang.String)">isPrivate</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isValidEnumKey(java.lang.String)">isValidEnumKey</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isVarArgsParameter(com.google.javascript.rhino.Node)">isVarArgsParameter</A></CODE></TD>
 </TR>
 </TABLE>
 &nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
diff --git a/javadoc/com/google/javascript/jscomp/CodingConvention.html b/javadoc/com/google/javascript/jscomp/CodingConvention.html
index 099b62e..eed82d5 100644
--- a/javadoc/com/google/javascript/jscomp/CodingConvention.html
+++ b/javadoc/com/google/javascript/jscomp/CodingConvention.html
@@ -343,6 +343,15 @@
 <TD><CODE><B><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html#isExported(java.lang.String)">isExported</A></B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;name)</CODE>
 
 <BR>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Should be isExported(name, true) || isExported(name, false);</TD>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
+<CODE>&nbsp;boolean</CODE></FONT></TD>
+<TD><CODE><B><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html#isExported(java.lang.String, boolean)">isExported</A></B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;name,
+           boolean&nbsp;local)</CODE>
+
+<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether a global variable or function name should be treated as
  exported, or externally referenceable.</TD>
 </TR>
@@ -477,21 +486,35 @@
 </DL>
 <HR>
 
-<A NAME="isExported(java.lang.String)"><!-- --></A><H3>
+<A NAME="isExported(java.lang.String, boolean)"><!-- --></A><H3>
 isExported</H3>
 <PRE>
-boolean <B>isExported</B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;name)</PRE>
+boolean <B>isExported</B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;name,
+                   boolean&nbsp;local)</PRE>
 <DL>
 <DD>Checks whether a global variable or function name should be treated as
  exported, or externally referenceable.
 <P>
 <DD><DL>
-<DT><B>Parameters:</B><DD><CODE>name</CODE> - A global variable or function name.
+<DT><B>Parameters:</B><DD><CODE>name</CODE> - A global variable or function name.<DD><CODE>local</CODE> - <code>true</code> if the name is a local variable.
 <DT><B>Returns:</B><DD><code>true</code> if the name should be considered exported.</DL>
 </DD>
 </DL>
 <HR>
 
+<A NAME="isExported(java.lang.String)"><!-- --></A><H3>
+isExported</H3>
+<PRE>
+boolean <B>isExported</B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;name)</PRE>
+<DL>
+<DD>Should be isExported(name, true) || isExported(name, false);
+<P>
+<DD><DL>
+</DL>
+</DD>
+</DL>
+<HR>
+
 <A NAME="isPrivate(java.lang.String)"><!-- --></A><H3>
 isPrivate</H3>
 <PRE>
diff --git a/javadoc/com/google/javascript/jscomp/Compiler.html b/javadoc/com/google/javascript/jscomp/Compiler.html
index b8c32da..ca4eaf2 100644
--- a/javadoc/com/google/javascript/jscomp/Compiler.html
+++ b/javadoc/com/google/javascript/jscomp/Compiler.html
@@ -165,14 +165,6 @@
 </TR>
 <TR BGCOLOR="white" CLASS="TableRowColor">
 <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
-<CODE>static&nbsp;com.google.common.flags.Flag&lt;<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Boolean.html?is-external=true" title="class or interface in java.lang">Boolean</A>&gt;</CODE></FONT></TD>
-<TD><CODE><B><A HREF="../../../../com/google/javascript/jscomp/Compiler.html#FLAG_output_js_string_usage">FLAG_output_js_string_usage</A></B></CODE>
-
-<BR>
-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
-</TR>
-<TR BGCOLOR="white" CLASS="TableRowColor">
-<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 <CODE>static&nbsp;<A HREF="../../../../com/google/javascript/jscomp/DiagnosticType.html" title="class in com.google.javascript.jscomp">DiagnosticType</A></CODE></FONT></TD>
 <TD><CODE><B><A HREF="../../../../com/google/javascript/jscomp/Compiler.html#MOTION_ITERATIONS_ERROR">MOTION_ITERATIONS_ERROR</A></B></CODE>
 
@@ -677,16 +669,6 @@
 </TR>
 </TABLE>
 
-<A NAME="FLAG_output_js_string_usage"><!-- --></A><H3>
-FLAG_output_js_string_usage</H3>
-<PRE>
-public static final com.google.common.flags.Flag&lt;<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/Boolean.html?is-external=true" title="class or interface in java.lang">Boolean</A>&gt; <B>FLAG_output_js_string_usage</B></PRE>
-<DL>
-<DL>
-</DL>
-</DL>
-<HR>
-
 <A NAME="tracker"><!-- --></A><H3>
 tracker</H3>
 <PRE>
diff --git a/javadoc/com/google/javascript/jscomp/DefaultCodingConvention.html b/javadoc/com/google/javascript/jscomp/DefaultCodingConvention.html
index 9203a7a..f32caa9 100644
--- a/javadoc/com/google/javascript/jscomp/DefaultCodingConvention.html
+++ b/javadoc/com/google/javascript/jscomp/DefaultCodingConvention.html
@@ -340,6 +340,15 @@
 <TD><CODE><B><A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isExported(java.lang.String)">isExported</A></B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;name)</CODE>
 
 <BR>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Should be isExported(name, true) || isExported(name, false);</TD>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
+<CODE>&nbsp;boolean</CODE></FONT></TD>
+<TD><CODE><B><A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isExported(java.lang.String, boolean)">isExported</A></B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;name,
+           boolean&nbsp;local)</CODE>
+
+<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether a global variable or function name should be treated as
  exported, or externally referenceable.</TD>
 </TR>
@@ -516,21 +525,39 @@
 </DL>
 <HR>
 
+<A NAME="isExported(java.lang.String, boolean)"><!-- --></A><H3>
+isExported</H3>
+<PRE>
+public boolean <B>isExported</B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;name,
+                          boolean&nbsp;local)</PRE>
+<DL>
+<DD><B>Description copied from interface: <CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html#isExported(java.lang.String, boolean)">CodingConvention</A></CODE></B></DD>
+<DD>Checks whether a global variable or function name should be treated as
+ exported, or externally referenceable.
+<P>
+<DD><DL>
+<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html#isExported(java.lang.String, boolean)">isExported</A></CODE> in interface <CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html" title="interface in com.google.javascript.jscomp">CodingConvention</A></CODE></DL>
+</DD>
+<DD><DL>
+<DT><B>Parameters:</B><DD><CODE>name</CODE> - A global variable or function name.<DD><CODE>local</CODE> - <code>true</code> if the name is a local variable.
+<DT><B>Returns:</B><DD><code>true</code> if the name should be considered exported.</DL>
+</DD>
+</DL>
+<HR>
+
 <A NAME="isExported(java.lang.String)"><!-- --></A><H3>
 isExported</H3>
 <PRE>
 public boolean <B>isExported</B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;name)</PRE>
 <DL>
 <DD><B>Description copied from interface: <CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html#isExported(java.lang.String)">CodingConvention</A></CODE></B></DD>
-<DD>Checks whether a global variable or function name should be treated as
- exported, or externally referenceable.
+<DD>Should be isExported(name, true) || isExported(name, false);
 <P>
 <DD><DL>
 <DT><B>Specified by:</B><DD><CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html#isExported(java.lang.String)">isExported</A></CODE> in interface <CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html" title="interface in com.google.javascript.jscomp">CodingConvention</A></CODE></DL>
 </DD>
 <DD><DL>
-<DT><B>Parameters:</B><DD><CODE>name</CODE> - A global variable or function name.
-<DT><B>Returns:</B><DD><code>true</code> if the name should be considered exported.</DL>
+</DL>
 </DD>
 </DL>
 <HR>
diff --git a/javadoc/com/google/javascript/jscomp/GoogleCodingConvention.html b/javadoc/com/google/javascript/jscomp/GoogleCodingConvention.html
index 2fc51e2..4a0e29c 100644
--- a/javadoc/com/google/javascript/jscomp/GoogleCodingConvention.html
+++ b/javadoc/com/google/javascript/jscomp/GoogleCodingConvention.html
@@ -167,7 +167,8 @@
 <TR BGCOLOR="white" CLASS="TableRowColor">
 <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 <CODE>&nbsp;boolean</CODE></FONT></TD>
-<TD><CODE><B><A HREF="../../../../com/google/javascript/jscomp/GoogleCodingConvention.html#isExported(java.lang.String)">isExported</A></B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;name)</CODE>
+<TD><CODE><B><A HREF="../../../../com/google/javascript/jscomp/GoogleCodingConvention.html#isExported(java.lang.String, boolean)">isExported</A></B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;name,
+           boolean&nbsp;local)</CODE>
 
 <BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether a global variable or function name should be treated as
@@ -224,7 +225,7 @@
 <TH ALIGN="left"><B>Methods inherited from class com.google.javascript.jscomp.<A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html" title="class in com.google.javascript.jscomp">DefaultCodingConvention</A></B></TH>
 </TR>
 <TR BGCOLOR="white" CLASS="TableRowColor">
-<TD><CODE><A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#applyDelegateRelationship(com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.jstype.FunctionType, com.google.javascript.rhino.jstype.FunctionType)">applyDelegateRelationship</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#defineDelegateProxyProperties(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.jscomp.Scope, java.util.Map)">defineDelegateProxyProperties</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#getDelegateRelationship(com.google.javascript.rhino.Node)">getDelegateRelationship</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#getDelegateSuperclassName()">getDelegateSuperclassName</A></CODE></TD>
+<TD><CODE><A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#applyDelegateRelationship(com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.jstype.FunctionType, com.google.javascript.rhino.jstype.FunctionType)">applyDelegateRelationship</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#defineDelegateProxyProperties(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.jscomp.Scope, java.util.Map)">defineDelegateProxyProperties</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#getDelegateRelationship(com.google.javascript.rhino.Node)">getDelegateRelationship</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#getDelegateSuperclassName()">getDelegateSuperclassName</A>, <A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isExported(java.lang.String)">isExported</A></CODE></TD>
 </TR>
 </TABLE>
 &nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
@@ -373,10 +374,11 @@
 </DL>
 <HR>
 
-<A NAME="isExported(java.lang.String)"><!-- --></A><H3>
+<A NAME="isExported(java.lang.String, boolean)"><!-- --></A><H3>
 isExported</H3>
 <PRE>
-public boolean <B>isExported</B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;name)</PRE>
+public boolean <B>isExported</B>(<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;name,
+                          boolean&nbsp;local)</PRE>
 <DL>
 <DD>Checks whether a global variable or function name should be treated as
  exported, or externally referenceable.
@@ -385,10 +387,10 @@
  considered exported.
 <P>
 <DD><DL>
-<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html#isExported(java.lang.String)">isExported</A></CODE> in interface <CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html" title="interface in com.google.javascript.jscomp">CodingConvention</A></CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isExported(java.lang.String)">isExported</A></CODE> in class <CODE><A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html" title="class in com.google.javascript.jscomp">DefaultCodingConvention</A></CODE></DL>
+<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html#isExported(java.lang.String, boolean)">isExported</A></CODE> in interface <CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html" title="interface in com.google.javascript.jscomp">CodingConvention</A></CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isExported(java.lang.String, boolean)">isExported</A></CODE> in class <CODE><A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html" title="class in com.google.javascript.jscomp">DefaultCodingConvention</A></CODE></DL>
 </DD>
 <DD><DL>
-<DT><B>Parameters:</B><DD><CODE>name</CODE> - A global variable or function name.
+<DT><B>Parameters:</B><DD><CODE>name</CODE> - A global variable or function name.<DD><CODE>local</CODE> - <code>true</code> if the name is a local variable.
 <DT><B>Returns:</B><DD><code>true</code> if the name should be considered exported.</DL>
 </DD>
 </DL>
@@ -405,7 +407,7 @@
  accessed by the class that defines them.
 
  <p>In Google code, private names end with an underscore, and exported
- names are never considered private (see <A HREF="../../../../com/google/javascript/jscomp/GoogleCodingConvention.html#isExported(java.lang.String)"><CODE>isExported(java.lang.String)</CODE></A>).
+ names are never considered private (see <A HREF="../../../../com/google/javascript/jscomp/GoogleCodingConvention.html#isExported(java.lang.String, boolean)"><CODE>isExported(java.lang.String, boolean)</CODE></A>).
 <P>
 <DD><DL>
 <DT><B>Specified by:</B><DD><CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html#isPrivate(java.lang.String)">isPrivate</A></CODE> in interface <CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html" title="interface in com.google.javascript.jscomp">CodingConvention</A></CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#isPrivate(java.lang.String)">isPrivate</A></CODE> in class <CODE><A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html" title="class in com.google.javascript.jscomp">DefaultCodingConvention</A></CODE></DL>
diff --git a/javadoc/index-all.html b/javadoc/index-all.html
index ceadf28..8eaba64 100644
--- a/javadoc/index-all.html
+++ b/javadoc/index-all.html
@@ -1620,9 +1620,6 @@
 <DT><A HREF="./com/google/javascript/jscomp/AbstractCompilerRunner.html#FLAG_module_wrapper"><B>FLAG_module_wrapper</B></A> - 
 Static variable in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/AbstractCompilerRunner.html" title="class in com.google.javascript.jscomp">AbstractCompilerRunner</A>
 <DD>&nbsp;
-<DT><A HREF="./com/google/javascript/jscomp/Compiler.html#FLAG_output_js_string_usage"><B>FLAG_output_js_string_usage</B></A> - 
-Static variable in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/Compiler.html" title="class in com.google.javascript.jscomp">Compiler</A>
-<DD>&nbsp;
 <DT><A HREF="./com/google/javascript/jscomp/AbstractCompilerRunner.html#FLAG_output_wrapper"><B>FLAG_output_wrapper</B></A> - 
 Static variable in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/AbstractCompilerRunner.html" title="class in com.google.javascript.jscomp">AbstractCompilerRunner</A>
 <DD>&nbsp;
@@ -3760,14 +3757,20 @@
 Method in class com.google.javascript.rhino.<A HREF="./com/google/javascript/rhino/JSDocInfo.html" title="class in com.google.javascript.rhino">JSDocInfo</A>
 <DD>Returns whether the <code>@export</code> annotation is present on this
  <A HREF="./com/google/javascript/rhino/JSDocInfo.html" title="class in com.google.javascript.rhino"><CODE>JSDocInfo</CODE></A>.
-<DT><A HREF="./com/google/javascript/jscomp/CodingConvention.html#isExported(java.lang.String)"><B>isExported(String)</B></A> - 
+<DT><A HREF="./com/google/javascript/jscomp/CodingConvention.html#isExported(java.lang.String, boolean)"><B>isExported(String, boolean)</B></A> - 
 Method in interface com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/CodingConvention.html" title="interface in com.google.javascript.jscomp">CodingConvention</A>
 <DD>Checks whether a global variable or function name should be treated as
  exported, or externally referenceable.
+<DT><A HREF="./com/google/javascript/jscomp/CodingConvention.html#isExported(java.lang.String)"><B>isExported(String)</B></A> - 
+Method in interface com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/CodingConvention.html" title="interface in com.google.javascript.jscomp">CodingConvention</A>
+<DD>Should be isExported(name, true) || isExported(name, false);
+<DT><A HREF="./com/google/javascript/jscomp/DefaultCodingConvention.html#isExported(java.lang.String, boolean)"><B>isExported(String, boolean)</B></A> - 
+Method in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/DefaultCodingConvention.html" title="class in com.google.javascript.jscomp">DefaultCodingConvention</A>
+<DD>&nbsp;
 <DT><A HREF="./com/google/javascript/jscomp/DefaultCodingConvention.html#isExported(java.lang.String)"><B>isExported(String)</B></A> - 
 Method in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/DefaultCodingConvention.html" title="class in com.google.javascript.jscomp">DefaultCodingConvention</A>
 <DD>&nbsp;
-<DT><A HREF="./com/google/javascript/jscomp/GoogleCodingConvention.html#isExported(java.lang.String)"><B>isExported(String)</B></A> - 
+<DT><A HREF="./com/google/javascript/jscomp/GoogleCodingConvention.html#isExported(java.lang.String, boolean)"><B>isExported(String, boolean)</B></A> - 
 Method in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/GoogleCodingConvention.html" title="class in com.google.javascript.jscomp">GoogleCodingConvention</A>
 <DD>Checks whether a global variable or function name should be treated as
  exported, or externally referenceable.
diff --git a/javadoc/serialized-form.html b/javadoc/serialized-form.html
index b5dd65e..36dfe35 100644
--- a/javadoc/serialized-form.html
+++ b/javadoc/serialized-form.html
@@ -1019,6 +1019,17 @@
 </DL>
 <HR>
 <H3>
+outputJsStringUsage</H3>
+<PRE>
+boolean <B>outputJsStringUsage</B></PRE>
+<DL>
+<DD>Print string usage as part of the compilation log.
+<P>
+<DL>
+</DL>
+</DL>
+<HR>
+<H3>
 convertToDottedProperties</H3>
 <PRE>
 boolean <B>convertToDottedProperties</B></PRE>
diff --git a/lib/google_common_deploy.jar b/lib/google_common_deploy.jar
index f9fed2e..698d36f 100755
--- a/lib/google_common_deploy.jar
+++ b/lib/google_common_deploy.jar
Binary files differ
diff --git a/src/com/google/javascript/jscomp/CodingConvention.java b/src/com/google/javascript/jscomp/CodingConvention.java
index a701819..ef37732 100644
--- a/src/com/google/javascript/jscomp/CodingConvention.java
+++ b/src/com/google/javascript/jscomp/CodingConvention.java
@@ -81,8 +81,14 @@
    * exported, or externally referenceable.
    *
    * @param name A global variable or function name.
+   * @param local {@code true} if the name is a local variable.
    * @return {@code true} if the name should be considered exported.
    */
+  public boolean isExported(String name, boolean local);
+  
+  /**
+   * Should be isExported(name, true) || isExported(name, false);
+   */
   public boolean isExported(String name);
 
   /**
diff --git a/src/com/google/javascript/jscomp/CompilationLevel.java b/src/com/google/javascript/jscomp/CompilationLevel.java
index e0eee18..cb9b4da 100644
--- a/src/com/google/javascript/jscomp/CompilationLevel.java
+++ b/src/com/google/javascript/jscomp/CompilationLevel.java
@@ -95,7 +95,6 @@
     options.deadAssignmentElimination = true;
     options.extractPrototypeMemberDeclarations = true;
     options.collapseVariableDeclarations = true;
-    options.collapseAnonymousFunctions = true;
     options.convertToDottedProperties = true;
     options.labelRenaming = true;
     options.removeDeadCode = true;
@@ -126,7 +125,6 @@
     options.deadAssignmentElimination = true;
     options.extractPrototypeMemberDeclarations = true;
     options.collapseVariableDeclarations = true;
-    options.collapseAnonymousFunctions = true;
     options.convertToDottedProperties = true;
     options.rewriteFunctionExpressions = true;
     options.labelRenaming = true;
@@ -138,6 +136,7 @@
     options.propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED;
     options.removeUnusedPrototypeProperties = true;
     options.removeUnusedPrototypePropertiesInExterns = true;
+    options.collapseAnonymousFunctions = true;
     options.collapseProperties = true;
     options.rewriteFunctionExpressions = true;
     options.devirtualizePrototypeMethods = true;
diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java
index a2c1bbd..e913372 100644
--- a/src/com/google/javascript/jscomp/Compiler.java
+++ b/src/com/google/javascript/jscomp/Compiler.java
@@ -22,8 +22,6 @@
 import com.google.common.base.Tracer;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import com.google.common.flags.Flag;
-import com.google.common.flags.FlagSpec;
 import com.google.javascript.jscomp.CompilerOptions.DevMode;
 import com.google.javascript.jscomp.CompilerOptions.TracerMode;
 import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;
@@ -63,12 +61,6 @@
 *
  */
 public class Compiler extends AbstractCompiler {
-  @FlagSpec(help = "As part of the aliasing pass, outputs all strings and " +
-                   "the number of times they were used in the application to " +
-                   "the server log.")
-  public static final Flag<Boolean> FLAG_output_js_string_usage =
-      Flag.value(false);
-
   CompilerOptions options_ = createDefaultOptions();
 
   private PassConfig passes = null;
@@ -1405,7 +1397,7 @@
       aliasStrings(options_.aliasableStrings,
                    options_.aliasAllStrings,
                    options_.aliasStringsBlacklist,
-                   FLAG_output_js_string_usage.get());
+                   options_.outputJsStringUsage);
     }
 
     if (options_.aliasExternals) {
diff --git a/src/com/google/javascript/jscomp/CompilerOptions.java b/src/com/google/javascript/jscomp/CompilerOptions.java
index 2ff9887..a272a80 100644
--- a/src/com/google/javascript/jscomp/CompilerOptions.java
+++ b/src/com/google/javascript/jscomp/CompilerOptions.java
@@ -299,6 +299,9 @@
    */
   public boolean aliasAllStrings;
 
+  /** Print string usage as part of the compilation log. */
+  boolean outputJsStringUsage;
+
   /** Converts quoted property accesses to dot syntax (a['b'] -> a.b) */
   public boolean convertToDottedProperties;
 
@@ -581,6 +584,7 @@
     aliasableStrings = Collections.emptySet();
     aliasStringsBlacklist = "";
     aliasAllStrings = false;
+    outputJsStringUsage = false;
     convertToDottedProperties = false;
     rewriteFunctionExpressions = false;
     optimizeParameters = false;
diff --git a/src/com/google/javascript/jscomp/ControlFlowGraph.java b/src/com/google/javascript/jscomp/ControlFlowGraph.java
index 8b1e11e..dd4afa2 100644
--- a/src/com/google/javascript/jscomp/ControlFlowGraph.java
+++ b/src/com/google/javascript/jscomp/ControlFlowGraph.java
@@ -138,33 +138,58 @@
       if (parent == null) {
         return true;
       }
-      switch (parent.getType()) {
-        case Token.BLOCK:
-        case Token.SCRIPT:
-        case Token.TRY:
-        case Token.FINALLY:
-          return false;
-        case Token.FUNCTION:
-          return n == parent.getFirstChild().getNext();
-        case Token.WHILE:
-        case Token.DO:
-        case Token.IF:
-          return NodeUtil.getConditionExpression(parent) == n;
-        case Token.FOR:
-          if (parent.getChildCount() == 4) {
-            return NodeUtil.getConditionExpression(parent) == n;
-          } else {
-            return n != parent.getLastChild();
-          }
-        case Token.SWITCH:
-        case Token.CASE:
-        case Token.CATCH:
-        case Token.WITH:
-          return n == parent.getFirstChild();
-
-        default:
-          return true;
-      }
+      return !isEnteringNewCfgNode(n);
+    }
+  }
+  
+  /**
+   * @return True if n should be represented by a new CFG node in the control
+   * flow graph.
+   */
+  public static boolean isEnteringNewCfgNode(Node n) {
+    Node parent = n.getParent();
+    switch (parent.getType()) {
+      case Token.BLOCK:
+      case Token.SCRIPT:
+      case Token.TRY:
+      case Token.FINALLY:
+        return true;
+      case Token.FUNCTION:
+        // A function node represents the start of a function where the name
+        // is bleed into the local scope and parameters has been assigned
+        // to the formal argument names. The node includes the name of the
+        // function and the LP list since we assume the whole set up process
+        // is atomic without change in control flow. The next change of
+        // control is going into the function's body represent by the second
+        // child.
+        return n != parent.getFirstChild().getNext();
+      case Token.WHILE:
+      case Token.DO:
+      case Token.IF:
+        // Theses control structure is represented by its node that holds the
+        // condition. Each of them is a branch node based on its condition.
+        return NodeUtil.getConditionExpression(parent) != n;
+        
+      case Token.FOR:
+        // The FOR(;;) node differs from other control structure in that
+        // it has a initialization and a increment statement. Those
+        // two statements have its corresponding CFG nodes to represent them.
+        // The FOR node represents the condition check for each iteration.
+        // That way the following:
+        // for(var x = 0; x < 10; x++) { } has a graph that is isomorphic to
+        // var x = 0; while(x<10) {  x++; }
+        if (parent.getChildCount() == 4) {
+          return NodeUtil.getConditionExpression(parent) != n;
+        } else {
+          return n == parent.getLastChild();
+        }
+      case Token.SWITCH:
+      case Token.CASE:
+      case Token.CATCH:
+      case Token.WITH:
+        return n != parent.getFirstChild();
+      default:
+        return false;
     }
   }
 }
diff --git a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java
index 1b55469..d554f78 100644
--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java
+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java
@@ -28,7 +28,6 @@
 import com.google.javascript.rhino.Token;
 
 import java.util.List;
-import java.util.logging.Logger;
 
 /**
  * Removes local variable assignments that are useless based on information from
@@ -43,8 +42,6 @@
 
   private final AbstractCompiler compiler;
   private LiveVariablesAnalysis liveness;
-  private static final Logger logger =
-    Logger.getLogger(DeadAssignmentsElimination.class.getName());
 
   public DeadAssignmentsElimination(AbstractCompiler compiler) {
     this.compiler = compiler;
@@ -111,45 +108,60 @@
         case Token.IF:
         case Token.WHILE:
         case Token.DO:
-          tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), n, state);
+          tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state);
           continue;
         case Token.FOR:
           if (n.getChildCount() == 4) {
             tryRemoveAssignment(
-                t, NodeUtil.getConditionExpression(n), n, state);
-            tryRemoveAssignment(
-                t, n.getFirstChild().getNext().getNext(), n, state);
+                t, NodeUtil.getConditionExpression(n), state);
           }
           continue;
         case Token.SWITCH:
         case Token.CASE:
         case Token.RETURN:
           if (n.hasChildren()) {
-            tryRemoveAssignment(t, n.getFirstChild(), n, state);
+            tryRemoveAssignment(t, n.getFirstChild(), state);
           }
           continue;
         // TODO(user): case Token.VAR: Remove var a=1;a=2;.....
       }
       
-      if (NodeUtil.isExpressionNode(n)) {
-        tryRemoveAssignment(t, n.getFirstChild(), n, state);
-      }
+      tryRemoveAssignment(t, n, state);
     }
   }
 
+  private void tryRemoveAssignment(NodeTraversal t, Node n,
+      FlowState<LiveVariableLattice> state) {
+    tryRemoveAssignment(t, n, n, state);
+  }
+  
   /**
    * Determines if any local variables are dead after the instruction {@code n}
    * and are assigned within the subtree of {@code n}. Removes those assignments
    * if there are any.
    *
    * @param n Target instruction.
-   * @param parent Parent of {@code n}.
+   * @param exprRoot The CFG node where the liveness information in state is
+   *     still correct.
    * @param state The liveness information at {@code n}.
    */
-  private void tryRemoveAssignment(NodeTraversal t, Node n, Node parent,
+  private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot,
       FlowState<LiveVariableLattice> state) {
-    if (NodeUtil.isAssign(n)) {
+
+    // TODO(user): Add implemenation to handle x++ and ++x by replacing
+    // them with x or x+1 respectively.
+    if (NodeUtil.isAssignmentOp(n)) {
+
       Node lhs = n.getFirstChild();
+      Node rhs = lhs.getNext();
+      
+      // Recurse first. Example: dead_x = dead_y = 1; We try to clean up dead_y
+      // first.
+      if (rhs != null) {
+        tryRemoveAssignment(t, rhs, exprRoot, state);
+        rhs = lhs.getNext();
+      }
+
       Scope scope = t.getScope();
       if (!NodeUtil.isName(lhs)) {
         return; // Not a local variable assignment.
@@ -165,8 +177,9 @@
       if (state.getOut().isLive(var)) {
         return; // Variable not dead.
       }
-      if (state.getIn().isLive(var)) {
-        // Oddly, the variable is killed here but it is also live before it.
+      if (state.getIn().isLive(var) &&
+          isVariableStillLiveWithinExpression(n, exprRoot, var.name)) {
+        // The variable is killed here but it is also live before it.
         // This is possible if we have say:
         //    if (X = a && a = C) {..} ; .......; a = S;
         // In this case we are safe to remove "a = C" because it is dead.
@@ -178,22 +191,106 @@
         // of GEN sets when we recurse here.
         return;
       }
-      Node rhs = n.getLastChild();
-      // Now we are at a dead local variable assignment.
-      logger.info("Removing dead assignemnt to " + name + " in "
-          + t.getSourceName() + " line " + n.getLineno());
-      n.removeChild(rhs);
-      parent.replaceChild(n, rhs);
+      
+      if (NodeUtil.isAssign(n)) {
+        n.removeChild(rhs);
+        n.getParent().replaceChild(n, rhs);
+      } else if (NodeUtil.isAssignmentOp(n)) {
+        n.removeChild(rhs);
+        n.removeChild(lhs);
+        Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs);
+        n.getParent().replaceChild(n, op);
+      } else {
+        // TODO(user): this is where the code that handles dead x++ and x--
+        // should go.
+        
+        // Not reachable.
+        Preconditions.checkState(false, "Unknow statement");
+      }
+      
       compiler.reportCodeChange();
       return;
 
     } else {
       for (Node c = n.getFirstChild(); c != null;) {
         Node next = c.getNext();
-        tryRemoveAssignment(t, c, n, state);
+        if (!ControlFlowGraph.isEnteringNewCfgNode(c)) {
+          tryRemoveAssignment(t, c, exprRoot, state);
+        }
         c = next;
       }
       return;
     }
   }
+  
+  /**
+   * Given a variable, node n in the tree and a sub-tree denoted by exprRoot as
+   * the root, this function returns true if there exists a read of that
+   * variable before a write to that variable that is on the right side of n.
+   * 
+   * For example, suppose the node is x = 1:
+   * 
+   * y = 1, x = 1; // false, there is no reads at all.
+   * y = 1, x = 1, print(x) // true, there is a read right of n.
+   * y = 1, x = 1, x = 2, print(x) // false, there is a read right of n but 
+   *                               // it is after a write.
+   * 
+   * @param n The current node we should look at.
+   * @param exprRoot The node
+   */
+  private boolean isVariableStillLiveWithinExpression(
+      Node n, Node exprRoot, String variable) {
+    while (n != exprRoot) {
+      for(Node sibling = n.getNext(); sibling != null;
+          sibling = sibling.getNext()) {
+        if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {
+          VariableLiveness state = readVariableBeforeKilling(sibling, variable);
+          
+          // If we see a READ or KILL there is no need to continue.
+          if (state == VariableLiveness.READ) {
+            return true;
+          } else if (state == VariableLiveness.KILL) {
+            return false;
+          }
+        }
+      }
+      n = n.getParent();
+    }
+    return false;
+  }
+  
+  // The current liveness of the variable
+  private enum VariableLiveness {
+    MAYBE_LIVE, // May be still live in the current expression tree.
+    READ, // Known there is a read left of it.
+    KILL, // Known there is a write before any read.
+  }
+
+  /**
+   * Give an expression and a variable. It returns READ, if the right-most
+   * reference of that variable is a read. It returns KILL, if the right-most
+   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.
+   * 
+   * This need to be a pre-order traversal so we cannot use the normal node
+   * traversals.
+   */
+  private VariableLiveness readVariableBeforeKilling(Node n, String variable) {
+    if (NodeUtil.isName(n) && variable.equals(n.getString())) {
+      if (NodeUtil.isLhs(n, n.getParent())) {
+        return VariableLiveness.KILL;
+      } else {
+        return VariableLiveness.READ;
+      }
+    }
+    for (Node child = n.getFirstChild();
+        child != null; child = child.getNext()) {
+      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {
+        VariableLiveness state = readVariableBeforeKilling(child, variable);
+        if (state != VariableLiveness.MAYBE_LIVE) {
+          return state;
+        }
+      }
+    }
+    return VariableLiveness.MAYBE_LIVE;
+  }
 }
diff --git a/src/com/google/javascript/jscomp/DefaultCodingConvention.java b/src/com/google/javascript/jscomp/DefaultCodingConvention.java
index 11103c0..3446893 100644
--- a/src/com/google/javascript/jscomp/DefaultCodingConvention.java
+++ b/src/com/google/javascript/jscomp/DefaultCodingConvention.java
@@ -56,8 +56,13 @@
   }
 
   @Override
+  public boolean isExported(String name, boolean local) {
+    return local && name.startsWith("$super");
+  }
+  
+  @Override
   public boolean isExported(String name) {
-    return false;
+    return isExported(name, false) || isExported(name, true);
   }
 
   @Override
diff --git a/src/com/google/javascript/jscomp/GoogleCodingConvention.java b/src/com/google/javascript/jscomp/GoogleCodingConvention.java
index 5510276..9546260 100644
--- a/src/com/google/javascript/jscomp/GoogleCodingConvention.java
+++ b/src/com/google/javascript/jscomp/GoogleCodingConvention.java
@@ -121,8 +121,8 @@
    * considered exported.
    */
   @Override
-  public boolean isExported(String name) {
-    return name.startsWith("_");
+  public boolean isExported(String name, boolean local) {
+    return !local && name.startsWith("_");
   }
 
   /**
diff --git a/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java b/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java
index f623da3..aed3242 100644
--- a/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java
+++ b/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java
@@ -17,8 +17,8 @@
 package com.google.javascript.jscomp;
 
 import com.google.common.base.Preconditions;
+import com.google.common.collect.HashMultimap;
 import com.google.common.collect.Multimap;
-import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
 import com.google.javascript.jscomp.ControlFlowGraph.Branch;
 import com.google.javascript.jscomp.Scope.Var;
@@ -85,7 +85,7 @@
     final Multimap<Var, Node> mayUseMap;
 
     public ReachingUses() {
-      mayUseMap = Multimaps.newHashMultimap();
+      mayUseMap = HashMultimap.create();
     }
 
     /**
@@ -94,7 +94,7 @@
      * @param other The constructed object is a replicated copy of this element.
      */
     public ReachingUses(ReachingUses other) {
-      mayUseMap = Multimaps.newHashMultimap(other.mayUseMap);
+      mayUseMap = HashMultimap.create(other.mayUseMap);
     }
 
     @Override
diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java
index 0ec71df..70a8490 100644
--- a/src/com/google/javascript/jscomp/NodeUtil.java
+++ b/src/com/google/javascript/jscomp/NodeUtil.java
@@ -716,6 +716,34 @@
     }
     return false;
   }
+  
+  static int getOpFromAssignmentOp(Node n) {
+    switch (n.getType()){
+      case Token.ASSIGN_BITOR:
+        return Token.BITOR;
+      case Token.ASSIGN_BITXOR:
+        return Token.BITXOR;
+      case Token.ASSIGN_BITAND:
+        return Token.BITAND;
+      case Token.ASSIGN_LSH:
+        return Token.LSH;
+      case Token.ASSIGN_RSH:
+        return Token.RSH;
+      case Token.ASSIGN_URSH:
+        return Token.URSH;
+      case Token.ASSIGN_ADD:
+        return Token.ADD;
+      case Token.ASSIGN_SUB:
+        return Token.SUB;
+      case Token.ASSIGN_MUL:
+        return Token.MUL;
+      case Token.ASSIGN_DIV:
+        return Token.DIV;
+      case Token.ASSIGN_MOD:
+        return Token.MOD;
+    }
+    throw new IllegalArgumentException("Not an assiment op");
+  }
 
   static boolean isExpressionNode(Node n) {
     return n.getType() == Token.EXPR_RESULT;
diff --git a/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java b/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java
index 3235601..aba0ae7 100644
--- a/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java
+++ b/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java
@@ -210,7 +210,11 @@
       // We have something like arguments[x] where x is not a constant. That
       // means at least one of the access is not known.
       if (index.getType() != Token.NUMBER) {
-        continue;
+        // TODO(user): Its possible not to give up just yet. The type
+        // inference did a 'semi value propagation'. If we know that string
+        // is never a subclass of the type of the index. We'd know that
+        // it is never 'callee'.
+        return false; // Give up.
       }
 
       // Replace the highest index if we see an access that has a higher index
diff --git a/src/com/google/javascript/jscomp/RenameVars.java b/src/com/google/javascript/jscomp/RenameVars.java
index 836fabb..18e2680 100644
--- a/src/com/google/javascript/jscomp/RenameVars.java
+++ b/src/com/google/javascript/jscomp/RenameVars.java
@@ -441,6 +441,6 @@
    * Determines whether a variable name is okay to rename.
    */
   private boolean okToRenameVar(String name, boolean isLocal) {
-    return isLocal || !compiler.getCodingConvention().isExported(name);
+    return !compiler.getCodingConvention().isExported(name, isLocal);
   }
 }
diff --git a/src/com/google/javascript/jscomp/RhinoErrorReporter.java b/src/com/google/javascript/jscomp/RhinoErrorReporter.java
index 5d7b2fc..0c90c7c 100644
--- a/src/com/google/javascript/jscomp/RhinoErrorReporter.java
+++ b/src/com/google/javascript/jscomp/RhinoErrorReporter.java
@@ -43,9 +43,12 @@
   static final DiagnosticType TRAILING_COMMA =
       DiagnosticType.error("JSC_TRAILING_COMMA", "Parse error. {0}");
 
-  static final DiagnosticType BAD_JSDOC_ANNOTATION = 
+  static final DiagnosticType DUPLICATE_PARAM =
+      DiagnosticType.error("JSC_DUPLICATE_PARAM", "Parse error. {0}");
+
+  static final DiagnosticType BAD_JSDOC_ANNOTATION =
     DiagnosticType.warning("JSC_BAD_JSDOC_ANNOTATION", "Parse error. {0}");
-  
+
   // A map of Rhino messages to their DiagnosticType.
   private final Map<String, DiagnosticType> typeMap;
 
@@ -64,18 +67,24 @@
   private RhinoErrorReporter(AbstractCompiler compiler) {
     this.compiler = compiler;
     typeMap = ImmutableMap.of(
-        
+
         // Extra @fileoverview
         replacePlaceHolders(
             ScriptRuntime.getMessage0("msg.jsdoc.fileoverview.extra")),
         EXTRA_FILEOVERVIEW,
-        
+
         // Trailing comma
         replacePlaceHolders(
             com.google.javascript.jscomp.mozilla.rhino.ScriptRuntime
               .getMessage0("msg.extra.trailing.comma")),
         TRAILING_COMMA,
-    
+
+        // Duplicate parameter
+        replacePlaceHolders(
+            com.google.javascript.jscomp.mozilla.rhino.ScriptRuntime
+              .getMessage0("msg.dup.parms")),
+        DUPLICATE_PARAM,
+
         // Unknown @annotations.
         replacePlaceHolders(ScriptRuntime.getMessage0("msg.bad.jsdoc.tag")),
         BAD_JSDOC_ANNOTATION);
diff --git a/src/com/google/javascript/jscomp/WarningLevel.java b/src/com/google/javascript/jscomp/WarningLevel.java
index b1eb15f..d7b3800 100644
--- a/src/com/google/javascript/jscomp/WarningLevel.java
+++ b/src/com/google/javascript/jscomp/WarningLevel.java
@@ -57,6 +57,7 @@
     // new one once it is default in command line JSCompiler.
     options.checkUndefinedProperties = CheckLevel.OFF;
     options.checkUnusedPropertiesEarly = false;
+    options.checkUnreachableCode = CheckLevel.WARNING;
   }
 
   /**
diff --git a/test/com/google/javascript/jscomp/CompilerRunnerTest.java b/test/com/google/javascript/jscomp/CompilerRunnerTest.java
index 1469980..0d8ac0f 100644
--- a/test/com/google/javascript/jscomp/CompilerRunnerTest.java
+++ b/test/com/google/javascript/jscomp/CompilerRunnerTest.java
@@ -30,6 +30,8 @@
  */
 public class CompilerRunnerTest extends TestCase {
 
+  private Compiler lastCompiler = null;
+
   /** Externs for the test */
   private final JSSourceFile[] externs = new JSSourceFile[] {
     JSSourceFile.fromCode("externs",
@@ -42,6 +44,7 @@
   @Override
   public void setUp() {
     Flags.disableStateCheckingForTest();
+    lastCompiler = null;
   }
 
   @Override
@@ -84,6 +87,11 @@
     test("var x = {}; var y = x.bar;", TypeCheck.INEXISTENT_PROPERTY);
   }
 
+  public void testDuplicateParams() {
+    test("function (a, a) {}", RhinoErrorReporter.DUPLICATE_PARAM);
+    assertTrue(lastCompiler.hasHaltingErrors());
+  }
+
   private void testSame(String original) {
     testSame(new String[] { original });
   }
@@ -143,6 +151,7 @@
   private Compiler compile(String[] original) {
     CompilerRunner runner = new CompilerRunner(new String[] {});
     Compiler compiler = runner.createCompiler();
+    lastCompiler = compiler;
     JSSourceFile[] inputs = new JSSourceFile[original.length];
     for (int i = 0; i < original.length; i++) {
       inputs[i] = JSSourceFile.fromCode("input" + i, original[i]);
diff --git a/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java b/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java
index 4bd3386..0c1b155 100644
--- a/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java
+++ b/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java
@@ -86,10 +86,19 @@
 
     inFunction("var x,y; if( (x=1)+(y=2) > 3){}",
         "var x,y; if( 1+2 > 3){}");
+  }
 
+  public void testUsedAsConditionsInSwitchStatements() {
     inFunction("var x; switch(x=1){}","var x; switch(1){}");
     inFunction("var x; switch(x){case(x=1):break;}",
         "var x; switch(x){case(1):break;}");
+    
+    inFunction("var x,y; switch(y) { case (x += 1): break; case (x): break;}");
+    
+    inFunction("var x,y; switch(y) { case (x = 1): break; case (2): break;}",
+               "var x,y; switch(y) { case (1): break; case (2): break;}");
+    inFunction("var x,y; switch(y) { case (x+=1): break; case (x=2): break;}",
+               "var x,y; switch(y) { case (x+1): break; case (2): break;}");
   }
 
   public void testAssignmentInReturn() {
@@ -107,8 +116,8 @@
    */
   public void testAssignAndReadInCondition() {
     inFunction("var a, b; if ((a = 1) && (b = a)) {b}");
-    // But we missed an opportunity here.
-    inFunction("var a, b; if ((b = a) && (a = 1)) {b}");
+    inFunction("var a, b; if ((b = a) && (a = 1)) {b}",
+               "var a, b; if ((b = a) && (1)) {b}");
   }
 
   public void testParameters() {
@@ -150,6 +159,147 @@
     inFunction("var x = 0; print(x); x = 1; var y = function(){}; y()");
   }
 
+  public void testSelfReAssignment() {
+    inFunction("var x; x = x;", "var x; x");
+  }
+  
+  public void testSelfIncrement() {
+    inFunction("var x; x = x + 1;", "var x; x + 1");
+  }
+  
+  public void testAssignmentOp() {
+    // We have remove constant expressions that cleans this one up.
+    inFunction("var x; x += foo()", "var x; x + foo()");
+  }
+  
+  public void testAssignmentOpUsedAsLhs() {
+    inFunction("var x,y; y = x += foo(); print(y)",
+               "var x,y; y = x +  foo(); print(y)");
+  }
+  
+  public void testAssignmentOpUsedAsCondition() {    
+    inFunction("var x; if(x += foo()) {}",
+               "var x; if(x +  foo()) {}");
+
+    inFunction("var x; if((x += foo()) > 1) {}",
+               "var x; if((x +  foo()) > 1) {}");
+    
+    // Not in a while because this happens every loop.
+    inFunction("var x; while((x += foo()) > 1) {}");
+    
+    inFunction("var x; for(;--x;){}");
+    inFunction("var x; for(;x--;){}");
+    inFunction("var x; for(;x -= 1;){}");
+    inFunction("var x; for(;x = 0;){}", "var x; for(;0;){}");
+    
+    inFunction("var x; for(;;--x){}");
+    inFunction("var x; for(;;x--){}");
+    inFunction("var x; for(;;x -= 1){}");
+    inFunction("var x; for(;;x = 0){}", "var x; for(;;0){}");
+    
+    // TODO(user): Add support of INC and DEC.
+    inFunction("var x; for(--x;;){}");
+    inFunction("var x; for(x--;;){}");
+    inFunction("var x; for(x -= 1;;){}", "var x; for(x - 1;;){}");
+    inFunction("var x; for(x = 0;;){}", "var x; for(0;;){}");
+  }
+  
+  public void testDeadIncrement() {
+    // TODO(user): Optimize this.
+    inFunction("var x; x ++");
+    inFunction("var x; x --");
+  }
+  
+  public void testDeadButAlivePartiallyWithinTheExpression() {
+    inFunction("var x; x = 100, print(x), x = 101;",
+               "var x; x = 100, print(x),     101;");
+    inFunction("var x; x = 100, print(x), print(x), x = 101;",
+               "var x; x = 100, print(x), print(x),     101;");
+    inFunction("var x; x = 100, print(x), x = 0, print(x), x = 101;",
+               "var x; x = 100, print(x), x = 0, print(x),     101;");
+  }
+  
+  public void testMutipleDeadAssignmentsButAlivePartiallyWithinTheExpression() {
+    inFunction("var x; x = 1, x = 2, x = 3, x = 4, x = 5," + 
+               "  print(x), x = 0, print(x), x = 101;",
+               
+               "var x; 1, 2, 3, 4, x = 5, print(x), x = 0, print(x), 101;");
+  }
+  
+
+  public void testDeadPartiallyWithinTheExpression() {
+    // Sadly, this is not covered. We don't suspect this would happend too
+    // often.
+    inFunction("var x; x = 100, x = 101; print(x);");
+  }
+  
+  public void testAssignmentChain() {
+    inFunction("var a,b,c,d,e; a = b = c = d = e = 1",
+               "var a,b,c,d,e; 1");
+    inFunction("var a,b,c,d,e; a = b = c = d = e = 1; print(c)",
+               "var a,b,c,d,e;         c = 1        ; print(c)");
+    inFunction("var a,b,c,d,e; a = b = c = d = e = 1; print(a + e)",
+               "var a,b,c,d,e; a =             e = 1; print(a + e)");
+    inFunction("var a,b,c,d,e; a = b = c = d = e = 1; print(b + d)",
+               "var a,b,c,d,e;     b =     d     = 1; print(b + d)");
+    inFunction("var a,b,c,d,e; a = b = c = d = e = 1; print(a + b + d + e)",
+               "var a,b,c,d,e; a = b =     d = e = 1; print(a + b + d + e)");
+    inFunction("var a,b,c,d,e; a = b = c = d = e = 1; print(a+b+c+d+e)");
+  }
+  
+  public void testAssignmentOpChain() {
+    inFunction("var a,b,c,d,e; a = b = c += d = e = 1",
+               "var a,b,c,d,e;         c + 1");
+    inFunction("var a,b,c,d,e; a = b = c += d = e = 1;  print(e)",
+               "var a,b,c,d,e;         c +     (e = 1); print(e)");
+    inFunction("var a,b,c,d,e; a = b = c += d = e = 1;  print(d)",
+               "var a,b,c,d,e;         c + (d = 1)  ;   print(d)");
+    inFunction("var a,b,c,d,e; a = b = c += d = e = 1;  print(a)",
+               "var a,b,c,d,e; a =     c +          1;  print(a)");
+  }
+  
+  public void testIncDecInSubExpressions() {
+    inFunction("var a; a = 1, a++; a");
+  }
+  
+  public void testNestedReassignments() {
+    inFunction("var a; a = (a = 1)", "var a; 1");
+    inFunction("var a; a = (a *= 2)", "var a; a*2");
+    
+    // TODO(user): ++ not supported.
+    
+    // Note a = (a++) is not same as a++. Only if 'a' is dead.
+    inFunction("var a; a = (a++)", "var a; a++");
+    inFunction("var a; a = (++a)", "var a; ++a");
+    
+    inFunction("var a; a = (b = (a = 1))", "var a; b = 1");
+    inFunction("var a; a = (b = (a *= 2))", "var a; b = a * 2");
+    inFunction("var a; a = (b = (a++))", "var a; b=a++");
+    inFunction("var a; a = (b = (++a))", "var a; b=++a");
+    
+    // Include b as local.
+    inFunction("var a,b; a = (b = (a = 1))", "var a,b; 1");
+    inFunction("var a,b; a = (b = (a *= 2))", "var a,b; a * 2");
+    inFunction("var a,b; a = (b = (a++))", "var a,b; a++");
+    inFunction("var a,b; a = (b = (++a))", "var a,b; ++a");
+    
+    inFunction("var a; a += (a++)", "var a; a+a++");
+    inFunction("var a; a += (++a)", "var a; a+ ++a");
+    
+    // Include b as local.
+    inFunction("var a,b; a += (b = (a = 1))", "var a,b; a + 1");
+    inFunction("var a,b; a += (b = (a *= 2))", "var a,b; a + (a * 2)");
+    inFunction("var a,b; a += (b = (a++))", "var a,b; a + a++");
+    inFunction("var a,b; a += (b = (++a))", "var a,b; a+(++a)"); 
+  }
+  
+  public void testIncrementalReassignmentInForLoops() {
+    inFunction("for(;x+=1;x+=1) {}");
+    inFunction("for(;x;x+=1){}");
+    inFunction("for(;x+=1;){foo(x)}");
+    inFunction("for(;1;x+=1){foo(x)}");
+  }
+  
   private void inFunction(String src) {
     inFunction(src, src);
   }
diff --git a/test/com/google/javascript/jscomp/OptimizeArgumentsArrayTest.java b/test/com/google/javascript/jscomp/OptimizeArgumentsArrayTest.java
index 215744c..25cdd90 100644
--- a/test/com/google/javascript/jscomp/OptimizeArgumentsArrayTest.java
+++ b/test/com/google/javascript/jscomp/OptimizeArgumentsArrayTest.java
@@ -88,11 +88,6 @@
        + "  {alert(r0 + r1 + opt_1 + opt_2 + p1); }");
   }
 
-  public void testNotAllIndexKnown() {
-    test("function foo(  ) {alert(arguments[0] + arguments[x]);}",
-         "function foo(p0) {alert(          p0 + arguments[x]);}");
-  }
-
   public void testInnerFunctions() {
     test("function f() { function b(  ) { arguments[0]  }}",
          "function f() { function b(p0) {            p0 }}");
@@ -147,4 +142,11 @@
   public void testNoOptimizationWhenGetProp() {
     testSame("function f() { arguments[0]; arguments.size }");
   }
+  
+  public void testNoOptimizationWhenIndexIsNotNumberConstant() {
+    testSame("function f() { arguments[0]; arguments['callee'].length}");
+    testSame("function f() { arguments[0]; arguments.callee.length}");
+    testSame(
+        "function f() { arguments[0]; var x = 'callee'; arguments[x].length}");
+  }
 }
diff --git a/test/com/google/javascript/jscomp/RenameVarsTest.java b/test/com/google/javascript/jscomp/RenameVarsTest.java
index efd9804..67c08d4 100644
--- a/test/com/google/javascript/jscomp/RenameVarsTest.java
+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java
@@ -35,8 +35,18 @@
   private boolean withClosurePass = false;
   private boolean localRenamingOnly = false;
   private boolean preserveAnonymousFunctionNames = false;
+  private boolean useGoogleCodingConvention = true;
 
   @Override
+  protected CodingConvention getCodingConvention() {
+    if (useGoogleCodingConvention) {
+      return new GoogleCodingConvention();
+    } else {
+      return new DefaultCodingConvention();
+    }
+  }
+  
+  @Override
   protected CompilerPass getProcessor(Compiler compiler) {
     if (withClosurePass) {
       return new ClosurePassAndRenameVars(compiler);
@@ -426,6 +436,20 @@
     test("var goog, a, b; goog.exportSymbol(a, b);",
          "var a, b, c; a.exportSymbol(b, c);");
   }
+  
+  public void testDollarSignSuperExport() {
+    useGoogleCodingConvention = false;
+    // See http://code.google.com/p/closure-compiler/issues/detail?id=32
+    test("var x = function($super,duper,$fantastic){}",
+         "var c = function($super,    a,        b){}");
+    
+    localRenamingOnly = false;
+    test("var $super = 1", "var a = 1");
+
+    useGoogleCodingConvention = true;
+    test("var x = function($super,duper,$fantastic){}",
+         "var d = function(a,     b,    c        ){}");
+  }
 
   private void testRenameMapUsingOldMap(String input, String expected,
                                         VariableMap expectedMap) {
diff --git a/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java b/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java
index ff6b476..306420c 100644
--- a/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java
+++ b/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java
@@ -18,8 +18,8 @@
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multiset;
-import com.google.common.collect.Multisets;
 import com.google.common.collect.Sets;
+import com.google.common.collect.TreeMultiset;
 import com.google.javascript.jscomp.DefinitionsRemover.Definition;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.rhino.Node;
@@ -326,7 +326,7 @@
         sb.append(" ");
         sb.append(node.getQualifiedName());
         sb.append(" -> ");
-        Multiset<String> defstrs = Multisets.newTreeMultiset();
+        Multiset<String> defstrs = TreeMultiset.create();
         for (Definition def : defs) {
           Node rValue = def.getRValue();
           if (rValue != null) {
