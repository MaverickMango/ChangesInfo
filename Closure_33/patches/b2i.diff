diff -r -u buggy/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java inducing/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java
--- buggy/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java	2023-06-12 11:34:21.126123211 +0800
+++ inducing/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java	2023-06-12 11:34:21.778135132 +0800
@@ -40,14 +40,14 @@
 package com.google.javascript.rhino.jstype;
 
 import static com.google.common.base.Preconditions.checkState;
-import com.google.common.base.Preconditions;
-import com.google.common.collect.ImmutableList;
+
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.google.javascript.rhino.ErrorReporter;
 import com.google.javascript.rhino.JSDocInfo;
 import com.google.javascript.rhino.Node;
 
+import java.io.Serializable;
 import java.util.Map;
 import java.util.Set;
 
@@ -79,11 +79,6 @@
   // some subclasses override this to do special resolution handling.
   private ObjectType implicitPrototypeFallback;
 
-  // If this is a function prototype, then this is the owner.
-  // A PrototypeObjectType can only be the prototype of one function. If we try
-  // to do this for multiple functions, then we'll have to create a new one.
-  private FunctionType ownerFunction = null;
-
   // Whether the toString representation of this should be pretty-printed,
   // by printing all properties.
   private boolean prettyPrint = false;
@@ -124,27 +119,6 @@
     }
   }
 
-  @Override
-  public Property getSlot(String name) {
-    if (properties.containsKey(name)) {
-      return properties.get(name);
-    }
-    ObjectType implicitPrototype = getImplicitPrototype();
-    if (implicitPrototype != null) {
-      Property prop = implicitPrototype.getSlot(name);
-      if (prop != null) {
-        return prop;
-      }
-    }
-    for (ObjectType interfaceType : getCtorExtendedInterfaces()) {
-      Property prop = interfaceType.getSlot(name);
-      if (prop != null) {
-        return prop;
-      }
-    }
-    return null;
-  }
-
   /**
    * Gets the number of properties of this object.
    */
@@ -165,8 +139,14 @@
 
   @Override
   public boolean hasProperty(String propertyName) {
-    // Unknown types have all properties.
-    return isUnknownType() || getSlot(propertyName) != null;
+    if (properties.get(propertyName) != null) {
+      return true;
+    }
+    ObjectType implicitPrototype = getImplicitPrototype();
+    if (implicitPrototype != null) {
+      return implicitPrototype.hasProperty(propertyName);
+    }
+    return false;
   }
 
   @Override
@@ -181,11 +161,16 @@
 
   @Override
   public boolean isPropertyTypeDeclared(String property) {
-    StaticSlot<JSType> slot = getSlot(property);
-    if (slot == null) {
+    Property p = properties.get(property);
+    if (p == null) {
+      ObjectType implicitPrototype = getImplicitPrototype();
+      if (implicitPrototype != null) {
+        return implicitPrototype.isPropertyTypeDeclared(property);
+      }
+      // property does not exist
       return false;
     }
-    return !slot.isTypeInferred();
+    return !p.inferred;
   }
 
   @Override
@@ -201,27 +186,36 @@
 
   @Override
   public boolean isPropertyTypeInferred(String property) {
-    StaticSlot<JSType> slot = getSlot(property);
-    if (slot == null) {
+    Property p = properties.get(property);
+    if (p == null) {
+      ObjectType implicitPrototype = getImplicitPrototype();
+      if (implicitPrototype != null) {
+        return implicitPrototype.isPropertyTypeInferred(property);
+      }
+      // property does not exist
       return false;
     }
-    return slot.isTypeInferred();
+    return p.inferred;
   }
 
   @Override
-  public JSType getPropertyType(String property) {
-    StaticSlot<JSType> slot = getSlot(property);
-    if (slot == null) {
-      return getNativeType(JSTypeNative.UNKNOWN_TYPE);
+  public JSType getPropertyType(String propertyName) {
+    Property p = properties.get(propertyName);
+    if (p != null) {
+      return p.type;
+    }
+    ObjectType implicitPrototype = getImplicitPrototype();
+    if (implicitPrototype != null) {
+      return implicitPrototype.getPropertyType(propertyName);
     }
-    return slot.getType();
+    return getNativeType(JSTypeNative.UNKNOWN_TYPE);
   }
 
   @Override
   public boolean isPropertyInExterns(String propertyName) {
     Property p = properties.get(propertyName);
     if (p != null) {
-      return p.isFromExterns();
+      return p.inExterns;
     }
     ObjectType implicitPrototype = getImplicitPrototype();
     if (implicitPrototype != null) {
@@ -232,32 +226,26 @@
 
   @Override
   boolean defineProperty(String name, JSType type, boolean inferred,
-      Node propertyNode) {
+      boolean inExterns, Node propertyNode) {
     if (hasOwnDeclaredProperty(name)) {
       return false;
     }
-    Property newProp = new Property(
-        name, type, inferred, propertyNode);
+    Property newProp = new Property(type, inferred, inExterns, propertyNode);
     Property oldProp = properties.get(name);
     if (oldProp != null) {
       // This is to keep previously inferred jsdoc info, e.g., in a
       // replaceScript scenario.
-      newProp.setJSDocInfo(oldProp.getJSDocInfo());
+      newProp.docInfo = oldProp.docInfo;
     }
     properties.put(name, newProp);
     return true;
   }
 
   @Override
-  public boolean removeProperty(String name) {
-    return properties.remove(name) != null;
-  }
-
-  @Override
   public Node getPropertyNode(String propertyName) {
     Property p = properties.get(propertyName);
     if (p != null) {
-      return p.getNode();
+      return p.propertyNode;
     }
     ObjectType implicitPrototype = getImplicitPrototype();
     if (implicitPrototype != null) {
@@ -270,27 +258,28 @@
   public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {
     Property p = properties.get(propertyName);
     if (p != null) {
-      return p.getJSDocInfo();
+      return p.docInfo;
     }
     return null;
   }
 
   @Override
-  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) {
+  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info,
+      boolean inExterns) {
     if (info != null) {
       if (!properties.containsKey(propertyName)) {
         // If docInfo was attached, but the type of the property
         // was not defined anywhere, then we consider this an explicit
         // declaration of the property.
         defineInferredProperty(propertyName, getPropertyType(propertyName),
-            null);
+            inExterns, null);
       }
 
       // The prototype property is not represented as a normal Property.
       // We probably don't want to attach any JSDoc to it anyway.
       Property property = properties.get(propertyName);
       if (property != null) {
-        property.setJSDocInfo(info);
+        property.docInfo = info;
       }
     }
   }
@@ -313,7 +302,7 @@
    * present on the object and different from the native one.
    */
   private boolean hasOverridenNativeProperty(String propertyName) {
-    if (isNativeObjectType()) {
+    if (isNative()) {
       return false;
     }
 
@@ -349,14 +338,19 @@
     return isRegexpType();
   }
 
+  /**
+   * Whether this represents a native type (such as Object, Date,
+   * RegExp, etc.).
+   */
+  boolean isNative() {
+    return nativeType;
+  }
+
   @Override
-  String toStringHelper(boolean forAnnotations) {
+  public String toString() {
     if (hasReferenceName()) {
       return getReferenceName();
     } else if (prettyPrint) {
-      // Don't pretty print recursively.
-      prettyPrint = false;
-
       // Use a tree set so that the properties are sorted.
       Set<String> propertyNames = Sets.newTreeSet();
       for (ObjectType current = this;
@@ -377,21 +371,19 @@
 
         sb.append(property);
         sb.append(": ");
-        sb.append(getPropertyType(property).toStringHelper(forAnnotations));
+        sb.append(getPropertyType(property).toString());
 
         ++i;
-        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {
+        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
           sb.append(", ...");
           break;
         }
       }
 
       sb.append("}");
-
-      prettyPrint = true;
       return sb.toString();
     } else {
-      return forAnnotations ? "?" : "{...}";
+      return "{...}";
     }
   }
 
@@ -399,10 +391,6 @@
     this.prettyPrint = prettyPrint;
   }
 
-  boolean isPrettyPrint() {
-    return prettyPrint;
-  }
-
   @Override
   public FunctionType getConstructor() {
     return null;
@@ -428,8 +416,6 @@
   public String getReferenceName() {
     if (className != null) {
       return className;
-    } else if (ownerFunction != null) {
-      return ownerFunction.getReferenceName() + ".prototype";
     } else {
       return null;
     }
@@ -437,25 +423,25 @@
 
   @Override
   public boolean hasReferenceName() {
-    return className != null || ownerFunction != null;
+    return className != null;
   }
 
   @Override
   public boolean isSubtype(JSType that) {
-    if (JSType.isSubtypeHelper(this, that)) {
+    if (JSType.isSubtype(this, that)) {
       return true;
     }
 
     // Union types
-    if (that.isUnionType()) {
+    if (that instanceof UnionType) {
       // The static {@code JSType.isSubtype} check already decomposed
       // union types, so we don't need to check those again.
       return false;
     }
 
     // record types
-    if (that.isRecordType()) {
-      return RecordType.isSubtype(this, that.toMaybeRecordType());
+    if (that instanceof RecordType) {
+      return RecordType.isSubtype(this, (RecordType) that);
     }
 
     // Interfaces
@@ -472,22 +458,18 @@
       }
     }
 
-    if (getConstructor() != null && getConstructor().isInterface()) {
-      for (ObjectType thisInterface : getCtorExtendedInterfaces()) {
-        if (thisInterface.isSubtype(that)) {
-          return true;
-        }
+    // other prototype based objects
+    if (that != null) {
+      if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
+        // If unsure, say 'yes', to avoid spurious warnings.
+        // TODO(user): resolve the prototype chain completely in all cases,
+        // to avoid guessing.
+        return true;
       }
+      return this.isImplicitPrototype(thatObj);
     }
 
-    // other prototype based objects
-    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
-      // If unsure, say 'yes', to avoid spurious warnings.
-      // TODO(user): resolve the prototype chain completely in all cases,
-      // to avoid guessing.
-      return true;
-    }
-    return this.isImplicitPrototype(thatObj);
+    return false;
   }
 
   private boolean implicitPrototypeChainIsUnknown() {
@@ -501,6 +483,42 @@
     return false;
   }
 
+  private static final class Property implements Serializable {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Property's type.
+     */
+    private JSType type;
+
+    /**
+     * Whether the property's type is inferred.
+     */
+    private final boolean inferred;
+
+    /**
+     * Whether the property is defined in the externs.
+     */
+    private final boolean inExterns;
+
+    /**
+     * The node corresponding to this property, e.g., a GETPROP node that
+     * declares this property.
+     */
+    private final Node propertyNode;
+
+    /**  The JSDocInfo for this property. */
+    private JSDocInfo docInfo = null;
+
+    private Property(JSType type, boolean inferred, boolean inExterns,
+        Node propertyNode) {
+      this.type = type;
+      this.inferred = inferred;
+      this.inExterns = inExterns;
+      this.propertyNode = propertyNode;
+    }
+  }
+
   @Override
   public boolean hasCachedValues() {
     return super.hasCachedValues();
@@ -512,30 +530,6 @@
     return nativeType;
   }
 
-  void setOwnerFunction(FunctionType type) {
-    Preconditions.checkState(ownerFunction == null || type == null);
-    ownerFunction = type;
-  }
-
-  @Override
-  public FunctionType getOwnerFunction() {
-    return ownerFunction;
-  }
-
-  @Override
-  public Iterable<ObjectType> getCtorImplementedInterfaces() {
-    return isFunctionPrototypeType()
-        ? getOwnerFunction().getImplementedInterfaces()
-        : ImmutableList.<ObjectType>of();
-  }
-
-  @Override
-  public Iterable<ObjectType> getCtorExtendedInterfaces() {
-    return isFunctionPrototypeType()
-        ? getOwnerFunction().getExtendedInterfaces()
-        : ImmutableList.<ObjectType>of();
-  }
-
   @Override
   JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
     setResolvedTypeInternal(this);
@@ -546,34 +540,8 @@
           (ObjectType) implicitPrototype.resolve(t, scope);
     }
     for (Property prop : properties.values()) {
-      prop.setType(safeResolve(prop.getType(), t, scope));
+      prop.type = safeResolve(prop.type, t, scope);
     }
     return this;
   }
-
-  @Override
-  public void matchConstraint(ObjectType constraintObj) {
-    // Handle the case where the constraint object is a record type.
-    //
-    // param constraintObj {{prop: (number|undefined)}}
-    // function f(constraintObj) {}
-    // f({});
-    //
-    // We want to modify the object literal to match the constraint, by
-    // taking any each property on the record and trying to match
-    // properties on this object.
-    if (constraintObj.isRecordType()) {
-      for (String prop : constraintObj.getOwnPropertyNames()) {
-        JSType propType = constraintObj.getPropertyType(prop);
-        if (!isPropertyTypeDeclared(prop)) {
-          JSType typeToInfer = propType;
-          if (!hasProperty(prop)) {
-            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
-                .getLeastSupertype(propType);
-          }
-          defineInferredProperty(prop, typeToInfer, null);
-        }
-      }
-    }
-  }
 }
diff -r -u buggy/test/com/google/javascript/jscomp/TypeCheckTest.java inducing/test/com/google/javascript/jscomp/TypeCheckTest.java
--- buggy/test/com/google/javascript/jscomp/TypeCheckTest.java	2023-06-12 11:34:21.126123211 +0800
+++ inducing/test/com/google/javascript/jscomp/TypeCheckTest.java	2023-06-12 11:34:21.782135205 +0800
@@ -19,7 +19,6 @@
 import com.google.common.base.Joiner;
 import com.google.common.collect.Lists;
 import com.google.javascript.jscomp.Scope.Var;
-import com.google.javascript.rhino.InputId;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.jstype.FunctionType;
@@ -46,7 +45,7 @@
 
   public void testInitialTypingScope() {
     Scope s = new TypedScopeCreator(compiler,
-        CodingConventions.getDefault()).createInitialScope(
+        new DefaultCodingConvention()).createInitialScope(
             new Node(Token.BLOCK));
 
     assertEquals(ARRAY_FUNCTION_TYPE, s.getVar("Array").getType());
@@ -102,6 +101,11 @@
         "/** @type {undefined|number} */var a;if (a == foo())return;}");
   }
 
+  public void testTypeCheck7() throws Exception {
+    testTypes("function foo() {delete 'abc';}",
+        TypeCheck.BAD_DELETE);
+  }
+
   public void testTypeCheck8() throws Exception {
     testTypes("/**@return {void}*/function foo(){do {} while (foo());}");
   }
@@ -226,17 +230,6 @@
         "required: string", false);
   }
 
-
-  public void testTypeCheckCustomExterns2() throws Exception {
-    testTypes(
-        DEFAULT_EXTERNS + "/** @enum {string} */ var Enum = {FOO: 1, BAR: 1};",
-        "/** @param {Enum} x */ function f(x) {} f(Enum.FOO); f(true);",
-        "actual parameter 1 of f does not match formal parameter\n" +
-        "found   : boolean\n" +
-        "required: Enum.<string>",
-        false);
-  }
-
   public void testParameterizedArray1() throws Exception {
     testTypes("/** @param {!Array.<number>} a\n" +
         "* @return {string}\n" +
@@ -251,7 +244,7 @@
         "* @return {number}\n" +
         "*/ var f = function(a) { return a[0]; };",
         "inconsistent return type\n" +
-        "found   : Array.<number>\n" +
+        "found   : Array\n" +
         "required: number");
   }
 
@@ -329,16 +322,6 @@
         "required: E.<string>");
   }
 
-  public void testParameterizedObject5() throws Exception {
-    testTypes("/** @constructor */ function F() {" +
-        "  /** @type {Object.<number, string>} */ this.numbers = {};" +
-        "}" +
-        "(new F()).numbers['ten'] = '10';",
-        "restricted index type\n" +
-        "found   : string\n" +
-        "required: number");
-  }
-
   public void testUnionOfFunctionAndType() throws Exception {
     testTypes("/** @type {null|(function(Number):void)} */ var a;" +
         "/** @type {(function(Number):void)|null} */ var b = null; a = b;");
@@ -629,7 +612,7 @@
     // Don't do type inference on GETELEMs.
     testClosureTypes(
         CLOSURE_DEFS +
-        "function f(x) { " +
+        "function f(arguments) { " +
         "  return goog.isString(arguments[0]) ? arguments[0] : 0;" +
         "}", null);
   }
@@ -638,7 +621,7 @@
     // Don't do type inference on GETELEMs.
     testClosureTypes(
         CLOSURE_DEFS +
-        "function f(x) { " +
+        "function f(arguments) { " +
         "  return typeof arguments[0] == 'string' ? arguments[0] : 0;" +
         "}", null);
   }
@@ -851,37 +834,6 @@
         "};");
   }
 
-  public void testUndeclaredGlobalProperty1() throws Exception {
-    testTypes("/** @const */ var x = {}; x.y = null;" +
-        "function f(a) { x.y = a; }" +
-        "/** @param {string} a */ function g(a) { }" +
-        "function h() { g(x.y); }");
-  }
-
-  public void testUndeclaredGlobalProperty2() throws Exception {
-    testTypes("/** @const */ var x = {}; x.y = null;" +
-        "function f() { x.y = 3; }" +
-        "/** @param {string} a */ function g(a) { }" +
-        "function h() { g(x.y); }",
-        "actual parameter 1 of g does not match formal parameter\n" +
-        "found   : (null|number)\n" +
-        "required: string");
-  }
-
-  public void testLocallyInferredGlobalProperty1() throws Exception {
-    // We used to have a bug where x.y.z leaked from f into h.
-    testTypes(
-        "/** @constructor */ function F() {}" +
-        "/** @type {number} */ F.prototype.z;" +
-        "/** @const */ var x = {}; /** @type {F} */ x.y;" +
-        "function f() { x.y.z = 'abc'; }" +
-        "/** @param {number} x */ function g(x) {}" +
-        "function h() { g(x.y.z); }",
-        "assignment to property z of F\n" +
-        "found   : string\n" +
-        "required: number");
-  }
-
   public void testPropertyInferredPropagation() throws Exception {
     testTypes("/** @return {Object} */function f() { return {}; }\n" +
          "function g() { var x = f(); if (x.p) x.a = 'a'; else x.a = 'b'; }\n" +
@@ -971,38 +923,6 @@
         "required: string");
   }
 
-  public void testPropertyInference9() throws Exception {
-    testTypes(
-        "/** @constructor */ function A() {}" +
-        "/** @return {function(): ?} */ function f() { " +
-        "  return function() {};" +
-        "}" +
-        "var g = f();" +
-        "/** @type {number} */ g.prototype.bar_ = null;",
-        "assignment\n" +
-        "found   : null\n" +
-        "required: number");
-  }
-
-  public void testPropertyInference10() throws Exception {
-    // NOTE(nicksantos): There used to be a bug where a property
-    // on the prototype of one structural function would leak onto
-    // the prototype of other variables with the same structural
-    // function type.
-    testTypes(
-        "/** @constructor */ function A() {}" +
-        "/** @return {function(): ?} */ function f() { " +
-        "  return function() {};" +
-        "}" +
-        "var g = f();" +
-        "/** @type {number} */ g.prototype.bar_ = 1;" +
-        "var h = f();" +
-        "/** @type {string} */ h.prototype.bar_ = 1;",
-        "assignment\n" +
-        "found   : number\n" +
-        "required: string");
-  }
-
   public void testNoPersistentTypeInferenceForObjectProperties()
       throws Exception {
     testTypes("/** @param {Object} o\n@param {string} x */\n" +
@@ -1497,21 +1417,6 @@
         "required: number");
   }
 
-  public void testScoping12() throws Exception {
-    testTypes(
-        "/** @constructor */ function F() {}" +
-        "/** @type {number} */ F.prototype.bar = 3;" +
-        "/** @param {!F} f */ function g(f) {" +
-        "  /** @return {string} */" +
-        "  function h() {" +
-        "    return f.bar;" +
-        "  }" +
-        "}",
-        "inconsistent return type\n" +
-        "found   : number\n" +
-        "required: string");
-  }
-
   public void testFunctionArguments1() throws Exception {
     testFunctionType(
         "/** @param {number} a\n@return {string} */" +
@@ -1523,7 +1428,7 @@
     testFunctionType(
         "/** @param {number} opt_a\n@return {string} */" +
         "function f(opt_a) {}",
-        "function (number=): string");
+        "function ((number|undefined)): string");
   }
 
   public void testFunctionArguments3() throws Exception {
@@ -1537,7 +1442,7 @@
     testFunctionType(
         "/** @param {number} opt_a\n@return {string} */" +
         "function f(a,opt_a) {}",
-        "function (?, number=): string");
+        "function (?, (number|undefined)): string");
   }
 
   public void testFunctionArguments5() throws Exception {
@@ -1590,13 +1495,13 @@
   }
 
   public void testFunctionArguments13() throws Exception {
-    // verifying that the argument type have non-inferrable types
+    // verifying that the argument type have inferable types
     testTypes(
         "/** @return {boolean} */ function u() { return true; }" +
-        "/** @param {boolean} b\n@return {?boolean} */" +
+        "/** @param {boolean} b\n@return {boolean} */" +
         "function f(b) { if (u()) { b = null; } return b; }",
-        "assignment\n" +
-        "found   : null\n" +
+        "inconsistent return type\n" +
+        "found   : (boolean|null)\n" +
         "required: boolean");
   }
 
@@ -1681,7 +1586,7 @@
   public void testFunctionInference6() throws Exception {
     testFunctionType(
         "/** @this Date\n@return {string} */function f(opt_a) {}",
-        "function (this:Date, ?=): string");
+        "function (this:Date, ?): string");
   }
 
   public void testFunctionInference7() throws Exception {
@@ -1907,43 +1812,6 @@
         "}");
   }
 
-  public void testInnerFunction10() throws Exception {
-    testTypes(
-        "function f() {" +
-        "  /** @type {?number} */ var x = null;" +
-        "  /** @return {string} */" +
-        "  function g() {" +
-        "    if (!x) {" +
-        "      x = 1;" +
-        "    }" +
-        "    return x;" +
-        "  }" +
-        "}",
-        "inconsistent return type\n" +
-        "found   : number\n" +
-        "required: string");
-  }
-
-  public void testInnerFunction11() throws Exception {
-    // TODO(nicksantos): This is actually bad inference, because
-    // h sets x to null. We should fix this, but for now we do it
-    // this way so that we don't break existing binaries. We will
-    // need to change TypeInference#isUnflowable to fix this.
-    testTypes(
-        "function f() {" +
-        "  /** @type {?number} */ var x = null;" +
-        "  /** @return {number} */" +
-        "  function g() {" +
-        "    x = 1;" +
-        "    h();" +
-        "    return x;" +
-        "  }" +
-        "  function h() {" +
-        "    x = null;" +
-        "  }" +
-        "}");
-  }
-
   public void testAbstractMethodHandling1() throws Exception {
     testTypes(
         "/** @type {Function} */ var abstractFn = function() {};" +
@@ -2073,7 +1941,10 @@
         "/** @constructor \n * @extends {F} */ " +
         "function G() {}" +
         "/** @override */ G.prototype.foo = function() { };" +
-        "(new G()).foo(1);");
+        "(new G()).foo(1);",
+        "Function G.prototype.foo: called with 1 argument(s). " +
+        "Function requires at least 0 argument(s) " +
+        "and no more than 0 argument(s).");
   }
 
   public void testMethodInference7() throws Exception {
@@ -2082,11 +1953,11 @@
         "F.prototype.foo = function() { };" +
         "/** @constructor \n * @extends {F} */ " +
         "function G() {}" +
-        "/** @override */ G.prototype.foo = function(x, y) { };",
-        "mismatch of the foo property type and the type of the property " +
-        "it overrides from superclass F\n" +
-        "original: function (this:F): undefined\n" +
-        "override: function (this:G, ?, ?): undefined");
+        "/** @override */ G.prototype.foo = function(x, y) { };" +
+        "(new G()).foo();",
+        "Function G.prototype.foo: called with 0 argument(s). " +
+        "Function requires at least 2 argument(s) " +
+        "and no more than 2 argument(s).");
   }
 
   public void testMethodInference8() throws Exception {
@@ -2096,8 +1967,10 @@
         "/** @constructor \n * @extends {F} */ " +
         "function G() {}" +
         "/** @override */ " +
-        "G.prototype.foo = function(opt_b, var_args) { };" +
-        "(new G()).foo(1, 2, 3);");
+        "G.prototype.foo = function(a, opt_b, var_args) { };" +
+        "(new G()).foo();",
+        "Function G.prototype.foo: called with 0 argument(s). " +
+        "Function requires at least 1 argument(s).");
   }
 
   public void testMethodInference9() throws Exception {
@@ -2107,7 +1980,7 @@
         "/** @constructor \n * @extends {F} */ " +
         "function G() {}" +
         "/** @override */ " +
-        "G.prototype.foo = function(var_args, opt_b) { };",
+        "G.prototype.foo = function(a, var_args, opt_b) { };",
         "variable length argument must be last");
   }
 
@@ -2206,31 +2079,23 @@
   }
 
   public void testDuplicateStaticPropertyDecl4() throws Exception {
-    testClosureTypesMultipleWarnings(
+    testTypes(
         "var goog = goog || {};" +
         "/** @type {!Foo} */ goog.foo;" +
         "/** @type {string} */ goog.foo = 'x';" +
         "/** @constructor */ function Foo() {}",
-        Lists.newArrayList(
-            "assignment to property foo of goog\n" +
-            "found   : string\n" +
-            "required: Foo",
-            "variable goog.foo redefined with type string, " +
-            "original definition at [testcode]:1 with type Foo"));
+        "variable goog.foo redefined with type string, " +
+        "original definition at [testcode]:1 with type Foo");
   }
 
   public void testDuplicateStaticPropertyDecl5() throws Exception {
-    testClosureTypesMultipleWarnings(
+    testTypes(
         "var goog = goog || {};" +
         "/** @type {!Foo} */ goog.foo;" +
         "/** @type {string}\n * @suppress {duplicate} */ goog.foo = 'x';" +
         "/** @constructor */ function Foo() {}",
-        Lists.newArrayList(
-            "assignment to property foo of goog\n" +
-            "found   : string\n" +
-            "required: Foo",
-            "variable goog.foo redefined with type string, " +
-            "original definition at [testcode]:1 with type Foo"));
+        "variable goog.foo redefined with type string, " +
+        "original definition at [testcode]:1 with type Foo");
   }
 
   public void testDuplicateStaticPropertyDecl6() throws Exception {
@@ -2263,89 +2128,12 @@
         "/** @constructor */ function EventCopy() {}");
   }
 
-  public void testDuplicateStaticPropertyDec20() throws Exception {
-    testTypes(
-        "/**\n" +
-        " * @fileoverview\n" +
-        " * @suppress {duplicate}\n" +
-        " */" +
-        "var goog = goog || {};" +
-        "/** @type {string} */ goog.foo = 'y';" +
-        "/** @type {string} */ goog.foo = 'x';");
-  }
-
   public void testDuplicateLocalVarDecl() throws Exception {
-    testClosureTypesMultipleWarnings(
+    testTypes(
         "/** @param {number} x */\n" +
         "function f(x) { /** @type {string} */ var x = ''; }",
-        Lists.newArrayList(
-            "variable x redefined with type string, original definition" +
-            " at [testcode]:2 with type number",
-            "initializing variable\n" +
-            "found   : string\n" +
-            "required: number"));
-  }
-
-  public void testDuplicateInstanceMethod1() throws Exception {
-    // If there's no jsdoc on the methods, then we treat them like
-    // any other inferred properties.
-    testTypes(
-        "/** @constructor */ function F() {}" +
-        "F.prototype.bar = function() {};" +
-        "F.prototype.bar = function() {};");
-  }
-
-  public void testDuplicateInstanceMethod2() throws Exception {
-    testTypes(
-        "/** @constructor */ function F() {}" +
-        "/** jsdoc */ F.prototype.bar = function() {};" +
-        "/** jsdoc */ F.prototype.bar = function() {};",
-        "variable F.prototype.bar redefined with type " +
-        "function (this:F): undefined, original definition at " +
-        "[testcode]:1 with type function (this:F): undefined");
-  }
-
-  public void testDuplicateInstanceMethod3() throws Exception {
-    testTypes(
-        "/** @constructor */ function F() {}" +
-        "F.prototype.bar = function() {};" +
-        "/** jsdoc */ F.prototype.bar = function() {};",
-        "variable F.prototype.bar redefined with type " +
-        "function (this:F): undefined, original definition at " +
-        "[testcode]:1 with type function (this:F): undefined");
-  }
-
-  public void testDuplicateInstanceMethod4() throws Exception {
-    testTypes(
-        "/** @constructor */ function F() {}" +
-        "/** jsdoc */ F.prototype.bar = function() {};" +
-        "F.prototype.bar = function() {};");
-  }
-
-  public void testDuplicateInstanceMethod5() throws Exception {
-    testTypes(
-        "/** @constructor */ function F() {}" +
-        "/** jsdoc \n * @return {number} */ F.prototype.bar = function() {" +
-        "  return 3;" +
-        "};" +
-        "/** jsdoc \n * @suppress {duplicate} */ " +
-        "F.prototype.bar = function() { return ''; };",
-        "inconsistent return type\n" +
-        "found   : string\n" +
-        "required: number");
-  }
-
-  public void testDuplicateInstanceMethod6() throws Exception {
-    testTypes(
-        "/** @constructor */ function F() {}" +
-        "/** jsdoc \n * @return {number} */ F.prototype.bar = function() {" +
-        "  return 3;" +
-        "};" +
-        "/** jsdoc \n * @return {string} * \n @suppress {duplicate} */ " +
-        "F.prototype.bar = function() { return ''; };",
-        "assignment to property bar of F.prototype\n" +
-        "found   : function (this:F): string\n" +
-        "required: function (this:F): number");
+        "variable x redefined with type string, " +
+        "original definition at [testcode]:2 with type number");
   }
 
   public void testStubFunctionDeclaration1() throws Exception {
@@ -2498,7 +2286,7 @@
   public void testIn4() throws Exception {
     testTypes("Date in Object",
         "left side of 'in'\n" +
-        "found   : function (new:Date, ?=, ?=, ?=, ?=, ?=, ?=, ?=): string\n" +
+        "found   : function (new:Date, ?, ?, ?, ?, ?, ?, ?): string\n" +
         "required: string");
   }
 
@@ -2755,20 +2543,19 @@
 
   public void testEnum3() throws Exception {
     testTypes("/**@enum*/var a={BB:1,BB:2}",
-        "variable a.BB redefined with type a.<number>, " +
-        "original definition at [testcode]:1 with type a.<number>");
+        "enum element BB already defined", true);
   }
 
   public void testEnum4() throws Exception {
     testTypes("/**@enum*/var a={BB:'string'}",
-        "assignment to property BB of enum{a}\n" +
+        "element type must match enum's type\n" +
         "found   : string\n" +
         "required: number");
   }
 
   public void testEnum5() throws Exception {
     testTypes("/**@enum {String}*/var a={BB:'string'}",
-        "assignment to property BB of enum{a}\n" +
+        "element type must match enum's type\n" +
         "found   : string\n" +
         "required: (String|null)");
   }
@@ -2787,23 +2574,15 @@
   }
 
   public void testEnum8() throws Exception {
-    testClosureTypesMultipleWarnings("/** @enum */var a=8;",
-        Lists.newArrayList(
-            "enum initializer must be an object literal or an enum",
-            "initializing variable\n" +
-            "found   : number\n" +
-            "required: enum{a}"));
+    testTypes("/** @enum */var a=8;",
+        "enum initializer must be an object literal or an enum");
   }
 
   public void testEnum9() throws Exception {
-    testClosureTypesMultipleWarnings(
+    testTypes(
         "var goog = {};" +
         "/** @enum */goog.a=8;",
-        Lists.newArrayList(
-            "assignment to property a of goog\n" +
-            "found   : number\n" +
-            "required: enum{goog.a}",
-            "enum initializer must be an object literal or an enum"));
+        "enum initializer must be an object literal or an enum");
   }
 
   public void testEnum10() throws Exception {
@@ -2850,15 +2629,14 @@
 
   public void testEnum16() throws Exception {
     testTypes("var goog = {};" +
-        "/**@enum*/goog .a={BB:1,BB:2}",
-        "variable goog.a.BB redefined with type goog.a.<number>, " +
-        "original definition at [testcode]:1 with type goog.a.<number>");
+        "/**@enum*/goog.a={BB:1,BB:2}",
+        "enum element BB already defined", true);
   }
 
   public void testEnum17() throws Exception {
     testTypes("var goog = {};" +
         "/**@enum*/goog.a={BB:'string'}",
-        "assignment to property BB of enum{goog.a}\n" +
+        "element type must match enum's type\n" +
         "found   : string\n" +
         "required: number");
   }
@@ -3024,13 +2802,6 @@
         "required: string");
   }
 
-  public void testEnum42() throws Exception {
-    testTypes(
-        "/** @param {number} x */ function f(x) {}" +
-        "/** @enum {Object} */ var MyEnum = {FOO: {newProperty: 1, b: 2}};" +
-        "f(MyEnum.FOO.newProperty);");
-  }
-
   public void testAliasedEnum1() throws Exception {
     testTypes(
         "/** @enum */ var YourEnum = {FOO: 3};" +
@@ -3140,6 +2911,15 @@
         "required: string");
   }
 
+  public void testBackwardsTypedefUse5() throws Exception {
+    testTypes(
+        "/** @return {MyTypedef} */ function f() { return null; }" +
+        "/** @type {string} */ var MyTypedef = goog.typedef;",
+        "inconsistent return type\n" +
+        "found   : null\n" +
+        "required: string");
+  }
+
   public void testBackwardsTypedefUse6() throws Exception {
     testTypes(
         "/** @return {goog.MyTypedef} */ function f() { return null; }" +
@@ -3178,18 +2958,6 @@
         "required: Array");
   }
 
-  public void testBackwardsTypedefUse10() throws Exception {
-    testTypes(
-        "/** @param {goog.MyEnum} x */ function g(x) {}" +
-        "var goog = {};" +
-        "/** @enum {goog.MyTypedef} */ goog.MyEnum = {FOO: 1};" +
-        "/** @typedef {number} */ goog.MyTypedef;" +
-        "g(1);",
-        "actual parameter 1 of g does not match formal parameter\n" +
-        "found   : number\n" +
-        "required: goog.MyEnum.<number>");
-  }
-
   public void testBackwardsConstructor1() throws Exception {
     testTypes(
         "function f() { (new Foo(true)); }" +
@@ -3342,44 +3110,6 @@
         "required: number");
   }
 
-  public void testGoodExtends14() throws Exception {
-    testTypes(
-        CLOSURE_DEFS +
-        "/** @param {Function} f */ function g(f) {" +
-        "  /** @constructor */ function NewType() {};" +
-        "  goog.inherits(NewType, f);" +
-        "  (new NewType());" +
-        "}");
-  }
-
-  public void testGoodExtends15() throws Exception {
-    testTypes(
-        CLOSURE_DEFS +
-        "/** @constructor */ function OldType() {}" +
-        "/** @param {?function(new:OldType)} f */ function g(f) {" +
-        "  /**\n" +
-        "    * @constructor\n" +
-        "    * @extends {OldType}\n" +
-        "    */\n" +
-        "  function NewType() {};" +
-        "  goog.inherits(NewType, f);" +
-        "  NewType.prototype.method = function() {" +
-        "    NewType.superClass_.foo.call(this);" +
-        "  };" +
-        "}",
-        "Property foo never defined on OldType.prototype");
-  }
-
-  public void testGoodExtends16() throws Exception {
-    testTypes(
-        CLOSURE_DEFS +
-        "/** @param {Function} f */ function g(f) {" +
-        "  /** @constructor */ function NewType() {};" +
-        "  goog.inherits(f, NewType);" +
-        "  (new NewType());" +
-        "}");
-  }
-
   public void testBadExtends1() throws Exception {
     testTypes("/** @constructor */function base() {}\n" +
         "/** @constructor\n * @extends {not_base} */function derived() {}\n",
@@ -3552,44 +3282,6 @@
         "goog.SubDisposable.prototype.dispose = function() {};");
   }
 
-  public void testGoodImplements5() throws Exception {
-    testTypes(
-        "/** @interface */\n" +
-        "goog.Disposable = function() {};" +
-        "/** @type {Function} */" +
-        "goog.Disposable.prototype.dispose = function() {};" +
-        "/** @implements {goog.Disposable}\n * @constructor */" +
-        "goog.SubDisposable = function() {};" +
-        "/** @param {number} key \n @override */ " +
-        "goog.SubDisposable.prototype.dispose = function(key) {};");
-  }
-
-  public void testGoodImplements6() throws Exception {
-    testTypes(
-        "var myNullFunction = function() {};" +
-        "/** @interface */\n" +
-        "goog.Disposable = function() {};" +
-        "/** @return {number} */" +
-        "goog.Disposable.prototype.dispose = myNullFunction;" +
-        "/** @implements {goog.Disposable}\n * @constructor */" +
-        "goog.SubDisposable = function() {};" +
-        "/** @return {number} \n @override */ " +
-        "goog.SubDisposable.prototype.dispose = function() { return 0; };");
-  }
-
-  public void testGoodImplements7() throws Exception {
-    testTypes(
-        "var myNullFunction = function() {};" +
-        "/** @interface */\n" +
-        "goog.Disposable = function() {};" +
-        "/** @return {number} */" +
-        "goog.Disposable.prototype.dispose = function() {};" +
-        "/** @implements {goog.Disposable}\n * @constructor */" +
-        "goog.SubDisposable = function() {};" +
-        "/** @return {number} \n @override */ " +
-        "goog.SubDisposable.prototype.dispose = function() { return 0; };");
-  }
-
   public void testBadImplements1() throws Exception {
     testTypes("/** @interface */function Base1() {}\n" +
         "/** @interface */function Base2() {}\n" +
@@ -3623,26 +3315,6 @@
         "but not implement interfaces");
   }
 
-  public void testBadImplements5() throws Exception {
-    testTypes("/** @interface */function Disposable() {}\n" +
-        "/** @type {number} */ Disposable.prototype.bar = function() {};",
-        "assignment to property bar of Disposable.prototype\n" +
-        "found   : function (): undefined\n" +
-        "required: number");
-  }
-
-  public void testBadImplements6() throws Exception {
-    testClosureTypesMultipleWarnings(
-        "/** @interface */function Disposable() {}\n" +
-        "/** @type {function()} */ Disposable.prototype.bar = 3;",
-        Lists.newArrayList(
-            "assignment to property bar of Disposable.prototype\n" +
-            "found   : number\n" +
-            "required: function (): ?",
-            "interface members can only be empty property declarations, " +
-            "empty functions, or goog.abstractMethod"));
-  }
-
   public void testInterfaceExtends() throws Exception {
     testTypes("/** @interface */function A() {}\n" +
         "/** @interface \n * @extends {A} */function B() {}\n" +
@@ -3770,8 +3442,7 @@
   public void testInterfaceAssignment8() throws Exception {
     testTypes("/** @interface */var I = function() {};\n" +
         "/** @type {I} */var i;\n" +
-        "/** @type {Object} */var o = i;\n" +
-        "new Object().prototype = i.prototype;");
+        "/** @type {Object} */var o = i;");
   }
 
   public void testInterfaceAssignment9() throws Exception {
@@ -3825,14 +3496,14 @@
 
   public void testGetprop1() throws Exception {
     testTypes("/** @return {void}*/function foo(){foo().bar;}",
-        "No properties on this expression\n" +
+        "undefined has no properties\n" +
         "found   : undefined\n" +
         "required: Object");
   }
 
   public void testGetprop2() throws Exception {
     testTypes("var x = null; x.alert();",
-        "No properties on this expression\n" +
+        "null has no properties\n" +
         "found   : null\n" +
         "required: Object");
   }
@@ -3897,14 +3568,6 @@
         "required: Object");
   }
 
-  public void testArrayAccess9() throws Exception {
-    testTypes("/** @return {?Array} */ function f() { return []; }" +
-        "f()[{}]",
-        "array access\n" +
-        "found   : {}\n" +
-        "required: number");
-  }
-
   public void testPropAccess() throws Exception {
     testTypes("/** @param {*} x */var f = function(x) {\n" +
         "var o = String(x);\n" +
@@ -3915,7 +3578,7 @@
 
   public void testPropAccess2() throws Exception {
     testTypes("var bar = void 0; bar.baz;",
-        "No properties on this expression\n" +
+        "undefined has no properties\n" +
         "found   : undefined\n" +
         "required: Object");
   }
@@ -3924,7 +3587,7 @@
     // Verifies that we don't emit two warnings, because
     // the var has been dereferenced after the first one.
     testTypes("var bar = void 0; bar.baz; bar.bax;",
-        "No properties on this expression\n" +
+        "undefined has no properties\n" +
         "found   : undefined\n" +
         "required: Object");
   }
@@ -4474,6 +4137,8 @@
   public void testClosure7() throws Exception {
     testClosureTypes(
         CLOSURE_DEFS +
+        "goog.asserts = {};" +
+        "/** @return {*} */ goog.asserts.assert = function(x) { return x; };" +
         "/** @type {string|null|undefined} */ var a = foo();" +
         "/** @type {number} */" +
         "var b = goog.asserts.assert(a);",
@@ -4722,114 +4387,6 @@
         "required: string");
   }
 
-  public void testOverriddenParams1() throws Exception {
-    testTypes(
-        "/** @constructor */ function Foo() {}" +
-        "/** @param {...?} var_args */" +
-        "Foo.prototype.bar = function(var_args) {};" +
-        "/**\n" +
-        " * @constructor\n" +
-        " * @extends {Foo}\n" +
-        " */ function SubFoo() {}" +
-        "/**\n" +
-        " * @param {number} x\n" +
-        " * @override\n" +
-        " */" +
-        "SubFoo.prototype.bar = function(x) {};");
-  }
-
-  public void testOverriddenParams2() throws Exception {
-    testTypes(
-        "/** @constructor */ function Foo() {}" +
-        "/** @type {function(...[?])} */" +
-        "Foo.prototype.bar = function(var_args) {};" +
-        "/**\n" +
-        " * @constructor\n" +
-        " * @extends {Foo}\n" +
-        " */ function SubFoo() {}" +
-        "/**\n" +
-        " * @type {function(number)}\n" +
-        " * @override\n" +
-        " */" +
-        "SubFoo.prototype.bar = function(x) {};");
-  }
-
-  public void testOverriddenParams3() throws Exception {
-    testTypes(
-        "/** @constructor */ function Foo() {}" +
-        "/** @param {...number} var_args */" +
-        "Foo.prototype.bar = function(var_args) { };" +
-        "/**\n" +
-        " * @constructor\n" +
-        " * @extends {Foo}\n" +
-        " */ function SubFoo() {}" +
-        "/**\n" +
-        " * @param {number} x\n" +
-        " * @override\n" +
-        " */" +
-        "SubFoo.prototype.bar = function(x) {};",
-        "mismatch of the bar property type and the type of the " +
-        "property it overrides from superclass Foo\n" +
-        "original: function (this:Foo, ...[number]): undefined\n" +
-        "override: function (this:SubFoo, number): undefined");
-  }
-
-  public void testOverriddenParams4() throws Exception {
-    testTypes(
-        "/** @constructor */ function Foo() {}" +
-        "/** @type {function(...[number])} */" +
-        "Foo.prototype.bar = function(var_args) {};" +
-        "/**\n" +
-        " * @constructor\n" +
-        " * @extends {Foo}\n" +
-        " */ function SubFoo() {}" +
-        "/**\n" +
-        " * @type {function(number)}\n" +
-        " * @override\n" +
-        " */" +
-        "SubFoo.prototype.bar = function(x) {};",
-        "mismatch of the bar property type and the type of the " +
-        "property it overrides from superclass Foo\n" +
-        "original: function (...[number]): ?\n" +
-        "override: function (number): ?");
-  }
-
-  public void testOverriddenParams5() throws Exception {
-    testTypes(
-        "/** @constructor */ function Foo() {}" +
-        "/** @param {number} x */" +
-        "Foo.prototype.bar = function(x) { };" +
-        "/**\n" +
-        " * @constructor\n" +
-        " * @extends {Foo}\n" +
-        " */ function SubFoo() {}" +
-        "/**\n" +
-        " * @override\n" +
-        " */" +
-        "SubFoo.prototype.bar = function() {};" +
-        "(new SubFoo()).bar();");
-  }
-
-  public void testOverriddenParams6() throws Exception {
-    testTypes(
-        "/** @constructor */ function Foo() {}" +
-        "/** @param {number} x */" +
-        "Foo.prototype.bar = function(x) { };" +
-        "/**\n" +
-        " * @constructor\n" +
-        " * @extends {Foo}\n" +
-        " */ function SubFoo() {}" +
-        "/**\n" +
-        " * @override\n" +
-        " */" +
-        "SubFoo.prototype.bar = function() {};" +
-        "(new SubFoo()).bar(true);",
-        "actual parameter 1 of SubFoo.prototype.bar " +
-        "does not match formal parameter\n" +
-        "found   : boolean\n" +
-        "required: number");
-  }
-
   public void testOverriddenReturn1() throws Exception {
     testTypes(
         "/** @constructor */ function Foo() {}" +
@@ -4867,39 +4424,6 @@
         "required: number");
   }
 
-  public void testOverriddenProperty1() throws Exception {
-    testTypes(
-        "/** @constructor */ function Foo() {}" +
-        "/** @type {Object} */" +
-        "Foo.prototype.bar = {};" +
-        "/**\n" +
-        " * @constructor\n" +
-        " * @extends {Foo}\n" +
-        " */ function SubFoo() {}" +
-        "/**\n" +
-        " * @type {Array}\n" +
-        " * @override\n" +
-        " */" +
-        "SubFoo.prototype.bar = [];");
-  }
-
-  public void testOverriddenProperty2() throws Exception {
-    testTypes(
-        "/** @constructor */ function Foo() {" +
-        "  /** @type {Object} */" +
-        "  this.bar = {};" +
-        "}" +
-        "/**\n" +
-        " * @constructor\n" +
-        " * @extends {Foo}\n" +
-        " */ function SubFoo() {}" +
-        "/**\n" +
-        " * @type {Array}\n" +
-        " * @override\n" +
-        " */" +
-        "SubFoo.prototype.bar = [];");
-  }
-
   public void testThis2() throws Exception {
     testTypes("var goog = {};" +
         "/** @constructor */goog.A = function(){" +
@@ -4999,80 +4523,6 @@
         "required: number");
   }
 
-  public void testThis12() throws Exception {
-    testTypes(
-        "/** @param {number} x */ function f(x) {}" +
-        "/** @constructor */ function Ctor() {}" +
-        "Ctor.prototype['method'] = function() {" +
-        "  f(this);" +
-        "}",
-        "actual parameter 1 of f does not match formal parameter\n" +
-        "found   : Ctor\n" +
-        "required: number");
-  }
-
-  public void testThis13() throws Exception {
-    testTypes(
-        "/** @param {number} x */ function f(x) {}" +
-        "/** @constructor */ function Ctor() {}" +
-        "Ctor.prototype = {" +
-        "  method: function() {" +
-        "    f(this);" +
-        "  }" +
-        "};",
-        "actual parameter 1 of f does not match formal parameter\n" +
-        "found   : Ctor\n" +
-        "required: number");
-  }
-
-  public void testThis14() throws Exception {
-    testTypes(
-        "/** @param {number} x */ function f(x) {}" +
-        "f(this.Object);",
-        "actual parameter 1 of f does not match formal parameter\n" +
-        "found   : function (new:Object, *=): ?\n" +
-        "required: number");
-  }
-
-  public void testThisTypeOfFunction1() throws Exception {
-    testTypes(
-        "/** @type {function(this:Object)} */ function f() {}" +
-        "f();");
-  }
-
-  public void testThisTypeOfFunction2() throws Exception {
-    testTypes(
-        "/** @constructor */ function F() {}" +
-        "/** @type {function(this:F)} */ function f() {}" +
-        "f();",
-        "\"function (this:F): ?\" must be called with a \"this\" type");
-  }
-
-  public void testThisTypeOfFunction3() throws Exception {
-    testTypes(
-        "/** @constructor */ function F() {}" +
-        "F.prototype.bar = function() {};" +
-        "var f = (new F()).bar; f();",
-        "\"function (this:F): undefined\" must be called with a \"this\" type");
-  }
-
-  public void testThisTypeOfFunction4() throws Exception {
-    testTypes(
-        "/** @constructor */ function F() {}" +
-        "F.prototype.moveTo = function(x, y) {};" +
-        "F.prototype.lineTo = function(x, y) {};" +
-        "function demo() {" +
-        "  var path = new F();" +
-        "  var points = [[1,1], [2,2]];" +
-        "  for (var i = 0; i < points.length; i++) {" +
-        "    (i == 0 ? path.moveTo : path.lineTo)(" +
-        "       points[i][0], points[i][1]);" +
-        "  }" +
-        "}",
-        "\"function (this:F, ?, ?): undefined\" " +
-        "must be called with a \"this\" type");
-  }
-
   public void testGlobalThis1() throws Exception {
     testTypes("/** @constructor */ function Window() {}" +
         "/** @param {string} msg */ " +
@@ -5596,27 +5046,6 @@
         "Property indexOf never defined on String.prototype.toLowerCase");
   }
 
-  public void testIssue368() throws Exception {
-    testTypes(
-        "/** @constructor */ function Foo(){}" +
-        "/**\n" +
-        " * @param {number} one\n" +
-        " * @param {string} two\n" +
-        " */\n" +
-        "Foo.prototype.add = function(one, two) {};" +
-        "/**\n" +
-        " * @constructor\n" +
-        " * @extends {Foo}\n" +
-        " */\n" +
-        "function Bar(){}" +
-        "/** @override */\n" +
-        "Bar.prototype.add = function(ignored) {};" +
-        "(new Bar()).add(1, 2);",
-        "actual parameter 2 of Bar.prototype.add does not match formal parameter\n" +
-        "found   : number\n" +
-        "required: string");
-  }
-
   public void testIssue380() throws Exception {
     testTypes(
         "/** @type { function(string): {innerHTML: string} } */" +
@@ -5626,153 +5055,6 @@
         "document.getElementById('node').innerHTML = list.toString();");
   }
 
-  public void testIssue483() throws Exception {
-    testTypes(
-        "/** @constructor */ function C() {" +
-        "  /** @type {?Array} */ this.a = [];" +
-        "}" +
-        "C.prototype.f = function() {" +
-        "  if (this.a.length > 0) {" +
-        "    g(this.a);" +
-        "  }" +
-        "};" +
-        "/** @param {number} a */ function g(a) {}",
-        "actual parameter 1 of g does not match formal parameter\n" +
-        "found   : Array\n" +
-        "required: number");
-  }
-
-  public void testIssue537a() throws Exception {
-    testTypes(
-        "/** @constructor */ function Foo() {}" +
-        "Foo.prototype = {method: function() {}};" +
-        "/**\n" +
-        " * @constructor\n" +
-        " * @extends {Foo}\n" +
-        " */\n" +
-        "function Bar() {" +
-        "  Foo.call(this);" +
-        "  if (this.baz()) this.method(1);" +
-        "}" +
-        "Bar.prototype = {" +
-        "  baz: function() {" +
-        "    return true;" +
-        "  }" +
-        "};" +
-        "Bar.prototype.__proto__ = Foo.prototype;",
-        "Function Foo.prototype.method: called with 1 argument(s). " +
-        "Function requires at least 0 argument(s) " +
-        "and no more than 0 argument(s).");
-  }
-
-  public void testIssue537b() throws Exception {
-    testTypes(
-        "/** @constructor */ function Foo() {}" +
-        "Foo.prototype = {method: function() {}};" +
-        "/**\n" +
-        " * @constructor\n" +
-        " * @extends {Foo}\n" +
-        " */\n" +
-        "function Bar() {" +
-        "  Foo.call(this);" +
-        "  if (this.baz(1)) this.method();" +
-        "}" +
-        "Bar.prototype = {" +
-        "  baz: function() {" +
-        "    return true;" +
-        "  }" +
-        "};" +
-        "Bar.prototype.__proto__ = Foo.prototype;",
-        "Function Bar.prototype.baz: called with 1 argument(s). " +
-        "Function requires at least 0 argument(s) " +
-        "and no more than 0 argument(s).");
-  }
-
-  public void testIssue537c() throws Exception {
-    testTypes(
-        "/** @constructor */ function Foo() {}" +
-        "/**\n" +
-        " * @constructor\n" +
-        " * @extends {Foo}\n" +
-        " */\n" +
-        "function Bar() {" +
-        "  Foo.call(this);" +
-        "  if (this.baz2()) alert(1);" +
-        "}" +
-        "Bar.prototype = {" +
-        "  baz: function() {" +
-        "    return true;" +
-        "  }" +
-        "};" +
-        "Bar.prototype.__proto__ = Foo.prototype;",
-        "Property baz2 never defined on Bar");
-  }
-
-  public void testIssue537d() throws Exception {
-    testTypes(
-        "/** @constructor */ function Foo() {}" +
-        "Foo.prototype = {" +
-        "  /** @return {Bar} */ x: function() { new Bar(); }," +
-        "  /** @return {Foo} */ y: function() { new Bar(); }" +
-        "};" +
-        "/**\n" +
-        " * @constructor\n" +
-        " * @extends {Foo}\n" +
-        " */\n" +
-        "function Bar() {" +
-        "  this.xy = 3;" +
-        "}" +
-        "/** @return {Bar} */ function f() { return new Bar(); }" +
-        "/** @return {Foo} */ function g() { return new Bar(); }" +
-        "Bar.prototype = {" +
-        "  /** @return {Bar} */ x: function() { new Bar(); }," +
-        "  /** @return {Foo} */ y: function() { new Bar(); }" +
-        "};" +
-        "Bar.prototype.__proto__ = Foo.prototype;");
-  }
-
-  public void testIssue586() throws Exception {
-    testTypes(
-        "/** @constructor */" +
-        "var MyClass = function() {};" +
-        "/** @param {boolean} success */" +
-        "MyClass.prototype.fn = function(success) {};" +
-        "MyClass.prototype.test = function() {" +
-        "  this.fn();" +
-        "  this.fn = function() {};" +
-        "};",
-        "Function MyClass.prototype.fn: called with 0 argument(s). " +
-        "Function requires at least 1 argument(s) " +
-        "and no more than 1 argument(s).");
-  }
-
-  public void testIssue635() throws Exception {
-    // TODO(nicksantos): Make this emit a warning, because of the 'this' type.
-    testTypes(
-        "/** @constructor */" +
-        "function F() {}" +
-        "F.prototype.bar = function() { this.baz(); };" +
-        "F.prototype.baz = function() {};" +
-        "/** @constructor */" +
-        "function G() {}" +
-        "G.prototype.bar = F.prototype.bar;");
-  }
-
-  public void testIssue669() throws Exception {
-    testTypes(
-        "/** @return {{prop1: (Object|undefined)}} */" +
-         "function f(a) {" +
-         "  var results;" +
-         "  if (a) {" +
-         "    results = {};" +
-         "    results.prop1 = {a: 3};" +
-         "  } else {" +
-         "    results = {prop2: 3};" +
-         "  }" +
-         "  return results;" +
-         "}");
-  }
-
   /**
    * Tests that the || operator is type checked correctly, that is of
    * the type of the first argument or of the second argument. See
@@ -5960,7 +5242,7 @@
         "var x = f();" +
         "/** @type {string} */" +
         "x.y = 3;",
-        "assignment\n" +
+        "assignment to property y of x\n" +
         "found   : number\n" +
         "required: string");
   }
@@ -6143,28 +5425,6 @@
         "})();");
   }
 
-  public void testQualifiedNameInference11() throws Exception {
-    testTypes(
-        "/** @constructor */ function Foo() {}" +
-        "function f() {" +
-        "  var x = new Foo();" +
-        "  x.onload = function() {" +
-        "    x.onload = null;" +
-        "  };" +
-        "}");
-  }
-
-  public void testQualifiedNameInference12() throws Exception {
-    // We should be able to tell that the two 'this' properties
-    // are different.
-    testTypes(
-        "/** @param {function(this:Object)} x */ function f(x) {}" +
-        "/** @constructor */ function Foo() {" +
-        "  /** @type {number} */ this.bar = 3;" +
-        "  f(function() { this.bar = true; });" +
-        "}");
-  }
-
   public void testSheqRefinedScope() throws Exception {
     Node n = parseAndTypeCheck(
         "/** @constructor */function A() {}\n" +
@@ -6327,17 +5587,6 @@
         "required: string");
   }
 
-  public void testNew17() throws Exception {
-    testTypes("var goog = {}; goog.x = 3; new goog.x",
-              "cannot instantiate non-constructor");
-  }
-
-  public void testNew18() throws Exception {
-    testTypes("var goog = {};" +
-              "/** @constructor */ goog.F = function() {};" +
-              "/** @constructor */ goog.G = goog.F;");
-  }
-
   public void testName1() throws Exception {
     assertEquals(VOID_TYPE, testNameNode("undefined"));
   }
@@ -6364,11 +5613,8 @@
   private JSType testNameNode(String name) {
     Node node = Node.newString(Token.NAME, name);
     Node parent = new Node(Token.SCRIPT, node);
-    parent.setInputId(new InputId("code"));
-
-    Node externs = new Node(Token.SCRIPT);
-    externs.setInputId(new InputId("externs"));
 
+    Node externs = new Node(Token.BLOCK);
     Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);
     externAndJsRoot.setIsSyntheticBlock(true);
 
@@ -6560,66 +5806,6 @@
         "};");
   }
 
-  public void testFunctionBind1() throws Exception {
-    testTypes(
-        "/** @type {function(string, number): boolean} */" +
-        "function f(x, y) { return true; }" +
-        "f.bind(null, 3);",
-        "actual parameter 2 of f.bind does not match formal parameter\n" +
-        "found   : number\n" +
-        "required: string");
-  }
-
-  public void testFunctionBind2() throws Exception {
-    testTypes(
-        "/** @type {function(number): boolean} */" +
-        "function f(x) { return true; }" +
-        "f(f.bind(null, 3)());",
-        "actual parameter 1 of f does not match formal parameter\n" +
-        "found   : boolean\n" +
-        "required: number");
-  }
-
-  public void testFunctionBind3() throws Exception {
-    testTypes(
-        "/** @type {function(number, string): boolean} */" +
-        "function f(x, y) { return true; }" +
-        "f.bind(null, 3)(true);",
-        "actual parameter 1 of function does not match formal parameter\n" +
-        "found   : boolean\n" +
-        "required: string");
-  }
-
-  public void testFunctionBind4() throws Exception {
-    testTypes(
-        "/** @param {...number} x */" +
-        "function f(x) {}" +
-        "f.bind(null, 3, 3, 3)(true);",
-        "actual parameter 1 of function does not match formal parameter\n" +
-        "found   : boolean\n" +
-        "required: (number|undefined)");
-  }
-
-  public void testFunctionBind5() throws Exception {
-    testTypes(
-        "/** @param {...number} x */" +
-        "function f(x) {}" +
-        "f.bind(null, true)(3, 3, 3);",
-        "actual parameter 2 of f.bind does not match formal parameter\n" +
-        "found   : boolean\n" +
-        "required: (number|undefined)");
-  }
-
-  public void testGoogBind1() throws Exception {
-    // We currently do not support goog.bind natively.
-    testClosureTypes(
-        "var goog = {}; goog.bind = function(var_args) {};" +
-        "/** @type {function(number): boolean} */" +
-        "function f(x, y) { return true; }" +
-        "f(goog.bind(f, null, 'x')());",
-        null);
-  }
-
   public void testCast2() throws Exception {
     // can upcast to a base type.
     testTypes("/** @constructor */function base() {}\n" +
@@ -6733,7 +5919,7 @@
     testTypes(
         "for (var i = 0; i < 10; i++) {" +
           "var x = /** @type {Object|number} */ ({foo: 3});" +
-          "/** @param {number} x */ function f(x) {}" +
+          "/** @param {boolean} x */ function f(x) {}" +
           "f(x.foo);" +
           "f([].foo);" +
         "}",
@@ -6747,7 +5933,7 @@
           "var x = /** @type {Object|number} */ (" +
           "  {/** @type {string} */ foo: 3});" +
         "}",
-        "assignment to property foo of Object\n" +
+        "assignment to property foo of (Object|null|number)\n" +
         "found   : number\n" +
         "required: string");
   }
@@ -6927,33 +6113,6 @@
         "}");
   }
 
-  public void testAnonymousPrototype1() throws Exception {
-    testTypes(
-        "var ns = {};" +
-        "/** @constructor */ ns.Foo = function() {" +
-        "  this.bar(3, 5);" +
-        "};" +
-        "ns.Foo.prototype = {" +
-        "  bar: function(x) {}" +
-        "};",
-        "Function ns.Foo.prototype.bar: called with 2 argument(s). " +
-        "Function requires at least 1 argument(s) and no more " +
-        "than 1 argument(s).");
-  }
-
-  public void testAnonymousPrototype2() throws Exception {
-    testTypes(
-        "/** @interface */ var Foo = function() {};" +
-        "Foo.prototype = {" +
-        "  foo: function(x) {}" +
-        "};" +
-        "/**\n" +
-        " * @constructor\n" +
-        " * @implements {Foo}\n" +
-        " */ var Bar = function() {};",
-        "property foo on interface Foo is not implemented by type Bar");
-  }
-
   public void testAnonymousType1() throws Exception {
     testTypes("function f() {}" +
         "/** @constructor */\n" +
@@ -7498,42 +6657,35 @@
         "Bad type annotation. Unknown type goog.Missing");
   }
 
-  public void testInheritanceCheck15() throws Exception {
-    testTypes(
-        "/** @constructor */function Super() {};" +
-        "/** @param {number} bar */Super.prototype.foo;" +
-        "/** @constructor\n @extends {Super} */function Sub() {};" +
-        "/** @override\n  @param {number} bar */Sub.prototype.foo =\n" +
-        "function(bar) {};");
-  }
-
-  public void testInheritanceCheck16() throws Exception {
-    testTypes(
-        "var goog = {};" +
-        "/** @constructor */goog.Super = function() {};" +
-        "/** @type {number} */ goog.Super.prototype.foo = 3;" +
-        "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" +
-        "/** @type {number} */ goog.Sub.prototype.foo = 5;",
-        "property foo already defined on superclass goog.Super; " +
-        "use @override to override it");
-  }
+  // TODO(user): We should support this way of declaring properties as it is
+  // widely used.
+  //public void testInheritanceCheck15() throws Exception {
+  //  testTypes(
+  //      "/** @constructor */function Super() {};" +
+  //      "/** @param {number} bar */Super.prototype.foo;" +
+  //      "/** @constructor\n @extends {Super} */function Sub() {};" +
+  //      "/** @override\n  @param {number} bar */Sub.prototype.foo =\n" +
+  //      "function(bar) {};");
+  //}
 
-  public void testInterfacePropertyOverride1() throws Exception {
-    testTypes(
-        "/** @interface */function Super() {};" +
-        "/** @desc description */Super.prototype.foo = function() {};" +
-        "/** @interface\n @extends {Super} */function Sub() {};" +
-        "/** @desc description */Sub.prototype.foo = function() {};");
-  }
+//   public void testInterfacePropertyOverride1() throws Exception {
+//     testTypes(
+//         "/** @interface */function Super() {};" +
+//         "/** @desc description */Super.prototype.foo = function() {};" +
+//         "/** @interface\n @extends {Super} */function Sub() {};" +
+//         "/** @desc description */Sub.prototype.foo = function() {};",
+//         "property foo is already defined by the Super extended interface");
+//   }
 
-  public void testInterfacePropertyOverride2() throws Exception {
-    testTypes(
-        "/** @interface */function Root() {};" +
-        "/** @desc description */Root.prototype.foo = function() {};" +
-        "/** @interface\n @extends {Root} */function Super() {};" +
-        "/** @interface\n @extends {Super} */function Sub() {};" +
-        "/** @desc description */Sub.prototype.foo = function() {};");
-  }
+//   public void testInterfacePropertyOverride2() throws Exception {
+//     testTypes(
+//         "/** @interface */function Root() {};" +
+//         "/** @desc description */Root.prototype.foo = function() {};" +
+//         "/** @interface\n @extends {Root} */function Super() {};" +
+//         "/** @interface\n @extends {Super} */function Sub() {};" +
+//         "/** @desc description */Sub.prototype.foo = function() {};",
+//         "property foo is already defined by the Root extended interface");
+//   }
 
   public void testInterfaceInheritanceCheck1() throws Exception {
     testTypes(
@@ -7669,17 +6821,6 @@
         "override: number");
   }
 
-  public void testInterfaceInheritanceCheck13() throws Exception {
-    testTypes(
-        "function abstractMethod() {};\n" +
-        "/** @interface */var base = function() {};\n" +
-        "/** @extends {base} \n @interface */ var Int = function() {}\n" +
-        "/** @type {{bar : !Function}} */ var x; \n" +
-        "/** @type {!Function} */ base.prototype.bar = abstractMethod; \n" +
-        "/** @type {Int} */ foo;\n" +
-        "foo.bar();");
-  }
-
   public void testInterfacePropertyNotImplemented() throws Exception {
     testTypes(
         "/** @interface */function Int() {};" +
@@ -7755,7 +6896,7 @@
   }
 
   public void testObjectLiteralDeclaration4() throws Exception {
-    testClosureTypes(
+    testClosureTypesMultipleWarnings(
         "var x = {" +
         "  /** @param {boolean} x */ abc: function(x) {}" +
         "};" +
@@ -7763,12 +6904,14 @@
         " * @param {string} x\n" +
         " * @suppress {duplicate}\n" +
         " */ x.abc = function(x) {};",
-        "assignment to property abc of x\n" +
-        "found   : function (string): undefined\n" +
-        "required: function (boolean): undefined");
-    // TODO(user): suppress {duplicate} currently also silence the
-    // redefining type error in the TypeValidator. May be it needs
-    // a new suppress name instead?
+        Lists.newArrayList(
+            "variable x.abc redefined with type " +
+            "function (string): undefined, " +
+            "original definition at  [testcode] :1 with type " +
+            "function (boolean): undefined",
+            "assignment to property abc of x\n" +
+            "found   : function (string): undefined\n" +
+            "required: function (boolean): undefined"));
   }
 
   public void testObjectLiteralDeclaration5() throws Exception {
@@ -7968,19 +7111,6 @@
         "override: string");
   }
 
-  public void testDataPropertyOnInterface4() throws Exception {
-    testTypes("/** @interface */ function T() {};\n" +
-        "/** @type {number} */T.prototype.x;\n" +
-        "/** @constructor \n" +
-        " *  @implements {T} \n" +
-        " */\n" +
-        "function C() { /** @type {string} */ \n this.x = 'foo'; }\n",
-        "mismatch of the x property type and the type of the property it " +
-        "overrides from interface T\n" +
-        "original: number\n" +
-        "override: string");
-  }
-
   public void testWarnDataPropertyOnInterface3() throws Exception {
     testTypes("/** @interface */ u.T = function () {};\n" +
         "/** @type {number} */u.T.prototype.x = 1;",
@@ -8040,15 +7170,11 @@
   }
 
   public void testErrorMismatchingPropertyOnInterface6() throws Exception {
-    testClosureTypesMultipleWarnings(
-        "/** @interface */ function T() {};\n" +
+    testTypes("/** @interface */ function T() {};\n" +
         "/** @return {number} */T.prototype.x = 1",
-        Lists.newArrayList(
-            "assignment to property x of T.prototype\n" +
-            "found   : number\n" +
-            "required: function (this:T): number",
-            "interface members can only be empty property declarations, " +
-            "empty functions, or goog.abstractMethod"));
+        "interface members can only be empty property declarations, "
+        + "empty functions, or goog.abstractMethod"
+        );
   }
 
   public void testInterfaceNonEmptyFunction() throws Exception {
@@ -8086,11 +7212,13 @@
   }
 
   public void testDirectPrototypeAssign() throws Exception {
-    // For now, we just ignore @type annotations on the prototype.
     testTypes(
         "/** @constructor */ function Foo() {}" +
         "/** @constructor */ function Bar() {}" +
-        "/** @type {Array} */ Bar.prototype = new Foo()");
+        "/** @type {Array} */ Bar.prototype = new Foo()",
+        "assignment to property prototype of Bar\n" +
+        "found   : Foo\n" +
+        "required: (Array|null)");
   }
 
   // In all testResolutionViaRegistry* tests, since u is unknown, u.T can only
@@ -8357,57 +7485,6 @@
         "right: number");
   }
 
-  public void testTypeInferenceWithNoEntry1() throws Exception {
-    testTypes(
-        "/** @param {number} x */ function f(x) {}" +
-        "/** @constructor */ function Foo() {}" +
-        "Foo.prototype.init = function() {" +
-        "  /** @type {?{baz: number}} */ this.bar = {baz: 3};" +
-        "};" +
-        "/**\n" +
-        " * @extends {Foo}\n" +
-        " * @constructor\n" +
-        " */" +
-        "function SubFoo() {}" +
-        "/** Method */" +
-        "SubFoo.prototype.method = function() {" +
-        "  for (var i = 0; i < 10; i++) {" +
-        "    f(this.bar);" +
-        "    f(this.bar.baz);" +
-        "  }" +
-        "};",
-        "actual parameter 1 of f does not match formal parameter\n"+
-        "found   : (null|{baz: number})\n" +
-        "required: number");
-  }
-
-  public void testTypeInferenceWithNoEntry2() throws Exception {
-    testClosureTypes(
-        CLOSURE_DEFS +
-        "/** @param {number} x */ function f(x) {}" +
-        "/** @param {!Object} x */ function g(x) {}" +
-        "/** @constructor */ function Foo() {}" +
-        "Foo.prototype.init = function() {" +
-        "  /** @type {?{baz: number}} */ this.bar = {baz: 3};" +
-        "};" +
-        "/**\n" +
-        " * @extends {Foo}\n" +
-        " * @constructor\n" +
-        " */" +
-        "function SubFoo() {}" +
-        "/** Method */" +
-        "SubFoo.prototype.method = function() {" +
-        "  for (var i = 0; i < 10; i++) {" +
-        "    f(this.bar);" +
-        "    goog.asserts.assert(this.bar);" +
-        "    g(this.bar);" +
-        "  }" +
-        "};",
-        "actual parameter 1 of f does not match formal parameter\n"+
-        "found   : (null|{baz: number})\n" +
-        "required: number");
-  }
-
   public void testForwardPropertyReference() throws Exception {
     testTypes("/** @constructor */ var Foo = function() { this.init(); };" +
         "/** @return {string} */" +
@@ -8530,6 +7607,68 @@
         "required: (MyType|null|number)");
   }
 
+  public void testMalformedOldTypeDef() throws Exception {
+    testTypes(
+        "var goog = {}; goog.typedef = true;" +
+        "goog.Bar = goog.typedef",
+        "Typedef for goog.Bar does not have any type information");
+  }
+
+  public void testMalformedOldTypeDef2() throws Exception {
+    testTypes(
+        "var goog = {}; goog.typedef = true;" +
+        "/** @typedef {boolean} */ goog.Bar = goog.typedef",
+        "Typedef for goog.Bar does not have any type information");
+  }
+
+  public void testDuplicateOldTypeDef() throws Exception {
+    testTypes(
+        "var goog = {}; goog.typedef = true;" +
+        "/** @constructor */ goog.Bar = function() {};" +
+        "/** @type {number} */ goog.Bar = goog.typedef",
+        "variable goog.Bar redefined with type number, " +
+        "original definition at [testcode]:1 " +
+        "with type function (new:goog.Bar): undefined");
+  }
+
+  public void testOldTypeDef1() throws Exception {
+    testTypes(
+        "var goog = {}; goog.typedef = true;" +
+        "/** @type {number} */ goog.Bar = goog.typedef;" +
+        "/** @param {goog.Bar} x */ function f(x) {}" +
+        "f(3);");
+  }
+
+  public void testOldTypeDef2() throws Exception {
+    testTypes(
+        "var goog = {}; goog.typedef = true;" +
+        "/** @type {number} */ goog.Bar = goog.typedef;" +
+        "/** @param {goog.Bar} x */ function f(x) {}" +
+        "f('3');",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testOldTypeDef3() throws Exception {
+    testTypes(
+        "var goog = {}; goog.typedef = true;" +
+        "/** @type {number} */ var Bar = goog.typedef;" +
+        "/** @param {Bar} x */ function f(x) {}" +
+        "f('3');",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testCircularOldTypeDef() throws Exception {
+    testTypes(
+        "var goog = {}; goog.typedef = true;" +
+        "/** @type {number|Array.<goog.Bar>} */ goog.Bar = goog.typedef;" +
+        "/** @param {goog.Bar} x */ function f(x) {}" +
+        "f(3); f([3]); f([[3]]);");
+  }
+
   public void testDuplicateTypeDef() throws Exception {
     testTypes(
         "var goog = {};" +
@@ -8628,16 +7767,6 @@
     assertEquals(100.0, getTypedPercent(js), 0.1);
   }
 
-  public void testGetTypedPercent5() throws Exception {
-    String js = "/** @enum {number} */ keys = {A: 1,B: 2,C: 3};";
-    assertEquals(100.0, getTypedPercent(js), 0.1);
-  }
-
-  public void testGetTypedPercent6() throws Exception {
-    String js = "a = {TRUE: 1, FALSE: 0};";
-    assertEquals(100.0, getTypedPercent(js), 0.1);
-  }
-
   private double getTypedPercent(String js) throws Exception {
     Node n = compiler.parseTestCode(js);
 
@@ -9002,34 +8131,6 @@
         "function g(x) { return x.isVisible; }");
   }
 
-  public void testMissingProperty38() throws Exception {
-    testTypes(
-        "/** @constructor */ function Foo() {}" +
-        "/** @constructor */ function Bar() {}" +
-        "/** @return {Foo|Bar} */ function f() { return new Foo(); }" +
-        "f().missing;",
-        "Property missing never defined on (Bar|Foo|null)");
-  }
-
-  public void testMissingProperty39() throws Exception {
-    testTypes(
-        "/** @return {string|number} */ function f() { return 3; }" +
-        "f().length;");
-  }
-
-  public void testMissingProperty40() throws Exception {
-    testClosureTypes(
-        "goog.addDependency('zzz.js', ['MissingType'], []);" +
-        "/** @param {(Array|MissingType)} x */" +
-        "function f(x) { x.impossible(); }", null);
-  }
-
-  public void testMissingProperty41() throws Exception {
-    testTypes(
-        "/** @param {(Array|Date)} x */" +
-        "function f(x) { if (x.impossible) x.impossible(); }");
-  }
-
   public void testReflectObject1() throws Exception {
     testClosureTypes(
         "var goog = {}; goog.reflect = {}; " +
@@ -9127,37 +8228,6 @@
             "Bad type annotation. missing object name in @lends tag"));
   }
 
-  public void testLends10() throws Exception {
-    testTypes(
-        "function defineClass(x) { return function() {}; } " +
-        "/** @constructor */" +
-        "var Foo = defineClass(" +
-        "    /** @lends {Foo.prototype} */ ({/** @type {number} */ bar: 1}));" +
-        "/** @return {string} */ function f() { return (new Foo()).bar; }",
-        "inconsistent return type\n" +
-        "found   : number\n" +
-        "required: string");
-  }
-
-  public void testLends11() throws Exception {
-    testTypes(
-        "function defineClass(x, y) { return function() {}; } " +
-        "/** @constructor */" +
-        "var Foo = function() {};" +
-        "/** @return {*} */ Foo.prototype.bar = function() { return 3; };" +
-        "/**\n" +
-        " * @constructor\n" +
-        " * @extends {Foo}\n" +
-        " */\n" +
-        "var SubFoo = defineClass(Foo, " +
-        "    /** @lends {SubFoo.prototype} */ ({\n" +
-        "      /** @return {number} */ bar: function() { return 3; }}));" +
-        "/** @return {string} */ function f() { return (new SubFoo()).bar(); }",
-        "inconsistent return type\n" +
-        "found   : number\n" +
-        "required: string");
-  }
-
   public void testDeclaredNativeTypeEquality() throws Exception {
     Node n = parseAndTypeCheck("/** @constructor */ function Object() {};");
     assertEquals(registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE),
@@ -9277,7 +8347,7 @@
         "*/\n" +
         "function f(x, y, z) {}\n" +
         "f(this, this, function() { this });",
-        FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format());
+        FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format(), true);
   }
 
   public void testBadTemplateType2() throws Exception {
@@ -9289,7 +8359,7 @@
         "*/\n" +
         "function f(x, y) {}\n" +
         "f(0, function() {});",
-        TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format("number"));
+        TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format(), true);
   }
 
   public void testBadTemplateType3() throws Exception {
@@ -9300,7 +8370,7 @@
         "*/\n" +
         "function f(x) {}\n" +
         "f(this);",
-        TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format());
+        TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format(), true);
   }
 
   public void testBadTemplateType4() throws Exception {
@@ -9310,7 +8380,7 @@
         "*/\n" +
         "function f() {}\n" +
         "f();",
-        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());
+        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);
   }
 
   public void testBadTemplateType5() throws Exception {
@@ -9321,7 +8391,7 @@
         "*/\n" +
         "function f() {}\n" +
         "f();",
-        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());
+        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);
   }
 
   public void testFunctionLiteralUndefinedThisArgument() throws Exception {
@@ -9347,7 +8417,7 @@
         + "baz(function() { this; }, {});");
   }
 
-  public void testFunctionLiteralUnreadNullThisArgument() throws Exception {
+  public void testFunctionLiteralUnreadThisArgument() throws Exception {
     testTypes(""
         + "/**\n"
         + " * @param {function(this:T, ...)?} fn\n"
@@ -9355,24 +8425,19 @@
         + " * @template T\n"
         + " */\n"
         + "function baz(fn, opt_obj) {}\n"
-        + "baz(function() {}, null);");
+        + "baz(function() {}, {});",
+        "Function literal argument does not refer to bound this argument");
   }
 
-  public void testUnionTemplateThisType() throws Exception {
-    testTypes(
-        "/** @constructor */ function F() {}" +
-        "/** @return {F|Array} */ function g() { return []; }" +
-        "/** @param {F} x */ function h(x) { }" +
-        "/**\n" +
-        "* @param {T} x\n" +
-        "* @param {function(this:T, ...)} y\n" +
-        "* @template T\n" +
-        "*/\n" +
-        "function f(x, y) {}\n" +
-        "f(g(), function() { h(this); });",
-        "actual parameter 1 of h does not match formal parameter\n" +
-        "found   : Object\n" +
-        "required: (F|null)");
+  public void testFunctionLiteralUnreadNullThisArgument() throws Exception {
+    testTypes(""
+        + "/**\n"
+        + " * @param {function(this:T, ...)?} fn\n"
+        + " * @param {?T} opt_obj\n"
+        + " * @template T\n"
+        + " */\n"
+        + "function baz(fn, opt_obj) {}\n"
+        + "baz(function() {}, null);");
   }
 
   public void testActiveXObject() throws Exception {
@@ -9381,89 +8446,6 @@
         "/** @type { {impossibleProperty} } */ var y = new ActiveXObject();");
   }
 
-  public void testRecordType1() throws Exception {
-    testTypes(
-        "/** @param {{prop: number}} x */" +
-        "function f(x) {}" +
-        "f({});",
-        "actual parameter 1 of f does not match formal parameter\n" +
-        "found   : {prop: (number|undefined)}\n" +
-        "required: {prop: number}");
-  }
-
-  public void testRecordType2() throws Exception {
-    testTypes(
-        "/** @param {{prop: (number|undefined)}} x */" +
-        "function f(x) {}" +
-        "f({});");
-  }
-
-  public void testRecordType3() throws Exception {
-    testTypes(
-        "/** @param {{prop: number}} x */" +
-        "function f(x) {}" +
-        "f({prop: 'x'});",
-        "actual parameter 1 of f does not match formal parameter\n" +
-        "found   : {prop: (number|string)}\n" +
-        "required: {prop: number}");
-  }
-
-  public void testRecordType4() throws Exception {
-    // Notice that we do not do flow-based inference on the object type:
-    // We don't try to prove that x.prop may not be string until x
-    // gets passed to g.
-    testClosureTypesMultipleWarnings(
-        "/** @param {{prop: (number|undefined)}} x */" +
-        "function f(x) {}" +
-        "/** @param {{prop: (string|undefined)}} x */" +
-        "function g(x) {}" +
-        "var x = {}; f(x); g(x);",
-        Lists.newArrayList(
-            "actual parameter 1 of f does not match formal parameter\n" +
-            "found   : {prop: (number|string|undefined)}\n" +
-            "required: {prop: (number|undefined)}",
-            "actual parameter 1 of g does not match formal parameter\n" +
-            "found   : {prop: (number|string|undefined)}\n" +
-            "required: {prop: (string|undefined)}"));
-  }
-
-  public void testRecordType5() throws Exception {
-    testTypes(
-        "/** @param {{prop: (number|undefined)}} x */" +
-        "function f(x) {}" +
-        "/** @param {{otherProp: (string|undefined)}} x */" +
-        "function g(x) {}" +
-        "var x = {}; f(x); g(x);");
-  }
-
-  public void testRecordType6() throws Exception {
-    testTypes(
-        "/** @return {{prop: (number|undefined)}} x */" +
-        "function f() { return {}; }");
-  }
-
-  public void testRecordType7() throws Exception {
-    testTypes(
-        "/** @return {{prop: (number|undefined)}} x */" +
-        "function f() { var x = {}; g(x); return x; }" +
-        "/** @param {number} x */" +
-        "function g(x) {}",
-        "actual parameter 1 of g does not match formal parameter\n" +
-        "found   : {prop: (number|undefined)}\n" +
-        "required: number");
-  }
-
-  public void testRecordType8() throws Exception {
-    testTypes(
-        "/** @return {{prop: (number|string)}} x */" +
-        "function f() { var x = {prop: 3}; g(x.prop); return x; }" +
-        "/** @param {string} x */" +
-        "function g(x) {}",
-        "actual parameter 1 of g does not match formal parameter\n" +
-        "found   : number\n" +
-        "required: string");
-  }
-
   public void testDuplicateRecordFields1() throws Exception {
     testTypes("/**"
          + "* @param {{x:string, x:number}} a"
@@ -9482,125 +8464,6 @@
            "Bad type annotation. Unknown type y"});
   }
 
-  public void testMultipleExtendsInterface1() throws Exception {
-    testTypes("/** @interface */ function base1() {}\n"
-        + "/** @interface */ function base2() {}\n"
-        + "/** @interface\n"
-        + "* @extends {base1}\n"
-        + "* @extends {base2}\n"
-        + "*/\n"
-        + "function derived() {}");
-  }
-
-  public void testMultipleExtendsInterface2() throws Exception {
-    testTypes(
-        "/** @interface */function Int0() {};" +
-        "/** @interface */function Int1() {};" +
-        "/** @desc description */Int0.prototype.foo = function() {};" +
-        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
-        "function Int2() {};" +
-        "/** @constructor\n @implements {Int2} */function Foo() {};",
-        "property foo on interface Int0 is not implemented by type Foo");
-  }
-
-  public void testMultipleExtendsInterface3() throws Exception {
-    testTypes(
-        "/** @interface */function Int0() {};" +
-        "/** @interface */function Int1() {};" +
-        "/** @desc description */Int1.prototype.foo = function() {};" +
-        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
-        "function Int2() {};" +
-        "/** @constructor\n @implements {Int2} */function Foo() {};",
-        "property foo on interface Int1 is not implemented by type Foo");
-  }
-
-  public void testMultipleExtendsInterface4() throws Exception {
-    testTypes(
-        "/** @interface */function Int0() {};" +
-        "/** @interface */function Int1() {};" +
-        "/** @interface \n @extends {Int0} \n @extends {Int1} \n" +
-        " @extends {number} */" +
-        "function Int2() {};" +
-        "/** @constructor\n @implements {Int2} */function Foo() {};",
-        "Int2 @extends non-object type number");
-  }
-
-  public void testMultipleExtendsInterface5() throws Exception {
-    testTypes(
-        "/** @interface */function Int0() {};" +
-        "/** @constructor */function Int1() {};" +
-        "/** @desc description @ return {string} x */" +
-        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
-        "function Int2() {};",
-        "Int2 cannot extend this type; a constructor can only extend " +
-        "objects and an interface can only extend interfaces");
-  }
-
-  public void testMultipleExtendsInterface6() throws Exception {
-    testTypes(
-        "/** @interface */function Super1() {};" +
-        "/** @interface */function Super2() {};" +
-        "/** @param {number} bar */Super2.prototype.foo = function(bar) {};" +
-        "/** @interface\n @extends {Super1}\n " +
-        "@extends {Super2} */function Sub() {};" +
-        "/** @override\n @param {string} bar */Sub.prototype.foo =\n" +
-        "function(bar) {};",
-        "mismatch of the foo property type and the type of the property it " +
-        "overrides from superclass Super2\n" +
-        "original: function (this:Super2, number): undefined\n" +
-        "override: function (this:Sub, string): undefined");
-  }
-
-  public void testMultipleExtendsInterfaceAssignment() throws Exception {
-    testTypes("/** @interface */var I1 = function() {};\n" +
-        "/** @interface */ var I2 = function() {}\n" +
-        "/** @interface\n@extends {I1}\n@extends {I2}*/" +
-        "var I3 = function() {};\n" +
-        "/** @constructor\n@implements {I3}*/var T = function() {};\n" +
-        "var t = new T();\n" +
-         "/** @type {I1} */var i1 = t;\n" +
-         "/** @type {I2} */var i2 = t;\n" +
-         "/** @type {I3} */var i3 = t;\n" +
-         "i1 = i3;\n" +
-         "i2 = i3;\n");
-  }
-
-  public void testMultipleExtendsInterfaceParamPass() throws Exception {
-    testTypes("/** @interface */var I1 = function() {};\n" +
-        "/** @interface */ var I2 = function() {}\n" +
-        "/** @interface\n@extends {I1}\n@extends {I2}*/" +
-        "var I3 = function() {};\n" +
-        "/** @constructor\n@implements {I3}*/var T = function() {};\n" +
-        "var t = new T();\n" +
-        "/** @param x I1 \n@param y I2\n@param z I3*/function foo(x,y,z){};\n" +
-        "foo(t,t,t)\n");
-  }
-
-  public void testBadMultipleExtendsClass() throws Exception {
-    testTypes("/** @constructor */ function base1() {}\n"
-        + "/** @constructor */ function base2() {}\n"
-        + "/** @constructor\n"
-        + "* @extends {base1}\n"
-        + "* @extends {base2}\n"
-        + "*/\n"
-        + "function derived() {}",
-        "Bad type annotation. type annotation incompatible "
-        + "with other annotations");
-  }
-
-  public void testInterfaceExtendsResolution() throws Exception {
-    testTypes("/** @interface \n @extends {A} */ function B() {};\n" +
-        "/** @constructor \n @implements {B} */ function C() {};\n" +
-        "/** @interface */ function A() {};");
-  }
-
-  public void testPropertyCanBeDefinedInObject() throws Exception {
-    testTypes("/** @interface */ function I() {};" +
-        "I.prototype.bar = function() {};" +
-        "/** @type {Object} */ var foo;" +
-        "foo.bar();");
-  }
-
   private void checkObjectType(ObjectType objectType, String propertyName,
         JSType expectedType) {
     assertTrue("Expected " + objectType.getReferenceName() +
@@ -9612,164 +8475,6 @@
         expectedType, objectType.getPropertyType(propertyName));
   }
 
-  public void testExtendedInterfacePropertiesCompatibility1() throws Exception {
-    testTypes(
-        "/** @interface */function Int0() {};" +
-        "/** @interface */function Int1() {};" +
-        "/** @type {number} */" +
-        "Int0.prototype.foo;" +
-        "/** @type {string} */" +
-        "Int1.prototype.foo;" +
-        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
-        "function Int2() {};",
-        "Interface Int2 has a property foo with incompatible types in its " +
-        "super interfaces Int0 and Int1");
-  }
-
-  public void testExtendedInterfacePropertiesCompatibility2() throws Exception {
-    testTypes(
-        "/** @interface */function Int0() {};" +
-        "/** @interface */function Int1() {};" +
-        "/** @interface */function Int2() {};" +
-        "/** @type {number} */" +
-        "Int0.prototype.foo;" +
-        "/** @type {string} */" +
-        "Int1.prototype.foo;" +
-        "/** @type {Object} */" +
-        "Int2.prototype.foo;" +
-        "/** @interface \n @extends {Int0} \n @extends {Int1} \n" +
-        "@extends {Int2}*/" +
-        "function Int3() {};",
-        new String[] {
-            "Interface Int3 has a property foo with incompatible types in " +
-            "its super interfaces Int0 and Int1",
-            "Interface Int3 has a property foo with incompatible types in " +
-            "its super interfaces Int1 and Int2"
-        });
-  }
-
-  public void testExtendedInterfacePropertiesCompatibility3() throws Exception {
-    testTypes(
-        "/** @interface */function Int0() {};" +
-        "/** @interface */function Int1() {};" +
-        "/** @type {number} */" +
-        "Int0.prototype.foo;" +
-        "/** @type {string} */" +
-        "Int1.prototype.foo;" +
-        "/** @interface \n @extends {Int1} */ function Int2() {};" +
-        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
-        "function Int3() {};",
-        "Interface Int3 has a property foo with incompatible types in its " +
-        "super interfaces Int0 and Int1");
-  }
-
-  public void testExtendedInterfacePropertiesCompatibility4() throws Exception {
-    testTypes(
-        "/** @interface */function Int0() {};" +
-        "/** @interface \n @extends {Int0} */ function Int1() {};" +
-        "/** @type {number} */" +
-        "Int0.prototype.foo;" +
-        "/** @interface */function Int2() {};" +
-        "/** @interface \n @extends {Int2} */ function Int3() {};" +
-        "/** @type {string} */" +
-        "Int2.prototype.foo;" +
-        "/** @interface \n @extends {Int1} \n @extends {Int3} */" +
-        "function Int4() {};",
-        "Interface Int4 has a property foo with incompatible types in its " +
-        "super interfaces Int0 and Int2");
-  }
-
-  public void testExtendedInterfacePropertiesCompatibility5() throws Exception {
-    testTypes(
-        "/** @interface */function Int0() {};" +
-        "/** @interface */function Int1() {};" +
-        "/** @type {number} */" +
-        "Int0.prototype.foo;" +
-        "/** @type {string} */" +
-        "Int1.prototype.foo;" +
-        "/** @interface \n @extends {Int1} */ function Int2() {};" +
-        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
-        "function Int3() {};" +
-        "/** @interface */function Int4() {};" +
-        "/** @type {number} */" +
-        "Int4.prototype.foo;" +
-        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
-        "function Int5() {};",
-        new String[] {
-            "Interface Int3 has a property foo with incompatible types in its" +
-            " super interfaces Int0 and Int1",
-            "Interface Int5 has a property foo with incompatible types in its" +
-            " super interfaces Int1 and Int4"});
-  }
-
-  public void testExtendedInterfacePropertiesCompatibility6() throws Exception {
-    testTypes(
-        "/** @interface */function Int0() {};" +
-        "/** @interface */function Int1() {};" +
-        "/** @type {number} */" +
-        "Int0.prototype.foo;" +
-        "/** @type {string} */" +
-        "Int1.prototype.foo;" +
-        "/** @interface \n @extends {Int1} */ function Int2() {};" +
-        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
-        "function Int3() {};" +
-        "/** @interface */function Int4() {};" +
-        "/** @type {string} */" +
-        "Int4.prototype.foo;" +
-        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
-        "function Int5() {};",
-        "Interface Int3 has a property foo with incompatible types in its" +
-        " super interfaces Int0 and Int1");
-  }
-
-  public void testExtendedInterfacePropertiesCompatibility7() throws Exception {
-    testTypes(
-        "/** @interface */function Int0() {};" +
-        "/** @interface */function Int1() {};" +
-        "/** @type {number} */" +
-        "Int0.prototype.foo;" +
-        "/** @type {string} */" +
-        "Int1.prototype.foo;" +
-        "/** @interface \n @extends {Int1} */ function Int2() {};" +
-        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
-        "function Int3() {};" +
-        "/** @interface */function Int4() {};" +
-        "/** @type {Object} */" +
-        "Int4.prototype.foo;" +
-        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
-        "function Int5() {};",
-        new String[] {
-            "Interface Int3 has a property foo with incompatible types in its" +
-            " super interfaces Int0 and Int1",
-            "Interface Int5 has a property foo with incompatible types in its" +
-            " super interfaces Int1 and Int4"});
-  }
-
-  public void testExtendedInterfacePropertiesCompatibility8() throws Exception {
-    testTypes(
-        "/** @interface */function Int0() {};" +
-        "/** @interface */function Int1() {};" +
-        "/** @type {number} */" +
-        "Int0.prototype.foo;" +
-        "/** @type {string} */" +
-        "Int1.prototype.bar;" +
-        "/** @interface \n @extends {Int1} */ function Int2() {};" +
-        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
-        "function Int3() {};" +
-        "/** @interface */function Int4() {};" +
-        "/** @type {Object} */" +
-        "Int4.prototype.foo;" +
-        "/** @type {Null} */" +
-        "Int4.prototype.bar;" +
-        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
-        "function Int5() {};",
-        new String[] {
-            "Interface Int5 has a property bar with incompatible types in its" +
-            " super interfaces Int1 and Int4",
-            "Interface Int5 has a property foo with incompatible types in its" +
-            " super interfaces Int0 and Int4"});
-  }
-
   private void testTypes(String js) throws Exception {
     testTypes(js, (String) null);
   }
@@ -9800,7 +8505,7 @@
         0, compiler.getErrorCount());
 
     // For processing goog.addDependency for forward typedefs.
-    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)
+    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)
         .process(null, n);
 
     CodingConvention convention = compiler.getCodingConvention();
@@ -9813,10 +8518,7 @@
         registry)
         .processForTesting(null, n);
 
-    assertEquals(
-        "unexpected error(s) : " +
-        Joiner.on(", ").join(compiler.getErrors()),
-        0, compiler.getErrorCount());
+    assertEquals(0, compiler.getErrorCount());
 
     if (descriptions == null) {
       assertEquals(
@@ -9889,13 +8591,12 @@
   private TypeCheckResult parseAndTypeCheckWithScope(
       String externs, String js) {
     compiler.init(
-        Lists.newArrayList(SourceFile.fromCode("[externs]", externs)),
-        Lists.newArrayList(SourceFile.fromCode("[testcode]", js)),
+        Lists.newArrayList(JSSourceFile.fromCode("[externs]", externs)),
+        Lists.newArrayList(JSSourceFile.fromCode("[testcode]", js)),
         compiler.getOptions());
 
-    Node n = compiler.getInput(new InputId("[testcode]")).getAstRoot(compiler);
-    Node externsNode = compiler.getInput(new InputId("[externs]"))
-        .getAstRoot(compiler);
+    Node n = compiler.getInput("[testcode]").getAstRoot(compiler);
+    Node externsNode = compiler.getInput("[externs]").getAstRoot(compiler);
     Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);
     externAndJsRoot.setIsSyntheticBlock(true);
 
