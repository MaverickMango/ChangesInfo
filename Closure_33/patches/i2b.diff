diff -r -u inducing/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java buggy/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java
--- inducing/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java	2023-06-12 11:40:20.558988947 +0800
+++ buggy/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java	2023-06-12 11:40:20.346998848 +0800
@@ -40,14 +40,14 @@
 package com.google.javascript.rhino.jstype;
 
 import static com.google.common.base.Preconditions.checkState;
-
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.google.javascript.rhino.ErrorReporter;
 import com.google.javascript.rhino.JSDocInfo;
 import com.google.javascript.rhino.Node;
 
-import java.io.Serializable;
 import java.util.Map;
 import java.util.Set;
 
@@ -79,6 +79,11 @@
   // some subclasses override this to do special resolution handling.
   private ObjectType implicitPrototypeFallback;
 
+  // If this is a function prototype, then this is the owner.
+  // A PrototypeObjectType can only be the prototype of one function. If we try
+  // to do this for multiple functions, then we'll have to create a new one.
+  private FunctionType ownerFunction = null;
+
   // Whether the toString representation of this should be pretty-printed,
   // by printing all properties.
   private boolean prettyPrint = false;
@@ -119,6 +124,27 @@
     }
   }
 
+  @Override
+  public Property getSlot(String name) {
+    if (properties.containsKey(name)) {
+      return properties.get(name);
+    }
+    ObjectType implicitPrototype = getImplicitPrototype();
+    if (implicitPrototype != null) {
+      Property prop = implicitPrototype.getSlot(name);
+      if (prop != null) {
+        return prop;
+      }
+    }
+    for (ObjectType interfaceType : getCtorExtendedInterfaces()) {
+      Property prop = interfaceType.getSlot(name);
+      if (prop != null) {
+        return prop;
+      }
+    }
+    return null;
+  }
+
   /**
    * Gets the number of properties of this object.
    */
@@ -139,14 +165,8 @@
 
   @Override
   public boolean hasProperty(String propertyName) {
-    if (properties.get(propertyName) != null) {
-      return true;
-    }
-    ObjectType implicitPrototype = getImplicitPrototype();
-    if (implicitPrototype != null) {
-      return implicitPrototype.hasProperty(propertyName);
-    }
-    return false;
+    // Unknown types have all properties.
+    return isUnknownType() || getSlot(propertyName) != null;
   }
 
   @Override
@@ -161,16 +181,11 @@
 
   @Override
   public boolean isPropertyTypeDeclared(String property) {
-    Property p = properties.get(property);
-    if (p == null) {
-      ObjectType implicitPrototype = getImplicitPrototype();
-      if (implicitPrototype != null) {
-        return implicitPrototype.isPropertyTypeDeclared(property);
-      }
-      // property does not exist
+    StaticSlot<JSType> slot = getSlot(property);
+    if (slot == null) {
       return false;
     }
-    return !p.inferred;
+    return !slot.isTypeInferred();
   }
 
   @Override
@@ -186,36 +201,27 @@
 
   @Override
   public boolean isPropertyTypeInferred(String property) {
-    Property p = properties.get(property);
-    if (p == null) {
-      ObjectType implicitPrototype = getImplicitPrototype();
-      if (implicitPrototype != null) {
-        return implicitPrototype.isPropertyTypeInferred(property);
-      }
-      // property does not exist
+    StaticSlot<JSType> slot = getSlot(property);
+    if (slot == null) {
       return false;
     }
-    return p.inferred;
+    return slot.isTypeInferred();
   }
 
   @Override
-  public JSType getPropertyType(String propertyName) {
-    Property p = properties.get(propertyName);
-    if (p != null) {
-      return p.type;
-    }
-    ObjectType implicitPrototype = getImplicitPrototype();
-    if (implicitPrototype != null) {
-      return implicitPrototype.getPropertyType(propertyName);
+  public JSType getPropertyType(String property) {
+    StaticSlot<JSType> slot = getSlot(property);
+    if (slot == null) {
+      return getNativeType(JSTypeNative.UNKNOWN_TYPE);
     }
-    return getNativeType(JSTypeNative.UNKNOWN_TYPE);
+    return slot.getType();
   }
 
   @Override
   public boolean isPropertyInExterns(String propertyName) {
     Property p = properties.get(propertyName);
     if (p != null) {
-      return p.inExterns;
+      return p.isFromExterns();
     }
     ObjectType implicitPrototype = getImplicitPrototype();
     if (implicitPrototype != null) {
@@ -226,26 +232,32 @@
 
   @Override
   boolean defineProperty(String name, JSType type, boolean inferred,
-      boolean inExterns, Node propertyNode) {
+      Node propertyNode) {
     if (hasOwnDeclaredProperty(name)) {
       return false;
     }
-    Property newProp = new Property(type, inferred, inExterns, propertyNode);
+    Property newProp = new Property(
+        name, type, inferred, propertyNode);
     Property oldProp = properties.get(name);
     if (oldProp != null) {
       // This is to keep previously inferred jsdoc info, e.g., in a
       // replaceScript scenario.
-      newProp.docInfo = oldProp.docInfo;
+      newProp.setJSDocInfo(oldProp.getJSDocInfo());
     }
     properties.put(name, newProp);
     return true;
   }
 
   @Override
+  public boolean removeProperty(String name) {
+    return properties.remove(name) != null;
+  }
+
+  @Override
   public Node getPropertyNode(String propertyName) {
     Property p = properties.get(propertyName);
     if (p != null) {
-      return p.propertyNode;
+      return p.getNode();
     }
     ObjectType implicitPrototype = getImplicitPrototype();
     if (implicitPrototype != null) {
@@ -258,28 +270,27 @@
   public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {
     Property p = properties.get(propertyName);
     if (p != null) {
-      return p.docInfo;
+      return p.getJSDocInfo();
     }
     return null;
   }
 
   @Override
-  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info,
-      boolean inExterns) {
+  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) {
     if (info != null) {
       if (!properties.containsKey(propertyName)) {
         // If docInfo was attached, but the type of the property
         // was not defined anywhere, then we consider this an explicit
         // declaration of the property.
         defineInferredProperty(propertyName, getPropertyType(propertyName),
-            inExterns, null);
+            null);
       }
 
       // The prototype property is not represented as a normal Property.
       // We probably don't want to attach any JSDoc to it anyway.
       Property property = properties.get(propertyName);
       if (property != null) {
-        property.docInfo = info;
+        property.setJSDocInfo(info);
       }
     }
   }
@@ -302,7 +313,7 @@
    * present on the object and different from the native one.
    */
   private boolean hasOverridenNativeProperty(String propertyName) {
-    if (isNative()) {
+    if (isNativeObjectType()) {
       return false;
     }
 
@@ -338,19 +349,14 @@
     return isRegexpType();
   }
 
-  /**
-   * Whether this represents a native type (such as Object, Date,
-   * RegExp, etc.).
-   */
-  boolean isNative() {
-    return nativeType;
-  }
-
   @Override
-  public String toString() {
+  String toStringHelper(boolean forAnnotations) {
     if (hasReferenceName()) {
       return getReferenceName();
     } else if (prettyPrint) {
+      // Don't pretty print recursively.
+      prettyPrint = false;
+
       // Use a tree set so that the properties are sorted.
       Set<String> propertyNames = Sets.newTreeSet();
       for (ObjectType current = this;
@@ -371,19 +377,21 @@
 
         sb.append(property);
         sb.append(": ");
-        sb.append(getPropertyType(property).toString());
+        sb.append(getPropertyType(property).toStringHelper(forAnnotations));
 
         ++i;
-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
+        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {
           sb.append(", ...");
           break;
         }
       }
 
       sb.append("}");
+
+      prettyPrint = true;
       return sb.toString();
     } else {
-      return "{...}";
+      return forAnnotations ? "?" : "{...}";
     }
   }
 
@@ -391,6 +399,10 @@
     this.prettyPrint = prettyPrint;
   }
 
+  boolean isPrettyPrint() {
+    return prettyPrint;
+  }
+
   @Override
   public FunctionType getConstructor() {
     return null;
@@ -416,6 +428,8 @@
   public String getReferenceName() {
     if (className != null) {
       return className;
+    } else if (ownerFunction != null) {
+      return ownerFunction.getReferenceName() + ".prototype";
     } else {
       return null;
     }
@@ -423,25 +437,25 @@
 
   @Override
   public boolean hasReferenceName() {
-    return className != null;
+    return className != null || ownerFunction != null;
   }
 
   @Override
   public boolean isSubtype(JSType that) {
-    if (JSType.isSubtype(this, that)) {
+    if (JSType.isSubtypeHelper(this, that)) {
       return true;
     }
 
     // Union types
-    if (that instanceof UnionType) {
+    if (that.isUnionType()) {
       // The static {@code JSType.isSubtype} check already decomposed
       // union types, so we don't need to check those again.
       return false;
     }
 
     // record types
-    if (that instanceof RecordType) {
-      return RecordType.isSubtype(this, (RecordType) that);
+    if (that.isRecordType()) {
+      return RecordType.isSubtype(this, that.toMaybeRecordType());
     }
 
     // Interfaces
@@ -458,18 +472,22 @@
       }
     }
 
-    // other prototype based objects
-    if (that != null) {
-      if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
-        // If unsure, say 'yes', to avoid spurious warnings.
-        // TODO(user): resolve the prototype chain completely in all cases,
-        // to avoid guessing.
-        return true;
+    if (getConstructor() != null && getConstructor().isInterface()) {
+      for (ObjectType thisInterface : getCtorExtendedInterfaces()) {
+        if (thisInterface.isSubtype(that)) {
+          return true;
+        }
       }
-      return this.isImplicitPrototype(thatObj);
     }
 
-    return false;
+    // other prototype based objects
+    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
+      // If unsure, say 'yes', to avoid spurious warnings.
+      // TODO(user): resolve the prototype chain completely in all cases,
+      // to avoid guessing.
+      return true;
+    }
+    return this.isImplicitPrototype(thatObj);
   }
 
   private boolean implicitPrototypeChainIsUnknown() {
@@ -483,42 +501,6 @@
     return false;
   }
 
-  private static final class Property implements Serializable {
-    private static final long serialVersionUID = 1L;
-
-    /**
-     * Property's type.
-     */
-    private JSType type;
-
-    /**
-     * Whether the property's type is inferred.
-     */
-    private final boolean inferred;
-
-    /**
-     * Whether the property is defined in the externs.
-     */
-    private final boolean inExterns;
-
-    /**
-     * The node corresponding to this property, e.g., a GETPROP node that
-     * declares this property.
-     */
-    private final Node propertyNode;
-
-    /**  The JSDocInfo for this property. */
-    private JSDocInfo docInfo = null;
-
-    private Property(JSType type, boolean inferred, boolean inExterns,
-        Node propertyNode) {
-      this.type = type;
-      this.inferred = inferred;
-      this.inExterns = inExterns;
-      this.propertyNode = propertyNode;
-    }
-  }
-
   @Override
   public boolean hasCachedValues() {
     return super.hasCachedValues();
@@ -530,6 +512,30 @@
     return nativeType;
   }
 
+  void setOwnerFunction(FunctionType type) {
+    Preconditions.checkState(ownerFunction == null || type == null);
+    ownerFunction = type;
+  }
+
+  @Override
+  public FunctionType getOwnerFunction() {
+    return ownerFunction;
+  }
+
+  @Override
+  public Iterable<ObjectType> getCtorImplementedInterfaces() {
+    return isFunctionPrototypeType()
+        ? getOwnerFunction().getImplementedInterfaces()
+        : ImmutableList.<ObjectType>of();
+  }
+
+  @Override
+  public Iterable<ObjectType> getCtorExtendedInterfaces() {
+    return isFunctionPrototypeType()
+        ? getOwnerFunction().getExtendedInterfaces()
+        : ImmutableList.<ObjectType>of();
+  }
+
   @Override
   JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
     setResolvedTypeInternal(this);
@@ -540,8 +546,34 @@
           (ObjectType) implicitPrototype.resolve(t, scope);
     }
     for (Property prop : properties.values()) {
-      prop.type = safeResolve(prop.type, t, scope);
+      prop.setType(safeResolve(prop.getType(), t, scope));
     }
     return this;
   }
+
+  @Override
+  public void matchConstraint(ObjectType constraintObj) {
+    // Handle the case where the constraint object is a record type.
+    //
+    // param constraintObj {{prop: (number|undefined)}}
+    // function f(constraintObj) {}
+    // f({});
+    //
+    // We want to modify the object literal to match the constraint, by
+    // taking any each property on the record and trying to match
+    // properties on this object.
+    if (constraintObj.isRecordType()) {
+      for (String prop : constraintObj.getOwnPropertyNames()) {
+        JSType propType = constraintObj.getPropertyType(prop);
+        if (!isPropertyTypeDeclared(prop)) {
+          JSType typeToInfer = propType;
+          if (!hasProperty(prop)) {
+            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
+                .getLeastSupertype(propType);
+          }
+          defineInferredProperty(prop, typeToInfer, null);
+        }
+      }
+    }
+  }
 }
diff -r -u inducing/test/com/google/javascript/jscomp/TypeCheckTest.java buggy/test/com/google/javascript/jscomp/TypeCheckTest.java
--- inducing/test/com/google/javascript/jscomp/TypeCheckTest.java	2023-06-12 11:40:20.558988947 +0800
+++ buggy/test/com/google/javascript/jscomp/TypeCheckTest.java	2023-06-12 11:40:20.346998848 +0800
@@ -19,6 +19,7 @@
 import com.google.common.base.Joiner;
 import com.google.common.collect.Lists;
 import com.google.javascript.jscomp.Scope.Var;
+import com.google.javascript.rhino.InputId;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.jstype.FunctionType;
@@ -45,7 +46,7 @@
 
   public void testInitialTypingScope() {
     Scope s = new TypedScopeCreator(compiler,
-        new DefaultCodingConvention()).createInitialScope(
+        CodingConventions.getDefault()).createInitialScope(
             new Node(Token.BLOCK));
 
     assertEquals(ARRAY_FUNCTION_TYPE, s.getVar("Array").getType());
@@ -101,11 +102,6 @@
         "/** @type {undefined|number} */var a;if (a == foo())return;}");
   }
 
-  public void testTypeCheck7() throws Exception {
-    testTypes("function foo() {delete 'abc';}",
-        TypeCheck.BAD_DELETE);
-  }
-
   public void testTypeCheck8() throws Exception {
     testTypes("/**@return {void}*/function foo(){do {} while (foo());}");
   }
@@ -230,6 +226,17 @@
         "required: string", false);
   }
 
+
+  public void testTypeCheckCustomExterns2() throws Exception {
+    testTypes(
+        DEFAULT_EXTERNS + "/** @enum {string} */ var Enum = {FOO: 1, BAR: 1};",
+        "/** @param {Enum} x */ function f(x) {} f(Enum.FOO); f(true);",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: Enum.<string>",
+        false);
+  }
+
   public void testParameterizedArray1() throws Exception {
     testTypes("/** @param {!Array.<number>} a\n" +
         "* @return {string}\n" +
@@ -244,7 +251,7 @@
         "* @return {number}\n" +
         "*/ var f = function(a) { return a[0]; };",
         "inconsistent return type\n" +
-        "found   : Array\n" +
+        "found   : Array.<number>\n" +
         "required: number");
   }
 
@@ -322,6 +329,16 @@
         "required: E.<string>");
   }
 
+  public void testParameterizedObject5() throws Exception {
+    testTypes("/** @constructor */ function F() {" +
+        "  /** @type {Object.<number, string>} */ this.numbers = {};" +
+        "}" +
+        "(new F()).numbers['ten'] = '10';",
+        "restricted index type\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
   public void testUnionOfFunctionAndType() throws Exception {
     testTypes("/** @type {null|(function(Number):void)} */ var a;" +
         "/** @type {(function(Number):void)|null} */ var b = null; a = b;");
@@ -612,7 +629,7 @@
     // Don't do type inference on GETELEMs.
     testClosureTypes(
         CLOSURE_DEFS +
-        "function f(arguments) { " +
+        "function f(x) { " +
         "  return goog.isString(arguments[0]) ? arguments[0] : 0;" +
         "}", null);
   }
@@ -621,7 +638,7 @@
     // Don't do type inference on GETELEMs.
     testClosureTypes(
         CLOSURE_DEFS +
-        "function f(arguments) { " +
+        "function f(x) { " +
         "  return typeof arguments[0] == 'string' ? arguments[0] : 0;" +
         "}", null);
   }
@@ -834,6 +851,37 @@
         "};");
   }
 
+  public void testUndeclaredGlobalProperty1() throws Exception {
+    testTypes("/** @const */ var x = {}; x.y = null;" +
+        "function f(a) { x.y = a; }" +
+        "/** @param {string} a */ function g(a) { }" +
+        "function h() { g(x.y); }");
+  }
+
+  public void testUndeclaredGlobalProperty2() throws Exception {
+    testTypes("/** @const */ var x = {}; x.y = null;" +
+        "function f() { x.y = 3; }" +
+        "/** @param {string} a */ function g(a) { }" +
+        "function h() { g(x.y); }",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : (null|number)\n" +
+        "required: string");
+  }
+
+  public void testLocallyInferredGlobalProperty1() throws Exception {
+    // We used to have a bug where x.y.z leaked from f into h.
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** @type {number} */ F.prototype.z;" +
+        "/** @const */ var x = {}; /** @type {F} */ x.y;" +
+        "function f() { x.y.z = 'abc'; }" +
+        "/** @param {number} x */ function g(x) {}" +
+        "function h() { g(x.y.z); }",
+        "assignment to property z of F\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
   public void testPropertyInferredPropagation() throws Exception {
     testTypes("/** @return {Object} */function f() { return {}; }\n" +
          "function g() { var x = f(); if (x.p) x.a = 'a'; else x.a = 'b'; }\n" +
@@ -923,6 +971,38 @@
         "required: string");
   }
 
+  public void testPropertyInference9() throws Exception {
+    testTypes(
+        "/** @constructor */ function A() {}" +
+        "/** @return {function(): ?} */ function f() { " +
+        "  return function() {};" +
+        "}" +
+        "var g = f();" +
+        "/** @type {number} */ g.prototype.bar_ = null;",
+        "assignment\n" +
+        "found   : null\n" +
+        "required: number");
+  }
+
+  public void testPropertyInference10() throws Exception {
+    // NOTE(nicksantos): There used to be a bug where a property
+    // on the prototype of one structural function would leak onto
+    // the prototype of other variables with the same structural
+    // function type.
+    testTypes(
+        "/** @constructor */ function A() {}" +
+        "/** @return {function(): ?} */ function f() { " +
+        "  return function() {};" +
+        "}" +
+        "var g = f();" +
+        "/** @type {number} */ g.prototype.bar_ = 1;" +
+        "var h = f();" +
+        "/** @type {string} */ h.prototype.bar_ = 1;",
+        "assignment\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testNoPersistentTypeInferenceForObjectProperties()
       throws Exception {
     testTypes("/** @param {Object} o\n@param {string} x */\n" +
@@ -1417,6 +1497,21 @@
         "required: number");
   }
 
+  public void testScoping12() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** @type {number} */ F.prototype.bar = 3;" +
+        "/** @param {!F} f */ function g(f) {" +
+        "  /** @return {string} */" +
+        "  function h() {" +
+        "    return f.bar;" +
+        "  }" +
+        "}",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testFunctionArguments1() throws Exception {
     testFunctionType(
         "/** @param {number} a\n@return {string} */" +
@@ -1428,7 +1523,7 @@
     testFunctionType(
         "/** @param {number} opt_a\n@return {string} */" +
         "function f(opt_a) {}",
-        "function ((number|undefined)): string");
+        "function (number=): string");
   }
 
   public void testFunctionArguments3() throws Exception {
@@ -1442,7 +1537,7 @@
     testFunctionType(
         "/** @param {number} opt_a\n@return {string} */" +
         "function f(a,opt_a) {}",
-        "function (?, (number|undefined)): string");
+        "function (?, number=): string");
   }
 
   public void testFunctionArguments5() throws Exception {
@@ -1495,13 +1590,13 @@
   }
 
   public void testFunctionArguments13() throws Exception {
-    // verifying that the argument type have inferable types
+    // verifying that the argument type have non-inferrable types
     testTypes(
         "/** @return {boolean} */ function u() { return true; }" +
-        "/** @param {boolean} b\n@return {boolean} */" +
+        "/** @param {boolean} b\n@return {?boolean} */" +
         "function f(b) { if (u()) { b = null; } return b; }",
-        "inconsistent return type\n" +
-        "found   : (boolean|null)\n" +
+        "assignment\n" +
+        "found   : null\n" +
         "required: boolean");
   }
 
@@ -1586,7 +1681,7 @@
   public void testFunctionInference6() throws Exception {
     testFunctionType(
         "/** @this Date\n@return {string} */function f(opt_a) {}",
-        "function (this:Date, ?): string");
+        "function (this:Date, ?=): string");
   }
 
   public void testFunctionInference7() throws Exception {
@@ -1812,6 +1907,43 @@
         "}");
   }
 
+  public void testInnerFunction10() throws Exception {
+    testTypes(
+        "function f() {" +
+        "  /** @type {?number} */ var x = null;" +
+        "  /** @return {string} */" +
+        "  function g() {" +
+        "    if (!x) {" +
+        "      x = 1;" +
+        "    }" +
+        "    return x;" +
+        "  }" +
+        "}",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testInnerFunction11() throws Exception {
+    // TODO(nicksantos): This is actually bad inference, because
+    // h sets x to null. We should fix this, but for now we do it
+    // this way so that we don't break existing binaries. We will
+    // need to change TypeInference#isUnflowable to fix this.
+    testTypes(
+        "function f() {" +
+        "  /** @type {?number} */ var x = null;" +
+        "  /** @return {number} */" +
+        "  function g() {" +
+        "    x = 1;" +
+        "    h();" +
+        "    return x;" +
+        "  }" +
+        "  function h() {" +
+        "    x = null;" +
+        "  }" +
+        "}");
+  }
+
   public void testAbstractMethodHandling1() throws Exception {
     testTypes(
         "/** @type {Function} */ var abstractFn = function() {};" +
@@ -1941,10 +2073,7 @@
         "/** @constructor \n * @extends {F} */ " +
         "function G() {}" +
         "/** @override */ G.prototype.foo = function() { };" +
-        "(new G()).foo(1);",
-        "Function G.prototype.foo: called with 1 argument(s). " +
-        "Function requires at least 0 argument(s) " +
-        "and no more than 0 argument(s).");
+        "(new G()).foo(1);");
   }
 
   public void testMethodInference7() throws Exception {
@@ -1953,11 +2082,11 @@
         "F.prototype.foo = function() { };" +
         "/** @constructor \n * @extends {F} */ " +
         "function G() {}" +
-        "/** @override */ G.prototype.foo = function(x, y) { };" +
-        "(new G()).foo();",
-        "Function G.prototype.foo: called with 0 argument(s). " +
-        "Function requires at least 2 argument(s) " +
-        "and no more than 2 argument(s).");
+        "/** @override */ G.prototype.foo = function(x, y) { };",
+        "mismatch of the foo property type and the type of the property " +
+        "it overrides from superclass F\n" +
+        "original: function (this:F): undefined\n" +
+        "override: function (this:G, ?, ?): undefined");
   }
 
   public void testMethodInference8() throws Exception {
@@ -1967,10 +2096,8 @@
         "/** @constructor \n * @extends {F} */ " +
         "function G() {}" +
         "/** @override */ " +
-        "G.prototype.foo = function(a, opt_b, var_args) { };" +
-        "(new G()).foo();",
-        "Function G.prototype.foo: called with 0 argument(s). " +
-        "Function requires at least 1 argument(s).");
+        "G.prototype.foo = function(opt_b, var_args) { };" +
+        "(new G()).foo(1, 2, 3);");
   }
 
   public void testMethodInference9() throws Exception {
@@ -1980,7 +2107,7 @@
         "/** @constructor \n * @extends {F} */ " +
         "function G() {}" +
         "/** @override */ " +
-        "G.prototype.foo = function(a, var_args, opt_b) { };",
+        "G.prototype.foo = function(var_args, opt_b) { };",
         "variable length argument must be last");
   }
 
@@ -2079,23 +2206,31 @@
   }
 
   public void testDuplicateStaticPropertyDecl4() throws Exception {
-    testTypes(
+    testClosureTypesMultipleWarnings(
         "var goog = goog || {};" +
         "/** @type {!Foo} */ goog.foo;" +
         "/** @type {string} */ goog.foo = 'x';" +
         "/** @constructor */ function Foo() {}",
-        "variable goog.foo redefined with type string, " +
-        "original definition at [testcode]:1 with type Foo");
+        Lists.newArrayList(
+            "assignment to property foo of goog\n" +
+            "found   : string\n" +
+            "required: Foo",
+            "variable goog.foo redefined with type string, " +
+            "original definition at [testcode]:1 with type Foo"));
   }
 
   public void testDuplicateStaticPropertyDecl5() throws Exception {
-    testTypes(
+    testClosureTypesMultipleWarnings(
         "var goog = goog || {};" +
         "/** @type {!Foo} */ goog.foo;" +
         "/** @type {string}\n * @suppress {duplicate} */ goog.foo = 'x';" +
         "/** @constructor */ function Foo() {}",
-        "variable goog.foo redefined with type string, " +
-        "original definition at [testcode]:1 with type Foo");
+        Lists.newArrayList(
+            "assignment to property foo of goog\n" +
+            "found   : string\n" +
+            "required: Foo",
+            "variable goog.foo redefined with type string, " +
+            "original definition at [testcode]:1 with type Foo"));
   }
 
   public void testDuplicateStaticPropertyDecl6() throws Exception {
@@ -2128,12 +2263,89 @@
         "/** @constructor */ function EventCopy() {}");
   }
 
-  public void testDuplicateLocalVarDecl() throws Exception {
+  public void testDuplicateStaticPropertyDec20() throws Exception {
     testTypes(
+        "/**\n" +
+        " * @fileoverview\n" +
+        " * @suppress {duplicate}\n" +
+        " */" +
+        "var goog = goog || {};" +
+        "/** @type {string} */ goog.foo = 'y';" +
+        "/** @type {string} */ goog.foo = 'x';");
+  }
+
+  public void testDuplicateLocalVarDecl() throws Exception {
+    testClosureTypesMultipleWarnings(
         "/** @param {number} x */\n" +
         "function f(x) { /** @type {string} */ var x = ''; }",
-        "variable x redefined with type string, " +
-        "original definition at [testcode]:2 with type number");
+        Lists.newArrayList(
+            "variable x redefined with type string, original definition" +
+            " at [testcode]:2 with type number",
+            "initializing variable\n" +
+            "found   : string\n" +
+            "required: number"));
+  }
+
+  public void testDuplicateInstanceMethod1() throws Exception {
+    // If there's no jsdoc on the methods, then we treat them like
+    // any other inferred properties.
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "F.prototype.bar = function() {};" +
+        "F.prototype.bar = function() {};");
+  }
+
+  public void testDuplicateInstanceMethod2() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** jsdoc */ F.prototype.bar = function() {};" +
+        "/** jsdoc */ F.prototype.bar = function() {};",
+        "variable F.prototype.bar redefined with type " +
+        "function (this:F): undefined, original definition at " +
+        "[testcode]:1 with type function (this:F): undefined");
+  }
+
+  public void testDuplicateInstanceMethod3() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "F.prototype.bar = function() {};" +
+        "/** jsdoc */ F.prototype.bar = function() {};",
+        "variable F.prototype.bar redefined with type " +
+        "function (this:F): undefined, original definition at " +
+        "[testcode]:1 with type function (this:F): undefined");
+  }
+
+  public void testDuplicateInstanceMethod4() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** jsdoc */ F.prototype.bar = function() {};" +
+        "F.prototype.bar = function() {};");
+  }
+
+  public void testDuplicateInstanceMethod5() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** jsdoc \n * @return {number} */ F.prototype.bar = function() {" +
+        "  return 3;" +
+        "};" +
+        "/** jsdoc \n * @suppress {duplicate} */ " +
+        "F.prototype.bar = function() { return ''; };",
+        "inconsistent return type\n" +
+        "found   : string\n" +
+        "required: number");
+  }
+
+  public void testDuplicateInstanceMethod6() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** jsdoc \n * @return {number} */ F.prototype.bar = function() {" +
+        "  return 3;" +
+        "};" +
+        "/** jsdoc \n * @return {string} * \n @suppress {duplicate} */ " +
+        "F.prototype.bar = function() { return ''; };",
+        "assignment to property bar of F.prototype\n" +
+        "found   : function (this:F): string\n" +
+        "required: function (this:F): number");
   }
 
   public void testStubFunctionDeclaration1() throws Exception {
@@ -2286,7 +2498,7 @@
   public void testIn4() throws Exception {
     testTypes("Date in Object",
         "left side of 'in'\n" +
-        "found   : function (new:Date, ?, ?, ?, ?, ?, ?, ?): string\n" +
+        "found   : function (new:Date, ?=, ?=, ?=, ?=, ?=, ?=, ?=): string\n" +
         "required: string");
   }
 
@@ -2543,19 +2755,20 @@
 
   public void testEnum3() throws Exception {
     testTypes("/**@enum*/var a={BB:1,BB:2}",
-        "enum element BB already defined", true);
+        "variable a.BB redefined with type a.<number>, " +
+        "original definition at [testcode]:1 with type a.<number>");
   }
 
   public void testEnum4() throws Exception {
     testTypes("/**@enum*/var a={BB:'string'}",
-        "element type must match enum's type\n" +
+        "assignment to property BB of enum{a}\n" +
         "found   : string\n" +
         "required: number");
   }
 
   public void testEnum5() throws Exception {
     testTypes("/**@enum {String}*/var a={BB:'string'}",
-        "element type must match enum's type\n" +
+        "assignment to property BB of enum{a}\n" +
         "found   : string\n" +
         "required: (String|null)");
   }
@@ -2574,15 +2787,23 @@
   }
 
   public void testEnum8() throws Exception {
-    testTypes("/** @enum */var a=8;",
-        "enum initializer must be an object literal or an enum");
+    testClosureTypesMultipleWarnings("/** @enum */var a=8;",
+        Lists.newArrayList(
+            "enum initializer must be an object literal or an enum",
+            "initializing variable\n" +
+            "found   : number\n" +
+            "required: enum{a}"));
   }
 
   public void testEnum9() throws Exception {
-    testTypes(
+    testClosureTypesMultipleWarnings(
         "var goog = {};" +
         "/** @enum */goog.a=8;",
-        "enum initializer must be an object literal or an enum");
+        Lists.newArrayList(
+            "assignment to property a of goog\n" +
+            "found   : number\n" +
+            "required: enum{goog.a}",
+            "enum initializer must be an object literal or an enum"));
   }
 
   public void testEnum10() throws Exception {
@@ -2629,14 +2850,15 @@
 
   public void testEnum16() throws Exception {
     testTypes("var goog = {};" +
-        "/**@enum*/goog.a={BB:1,BB:2}",
-        "enum element BB already defined", true);
+        "/**@enum*/goog .a={BB:1,BB:2}",
+        "variable goog.a.BB redefined with type goog.a.<number>, " +
+        "original definition at [testcode]:1 with type goog.a.<number>");
   }
 
   public void testEnum17() throws Exception {
     testTypes("var goog = {};" +
         "/**@enum*/goog.a={BB:'string'}",
-        "element type must match enum's type\n" +
+        "assignment to property BB of enum{goog.a}\n" +
         "found   : string\n" +
         "required: number");
   }
@@ -2802,6 +3024,13 @@
         "required: string");
   }
 
+  public void testEnum42() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @enum {Object} */ var MyEnum = {FOO: {newProperty: 1, b: 2}};" +
+        "f(MyEnum.FOO.newProperty);");
+  }
+
   public void testAliasedEnum1() throws Exception {
     testTypes(
         "/** @enum */ var YourEnum = {FOO: 3};" +
@@ -2911,15 +3140,6 @@
         "required: string");
   }
 
-  public void testBackwardsTypedefUse5() throws Exception {
-    testTypes(
-        "/** @return {MyTypedef} */ function f() { return null; }" +
-        "/** @type {string} */ var MyTypedef = goog.typedef;",
-        "inconsistent return type\n" +
-        "found   : null\n" +
-        "required: string");
-  }
-
   public void testBackwardsTypedefUse6() throws Exception {
     testTypes(
         "/** @return {goog.MyTypedef} */ function f() { return null; }" +
@@ -2958,6 +3178,18 @@
         "required: Array");
   }
 
+  public void testBackwardsTypedefUse10() throws Exception {
+    testTypes(
+        "/** @param {goog.MyEnum} x */ function g(x) {}" +
+        "var goog = {};" +
+        "/** @enum {goog.MyTypedef} */ goog.MyEnum = {FOO: 1};" +
+        "/** @typedef {number} */ goog.MyTypedef;" +
+        "g(1);",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: goog.MyEnum.<number>");
+  }
+
   public void testBackwardsConstructor1() throws Exception {
     testTypes(
         "function f() { (new Foo(true)); }" +
@@ -3110,6 +3342,44 @@
         "required: number");
   }
 
+  public void testGoodExtends14() throws Exception {
+    testTypes(
+        CLOSURE_DEFS +
+        "/** @param {Function} f */ function g(f) {" +
+        "  /** @constructor */ function NewType() {};" +
+        "  goog.inherits(NewType, f);" +
+        "  (new NewType());" +
+        "}");
+  }
+
+  public void testGoodExtends15() throws Exception {
+    testTypes(
+        CLOSURE_DEFS +
+        "/** @constructor */ function OldType() {}" +
+        "/** @param {?function(new:OldType)} f */ function g(f) {" +
+        "  /**\n" +
+        "    * @constructor\n" +
+        "    * @extends {OldType}\n" +
+        "    */\n" +
+        "  function NewType() {};" +
+        "  goog.inherits(NewType, f);" +
+        "  NewType.prototype.method = function() {" +
+        "    NewType.superClass_.foo.call(this);" +
+        "  };" +
+        "}",
+        "Property foo never defined on OldType.prototype");
+  }
+
+  public void testGoodExtends16() throws Exception {
+    testTypes(
+        CLOSURE_DEFS +
+        "/** @param {Function} f */ function g(f) {" +
+        "  /** @constructor */ function NewType() {};" +
+        "  goog.inherits(f, NewType);" +
+        "  (new NewType());" +
+        "}");
+  }
+
   public void testBadExtends1() throws Exception {
     testTypes("/** @constructor */function base() {}\n" +
         "/** @constructor\n * @extends {not_base} */function derived() {}\n",
@@ -3282,6 +3552,44 @@
         "goog.SubDisposable.prototype.dispose = function() {};");
   }
 
+  public void testGoodImplements5() throws Exception {
+    testTypes(
+        "/** @interface */\n" +
+        "goog.Disposable = function() {};" +
+        "/** @type {Function} */" +
+        "goog.Disposable.prototype.dispose = function() {};" +
+        "/** @implements {goog.Disposable}\n * @constructor */" +
+        "goog.SubDisposable = function() {};" +
+        "/** @param {number} key \n @override */ " +
+        "goog.SubDisposable.prototype.dispose = function(key) {};");
+  }
+
+  public void testGoodImplements6() throws Exception {
+    testTypes(
+        "var myNullFunction = function() {};" +
+        "/** @interface */\n" +
+        "goog.Disposable = function() {};" +
+        "/** @return {number} */" +
+        "goog.Disposable.prototype.dispose = myNullFunction;" +
+        "/** @implements {goog.Disposable}\n * @constructor */" +
+        "goog.SubDisposable = function() {};" +
+        "/** @return {number} \n @override */ " +
+        "goog.SubDisposable.prototype.dispose = function() { return 0; };");
+  }
+
+  public void testGoodImplements7() throws Exception {
+    testTypes(
+        "var myNullFunction = function() {};" +
+        "/** @interface */\n" +
+        "goog.Disposable = function() {};" +
+        "/** @return {number} */" +
+        "goog.Disposable.prototype.dispose = function() {};" +
+        "/** @implements {goog.Disposable}\n * @constructor */" +
+        "goog.SubDisposable = function() {};" +
+        "/** @return {number} \n @override */ " +
+        "goog.SubDisposable.prototype.dispose = function() { return 0; };");
+  }
+
   public void testBadImplements1() throws Exception {
     testTypes("/** @interface */function Base1() {}\n" +
         "/** @interface */function Base2() {}\n" +
@@ -3315,6 +3623,26 @@
         "but not implement interfaces");
   }
 
+  public void testBadImplements5() throws Exception {
+    testTypes("/** @interface */function Disposable() {}\n" +
+        "/** @type {number} */ Disposable.prototype.bar = function() {};",
+        "assignment to property bar of Disposable.prototype\n" +
+        "found   : function (): undefined\n" +
+        "required: number");
+  }
+
+  public void testBadImplements6() throws Exception {
+    testClosureTypesMultipleWarnings(
+        "/** @interface */function Disposable() {}\n" +
+        "/** @type {function()} */ Disposable.prototype.bar = 3;",
+        Lists.newArrayList(
+            "assignment to property bar of Disposable.prototype\n" +
+            "found   : number\n" +
+            "required: function (): ?",
+            "interface members can only be empty property declarations, " +
+            "empty functions, or goog.abstractMethod"));
+  }
+
   public void testInterfaceExtends() throws Exception {
     testTypes("/** @interface */function A() {}\n" +
         "/** @interface \n * @extends {A} */function B() {}\n" +
@@ -3442,7 +3770,8 @@
   public void testInterfaceAssignment8() throws Exception {
     testTypes("/** @interface */var I = function() {};\n" +
         "/** @type {I} */var i;\n" +
-        "/** @type {Object} */var o = i;");
+        "/** @type {Object} */var o = i;\n" +
+        "new Object().prototype = i.prototype;");
   }
 
   public void testInterfaceAssignment9() throws Exception {
@@ -3496,14 +3825,14 @@
 
   public void testGetprop1() throws Exception {
     testTypes("/** @return {void}*/function foo(){foo().bar;}",
-        "undefined has no properties\n" +
+        "No properties on this expression\n" +
         "found   : undefined\n" +
         "required: Object");
   }
 
   public void testGetprop2() throws Exception {
     testTypes("var x = null; x.alert();",
-        "null has no properties\n" +
+        "No properties on this expression\n" +
         "found   : null\n" +
         "required: Object");
   }
@@ -3568,6 +3897,14 @@
         "required: Object");
   }
 
+  public void testArrayAccess9() throws Exception {
+    testTypes("/** @return {?Array} */ function f() { return []; }" +
+        "f()[{}]",
+        "array access\n" +
+        "found   : {}\n" +
+        "required: number");
+  }
+
   public void testPropAccess() throws Exception {
     testTypes("/** @param {*} x */var f = function(x) {\n" +
         "var o = String(x);\n" +
@@ -3578,7 +3915,7 @@
 
   public void testPropAccess2() throws Exception {
     testTypes("var bar = void 0; bar.baz;",
-        "undefined has no properties\n" +
+        "No properties on this expression\n" +
         "found   : undefined\n" +
         "required: Object");
   }
@@ -3587,7 +3924,7 @@
     // Verifies that we don't emit two warnings, because
     // the var has been dereferenced after the first one.
     testTypes("var bar = void 0; bar.baz; bar.bax;",
-        "undefined has no properties\n" +
+        "No properties on this expression\n" +
         "found   : undefined\n" +
         "required: Object");
   }
@@ -4137,8 +4474,6 @@
   public void testClosure7() throws Exception {
     testClosureTypes(
         CLOSURE_DEFS +
-        "goog.asserts = {};" +
-        "/** @return {*} */ goog.asserts.assert = function(x) { return x; };" +
         "/** @type {string|null|undefined} */ var a = foo();" +
         "/** @type {number} */" +
         "var b = goog.asserts.assert(a);",
@@ -4387,6 +4722,114 @@
         "required: string");
   }
 
+  public void testOverriddenParams1() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @param {...?} var_args */" +
+        "Foo.prototype.bar = function(var_args) {};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @param {number} x\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function(x) {};");
+  }
+
+  public void testOverriddenParams2() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @type {function(...[?])} */" +
+        "Foo.prototype.bar = function(var_args) {};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @type {function(number)}\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function(x) {};");
+  }
+
+  public void testOverriddenParams3() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @param {...number} var_args */" +
+        "Foo.prototype.bar = function(var_args) { };" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @param {number} x\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function(x) {};",
+        "mismatch of the bar property type and the type of the " +
+        "property it overrides from superclass Foo\n" +
+        "original: function (this:Foo, ...[number]): undefined\n" +
+        "override: function (this:SubFoo, number): undefined");
+  }
+
+  public void testOverriddenParams4() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @type {function(...[number])} */" +
+        "Foo.prototype.bar = function(var_args) {};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @type {function(number)}\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function(x) {};",
+        "mismatch of the bar property type and the type of the " +
+        "property it overrides from superclass Foo\n" +
+        "original: function (...[number]): ?\n" +
+        "override: function (number): ?");
+  }
+
+  public void testOverriddenParams5() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @param {number} x */" +
+        "Foo.prototype.bar = function(x) { };" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function() {};" +
+        "(new SubFoo()).bar();");
+  }
+
+  public void testOverriddenParams6() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @param {number} x */" +
+        "Foo.prototype.bar = function(x) { };" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = function() {};" +
+        "(new SubFoo()).bar(true);",
+        "actual parameter 1 of SubFoo.prototype.bar " +
+        "does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
   public void testOverriddenReturn1() throws Exception {
     testTypes(
         "/** @constructor */ function Foo() {}" +
@@ -4424,6 +4867,39 @@
         "required: number");
   }
 
+  public void testOverriddenProperty1() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @type {Object} */" +
+        "Foo.prototype.bar = {};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @type {Array}\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = [];");
+  }
+
+  public void testOverriddenProperty2() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {" +
+        "  /** @type {Object} */" +
+        "  this.bar = {};" +
+        "}" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */ function SubFoo() {}" +
+        "/**\n" +
+        " * @type {Array}\n" +
+        " * @override\n" +
+        " */" +
+        "SubFoo.prototype.bar = [];");
+  }
+
   public void testThis2() throws Exception {
     testTypes("var goog = {};" +
         "/** @constructor */goog.A = function(){" +
@@ -4523,6 +4999,80 @@
         "required: number");
   }
 
+  public void testThis12() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @constructor */ function Ctor() {}" +
+        "Ctor.prototype['method'] = function() {" +
+        "  f(this);" +
+        "}",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : Ctor\n" +
+        "required: number");
+  }
+
+  public void testThis13() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @constructor */ function Ctor() {}" +
+        "Ctor.prototype = {" +
+        "  method: function() {" +
+        "    f(this);" +
+        "  }" +
+        "};",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : Ctor\n" +
+        "required: number");
+  }
+
+  public void testThis14() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "f(this.Object);",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : function (new:Object, *=): ?\n" +
+        "required: number");
+  }
+
+  public void testThisTypeOfFunction1() throws Exception {
+    testTypes(
+        "/** @type {function(this:Object)} */ function f() {}" +
+        "f();");
+  }
+
+  public void testThisTypeOfFunction2() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** @type {function(this:F)} */ function f() {}" +
+        "f();",
+        "\"function (this:F): ?\" must be called with a \"this\" type");
+  }
+
+  public void testThisTypeOfFunction3() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "F.prototype.bar = function() {};" +
+        "var f = (new F()).bar; f();",
+        "\"function (this:F): undefined\" must be called with a \"this\" type");
+  }
+
+  public void testThisTypeOfFunction4() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "F.prototype.moveTo = function(x, y) {};" +
+        "F.prototype.lineTo = function(x, y) {};" +
+        "function demo() {" +
+        "  var path = new F();" +
+        "  var points = [[1,1], [2,2]];" +
+        "  for (var i = 0; i < points.length; i++) {" +
+        "    (i == 0 ? path.moveTo : path.lineTo)(" +
+        "       points[i][0], points[i][1]);" +
+        "  }" +
+        "}",
+        "\"function (this:F, ?, ?): undefined\" " +
+        "must be called with a \"this\" type");
+  }
+
   public void testGlobalThis1() throws Exception {
     testTypes("/** @constructor */ function Window() {}" +
         "/** @param {string} msg */ " +
@@ -5046,6 +5596,27 @@
         "Property indexOf never defined on String.prototype.toLowerCase");
   }
 
+  public void testIssue368() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo(){}" +
+        "/**\n" +
+        " * @param {number} one\n" +
+        " * @param {string} two\n" +
+        " */\n" +
+        "Foo.prototype.add = function(one, two) {};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar(){}" +
+        "/** @override */\n" +
+        "Bar.prototype.add = function(ignored) {};" +
+        "(new Bar()).add(1, 2);",
+        "actual parameter 2 of Bar.prototype.add does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testIssue380() throws Exception {
     testTypes(
         "/** @type { function(string): {innerHTML: string} } */" +
@@ -5055,6 +5626,153 @@
         "document.getElementById('node').innerHTML = list.toString();");
   }
 
+  public void testIssue483() throws Exception {
+    testTypes(
+        "/** @constructor */ function C() {" +
+        "  /** @type {?Array} */ this.a = [];" +
+        "}" +
+        "C.prototype.f = function() {" +
+        "  if (this.a.length > 0) {" +
+        "    g(this.a);" +
+        "  }" +
+        "};" +
+        "/** @param {number} a */ function g(a) {}",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : Array\n" +
+        "required: number");
+  }
+
+  public void testIssue537a() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype = {method: function() {}};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {" +
+        "  Foo.call(this);" +
+        "  if (this.baz()) this.method(1);" +
+        "}" +
+        "Bar.prototype = {" +
+        "  baz: function() {" +
+        "    return true;" +
+        "  }" +
+        "};" +
+        "Bar.prototype.__proto__ = Foo.prototype;",
+        "Function Foo.prototype.method: called with 1 argument(s). " +
+        "Function requires at least 0 argument(s) " +
+        "and no more than 0 argument(s).");
+  }
+
+  public void testIssue537b() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype = {method: function() {}};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {" +
+        "  Foo.call(this);" +
+        "  if (this.baz(1)) this.method();" +
+        "}" +
+        "Bar.prototype = {" +
+        "  baz: function() {" +
+        "    return true;" +
+        "  }" +
+        "};" +
+        "Bar.prototype.__proto__ = Foo.prototype;",
+        "Function Bar.prototype.baz: called with 1 argument(s). " +
+        "Function requires at least 0 argument(s) " +
+        "and no more than 0 argument(s).");
+  }
+
+  public void testIssue537c() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {" +
+        "  Foo.call(this);" +
+        "  if (this.baz2()) alert(1);" +
+        "}" +
+        "Bar.prototype = {" +
+        "  baz: function() {" +
+        "    return true;" +
+        "  }" +
+        "};" +
+        "Bar.prototype.__proto__ = Foo.prototype;",
+        "Property baz2 never defined on Bar");
+  }
+
+  public void testIssue537d() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype = {" +
+        "  /** @return {Bar} */ x: function() { new Bar(); }," +
+        "  /** @return {Foo} */ y: function() { new Bar(); }" +
+        "};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "function Bar() {" +
+        "  this.xy = 3;" +
+        "}" +
+        "/** @return {Bar} */ function f() { return new Bar(); }" +
+        "/** @return {Foo} */ function g() { return new Bar(); }" +
+        "Bar.prototype = {" +
+        "  /** @return {Bar} */ x: function() { new Bar(); }," +
+        "  /** @return {Foo} */ y: function() { new Bar(); }" +
+        "};" +
+        "Bar.prototype.__proto__ = Foo.prototype;");
+  }
+
+  public void testIssue586() throws Exception {
+    testTypes(
+        "/** @constructor */" +
+        "var MyClass = function() {};" +
+        "/** @param {boolean} success */" +
+        "MyClass.prototype.fn = function(success) {};" +
+        "MyClass.prototype.test = function() {" +
+        "  this.fn();" +
+        "  this.fn = function() {};" +
+        "};",
+        "Function MyClass.prototype.fn: called with 0 argument(s). " +
+        "Function requires at least 1 argument(s) " +
+        "and no more than 1 argument(s).");
+  }
+
+  public void testIssue635() throws Exception {
+    // TODO(nicksantos): Make this emit a warning, because of the 'this' type.
+    testTypes(
+        "/** @constructor */" +
+        "function F() {}" +
+        "F.prototype.bar = function() { this.baz(); };" +
+        "F.prototype.baz = function() {};" +
+        "/** @constructor */" +
+        "function G() {}" +
+        "G.prototype.bar = F.prototype.bar;");
+  }
+
+  public void testIssue669() throws Exception {
+    testTypes(
+        "/** @return {{prop1: (Object|undefined)}} */" +
+         "function f(a) {" +
+         "  var results;" +
+         "  if (a) {" +
+         "    results = {};" +
+         "    results.prop1 = {a: 3};" +
+         "  } else {" +
+         "    results = {prop2: 3};" +
+         "  }" +
+         "  return results;" +
+         "}");
+  }
+
   /**
    * Tests that the || operator is type checked correctly, that is of
    * the type of the first argument or of the second argument. See
@@ -5242,7 +5960,7 @@
         "var x = f();" +
         "/** @type {string} */" +
         "x.y = 3;",
-        "assignment to property y of x\n" +
+        "assignment\n" +
         "found   : number\n" +
         "required: string");
   }
@@ -5425,6 +6143,28 @@
         "})();");
   }
 
+  public void testQualifiedNameInference11() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "function f() {" +
+        "  var x = new Foo();" +
+        "  x.onload = function() {" +
+        "    x.onload = null;" +
+        "  };" +
+        "}");
+  }
+
+  public void testQualifiedNameInference12() throws Exception {
+    // We should be able to tell that the two 'this' properties
+    // are different.
+    testTypes(
+        "/** @param {function(this:Object)} x */ function f(x) {}" +
+        "/** @constructor */ function Foo() {" +
+        "  /** @type {number} */ this.bar = 3;" +
+        "  f(function() { this.bar = true; });" +
+        "}");
+  }
+
   public void testSheqRefinedScope() throws Exception {
     Node n = parseAndTypeCheck(
         "/** @constructor */function A() {}\n" +
@@ -5587,6 +6327,17 @@
         "required: string");
   }
 
+  public void testNew17() throws Exception {
+    testTypes("var goog = {}; goog.x = 3; new goog.x",
+              "cannot instantiate non-constructor");
+  }
+
+  public void testNew18() throws Exception {
+    testTypes("var goog = {};" +
+              "/** @constructor */ goog.F = function() {};" +
+              "/** @constructor */ goog.G = goog.F;");
+  }
+
   public void testName1() throws Exception {
     assertEquals(VOID_TYPE, testNameNode("undefined"));
   }
@@ -5613,8 +6364,11 @@
   private JSType testNameNode(String name) {
     Node node = Node.newString(Token.NAME, name);
     Node parent = new Node(Token.SCRIPT, node);
+    parent.setInputId(new InputId("code"));
+
+    Node externs = new Node(Token.SCRIPT);
+    externs.setInputId(new InputId("externs"));
 
-    Node externs = new Node(Token.BLOCK);
     Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);
     externAndJsRoot.setIsSyntheticBlock(true);
 
@@ -5806,6 +6560,66 @@
         "};");
   }
 
+  public void testFunctionBind1() throws Exception {
+    testTypes(
+        "/** @type {function(string, number): boolean} */" +
+        "function f(x, y) { return true; }" +
+        "f.bind(null, 3);",
+        "actual parameter 2 of f.bind does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testFunctionBind2() throws Exception {
+    testTypes(
+        "/** @type {function(number): boolean} */" +
+        "function f(x) { return true; }" +
+        "f(f.bind(null, 3)());",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: number");
+  }
+
+  public void testFunctionBind3() throws Exception {
+    testTypes(
+        "/** @type {function(number, string): boolean} */" +
+        "function f(x, y) { return true; }" +
+        "f.bind(null, 3)(true);",
+        "actual parameter 1 of function does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: string");
+  }
+
+  public void testFunctionBind4() throws Exception {
+    testTypes(
+        "/** @param {...number} x */" +
+        "function f(x) {}" +
+        "f.bind(null, 3, 3, 3)(true);",
+        "actual parameter 1 of function does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: (number|undefined)");
+  }
+
+  public void testFunctionBind5() throws Exception {
+    testTypes(
+        "/** @param {...number} x */" +
+        "function f(x) {}" +
+        "f.bind(null, true)(3, 3, 3);",
+        "actual parameter 2 of f.bind does not match formal parameter\n" +
+        "found   : boolean\n" +
+        "required: (number|undefined)");
+  }
+
+  public void testGoogBind1() throws Exception {
+    // We currently do not support goog.bind natively.
+    testClosureTypes(
+        "var goog = {}; goog.bind = function(var_args) {};" +
+        "/** @type {function(number): boolean} */" +
+        "function f(x, y) { return true; }" +
+        "f(goog.bind(f, null, 'x')());",
+        null);
+  }
+
   public void testCast2() throws Exception {
     // can upcast to a base type.
     testTypes("/** @constructor */function base() {}\n" +
@@ -5919,7 +6733,7 @@
     testTypes(
         "for (var i = 0; i < 10; i++) {" +
           "var x = /** @type {Object|number} */ ({foo: 3});" +
-          "/** @param {boolean} x */ function f(x) {}" +
+          "/** @param {number} x */ function f(x) {}" +
           "f(x.foo);" +
           "f([].foo);" +
         "}",
@@ -5933,7 +6747,7 @@
           "var x = /** @type {Object|number} */ (" +
           "  {/** @type {string} */ foo: 3});" +
         "}",
-        "assignment to property foo of (Object|null|number)\n" +
+        "assignment to property foo of Object\n" +
         "found   : number\n" +
         "required: string");
   }
@@ -6113,6 +6927,33 @@
         "}");
   }
 
+  public void testAnonymousPrototype1() throws Exception {
+    testTypes(
+        "var ns = {};" +
+        "/** @constructor */ ns.Foo = function() {" +
+        "  this.bar(3, 5);" +
+        "};" +
+        "ns.Foo.prototype = {" +
+        "  bar: function(x) {}" +
+        "};",
+        "Function ns.Foo.prototype.bar: called with 2 argument(s). " +
+        "Function requires at least 1 argument(s) and no more " +
+        "than 1 argument(s).");
+  }
+
+  public void testAnonymousPrototype2() throws Exception {
+    testTypes(
+        "/** @interface */ var Foo = function() {};" +
+        "Foo.prototype = {" +
+        "  foo: function(x) {}" +
+        "};" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @implements {Foo}\n" +
+        " */ var Bar = function() {};",
+        "property foo on interface Foo is not implemented by type Bar");
+  }
+
   public void testAnonymousType1() throws Exception {
     testTypes("function f() {}" +
         "/** @constructor */\n" +
@@ -6657,35 +7498,42 @@
         "Bad type annotation. Unknown type goog.Missing");
   }
 
-  // TODO(user): We should support this way of declaring properties as it is
-  // widely used.
-  //public void testInheritanceCheck15() throws Exception {
-  //  testTypes(
-  //      "/** @constructor */function Super() {};" +
-  //      "/** @param {number} bar */Super.prototype.foo;" +
-  //      "/** @constructor\n @extends {Super} */function Sub() {};" +
-  //      "/** @override\n  @param {number} bar */Sub.prototype.foo =\n" +
-  //      "function(bar) {};");
-  //}
+  public void testInheritanceCheck15() throws Exception {
+    testTypes(
+        "/** @constructor */function Super() {};" +
+        "/** @param {number} bar */Super.prototype.foo;" +
+        "/** @constructor\n @extends {Super} */function Sub() {};" +
+        "/** @override\n  @param {number} bar */Sub.prototype.foo =\n" +
+        "function(bar) {};");
+  }
 
-//   public void testInterfacePropertyOverride1() throws Exception {
-//     testTypes(
-//         "/** @interface */function Super() {};" +
-//         "/** @desc description */Super.prototype.foo = function() {};" +
-//         "/** @interface\n @extends {Super} */function Sub() {};" +
-//         "/** @desc description */Sub.prototype.foo = function() {};",
-//         "property foo is already defined by the Super extended interface");
-//   }
+  public void testInheritanceCheck16() throws Exception {
+    testTypes(
+        "var goog = {};" +
+        "/** @constructor */goog.Super = function() {};" +
+        "/** @type {number} */ goog.Super.prototype.foo = 3;" +
+        "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" +
+        "/** @type {number} */ goog.Sub.prototype.foo = 5;",
+        "property foo already defined on superclass goog.Super; " +
+        "use @override to override it");
+  }
 
-//   public void testInterfacePropertyOverride2() throws Exception {
-//     testTypes(
-//         "/** @interface */function Root() {};" +
-//         "/** @desc description */Root.prototype.foo = function() {};" +
-//         "/** @interface\n @extends {Root} */function Super() {};" +
-//         "/** @interface\n @extends {Super} */function Sub() {};" +
-//         "/** @desc description */Sub.prototype.foo = function() {};",
-//         "property foo is already defined by the Root extended interface");
-//   }
+  public void testInterfacePropertyOverride1() throws Exception {
+    testTypes(
+        "/** @interface */function Super() {};" +
+        "/** @desc description */Super.prototype.foo = function() {};" +
+        "/** @interface\n @extends {Super} */function Sub() {};" +
+        "/** @desc description */Sub.prototype.foo = function() {};");
+  }
+
+  public void testInterfacePropertyOverride2() throws Exception {
+    testTypes(
+        "/** @interface */function Root() {};" +
+        "/** @desc description */Root.prototype.foo = function() {};" +
+        "/** @interface\n @extends {Root} */function Super() {};" +
+        "/** @interface\n @extends {Super} */function Sub() {};" +
+        "/** @desc description */Sub.prototype.foo = function() {};");
+  }
 
   public void testInterfaceInheritanceCheck1() throws Exception {
     testTypes(
@@ -6821,6 +7669,17 @@
         "override: number");
   }
 
+  public void testInterfaceInheritanceCheck13() throws Exception {
+    testTypes(
+        "function abstractMethod() {};\n" +
+        "/** @interface */var base = function() {};\n" +
+        "/** @extends {base} \n @interface */ var Int = function() {}\n" +
+        "/** @type {{bar : !Function}} */ var x; \n" +
+        "/** @type {!Function} */ base.prototype.bar = abstractMethod; \n" +
+        "/** @type {Int} */ foo;\n" +
+        "foo.bar();");
+  }
+
   public void testInterfacePropertyNotImplemented() throws Exception {
     testTypes(
         "/** @interface */function Int() {};" +
@@ -6896,7 +7755,7 @@
   }
 
   public void testObjectLiteralDeclaration4() throws Exception {
-    testClosureTypesMultipleWarnings(
+    testClosureTypes(
         "var x = {" +
         "  /** @param {boolean} x */ abc: function(x) {}" +
         "};" +
@@ -6904,14 +7763,12 @@
         " * @param {string} x\n" +
         " * @suppress {duplicate}\n" +
         " */ x.abc = function(x) {};",
-        Lists.newArrayList(
-            "variable x.abc redefined with type " +
-            "function (string): undefined, " +
-            "original definition at  [testcode] :1 with type " +
-            "function (boolean): undefined",
-            "assignment to property abc of x\n" +
-            "found   : function (string): undefined\n" +
-            "required: function (boolean): undefined"));
+        "assignment to property abc of x\n" +
+        "found   : function (string): undefined\n" +
+        "required: function (boolean): undefined");
+    // TODO(user): suppress {duplicate} currently also silence the
+    // redefining type error in the TypeValidator. May be it needs
+    // a new suppress name instead?
   }
 
   public void testObjectLiteralDeclaration5() throws Exception {
@@ -7111,6 +7968,19 @@
         "override: string");
   }
 
+  public void testDataPropertyOnInterface4() throws Exception {
+    testTypes("/** @interface */ function T() {};\n" +
+        "/** @type {number} */T.prototype.x;\n" +
+        "/** @constructor \n" +
+        " *  @implements {T} \n" +
+        " */\n" +
+        "function C() { /** @type {string} */ \n this.x = 'foo'; }\n",
+        "mismatch of the x property type and the type of the property it " +
+        "overrides from interface T\n" +
+        "original: number\n" +
+        "override: string");
+  }
+
   public void testWarnDataPropertyOnInterface3() throws Exception {
     testTypes("/** @interface */ u.T = function () {};\n" +
         "/** @type {number} */u.T.prototype.x = 1;",
@@ -7170,11 +8040,15 @@
   }
 
   public void testErrorMismatchingPropertyOnInterface6() throws Exception {
-    testTypes("/** @interface */ function T() {};\n" +
+    testClosureTypesMultipleWarnings(
+        "/** @interface */ function T() {};\n" +
         "/** @return {number} */T.prototype.x = 1",
-        "interface members can only be empty property declarations, "
-        + "empty functions, or goog.abstractMethod"
-        );
+        Lists.newArrayList(
+            "assignment to property x of T.prototype\n" +
+            "found   : number\n" +
+            "required: function (this:T): number",
+            "interface members can only be empty property declarations, " +
+            "empty functions, or goog.abstractMethod"));
   }
 
   public void testInterfaceNonEmptyFunction() throws Exception {
@@ -7212,13 +8086,11 @@
   }
 
   public void testDirectPrototypeAssign() throws Exception {
+    // For now, we just ignore @type annotations on the prototype.
     testTypes(
         "/** @constructor */ function Foo() {}" +
         "/** @constructor */ function Bar() {}" +
-        "/** @type {Array} */ Bar.prototype = new Foo()",
-        "assignment to property prototype of Bar\n" +
-        "found   : Foo\n" +
-        "required: (Array|null)");
+        "/** @type {Array} */ Bar.prototype = new Foo()");
   }
 
   // In all testResolutionViaRegistry* tests, since u is unknown, u.T can only
@@ -7485,6 +8357,57 @@
         "right: number");
   }
 
+  public void testTypeInferenceWithNoEntry1() throws Exception {
+    testTypes(
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype.init = function() {" +
+        "  /** @type {?{baz: number}} */ this.bar = {baz: 3};" +
+        "};" +
+        "/**\n" +
+        " * @extends {Foo}\n" +
+        " * @constructor\n" +
+        " */" +
+        "function SubFoo() {}" +
+        "/** Method */" +
+        "SubFoo.prototype.method = function() {" +
+        "  for (var i = 0; i < 10; i++) {" +
+        "    f(this.bar);" +
+        "    f(this.bar.baz);" +
+        "  }" +
+        "};",
+        "actual parameter 1 of f does not match formal parameter\n"+
+        "found   : (null|{baz: number})\n" +
+        "required: number");
+  }
+
+  public void testTypeInferenceWithNoEntry2() throws Exception {
+    testClosureTypes(
+        CLOSURE_DEFS +
+        "/** @param {number} x */ function f(x) {}" +
+        "/** @param {!Object} x */ function g(x) {}" +
+        "/** @constructor */ function Foo() {}" +
+        "Foo.prototype.init = function() {" +
+        "  /** @type {?{baz: number}} */ this.bar = {baz: 3};" +
+        "};" +
+        "/**\n" +
+        " * @extends {Foo}\n" +
+        " * @constructor\n" +
+        " */" +
+        "function SubFoo() {}" +
+        "/** Method */" +
+        "SubFoo.prototype.method = function() {" +
+        "  for (var i = 0; i < 10; i++) {" +
+        "    f(this.bar);" +
+        "    goog.asserts.assert(this.bar);" +
+        "    g(this.bar);" +
+        "  }" +
+        "};",
+        "actual parameter 1 of f does not match formal parameter\n"+
+        "found   : (null|{baz: number})\n" +
+        "required: number");
+  }
+
   public void testForwardPropertyReference() throws Exception {
     testTypes("/** @constructor */ var Foo = function() { this.init(); };" +
         "/** @return {string} */" +
@@ -7607,68 +8530,6 @@
         "required: (MyType|null|number)");
   }
 
-  public void testMalformedOldTypeDef() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "goog.Bar = goog.typedef",
-        "Typedef for goog.Bar does not have any type information");
-  }
-
-  public void testMalformedOldTypeDef2() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @typedef {boolean} */ goog.Bar = goog.typedef",
-        "Typedef for goog.Bar does not have any type information");
-  }
-
-  public void testDuplicateOldTypeDef() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @constructor */ goog.Bar = function() {};" +
-        "/** @type {number} */ goog.Bar = goog.typedef",
-        "variable goog.Bar redefined with type number, " +
-        "original definition at [testcode]:1 " +
-        "with type function (new:goog.Bar): undefined");
-  }
-
-  public void testOldTypeDef1() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @type {number} */ goog.Bar = goog.typedef;" +
-        "/** @param {goog.Bar} x */ function f(x) {}" +
-        "f(3);");
-  }
-
-  public void testOldTypeDef2() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @type {number} */ goog.Bar = goog.typedef;" +
-        "/** @param {goog.Bar} x */ function f(x) {}" +
-        "f('3');",
-        "actual parameter 1 of f does not match formal parameter\n" +
-        "found   : string\n" +
-        "required: number");
-  }
-
-  public void testOldTypeDef3() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @type {number} */ var Bar = goog.typedef;" +
-        "/** @param {Bar} x */ function f(x) {}" +
-        "f('3');",
-        "actual parameter 1 of f does not match formal parameter\n" +
-        "found   : string\n" +
-        "required: number");
-  }
-
-  public void testCircularOldTypeDef() throws Exception {
-    testTypes(
-        "var goog = {}; goog.typedef = true;" +
-        "/** @type {number|Array.<goog.Bar>} */ goog.Bar = goog.typedef;" +
-        "/** @param {goog.Bar} x */ function f(x) {}" +
-        "f(3); f([3]); f([[3]]);");
-  }
-
   public void testDuplicateTypeDef() throws Exception {
     testTypes(
         "var goog = {};" +
@@ -7767,6 +8628,16 @@
     assertEquals(100.0, getTypedPercent(js), 0.1);
   }
 
+  public void testGetTypedPercent5() throws Exception {
+    String js = "/** @enum {number} */ keys = {A: 1,B: 2,C: 3};";
+    assertEquals(100.0, getTypedPercent(js), 0.1);
+  }
+
+  public void testGetTypedPercent6() throws Exception {
+    String js = "a = {TRUE: 1, FALSE: 0};";
+    assertEquals(100.0, getTypedPercent(js), 0.1);
+  }
+
   private double getTypedPercent(String js) throws Exception {
     Node n = compiler.parseTestCode(js);
 
@@ -8131,6 +9002,34 @@
         "function g(x) { return x.isVisible; }");
   }
 
+  public void testMissingProperty38() throws Exception {
+    testTypes(
+        "/** @constructor */ function Foo() {}" +
+        "/** @constructor */ function Bar() {}" +
+        "/** @return {Foo|Bar} */ function f() { return new Foo(); }" +
+        "f().missing;",
+        "Property missing never defined on (Bar|Foo|null)");
+  }
+
+  public void testMissingProperty39() throws Exception {
+    testTypes(
+        "/** @return {string|number} */ function f() { return 3; }" +
+        "f().length;");
+  }
+
+  public void testMissingProperty40() throws Exception {
+    testClosureTypes(
+        "goog.addDependency('zzz.js', ['MissingType'], []);" +
+        "/** @param {(Array|MissingType)} x */" +
+        "function f(x) { x.impossible(); }", null);
+  }
+
+  public void testMissingProperty41() throws Exception {
+    testTypes(
+        "/** @param {(Array|Date)} x */" +
+        "function f(x) { if (x.impossible) x.impossible(); }");
+  }
+
   public void testReflectObject1() throws Exception {
     testClosureTypes(
         "var goog = {}; goog.reflect = {}; " +
@@ -8228,6 +9127,37 @@
             "Bad type annotation. missing object name in @lends tag"));
   }
 
+  public void testLends10() throws Exception {
+    testTypes(
+        "function defineClass(x) { return function() {}; } " +
+        "/** @constructor */" +
+        "var Foo = defineClass(" +
+        "    /** @lends {Foo.prototype} */ ({/** @type {number} */ bar: 1}));" +
+        "/** @return {string} */ function f() { return (new Foo()).bar; }",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testLends11() throws Exception {
+    testTypes(
+        "function defineClass(x, y) { return function() {}; } " +
+        "/** @constructor */" +
+        "var Foo = function() {};" +
+        "/** @return {*} */ Foo.prototype.bar = function() { return 3; };" +
+        "/**\n" +
+        " * @constructor\n" +
+        " * @extends {Foo}\n" +
+        " */\n" +
+        "var SubFoo = defineClass(Foo, " +
+        "    /** @lends {SubFoo.prototype} */ ({\n" +
+        "      /** @return {number} */ bar: function() { return 3; }}));" +
+        "/** @return {string} */ function f() { return (new SubFoo()).bar(); }",
+        "inconsistent return type\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testDeclaredNativeTypeEquality() throws Exception {
     Node n = parseAndTypeCheck("/** @constructor */ function Object() {};");
     assertEquals(registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE),
@@ -8347,7 +9277,7 @@
         "*/\n" +
         "function f(x, y, z) {}\n" +
         "f(this, this, function() { this });",
-        FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format(), true);
+        FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format());
   }
 
   public void testBadTemplateType2() throws Exception {
@@ -8359,7 +9289,7 @@
         "*/\n" +
         "function f(x, y) {}\n" +
         "f(0, function() {});",
-        TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format(), true);
+        TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format("number"));
   }
 
   public void testBadTemplateType3() throws Exception {
@@ -8370,7 +9300,7 @@
         "*/\n" +
         "function f(x) {}\n" +
         "f(this);",
-        TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format(), true);
+        TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format());
   }
 
   public void testBadTemplateType4() throws Exception {
@@ -8380,7 +9310,7 @@
         "*/\n" +
         "function f() {}\n" +
         "f();",
-        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);
+        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());
   }
 
   public void testBadTemplateType5() throws Exception {
@@ -8391,7 +9321,7 @@
         "*/\n" +
         "function f() {}\n" +
         "f();",
-        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);
+        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());
   }
 
   public void testFunctionLiteralUndefinedThisArgument() throws Exception {
@@ -8417,18 +9347,6 @@
         + "baz(function() { this; }, {});");
   }
 
-  public void testFunctionLiteralUnreadThisArgument() throws Exception {
-    testTypes(""
-        + "/**\n"
-        + " * @param {function(this:T, ...)?} fn\n"
-        + " * @param {?T} opt_obj\n"
-        + " * @template T\n"
-        + " */\n"
-        + "function baz(fn, opt_obj) {}\n"
-        + "baz(function() {}, {});",
-        "Function literal argument does not refer to bound this argument");
-  }
-
   public void testFunctionLiteralUnreadNullThisArgument() throws Exception {
     testTypes(""
         + "/**\n"
@@ -8440,12 +9358,112 @@
         + "baz(function() {}, null);");
   }
 
+  public void testUnionTemplateThisType() throws Exception {
+    testTypes(
+        "/** @constructor */ function F() {}" +
+        "/** @return {F|Array} */ function g() { return []; }" +
+        "/** @param {F} x */ function h(x) { }" +
+        "/**\n" +
+        "* @param {T} x\n" +
+        "* @param {function(this:T, ...)} y\n" +
+        "* @template T\n" +
+        "*/\n" +
+        "function f(x, y) {}\n" +
+        "f(g(), function() { h(this); });",
+        "actual parameter 1 of h does not match formal parameter\n" +
+        "found   : Object\n" +
+        "required: (F|null)");
+  }
+
   public void testActiveXObject() throws Exception {
     testTypes(
         "/** @type {Object} */ var x = new ActiveXObject();" +
         "/** @type { {impossibleProperty} } */ var y = new ActiveXObject();");
   }
 
+  public void testRecordType1() throws Exception {
+    testTypes(
+        "/** @param {{prop: number}} x */" +
+        "function f(x) {}" +
+        "f({});",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : {prop: (number|undefined)}\n" +
+        "required: {prop: number}");
+  }
+
+  public void testRecordType2() throws Exception {
+    testTypes(
+        "/** @param {{prop: (number|undefined)}} x */" +
+        "function f(x) {}" +
+        "f({});");
+  }
+
+  public void testRecordType3() throws Exception {
+    testTypes(
+        "/** @param {{prop: number}} x */" +
+        "function f(x) {}" +
+        "f({prop: 'x'});",
+        "actual parameter 1 of f does not match formal parameter\n" +
+        "found   : {prop: (number|string)}\n" +
+        "required: {prop: number}");
+  }
+
+  public void testRecordType4() throws Exception {
+    // Notice that we do not do flow-based inference on the object type:
+    // We don't try to prove that x.prop may not be string until x
+    // gets passed to g.
+    testClosureTypesMultipleWarnings(
+        "/** @param {{prop: (number|undefined)}} x */" +
+        "function f(x) {}" +
+        "/** @param {{prop: (string|undefined)}} x */" +
+        "function g(x) {}" +
+        "var x = {}; f(x); g(x);",
+        Lists.newArrayList(
+            "actual parameter 1 of f does not match formal parameter\n" +
+            "found   : {prop: (number|string|undefined)}\n" +
+            "required: {prop: (number|undefined)}",
+            "actual parameter 1 of g does not match formal parameter\n" +
+            "found   : {prop: (number|string|undefined)}\n" +
+            "required: {prop: (string|undefined)}"));
+  }
+
+  public void testRecordType5() throws Exception {
+    testTypes(
+        "/** @param {{prop: (number|undefined)}} x */" +
+        "function f(x) {}" +
+        "/** @param {{otherProp: (string|undefined)}} x */" +
+        "function g(x) {}" +
+        "var x = {}; f(x); g(x);");
+  }
+
+  public void testRecordType6() throws Exception {
+    testTypes(
+        "/** @return {{prop: (number|undefined)}} x */" +
+        "function f() { return {}; }");
+  }
+
+  public void testRecordType7() throws Exception {
+    testTypes(
+        "/** @return {{prop: (number|undefined)}} x */" +
+        "function f() { var x = {}; g(x); return x; }" +
+        "/** @param {number} x */" +
+        "function g(x) {}",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : {prop: (number|undefined)}\n" +
+        "required: number");
+  }
+
+  public void testRecordType8() throws Exception {
+    testTypes(
+        "/** @return {{prop: (number|string)}} x */" +
+        "function f() { var x = {prop: 3}; g(x.prop); return x; }" +
+        "/** @param {string} x */" +
+        "function g(x) {}",
+        "actual parameter 1 of g does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testDuplicateRecordFields1() throws Exception {
     testTypes("/**"
          + "* @param {{x:string, x:number}} a"
@@ -8464,6 +9482,125 @@
            "Bad type annotation. Unknown type y"});
   }
 
+  public void testMultipleExtendsInterface1() throws Exception {
+    testTypes("/** @interface */ function base1() {}\n"
+        + "/** @interface */ function base2() {}\n"
+        + "/** @interface\n"
+        + "* @extends {base1}\n"
+        + "* @extends {base2}\n"
+        + "*/\n"
+        + "function derived() {}");
+  }
+
+  public void testMultipleExtendsInterface2() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @desc description */Int0.prototype.foo = function() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
+        "function Int2() {};" +
+        "/** @constructor\n @implements {Int2} */function Foo() {};",
+        "property foo on interface Int0 is not implemented by type Foo");
+  }
+
+  public void testMultipleExtendsInterface3() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @desc description */Int1.prototype.foo = function() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
+        "function Int2() {};" +
+        "/** @constructor\n @implements {Int2} */function Foo() {};",
+        "property foo on interface Int1 is not implemented by type Foo");
+  }
+
+  public void testMultipleExtendsInterface4() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} \n" +
+        " @extends {number} */" +
+        "function Int2() {};" +
+        "/** @constructor\n @implements {Int2} */function Foo() {};",
+        "Int2 @extends non-object type number");
+  }
+
+  public void testMultipleExtendsInterface5() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @constructor */function Int1() {};" +
+        "/** @desc description @ return {string} x */" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
+        "function Int2() {};",
+        "Int2 cannot extend this type; a constructor can only extend " +
+        "objects and an interface can only extend interfaces");
+  }
+
+  public void testMultipleExtendsInterface6() throws Exception {
+    testTypes(
+        "/** @interface */function Super1() {};" +
+        "/** @interface */function Super2() {};" +
+        "/** @param {number} bar */Super2.prototype.foo = function(bar) {};" +
+        "/** @interface\n @extends {Super1}\n " +
+        "@extends {Super2} */function Sub() {};" +
+        "/** @override\n @param {string} bar */Sub.prototype.foo =\n" +
+        "function(bar) {};",
+        "mismatch of the foo property type and the type of the property it " +
+        "overrides from superclass Super2\n" +
+        "original: function (this:Super2, number): undefined\n" +
+        "override: function (this:Sub, string): undefined");
+  }
+
+  public void testMultipleExtendsInterfaceAssignment() throws Exception {
+    testTypes("/** @interface */var I1 = function() {};\n" +
+        "/** @interface */ var I2 = function() {}\n" +
+        "/** @interface\n@extends {I1}\n@extends {I2}*/" +
+        "var I3 = function() {};\n" +
+        "/** @constructor\n@implements {I3}*/var T = function() {};\n" +
+        "var t = new T();\n" +
+         "/** @type {I1} */var i1 = t;\n" +
+         "/** @type {I2} */var i2 = t;\n" +
+         "/** @type {I3} */var i3 = t;\n" +
+         "i1 = i3;\n" +
+         "i2 = i3;\n");
+  }
+
+  public void testMultipleExtendsInterfaceParamPass() throws Exception {
+    testTypes("/** @interface */var I1 = function() {};\n" +
+        "/** @interface */ var I2 = function() {}\n" +
+        "/** @interface\n@extends {I1}\n@extends {I2}*/" +
+        "var I3 = function() {};\n" +
+        "/** @constructor\n@implements {I3}*/var T = function() {};\n" +
+        "var t = new T();\n" +
+        "/** @param x I1 \n@param y I2\n@param z I3*/function foo(x,y,z){};\n" +
+        "foo(t,t,t)\n");
+  }
+
+  public void testBadMultipleExtendsClass() throws Exception {
+    testTypes("/** @constructor */ function base1() {}\n"
+        + "/** @constructor */ function base2() {}\n"
+        + "/** @constructor\n"
+        + "* @extends {base1}\n"
+        + "* @extends {base2}\n"
+        + "*/\n"
+        + "function derived() {}",
+        "Bad type annotation. type annotation incompatible "
+        + "with other annotations");
+  }
+
+  public void testInterfaceExtendsResolution() throws Exception {
+    testTypes("/** @interface \n @extends {A} */ function B() {};\n" +
+        "/** @constructor \n @implements {B} */ function C() {};\n" +
+        "/** @interface */ function A() {};");
+  }
+
+  public void testPropertyCanBeDefinedInObject() throws Exception {
+    testTypes("/** @interface */ function I() {};" +
+        "I.prototype.bar = function() {};" +
+        "/** @type {Object} */ var foo;" +
+        "foo.bar();");
+  }
+
   private void checkObjectType(ObjectType objectType, String propertyName,
         JSType expectedType) {
     assertTrue("Expected " + objectType.getReferenceName() +
@@ -8475,6 +9612,164 @@
         expectedType, objectType.getPropertyType(propertyName));
   }
 
+  public void testExtendedInterfacePropertiesCompatibility1() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} */" +
+        "function Int2() {};",
+        "Interface Int2 has a property foo with incompatible types in its " +
+        "super interfaces Int0 and Int1");
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility2() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @interface */function Int2() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @type {Object} */" +
+        "Int2.prototype.foo;" +
+        "/** @interface \n @extends {Int0} \n @extends {Int1} \n" +
+        "@extends {Int2}*/" +
+        "function Int3() {};",
+        new String[] {
+            "Interface Int3 has a property foo with incompatible types in " +
+            "its super interfaces Int0 and Int1",
+            "Interface Int3 has a property foo with incompatible types in " +
+            "its super interfaces Int1 and Int2"
+        });
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility3() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};",
+        "Interface Int3 has a property foo with incompatible types in its " +
+        "super interfaces Int0 and Int1");
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility4() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface \n @extends {Int0} */ function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @interface */function Int2() {};" +
+        "/** @interface \n @extends {Int2} */ function Int3() {};" +
+        "/** @type {string} */" +
+        "Int2.prototype.foo;" +
+        "/** @interface \n @extends {Int1} \n @extends {Int3} */" +
+        "function Int4() {};",
+        "Interface Int4 has a property foo with incompatible types in its " +
+        "super interfaces Int0 and Int2");
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility5() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};" +
+        "/** @interface */function Int4() {};" +
+        "/** @type {number} */" +
+        "Int4.prototype.foo;" +
+        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
+        "function Int5() {};",
+        new String[] {
+            "Interface Int3 has a property foo with incompatible types in its" +
+            " super interfaces Int0 and Int1",
+            "Interface Int5 has a property foo with incompatible types in its" +
+            " super interfaces Int1 and Int4"});
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility6() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};" +
+        "/** @interface */function Int4() {};" +
+        "/** @type {string} */" +
+        "Int4.prototype.foo;" +
+        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
+        "function Int5() {};",
+        "Interface Int3 has a property foo with incompatible types in its" +
+        " super interfaces Int0 and Int1");
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility7() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.foo;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};" +
+        "/** @interface */function Int4() {};" +
+        "/** @type {Object} */" +
+        "Int4.prototype.foo;" +
+        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
+        "function Int5() {};",
+        new String[] {
+            "Interface Int3 has a property foo with incompatible types in its" +
+            " super interfaces Int0 and Int1",
+            "Interface Int5 has a property foo with incompatible types in its" +
+            " super interfaces Int1 and Int4"});
+  }
+
+  public void testExtendedInterfacePropertiesCompatibility8() throws Exception {
+    testTypes(
+        "/** @interface */function Int0() {};" +
+        "/** @interface */function Int1() {};" +
+        "/** @type {number} */" +
+        "Int0.prototype.foo;" +
+        "/** @type {string} */" +
+        "Int1.prototype.bar;" +
+        "/** @interface \n @extends {Int1} */ function Int2() {};" +
+        "/** @interface \n @extends {Int0} \n @extends {Int2} */" +
+        "function Int3() {};" +
+        "/** @interface */function Int4() {};" +
+        "/** @type {Object} */" +
+        "Int4.prototype.foo;" +
+        "/** @type {Null} */" +
+        "Int4.prototype.bar;" +
+        "/** @interface \n @extends {Int3} \n @extends {Int4} */" +
+        "function Int5() {};",
+        new String[] {
+            "Interface Int5 has a property bar with incompatible types in its" +
+            " super interfaces Int1 and Int4",
+            "Interface Int5 has a property foo with incompatible types in its" +
+            " super interfaces Int0 and Int4"});
+  }
+
   private void testTypes(String js) throws Exception {
     testTypes(js, (String) null);
   }
@@ -8505,7 +9800,7 @@
         0, compiler.getErrorCount());
 
     // For processing goog.addDependency for forward typedefs.
-    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)
+    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)
         .process(null, n);
 
     CodingConvention convention = compiler.getCodingConvention();
@@ -8518,7 +9813,10 @@
         registry)
         .processForTesting(null, n);
 
-    assertEquals(0, compiler.getErrorCount());
+    assertEquals(
+        "unexpected error(s) : " +
+        Joiner.on(", ").join(compiler.getErrors()),
+        0, compiler.getErrorCount());
 
     if (descriptions == null) {
       assertEquals(
@@ -8591,12 +9889,13 @@
   private TypeCheckResult parseAndTypeCheckWithScope(
       String externs, String js) {
     compiler.init(
-        Lists.newArrayList(JSSourceFile.fromCode("[externs]", externs)),
-        Lists.newArrayList(JSSourceFile.fromCode("[testcode]", js)),
+        Lists.newArrayList(SourceFile.fromCode("[externs]", externs)),
+        Lists.newArrayList(SourceFile.fromCode("[testcode]", js)),
         compiler.getOptions());
 
-    Node n = compiler.getInput("[testcode]").getAstRoot(compiler);
-    Node externsNode = compiler.getInput("[externs]").getAstRoot(compiler);
+    Node n = compiler.getInput(new InputId("[testcode]")).getAstRoot(compiler);
+    Node externsNode = compiler.getInput(new InputId("[externs]"))
+        .getAstRoot(compiler);
     Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);
     externAndJsRoot.setIsSyntheticBlock(true);
 
