diff -r -u original/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java buggy/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java
--- original/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	2023-06-13 15:31:51.647141712 +0800
+++ buggy/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	2023-06-12 11:40:39.342130014 +0800
@@ -70,7 +70,7 @@
  * structures. User can for example store a vector of n variables depending on three x, y
  * and z free parameters in one array as follows:
  * <pre>
- *   // parameter 0 is x, parameter 1 is y, parameter 3 is z
+ *   // parameter 0 is x, parameter 1 is y, parameter 2 is z
  *   int parameters = 3;
  *   DSCompiler compiler = DSCompiler.getCompiler(parameters, order);
  *   int size = compiler.getSize();
@@ -149,6 +149,34 @@
     /** Indirection arrays for function composition. */
     private final int[][][] compIndirection;
 
+    /** Private constructor, reserved for the factory method {@link #getCompiler(int, int)}.
+     * @param parameters number of free parameters
+     * @param order derivation order
+     * @param valueCompiler compiler for the value part
+     * @param derivativeCompiler compiler for the derivative part
+     */
+    private DSCompiler(final int parameters, final int order,
+                       final DSCompiler valueCompiler, final DSCompiler derivativeCompiler) {
+
+        this.parameters = parameters;
+        this.order      = order;
+        this.sizes      = compileSizes(parameters, order, valueCompiler);
+        this.derivativesIndirection =
+                compileDerivativesIndirection(parameters, order,
+                                              valueCompiler, derivativeCompiler);
+        this.lowerIndirection =
+                compileLowerIndirection(parameters, order,
+                                        valueCompiler, derivativeCompiler);
+        this.multIndirection =
+                compileMultiplicationIndirection(parameters, order,
+                                                 valueCompiler, derivativeCompiler, lowerIndirection);
+        this.compIndirection =
+                compileCompositionIndirection(parameters, order,
+                                              valueCompiler, derivativeCompiler,
+                                              sizes, derivativesIndirection);
+
+    }
+
     /** Get the compiler for number of free parameters and order.
      * @param parameters number of free parameters
      * @param order derivation order
@@ -159,8 +187,10 @@
         // get the cached compilers
         final DSCompiler[][] cache = compilers.get();
         if (cache != null && cache.length > parameters && cache[parameters].length > order) {
-            // the compiler has already been created
-            return cache[parameters][order];
+            if (cache[parameters][order] != null) {
+                // the compiler has already been created
+                return cache[parameters][order];
+            }
         }
 
         // we need to create more compilers
@@ -176,8 +206,8 @@
         }
 
         // create the array in increasing diagonal order
-        for (int diag = 0; diag <= maxParameters + maxOrder; ++diag) {
-            for (int o = FastMath.max(0, diag - maxParameters); o <= FastMath.min(maxOrder, diag); ++o) {
+        for (int diag = 0; diag <= parameters + order; ++diag) {
+            for (int o = FastMath.max(0, diag - parameters); o <= FastMath.min(order, diag); ++o) {
                 final int p = diag - o;
                 if (newCache[p][o] == null) {
                     final DSCompiler valueCompiler      = (p == 0) ? null : newCache[p - 1][o];
@@ -194,45 +224,14 @@
 
     }
 
-    /** Private constructor, reserved for the factory method {@link #getCompiler(int, int)}.
-     * @param parameters number of free parameters
-     * @param order derivation order
-     * @param valueCompiler compiler for the value part
-     * @param derivativeCompiler compiler for the derivative part
-     */
-    private DSCompiler(final int parameters, final int order,
-                       final DSCompiler valueCompiler, final DSCompiler derivativeCompiler) {
-
-        this.parameters = parameters;
-        this.order      = order;
-        this.sizes      = compileSizes(parameters, order, valueCompiler, derivativeCompiler);
-        this.derivativesIndirection =
-                compileDerivativesIndirection(parameters, order,
-                                              valueCompiler, derivativeCompiler);
-        this.lowerIndirection =
-                compileLowerIndirection(parameters, order,
-                                        valueCompiler, derivativeCompiler);
-        this.multIndirection =
-                compileMultiplicationIndirection(parameters, order,
-                                                 valueCompiler, derivativeCompiler, lowerIndirection);
-        this.compIndirection =
-                compileCompositionIndirection(parameters, order,
-                                              valueCompiler, derivativeCompiler,
-                                              sizes, derivativesIndirection, lowerIndirection);
-
-
-    }
-
     /** Compile the sizes array.
      * @param parameters number of free parameters
      * @param order derivation order
      * @param valueCompiler compiler for the value part
-     * @param derivativeCompiler compiler for the derivative part
      * @return sizes array
      */
     private static int[][] compileSizes(final int parameters, final int order,
-                                        final DSCompiler valueCompiler,
-                                        final DSCompiler derivativeCompiler) {
+                                        final DSCompiler valueCompiler) {
 
         final int[][] sizes = new int[parameters + 1][order + 1];
         if (parameters == 0) {
@@ -400,15 +399,13 @@
      * @param derivativeCompiler compiler for the derivative part
      * @param sizes sizes array
      * @param derivativesIndirection derivatives indirection array
-     * @param lowerIndirection lower derivatives indirection array
      * @return multiplication indirection array
      */
     private static int[][][] compileCompositionIndirection(final int parameters, final int order,
                                                         final DSCompiler valueCompiler,
                                                         final DSCompiler derivativeCompiler,
                                                         final int[][] sizes,
-                                                        final int[][] derivativesIndirection,
-                                                        final int[] lowerIndirection) {
+                                                        final int[][] derivativesIndirection) {
 
         if ((parameters == 0) || (order == 0)) {
             return new int[][][] { { { 1, 0 } } };
@@ -505,10 +502,24 @@
     /** Get the index of a partial derivative in the array.
      * <p>
      * If all orders are set to 0, then the 0<sup>th</sup> order derivative
-     * is returned, which is the value of the function. The index for this
-     * 0<sup>th</sup> order derivative is always 0. the indices of higher
-     * order derivatives is between 1 and {@link #getSize() - 1)}.
+     * is returned, which is the value of the function.
+     * </p>
+     * <p>The indices of derivatives are between 0 and {@link #getSize() getSize()} - 1.
+     * Their specific order is fixed for a given compiler, but otherwise not
+     * publicly specified. There are however some simple cases which have guaranteed
+     * indices:
      * </p>
+     * <ul>
+     *   <li>the index of 0<sup>th</sup> order derivative is always 0</li>
+     *   <li>if there is only 1 {@link #getFreeParameters() free parameter}, then the
+     *   derivatives are sorted in increasing derivation order (i.e. f at index 0, df/dp
+     *   at index 1, d<sup>2</sup>f/dp<sup>2</sup> at index 2 ...
+     *   d<sup>k</sup>f/dp<sup>k</sup> at index k),</li>
+     *   <li>if the {@link #getOrder() derivation order} is 1, then the derivatives
+     *   are sorted in incresing free parameter order (i.e. f at index 0, df/dx<sub>1</sub>
+     *   at index 1, df/dx<sub>2</sub> at index 2 ... df/dx<sub>k</sub> at index k),</li>
+     *   <li>all other cases are not publicly specified</li>
+     * </ul>
      * <p>
      * This method is the inverse of method {@link #getPartialDerivativeOrders(int)}
      * </p>
@@ -936,15 +947,18 @@
         double[] function = new double[1 + order];
         double xk;
         if (n == 2) {
-            xk = FastMath.sqrt(operand[operandOffset]);
+            function[0] = FastMath.sqrt(operand[operandOffset]);
+            xk          = 0.5 / function[0];
         } else if (n == 3) {
-            xk = FastMath.cbrt(operand[operandOffset]);
+            function[0] = FastMath.cbrt(operand[operandOffset]);
+            xk          = 1.0 / (3.0 * function[0] * function[0]);
         } else {
-            xk = FastMath.pow(operand[operandOffset], 1.0 / n);
+            function[0] = FastMath.pow(operand[operandOffset], 1.0 / n);
+            xk          = 1.0 / (n * FastMath.pow(function[0], n - 1));
         }
         final double nReciprocal = 1.0 / n;
         final double xReciprocal = 1.0 / operand[operandOffset];
-        for (int i = 0; i <= order; ++i) {
+        for (int i = 1; i <= order; ++i) {
             function[i] = xk;
             xk *= xReciprocal * (nReciprocal - i);
         }
@@ -974,6 +988,27 @@
 
     }
 
+    /** Compute exp(x) - 1 of a derivative structure.
+     * @param operand array holding the operand
+     * @param operandOffset offset of the operand in its array
+     * @param result array where result must be stored (for
+     * exponential the result array <em>cannot</em> be the input
+     * array)
+     * @param resultOffset offset of the result in its array
+     */
+    public void expm1(final double[] operand, final int operandOffset,
+                      final double[] result, final int resultOffset) {
+
+        // create the function value and derivatives
+        double[] function = new double[1 + order];
+        function[0] = FastMath.expm1(operand[operandOffset]);
+        Arrays.fill(function, 1, 1 + order, FastMath.exp(operand[operandOffset]));
+
+        // apply function composition
+        compose(operand, operandOffset, function, result, resultOffset);
+
+    }
+
     /** Compute natural logarithm of a derivative structure.
      * @param operand array holding the operand
      * @param operandOffset offset of the operand in its array
@@ -1002,6 +1037,60 @@
 
     }
 
+    /** Computes shifted logarithm of a derivative structure.
+     * @param operand array holding the operand
+     * @param operandOffset offset of the operand in its array
+     * @param result array where result must be stored (for
+     * shifted logarithm the result array <em>cannot</em> be the input array)
+     * @param resultOffset offset of the result in its array
+     */
+    public void log1p(final double[] operand, final int operandOffset,
+                      final double[] result, final int resultOffset) {
+
+        // create the function value and derivatives
+        double[] function = new double[1 + order];
+        function[0] = FastMath.log1p(operand[operandOffset]);
+        if (order > 0) {
+            double inv = 1.0 / (1.0 + operand[operandOffset]);
+            double xk  = inv;
+            for (int i = 1; i <= order; ++i) {
+                function[i] = xk;
+                xk *= -i * inv;
+            }
+        }
+
+        // apply function composition
+        compose(operand, operandOffset, function, result, resultOffset);
+
+    }
+
+    /** Computes base 10 logarithm of a derivative structure.
+     * @param operand array holding the operand
+     * @param operandOffset offset of the operand in its array
+     * @param result array where result must be stored (for
+     * base 10 logarithm the result array <em>cannot</em> be the input array)
+     * @param resultOffset offset of the result in its array
+     */
+    public void log10(final double[] operand, final int operandOffset,
+                      final double[] result, final int resultOffset) {
+
+        // create the function value and derivatives
+        double[] function = new double[1 + order];
+        function[0] = FastMath.log10(operand[operandOffset]);
+        if (order > 0) {
+            double inv = 1.0 / operand[operandOffset];
+            double xk  = inv / FastMath.log(10.0);
+            for (int i = 1; i <= order; ++i) {
+                function[i] = xk;
+                xk *= -i * inv;
+            }
+        }
+
+        // apply function composition
+        compose(operand, operandOffset, function, result, resultOffset);
+
+    }
+
     /** Compute cosine of a derivative structure.
      * @param operand array holding the operand
      * @param operandOffset offset of the operand in its array
@@ -1066,33 +1155,41 @@
                     final double[] result, final int resultOffset) {
 
         // create the function value and derivatives
-        double[] function = new double[1 + order];
-        final double z = operand[operandOffset];
-        final double t = FastMath.tan(z);
+        final double[] function = new double[1 + order];
+        final double t = FastMath.tan(operand[operandOffset]);
         function[0] = t;
+
         if (order > 0) {
-            final double secant2 = 1 + t * t;
-            function[1] = secant2;
-            for (int n = 2; n <= order; ++n) {
-                final int signN4 = ((n & 0x02) == 0) ? 1 : -1;
-                double outerSum = 0;
-                int sign = 1;
-                double secant2Kp2 = secant2;
-                for (int k = 0; k < n; ++k) {
-                    double innerSum = 0;
-                    for (int j = 0; j < k; ++j) {
-                        final double alpha = 2 * (k - j) * z;
-                        final double sc  = ((n & 0x01) == 0) ? FastMath.sin(alpha) : FastMath.cos(alpha);
-                         innerSum += sc * signN4 * ArithmeticUtils.pow(k - j, n - 1) *
-                                    ArithmeticUtils.binomialCoefficient(2 * k, j);
+
+            // the nth order derivative of tan has the form:
+            // dn(tan(x)/dxn = P_n(tan(x))
+            // where P_n(t) is a degree n+1 polynomial with same parity as n+1
+            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...
+            // the general recurrence relation for P_n is:
+            // P_n(x) = (1+t^2) P_(n-1)'(t)
+            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
+            final double[] p = new double[order + 2];
+            p[1] = 1;
+            final double t2 = t * t;
+            for (int n = 1; n <= order; ++n) {
+
+                // update and evaluate polynomial P_n(t)
+                double v = 0;
+                p[n + 1] = n * p[n];
+                for (int k = n + 1; k >= 0; k -= 2) {
+                    v = v * t2 + p[k];
+                    if (k > 2) {
+                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];
+                    } else if (k == 2) {
+                        p[0] = p[1];
                     }
-                    double twoNm2K = (n >= 2 * k) ? (1 << (n - 2 * k)) : (1.0 / (1 << (2 * k - n)));
-                    outerSum  += sign * innerSum * ArithmeticUtils.binomialCoefficient(n - 1, k) *
-                                 twoNm2K * secant2Kp2 / (k + 1);
-                    sign       = -sign;
-                    secant2Kp2 *= secant2;
                 }
-                function[n] = n * outerSum;
+                if ((n & 0x1) == 0) {
+                    v *= t;
+                }
+
+                function[n] = v;
+
             }
         }
 
@@ -1286,16 +1383,316 @@
                       final double[] x, final int xOffset,
                       final double[] result, final int resultOffset) {
 
-        final double y0 = y[yOffset];
-        final double x0 = x[xOffset];
-        result[resultOffset] = FastMath.atan2(y0, x0);
+        // compute r = sqrt(x^2+y^2)
+        double[] tmp1 = new double[getSize()];
+        multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2
+        double[] tmp2 = new double[getSize()];
+        multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2
+        add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2
+        rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)
+
+        if (x[xOffset] >= 0) {
+
+            // compute atan2(y, x) = 2 atan(y / (r + x))
+            add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x
+            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)
+            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))
+            for (int i = 0; i < tmp2.length; ++i) {
+                result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))
+            }
+
+        } else {
+
+            // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
+            subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x
+            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)
+            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))
+            result[resultOffset] =
+                    ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))
+            for (int i = 1; i < tmp2.length; ++i) {
+                result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))
+            }
+
+        }
+
+    }
+
+    /** Compute hyperbolic cosine of a derivative structure.
+     * @param operand array holding the operand
+     * @param operandOffset offset of the operand in its array
+     * @param result array where result must be stored (for
+     * hyperbolic cosine the result array <em>cannot</em> be the input
+     * array)
+     * @param resultOffset offset of the result in its array
+     */
+    public void cosh(final double[] operand, final int operandOffset,
+                     final double[] result, final int resultOffset) {
+
+        // create the function value and derivatives
+        double[] function = new double[1 + order];
+        function[0] = FastMath.cosh(operand[operandOffset]);
+        if (order > 0) {
+            function[1] = FastMath.sinh(operand[operandOffset]);
+            for (int i = 2; i <= order; ++i) {
+                function[i] = function[i - 2];
+            }
+        }
+
+        // apply function composition
+        compose(operand, operandOffset, function, result, resultOffset);
+
+    }
+
+    /** Compute hyperbolic sine of a derivative structure.
+     * @param operand array holding the operand
+     * @param operandOffset offset of the operand in its array
+     * @param result array where result must be stored (for
+     * hyperbolic sine the result array <em>cannot</em> be the input
+     * array)
+     * @param resultOffset offset of the result in its array
+     */
+    public void sinh(final double[] operand, final int operandOffset,
+                     final double[] result, final int resultOffset) {
+
+        // create the function value and derivatives
+        double[] function = new double[1 + order];
+        function[0] = FastMath.sinh(operand[operandOffset]);
         if (order > 0) {
-            for (int i = 1; i <= order; ++i) {
-                // TODO compute higher order derivatives
-                result[resultOffset + i] = Double.NaN;
+            function[1] = FastMath.cosh(operand[operandOffset]);
+            for (int i = 2; i <= order; ++i) {
+                function[i] = function[i - 2];
             }
         }
 
+        // apply function composition
+        compose(operand, operandOffset, function, result, resultOffset);
+
+    }
+
+    /** Compute hyperbolic tangent of a derivative structure.
+     * @param operand array holding the operand
+     * @param operandOffset offset of the operand in its array
+     * @param result array where result must be stored (for
+     * hyperbolic tangent the result array <em>cannot</em> be the input
+     * array)
+     * @param resultOffset offset of the result in its array
+     */
+    public void tanh(final double[] operand, final int operandOffset,
+                     final double[] result, final int resultOffset) {
+
+        // create the function value and derivatives
+        final double[] function = new double[1 + order];
+        final double t = FastMath.tanh(operand[operandOffset]);
+        function[0] = t;
+
+        if (order > 0) {
+
+            // the nth order derivative of tanh has the form:
+            // dn(tanh(x)/dxn = P_n(tanh(x))
+            // where P_n(t) is a degree n+1 polynomial with same parity as n+1
+            // P_0(t) = t, P_1(t) = 1 - t^2, P_2(t) = -2 t (1 - t^2) ...
+            // the general recurrence relation for P_n is:
+            // P_n(x) = (1-t^2) P_(n-1)'(t)
+            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
+            final double[] p = new double[order + 2];
+            p[1] = 1;
+            final double t2 = t * t;
+            for (int n = 1; n <= order; ++n) {
+
+                // update and evaluate polynomial P_n(t)
+                double v = 0;
+                p[n + 1] = -n * p[n];
+                for (int k = n + 1; k >= 0; k -= 2) {
+                    v = v * t2 + p[k];
+                    if (k > 2) {
+                        p[k - 2] = (k - 1) * p[k - 1] - (k - 3) * p[k - 3];
+                    } else if (k == 2) {
+                        p[0] = p[1];
+                    }
+                }
+                if ((n & 0x1) == 0) {
+                    v *= t;
+                }
+
+                function[n] = v;
+
+            }
+        }
+
+        // apply function composition
+        compose(operand, operandOffset, function, result, resultOffset);
+
+    }
+
+    /** Compute inverse hyperbolic cosine of a derivative structure.
+     * @param operand array holding the operand
+     * @param operandOffset offset of the operand in its array
+     * @param result array where result must be stored (for
+     * inverse hyperbolic cosine the result array <em>cannot</em> be the input
+     * array)
+     * @param resultOffset offset of the result in its array
+     */
+    public void acosh(final double[] operand, final int operandOffset,
+                     final double[] result, final int resultOffset) {
+
+        // create the function value and derivatives
+        double[] function = new double[1 + order];
+        final double x = operand[operandOffset];
+        function[0] = FastMath.acosh(x);
+        if (order > 0) {
+            // the nth order derivative of acosh has the form:
+            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)
+            // where P_n(x) is a degree n-1 polynomial with same parity as n-1
+            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...
+            // the general recurrence relation for P_n is:
+            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)
+            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
+            final double[] p = new double[order];
+            p[0] = 1;
+            final double x2  = x * x;
+            final double f   = 1.0 / (x2 - 1);
+            double coeff = FastMath.sqrt(f);
+            function[1] = coeff * p[0];
+            for (int n = 2; n <= order; ++n) {
+
+                // update and evaluate polynomial P_n(x)
+                double v = 0;
+                p[n - 1] = (1 - n) * p[n - 2];
+                for (int k = n - 1; k >= 0; k -= 2) {
+                    v = v * x2 + p[k];
+                    if (k > 2) {
+                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];
+                    } else if (k == 2) {
+                        p[0] = -p[1];
+                    }
+                }
+                if ((n & 0x1) == 0) {
+                    v *= x;
+                }
+
+                coeff *= f;
+                function[n] = coeff * v;
+
+            }
+        }
+
+        // apply function composition
+        compose(operand, operandOffset, function, result, resultOffset);
+
+    }
+
+    /** Compute inverse hyperbolic sine of a derivative structure.
+     * @param operand array holding the operand
+     * @param operandOffset offset of the operand in its array
+     * @param result array where result must be stored (for
+     * inverse hyperbolic sine the result array <em>cannot</em> be the input
+     * array)
+     * @param resultOffset offset of the result in its array
+     */
+    public void asinh(final double[] operand, final int operandOffset,
+                     final double[] result, final int resultOffset) {
+
+        // create the function value and derivatives
+        double[] function = new double[1 + order];
+        final double x = operand[operandOffset];
+        function[0] = FastMath.asinh(x);
+        if (order > 0) {
+            // the nth order derivative of asinh has the form:
+            // dn(asinh(x)/dxn = P_n(x) / [x^2 + 1]^((2n-1)/2)
+            // where P_n(x) is a degree n-1 polynomial with same parity as n-1
+            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 - 1 ...
+            // the general recurrence relation for P_n is:
+            // P_n(x) = (x^2+1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)
+            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
+            final double[] p = new double[order];
+            p[0] = 1;
+            final double x2    = x * x;
+            final double f     = 1.0 / (1 + x2);
+            double coeff = FastMath.sqrt(f);
+            function[1] = coeff * p[0];
+            for (int n = 2; n <= order; ++n) {
+
+                // update and evaluate polynomial P_n(x)
+                double v = 0;
+                p[n - 1] = (1 - n) * p[n - 2];
+                for (int k = n - 1; k >= 0; k -= 2) {
+                    v = v * x2 + p[k];
+                    if (k > 2) {
+                        p[k - 2] = (k - 1) * p[k - 1] + (k - 2 * n) * p[k - 3];
+                    } else if (k == 2) {
+                        p[0] = p[1];
+                    }
+                }
+                if ((n & 0x1) == 0) {
+                    v *= x;
+                }
+
+                coeff *= f;
+                function[n] = coeff * v;
+
+            }
+        }
+
+        // apply function composition
+        compose(operand, operandOffset, function, result, resultOffset);
+
+    }
+
+    /** Compute inverse hyperbolic tangent of a derivative structure.
+     * @param operand array holding the operand
+     * @param operandOffset offset of the operand in its array
+     * @param result array where result must be stored (for
+     * inverse hyperbolic tangent the result array <em>cannot</em> be the input
+     * array)
+     * @param resultOffset offset of the result in its array
+     */
+    public void atanh(final double[] operand, final int operandOffset,
+                      final double[] result, final int resultOffset) {
+
+        // create the function value and derivatives
+        double[] function = new double[1 + order];
+        final double x = operand[operandOffset];
+        function[0] = FastMath.atanh(x);
+        if (order > 0) {
+            // the nth order derivative of atanh has the form:
+            // dn(atanh(x)/dxn = Q_n(x) / (1 - x^2)^n
+            // where Q_n(x) is a degree n-1 polynomial with same parity as n-1
+            // Q_1(x) = 1, Q_2(x) = 2x, Q_3(x) = 6x^2 + 2 ...
+            // the general recurrence relation for Q_n is:
+            // Q_n(x) = (1-x^2) Q_(n-1)'(x) + 2(n-1) x Q_(n-1)(x)
+            // as per polynomial parity, we can store coefficients of both Q_(n-1) and Q_n in the same array
+            final double[] q = new double[order];
+            q[0] = 1;
+            final double x2 = x * x;
+            final double f  = 1.0 / (1 - x2);
+            double coeff = f;
+            function[1] = coeff * q[0];
+            for (int n = 2; n <= order; ++n) {
+
+                // update and evaluate polynomial Q_n(x)
+                double v = 0;
+                q[n - 1] = n * q[n - 2];
+                for (int k = n - 1; k >= 0; k -= 2) {
+                    v = v * x2 + q[k];
+                    if (k > 2) {
+                        q[k - 2] = (k - 1) * q[k - 1] + (2 * n - k + 1) * q[k - 3];
+                    } else if (k == 2) {
+                        q[0] = q[1];
+                    }
+                }
+                if ((n & 0x1) == 0) {
+                    v *= x;
+                }
+
+                coeff *= f;
+                function[n] = coeff * v;
+
+            }
+        }
+
+        // apply function composition
+        compose(operand, operandOffset, function, result, resultOffset);
+
     }
 
     /** Compute composition of a derivative structure by a function.
@@ -1325,15 +1722,25 @@
         }
     }
 
-    /** Evaluate Taylor expansion a derivative structure.
-     * @param ds array holding the derivative structure 
+    /** Evaluate Taylor expansion of a derivative structure.
+     * @param ds array holding the derivative structure
      * @param dsOffset offset of the derivative structure in its array
-     * @param offsets parameters offsets (dx, dy, ...)
-     * @return value of the Taylor expansion at x+dx, y.dy, ...
+     * @param delta parameters offsets (&Delta;x, &Delta;y, ...)
+     * @return value of the Taylor expansion at x + &Delta;x, y + &Delta;y, ...
      */
-    public double taylor(final double[] ds, final int dsOffset, final double ... offsets) {
-        // TODO
-        return Double.NaN;
+    public double taylor(final double[] ds, final int dsOffset, final double ... delta) {
+        double value = 0;
+        for (int i = getSize() - 1; i >= 0; --i) {
+            final int[] orders = getPartialDerivativeOrders(i);
+            double term = ds[dsOffset + i];
+            for (int k = 0; k < orders.length; ++k) {
+                if (orders[k] > 0) {
+                    term *= FastMath.pow(delta[k], orders[k]) / ArithmeticUtils.factorial(orders[k]);
+                }
+            }
+            value += term;
+        }
+        return value;
     }
 
     /** Check rules set compatibility.
diff -r -u original/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java buggy/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java
--- original/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java	2023-06-13 15:31:51.647141712 +0800
+++ buggy/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java	2023-06-12 11:40:39.394127687 +0800
@@ -20,6 +20,8 @@
 import java.util.Arrays;
 import java.util.List;
 
+import org.apache.commons.math3.TestUtils;
+import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;
 import org.apache.commons.math3.exception.DimensionMismatchException;
 import org.apache.commons.math3.exception.NumberIsTooLargeException;
 import org.apache.commons.math3.util.ArithmeticUtils;
@@ -223,24 +225,37 @@
                                                     -2, dsZ,
                                                     1, new DerivativeStructure(8, dsZ.multiply(dsX),
                                                                                -1, dsY).pow(3));
+                    DerivativeStructure dsOther =
+                            new DerivativeStructure(1, dsX,
+                                                    5, dsX.multiply(dsY),
+                                                    -2, dsZ).add(new DerivativeStructure(8, dsZ.multiply(dsX),
+                                                                                         -1, dsY).pow(3));
                     double f = x + 5 * x * y - 2 * z + FastMath.pow(8 * z * x - y, 3);
                     Assert.assertEquals(f, ds.getValue(),
                                         FastMath.abs(epsilon * f));
+                    Assert.assertEquals(f, dsOther.getValue(),
+                                        FastMath.abs(epsilon * f));
 
                     // df/dx = 1 + 5 y + 24 (8 z x - y)^2 z
                     double dfdx = 1 + 5 * y + 24 * z * FastMath.pow(8 * z * x - y, 2);
                     Assert.assertEquals(dfdx, ds.getPartialDerivative(1, 0, 0),
                                         FastMath.abs(epsilon * dfdx));
+                    Assert.assertEquals(dfdx, dsOther.getPartialDerivative(1, 0, 0),
+                                        FastMath.abs(epsilon * dfdx));
 
                     // df/dxdy = 5 + 48 z*(y - 8 z x)
                     double dfdxdy = 5 + 48 * z * (y - 8 * z * x);
                     Assert.assertEquals(dfdxdy, ds.getPartialDerivative(1, 1, 0),
                                         FastMath.abs(epsilon * dfdxdy));
+                    Assert.assertEquals(dfdxdy, dsOther.getPartialDerivative(1, 1, 0),
+                                        FastMath.abs(epsilon * dfdxdy));
 
                     // df/dxdydz = 48 (y - 16 z x)
                     double dfdxdydz = 48 * (y - 16 * z * x);
                     Assert.assertEquals(dfdxdydz, ds.getPartialDerivative(1, 1, 1),
                                         FastMath.abs(epsilon * dfdxdydz));
+                    Assert.assertEquals(dfdxdydz, dsOther.getPartialDerivative(1, 1, 1),
+                                        FastMath.abs(epsilon * dfdxdydz));
 
                 }
                 
@@ -336,6 +351,69 @@
     }
 
     @Test
+    public void testRootNSingularity() {
+        for (int n = 2; n < 10; ++n) {
+            for (int maxOrder = 0; maxOrder < 12; ++maxOrder) {
+                DerivativeStructure dsZero = new DerivativeStructure(1, maxOrder, 0, 0.0);
+                DerivativeStructure rootN  = dsZero.rootN(n);
+                Assert.assertEquals(0.0, rootN.getValue(), 1.0e-20);
+                if (maxOrder > 0) {
+                    Assert.assertTrue(Double.isInfinite(rootN.getPartialDerivative(1)));
+                    Assert.assertTrue(rootN.getPartialDerivative(1) > 0);
+                    for (int order = 2; order <= maxOrder; ++order) {
+                        // the following checks shows a LIMITATION of the current implementation
+                        // we have no way to tell dsZero is a pure linear variable x = 0
+                        // we only say: "dsZero is a structure with value = 0.0,
+                        // first derivative = 1.0, second and higher derivatives = 0.0".
+                        // Function composition rule for second derivatives is:
+                        // d2[f(g(x))]/dx2 = f''(g(x)) * [g'(x)]^2 + f'(g(x)) * g''(x)
+                        // when function f is the nth root and x = 0 we have:
+                        // f(0) = 0, f'(0) = +infinity, f''(0) = -infinity (and higher
+                        // derivatives keep switching between +infinity and -infinity)
+                        // so given that in our case dsZero represents g, we have g(x) = 0,
+                        // g'(x) = 1 and g''(x) = 0
+                        // applying the composition rules gives:
+                        // d2[f(g(x))]/dx2 = f''(g(x)) * [g'(x)]^2 + f'(g(x)) * g''(x)
+                        //                 = -infinity * 1^2 + +infinity * 0
+                        //                 = -infinity + NaN
+                        //                 = NaN
+                        // if we knew dsZero is really the x variable and not the identity
+                        // function applied to x, we would not have computed f'(g(x)) * g''(x)
+                        // and we would have found that the result was -infinity and not NaN
+                        Assert.assertTrue(Double.isNaN(rootN.getPartialDerivative(order)));
+                    }
+                }
+
+                // the following shows that the limitation explained above is NOT a bug...
+                // if we set up the higher order derivatives for g appropriately, we do
+                // compute the higher order derivatives of the composition correctly
+                double[] gDerivatives = new double[ 1 + maxOrder];
+                gDerivatives[0] = 0.0;
+                for (int k = 1; k <= maxOrder; ++k) {
+                    gDerivatives[k] = FastMath.pow(-1.0, k + 1);
+                }
+                DerivativeStructure correctRoot = new DerivativeStructure(1, maxOrder, gDerivatives).rootN(n);
+                Assert.assertEquals(0.0, correctRoot.getValue(), 1.0e-20);
+                if (maxOrder > 0) {
+                    Assert.assertTrue(Double.isInfinite(correctRoot.getPartialDerivative(1)));
+                    Assert.assertTrue(correctRoot.getPartialDerivative(1) > 0);
+                    for (int order = 2; order <= maxOrder; ++order) {
+                        Assert.assertTrue(Double.isInfinite(correctRoot.getPartialDerivative(order)));
+                        if ((order % 2) == 0) {
+                            Assert.assertTrue(correctRoot.getPartialDerivative(order) < 0);
+                        } else {
+                            Assert.assertTrue(correctRoot.getPartialDerivative(order) > 0);
+                        }
+                    }
+                }
+
+            }
+
+        }
+
+    }
+
+    @Test
     public void testSqrtPow2() {
         double[] epsilon = new double[] { 1.0e-16, 3.0e-16, 2.0e-15, 6.0e-14, 6.0e-12 };
         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
@@ -404,6 +482,89 @@
     }
 
     @Test
+    public void testHypotDefinition() {
+        double epsilon = 1.0e-20;
+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
+            for (double x = -1.7; x < 2; x += 0.2) {
+                DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x);
+                for (double y = -1.7; y < 2; y += 0.2) {
+                    DerivativeStructure dsY = new DerivativeStructure(2, maxOrder, 1, y);
+                    DerivativeStructure hypot = DerivativeStructure.hypot(dsY, dsX);
+                    DerivativeStructure ref = dsX.multiply(dsX).add(dsY.multiply(dsY)).sqrt();
+                    DerivativeStructure zero = hypot.subtract(ref);
+                    for (int n = 0; n <= maxOrder; ++n) {
+                        for (int m = 0; m <= maxOrder; ++m) {
+                            if (n + m <= maxOrder) {
+                                Assert.assertEquals(0, zero.getPartialDerivative(n, m), epsilon);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testHypotNoOverflow() {
+
+        DerivativeStructure dsX = new DerivativeStructure(2, 5, 0, +3.0e250);
+        DerivativeStructure dsY = new DerivativeStructure(2, 5, 1, -4.0e250);
+        DerivativeStructure hypot = DerivativeStructure.hypot(dsX, dsY);
+        Assert.assertEquals(5.0e250, hypot.getValue(), 1.0e235);
+        Assert.assertEquals(dsX.getValue() / hypot.getValue(), hypot.getPartialDerivative(1, 0), 1.0e-10);
+        Assert.assertEquals(dsY.getValue() / hypot.getValue(), hypot.getPartialDerivative(0, 1), 1.0e-10);
+
+        DerivativeStructure sqrt  = dsX.multiply(dsX).add(dsY.multiply(dsY)).sqrt();
+        Assert.assertTrue(Double.isInfinite(sqrt.getValue()));
+
+    }
+
+    @Test
+    public void testPrimitiveRemainder() {
+        double epsilon = 1.0e-15;
+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
+            for (double x = -1.7; x < 2; x += 0.2) {
+                DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x);
+                for (double y = -1.7; y < 2; y += 0.2) {
+                    DerivativeStructure remainder = dsX.remainder(y);
+                    DerivativeStructure ref = dsX.subtract(x - (x % y));
+                    DerivativeStructure zero = remainder.subtract(ref);
+                    for (int n = 0; n <= maxOrder; ++n) {
+                        for (int m = 0; m <= maxOrder; ++m) {
+                            if (n + m <= maxOrder) {
+                                Assert.assertEquals(0, zero.getPartialDerivative(n, m), epsilon);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testRemainder() {
+        double epsilon = 1.0e-15;
+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
+            for (double x = -1.7; x < 2; x += 0.2) {
+                DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x);
+                for (double y = -1.7; y < 2; y += 0.2) {
+                    DerivativeStructure dsY = new DerivativeStructure(2, maxOrder, 1, y);
+                    DerivativeStructure remainder = dsX.remainder(dsY);
+                    DerivativeStructure ref = dsX.subtract(dsY.multiply((x - (x % y)) / y));
+                    DerivativeStructure zero = remainder.subtract(ref);
+                    for (int n = 0; n <= maxOrder; ++n) {
+                        for (int m = 0; m <= maxOrder; ++m) {
+                            if (n + m <= maxOrder) {
+                                Assert.assertEquals(0, zero.getPartialDerivative(n, m), epsilon);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    @Test
     public void testExp() {
         double[] epsilon = new double[] { 1.0e-16, 1.0e-16, 1.0e-16, 1.0e-16, 1.0e-16 };
         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
@@ -418,6 +579,22 @@
     }
 
     @Test
+    public void testExpm1Definition() {
+        double epsilon = 3.0e-16;
+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
+            for (double x = 0.1; x < 1.2; x += 0.001) {
+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);
+                DerivativeStructure expm11 = dsX.expm1();
+                DerivativeStructure expm12 = dsX.exp().subtract(dsX.getField().getOne());
+                DerivativeStructure zero = expm11.subtract(expm12);
+                for (int n = 0; n <= maxOrder; ++n) {
+                    Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon);
+                }
+            }
+        }
+    }
+
+    @Test
     public void testLog() {
         double[] epsilon = new double[] { 1.0e-16, 1.0e-16, 3.0e-14, 7.0e-13, 3.0e-11 };
         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
@@ -433,6 +610,38 @@
     }
 
     @Test
+    public void testLog1pDefinition() {
+        double epsilon = 3.0e-16;
+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
+            for (double x = 0.1; x < 1.2; x += 0.001) {
+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);
+                DerivativeStructure log1p1 = dsX.log1p();
+                DerivativeStructure log1p2 = dsX.add(dsX.getField().getOne()).log();
+                DerivativeStructure zero = log1p1.subtract(log1p2);
+                for (int n = 0; n <= maxOrder; ++n) {
+                    Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon);
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testLog10Definition() {
+        double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 8.0e-15, 3.0e-13, 8.0e-12 };
+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
+            for (double x = 0.1; x < 1.2; x += 0.001) {
+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);
+                DerivativeStructure log101 = dsX.log10();
+                DerivativeStructure log102 = dsX.log().divide(FastMath.log(10.0));
+                DerivativeStructure zero = log101.subtract(log102);
+                for (int n = 0; n <= maxOrder; ++n) {
+                    Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);
+                }
+            }
+        }
+    }
+
+    @Test
     public void testLogExp() {
         double[] epsilon = new double[] { 2.0e-16, 2.0e-16, 3.0e-16, 2.0e-15, 6.0e-15 };
         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
@@ -448,6 +657,36 @@
     }
 
     @Test
+    public void testLog1pExpm1() {
+        double[] epsilon = new double[] { 6.0e-17, 3.0e-16, 5.0e-16, 9.0e-16, 6.0e-15 };
+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
+            for (double x = 0.1; x < 1.2; x += 0.001) {
+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);
+                DerivativeStructure rebuiltX = dsX.expm1().log1p();
+                DerivativeStructure zero = rebuiltX.subtract(dsX);
+                for (int n = 0; n <= maxOrder; ++n) {
+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testLog10Power() {
+        double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 9.0e-16, 6.0e-15, 6.0e-14 };
+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
+            for (double x = 0.1; x < 1.2; x += 0.001) {
+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);
+                DerivativeStructure rebuiltX = new DerivativeStructure(1, maxOrder, 10.0).pow(dsX).log10();
+                DerivativeStructure zero = rebuiltX.subtract(dsX);
+                for (int n = 0; n <= maxOrder; ++n) {
+                    Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);
+                }
+            }
+        }
+    }
+
+    @Test
     public void testSinCos() {
         double epsilon = 5.0e-16;
         for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {
@@ -543,6 +782,125 @@
     }
 
     @Test
+    public void testAtan2() {
+        double[] epsilon = new double[] { 5.0e-16, 3.0e-15, 2.2e-14, 1.0e-12, 8.0e-11 };
+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
+            for (double x = -1.7; x < 2; x += 0.2) {
+                DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x);
+                for (double y = -1.7; y < 2; y += 0.2) {
+                    DerivativeStructure dsY = new DerivativeStructure(2, maxOrder, 1, y);
+                    DerivativeStructure atan2 = DerivativeStructure.atan2(dsY, dsX);
+                    DerivativeStructure ref = dsY.divide(dsX).atan();
+                    if (x < 0) {
+                        ref = (y < 0) ? ref.subtract(FastMath.PI) : ref.add(FastMath.PI);
+                    }
+                    DerivativeStructure zero = atan2.subtract(ref);
+                    for (int n = 0; n <= maxOrder; ++n) {
+                        for (int m = 0; m <= maxOrder; ++m) {
+                            if (n + m <= maxOrder) {
+                                Assert.assertEquals(0, zero.getPartialDerivative(n, m), epsilon[n + m]);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testSinhDefinition() {
+        double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 5.0e-16, 2.0e-15, 6.0e-15 };
+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
+            for (double x = 0.1; x < 1.2; x += 0.001) {
+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);
+                DerivativeStructure sinh1 = dsX.exp().subtract(dsX.exp().reciprocal()).multiply(0.5);
+                DerivativeStructure sinh2 = dsX.sinh();
+                DerivativeStructure zero = sinh1.subtract(sinh2);
+                for (int n = 0; n <= maxOrder; ++n) {
+                    Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testCoshDefinition() {
+        double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 5.0e-16, 2.0e-15, 6.0e-15 };
+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
+            for (double x = 0.1; x < 1.2; x += 0.001) {
+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);
+                DerivativeStructure cosh1 = dsX.exp().add(dsX.exp().reciprocal()).multiply(0.5);
+                DerivativeStructure cosh2 = dsX.cosh();
+                DerivativeStructure zero = cosh1.subtract(cosh2);
+                for (int n = 0; n <= maxOrder; ++n) {
+                    Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testTanhDefinition() {
+        double[] epsilon = new double[] { 3.0e-16, 5.0e-16, 7.0e-16, 3.0e-15, 2.0e-14 };
+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
+            for (double x = 0.1; x < 1.2; x += 0.001) {
+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);
+                DerivativeStructure tanh1 = dsX.exp().subtract(dsX.exp().reciprocal()).divide(dsX.exp().add(dsX.exp().reciprocal()));
+                DerivativeStructure tanh2 = dsX.tanh();
+                DerivativeStructure zero = tanh1.subtract(tanh2);
+                for (int n = 0; n <= maxOrder; ++n) {
+                    Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testSinhAsinh() {
+        double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 4.0e-16, 7.0e-16, 3.0e-15, 8.0e-15 };
+        for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {
+            for (double x = 0.1; x < 1.2; x += 0.001) {
+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);
+                DerivativeStructure rebuiltX = dsX.sinh().asinh();
+                DerivativeStructure zero = rebuiltX.subtract(dsX);
+                for (int n = 0; n <= maxOrder; ++n) {
+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testCoshAcosh() {
+        double[] epsilon = new double[] { 2.0e-15, 1.0e-14, 2.0e-13, 6.0e-12, 3.0e-10, 2.0e-8 };
+        for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {
+            for (double x = 0.1; x < 1.2; x += 0.001) {
+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);
+                DerivativeStructure rebuiltX = dsX.cosh().acosh();
+                DerivativeStructure zero = rebuiltX.subtract(dsX);
+                for (int n = 0; n <= maxOrder; ++n) {
+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testTanhAtanh() {
+        double[] epsilon = new double[] { 3.0e-16, 2.0e-16, 7.0e-16, 4.0e-15, 3.0e-14, 4.0e-13 };
+        for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {
+            for (double x = 0.1; x < 1.2; x += 0.001) {
+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);
+                DerivativeStructure rebuiltX = dsX.tanh().atanh();
+                DerivativeStructure zero = rebuiltX.subtract(dsX);
+                for (int n = 0; n <= maxOrder; ++n) {
+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);
+                }
+            }
+        }
+    }
+
+    @Test
     public void testCompositionOneVariableY() {
         double epsilon = 1.0e-13;
         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
@@ -571,6 +929,210 @@
     }
 
     @Test
+    public void testTaylorPolynomial() {
+        for (double x = 0; x < 1.2; x += 0.1) {
+            DerivativeStructure dsX = new DerivativeStructure(3, 4, 0, x);
+            for (double y = 0; y < 1.2; y += 0.2) {
+                DerivativeStructure dsY = new DerivativeStructure(3, 4, 1, y);
+                for (double z = 0; z < 1.2; z += 0.2) {
+                    DerivativeStructure dsZ = new DerivativeStructure(3, 4, 2, z);
+                    DerivativeStructure f = dsX.multiply(dsY).add(dsZ).multiply(dsX).multiply(dsY);
+                    for (double dx = -0.2; dx < 0.2; dx += 0.2) {
+                        for (double dy = -0.2; dy < 0.2; dy += 0.1) {
+                            for (double dz = -0.2; dz < 0.2; dz += 0.1) {
+                                double ref = (x + dx) * (y + dy) * ((x + dx) * (y + dy) + (z + dz));
+                                Assert.assertEquals(ref, f.taylor(dx, dy, dz), 2.0e-15);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testTaylorAtan2() {
+        double[] expected = new double[] { 0.214, 0.0241, 0.00422, 6.48e-4, 8.04e-5 };
+        double x0 =  0.1;
+        double y0 = -0.3;
+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {
+            DerivativeStructure dsX   = new DerivativeStructure(2, maxOrder, 0, x0);
+            DerivativeStructure dsY   = new DerivativeStructure(2, maxOrder, 1, y0);
+            DerivativeStructure atan2 = DerivativeStructure.atan2(dsY, dsX);
+            double maxError = 0;
+            for (double dx = -0.05; dx < 0.05; dx += 0.001) {
+                for (double dy = -0.05; dy < 0.05; dy += 0.001) {
+                    double ref = FastMath.atan2(y0 + dy, x0 + dx);
+                    maxError = FastMath.max(maxError, FastMath.abs(ref - atan2.taylor(dx, dy)));
+                }
+            }
+            Assert.assertEquals(0.0, expected[maxOrder] - maxError, 0.01 * expected[maxOrder]);
+        }
+    }
+
+    @Test
+    public void testAbs() {
+
+        DerivativeStructure minusOne = new DerivativeStructure(1, 1, 0, -1.0);
+        Assert.assertEquals(+1.0, minusOne.abs().getPartialDerivative(0), 1.0e-15);
+        Assert.assertEquals(-1.0, minusOne.abs().getPartialDerivative(1), 1.0e-15);
+
+        DerivativeStructure plusOne = new DerivativeStructure(1, 1, 0, +1.0);
+        Assert.assertEquals(+1.0, plusOne.abs().getPartialDerivative(0), 1.0e-15);
+        Assert.assertEquals(+1.0, plusOne.abs().getPartialDerivative(1), 1.0e-15);
+
+        DerivativeStructure minusZero = new DerivativeStructure(1, 1, 0, -0.0);
+        Assert.assertEquals(+0.0, minusZero.abs().getPartialDerivative(0), 1.0e-15);
+        Assert.assertEquals(-1.0, minusZero.abs().getPartialDerivative(1), 1.0e-15);
+
+        DerivativeStructure plusZero = new DerivativeStructure(1, 1, 0, +0.0);
+        Assert.assertEquals(+0.0, plusZero.abs().getPartialDerivative(0), 1.0e-15);
+        Assert.assertEquals(+1.0, plusZero.abs().getPartialDerivative(1), 1.0e-15);
+
+    }
+
+    @Test
+    public void testSignum() {
+
+        DerivativeStructure minusOne = new DerivativeStructure(1, 1, 0, -1.0);
+        Assert.assertEquals(-1.0, minusOne.signum().getPartialDerivative(0), 1.0e-15);
+        Assert.assertEquals( 0.0, minusOne.signum().getPartialDerivative(1), 1.0e-15);
+
+        DerivativeStructure plusOne = new DerivativeStructure(1, 1, 0, +1.0);
+        Assert.assertEquals(+1.0, plusOne.signum().getPartialDerivative(0), 1.0e-15);
+        Assert.assertEquals( 0.0, plusOne.signum().getPartialDerivative(1), 1.0e-15);
+
+        DerivativeStructure minusZero = new DerivativeStructure(1, 1, 0, -0.0);
+        Assert.assertEquals(-0.0, minusZero.signum().getPartialDerivative(0), 1.0e-15);
+        Assert.assertTrue(Double.doubleToLongBits(minusZero.signum().getValue()) < 0);
+        Assert.assertEquals( 0.0, minusZero.signum().getPartialDerivative(1), 1.0e-15);
+
+        DerivativeStructure plusZero = new DerivativeStructure(1, 1, 0, +0.0);
+        Assert.assertEquals(+0.0, plusZero.signum().getPartialDerivative(0), 1.0e-15);
+        Assert.assertTrue(Double.doubleToLongBits(plusZero.signum().getValue()) == 0);
+        Assert.assertEquals( 0.0, plusZero.signum().getPartialDerivative(1), 1.0e-15);
+
+    }
+
+    @Test
+    public void testCeilFloorRintLong() {
+
+        DerivativeStructure x = new DerivativeStructure(1, 1, 0, -1.5);
+        Assert.assertEquals(-1.5, x.getPartialDerivative(0), 1.0e-15);
+        Assert.assertEquals(+1.0, x.getPartialDerivative(1), 1.0e-15);
+        Assert.assertEquals(-1.0, x.ceil().getPartialDerivative(0), 1.0e-15);
+        Assert.assertEquals(+0.0, x.ceil().getPartialDerivative(1), 1.0e-15);
+        Assert.assertEquals(-2.0, x.floor().getPartialDerivative(0), 1.0e-15);
+        Assert.assertEquals(+0.0, x.floor().getPartialDerivative(1), 1.0e-15);
+        Assert.assertEquals(-2.0, x.rint().getPartialDerivative(0), 1.0e-15);
+        Assert.assertEquals(+0.0, x.rint().getPartialDerivative(1), 1.0e-15);
+        Assert.assertEquals(-2.0, x.subtract(x.getField().getOne()).rint().getPartialDerivative(0), 1.0e-15);
+        Assert.assertEquals(-1l, x.round());
+
+    }
+
+    @Test
+    public void testCopySign() {
+        DerivativeStructure minusOne = new DerivativeStructure(1, 1, 0, -1.0);
+        Assert.assertEquals(+1.0, minusOne.copySign(+1.0).getPartialDerivative(0), 1.0e-15);
+        Assert.assertEquals(-1.0, minusOne.copySign(+1.0).getPartialDerivative(1), 1.0e-15);
+        Assert.assertEquals(-1.0, minusOne.copySign(-1.0).getPartialDerivative(0), 1.0e-15);
+        Assert.assertEquals(+1.0, minusOne.copySign(-1.0).getPartialDerivative(1), 1.0e-15);
+        Assert.assertEquals(+1.0, minusOne.copySign(+0.0).getPartialDerivative(0), 1.0e-15);
+        Assert.assertEquals(-1.0, minusOne.copySign(+0.0).getPartialDerivative(1), 1.0e-15);
+        Assert.assertEquals(-1.0, minusOne.copySign(-0.0).getPartialDerivative(0), 1.0e-15);
+        Assert.assertEquals(+1.0, minusOne.copySign(-0.0).getPartialDerivative(1), 1.0e-15);
+        Assert.assertEquals(+1.0, minusOne.copySign(Double.NaN).getPartialDerivative(0), 1.0e-15);
+        Assert.assertEquals(-1.0, minusOne.copySign(Double.NaN).getPartialDerivative(1), 1.0e-15);
+    }
+
+    @Test
+    public void testToDegreesDefinition() {
+        double epsilon = 3.0e-16;
+        for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {
+            for (double x = 0.1; x < 1.2; x += 0.001) {
+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);
+                Assert.assertEquals(FastMath.toDegrees(x), dsX.toDegrees().getValue(), epsilon);
+                for (int n = 1; n <= maxOrder; ++n) {
+                    if (n == 1) {
+                        Assert.assertEquals(180 / FastMath.PI, dsX.toDegrees().getPartialDerivative(1), epsilon);
+                    } else {
+                        Assert.assertEquals(0.0, dsX.toDegrees().getPartialDerivative(n), epsilon);
+                    }
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testToRadiansDefinition() {
+        double epsilon = 3.0e-16;
+        for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {
+            for (double x = 0.1; x < 1.2; x += 0.001) {
+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);
+                Assert.assertEquals(FastMath.toRadians(x), dsX.toRadians().getValue(), epsilon);
+                for (int n = 1; n <= maxOrder; ++n) {
+                    if (n == 1) {
+                        Assert.assertEquals(FastMath.PI / 180, dsX.toRadians().getPartialDerivative(1), epsilon);
+                    } else {
+                        Assert.assertEquals(0.0, dsX.toRadians().getPartialDerivative(n), epsilon);
+                    }
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testDegRad() {
+        double epsilon = 3.0e-16;
+        for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {
+            for (double x = 0.1; x < 1.2; x += 0.001) {
+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);
+                DerivativeStructure rebuiltX = dsX.toDegrees().toRadians();
+                DerivativeStructure zero = rebuiltX.subtract(dsX);
+                for (int n = 0; n <= maxOrder; ++n) {
+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon);
+                }
+            }
+        }
+    }
+
+    @Test(expected=DimensionMismatchException.class)
+    public void testComposeMismatchedDimensions() {
+        new DerivativeStructure(1, 3, 0, 1.2).compose(new double[3]);
+    }
+
+    @Test
+    public void testCompose() {
+        double[] epsilon = new double[] { 1.0e-20, 5.0e-14, 2.0e-13, 3.0e-13, 2.0e-13, 1.0e-20 };
+        PolynomialFunction poly =
+                new PolynomialFunction(new double[] { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 });
+        for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {
+            PolynomialFunction[] p = new PolynomialFunction[maxOrder + 1];
+            p[0] = poly;
+            for (int i = 1; i <= maxOrder; ++i) {
+                p[i] = p[i - 1].polynomialDerivative();
+            }
+            for (double x = 0.1; x < 1.2; x += 0.001) {
+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);
+                DerivativeStructure dsY1 = dsX.getField().getZero();
+                for (int i = poly.degree(); i >= 0; --i) {
+                    dsY1 = dsY1.multiply(dsX).add(poly.getCoefficients()[i]);
+                }
+                double[] f = new double[maxOrder + 1];
+                for (int i = 0; i < f.length; ++i) {
+                    f[i] = p[i].value(x);
+                }
+                DerivativeStructure dsY2 = dsX.compose(f);
+                DerivativeStructure zero = dsY1.subtract(dsY2);
+                for (int n = 0; n <= maxOrder; ++n) {
+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);
+                }
+            }
+        }
+    }
+
+    @Test
     public void testField() {
         for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {
             DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 1.0);
@@ -582,6 +1144,57 @@
         }
     }
 
+    @Test
+    public void testOneParameterConstructor() {
+        double x = 1.2;
+        double cos = FastMath.cos(x);
+        double sin = FastMath.sin(x);
+        DerivativeStructure yRef = new DerivativeStructure(1, 4, 0, x).cos();
+        try {
+            new DerivativeStructure(1, 4, 0.0, 0.0);
+            Assert.fail("an exception should have been thrown");
+        } catch (DimensionMismatchException dme) {
+            // expected
+        } catch (Exception e) {
+            Assert.fail("wrong exceptionc caught " + e.getClass().getName());
+        }
+        double[] derivatives = new double[] { cos, -sin, -cos, sin, cos };
+        DerivativeStructure y = new DerivativeStructure(1,  4, derivatives);
+        checkEquals(yRef, y, 1.0e-15);
+        TestUtils.assertEquals(derivatives, y.getAllDerivatives(), 1.0e-15);
+    }
+
+    @Test
+    public void testOneOrderConstructor() {
+        double x =  1.2;
+        double y =  2.4;
+        double z = 12.5;
+        DerivativeStructure xRef = new DerivativeStructure(3, 1, 0, x);
+        DerivativeStructure yRef = new DerivativeStructure(3, 1, 1, y);
+        DerivativeStructure zRef = new DerivativeStructure(3, 1, 2, z);
+        try {
+            new DerivativeStructure(3, 1, x + y - z, 1.0, 1.0);
+            Assert.fail("an exception should have been thrown");
+        } catch (DimensionMismatchException dme) {
+            // expected
+        } catch (Exception e) {
+            Assert.fail("wrong exceptionc caught " + e.getClass().getName());
+        }
+        double[] derivatives = new double[] { x + y - z, 1.0, 1.0, -1.0 };
+        DerivativeStructure t = new DerivativeStructure(3, 1, derivatives);
+        checkEquals(xRef.add(yRef.subtract(zRef)), t, 1.0e-15);
+        TestUtils.assertEquals(derivatives, xRef.add(yRef.subtract(zRef)).getAllDerivatives(), 1.0e-15);
+    }
+
+    @Test
+    public void testSerialization() {
+        DerivativeStructure a = new DerivativeStructure(3, 2, 0, 1.3);
+        DerivativeStructure b = (DerivativeStructure) TestUtils.serializeAndRecover(a);
+        Assert.assertEquals(a.getFreeParameters(), b.getFreeParameters());
+        Assert.assertEquals(a.getOrder(), b.getOrder());
+        checkEquals(a, b, 1.0e-15);
+    }
+
     private void checkF0F1(DerivativeStructure ds, double value, double...derivatives) {
 
         // check dimension
