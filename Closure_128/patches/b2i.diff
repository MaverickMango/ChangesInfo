diff -r -u buggy/src/com/google/javascript/jscomp/CodeGenerator.java inducing/src/com/google/javascript/jscomp/CodeGenerator.java
--- buggy/src/com/google/javascript/jscomp/CodeGenerator.java	2023-06-12 11:34:35.598387674 +0800
+++ inducing/src/com/google/javascript/jscomp/CodeGenerator.java	2023-06-12 11:34:36.146397682 +0800
@@ -19,6 +19,7 @@
 import com.google.common.base.Charsets;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Maps;
+import com.google.javascript.jscomp.NodeUtil.MatchNotFunction;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.TokenStream;
@@ -34,9 +35,6 @@
  *
  */
 class CodeGenerator {
-  private static final String LT_ESCAPED = "\\x3c";
-  private static final String GT_ESCAPED = "\\x3e";
-
   // A memoizer for formatting strings as JS strings.
   private final Map<String, String> ESCAPED_JS_STRINGS = Maps.newHashMap();
 
@@ -48,26 +46,9 @@
 
   private final CharsetEncoder outputCharsetEncoder;
 
-  private final boolean preferSingleQuotes;
-  private final boolean trustedStrings;
-
-  private CodeGenerator(CodeConsumer consumer) {
-    cc = consumer;
-    outputCharsetEncoder = null;
-    preferSingleQuotes = false;
-    trustedStrings = true;
-  }
-
-  static CodeGenerator forCostEstimation(CodeConsumer consumer) {
-    return new CodeGenerator(consumer);
-  }
-
   CodeGenerator(
-      CodeConsumer consumer,
-      CompilerOptions options) {
+      CodeConsumer consumer, Charset outputCharset) {
     cc = consumer;
-
-    Charset outputCharset = options.getOutputCharset();
     if (outputCharset == null || outputCharset == Charsets.US_ASCII) {
       // If we want our default (pretending to be UTF-8, but escaping anything
       // outside of straight ASCII), then don't use the encoder, but
@@ -77,8 +58,10 @@
     } else {
       this.outputCharsetEncoder = outputCharset.newEncoder();
     }
-    this.preferSingleQuotes = options.preferSingleQuotes;
-    this.trustedStrings = options.trustedStrings;
+  }
+
+  CodeGenerator(CodeConsumer consumer) {
+    this(consumer, null);
   }
 
   /**
@@ -118,6 +101,8 @@
           "Bad binary operator \"%s\": expected 2 arguments but got %s",
           opstr, childCount);
       int p = NodeUtil.precedence(type);
+      addLeftExpr(first, p, context);
+      cc.addOp(opstr, true);
 
       // For right-hand-side of operations, only pass context if it's
       // the IN_FOR_INIT_CLAUSE one.
@@ -128,16 +113,12 @@
       // we can simply generate a * b * c.
       if (last.getType() == type &&
           NodeUtil.isAssociative(type)) {
-        addExpr(first, p, context);
-        cc.addOp(opstr, true);
         addExpr(last, p, rhsContext);
       } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
         // Assignments are the only right-associative binary operators
-        addExpr(first, p, context);
-        cc.addOp(opstr, true);
         addExpr(last, p, rhsContext);
       } else {
-        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
+        addExpr(last, p + 1, rhsContext);
       }
       return;
     }
@@ -146,7 +127,7 @@
 
     switch (type) {
       case Token.TRY: {
-        Preconditions.checkState(first.getNext().isBlock() &&
+        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&
                 !first.getNext().hasMoreThanOneChild());
         Preconditions.checkState(childCount >= 2 && childCount <= 3);
 
@@ -208,14 +189,14 @@
         break;
 
       case Token.NAME:
-        if (first == null || first.isEmpty()) {
+        if (first == null || first.getType() == Token.EMPTY) {
           addIdentifier(n.getString());
         } else {
           Preconditions.checkState(childCount == 1);
           addIdentifier(n.getString());
           cc.addOp("=", true);
-          if (first.isComma()) {
-            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
+          if (first.getType() == Token.COMMA) {
+            addExpr(first, NodeUtil.precedence(Token.ASSIGN));
           } else {
             // Add expression, consider nearby code at lowest level of
             // precedence.
@@ -230,7 +211,7 @@
         add("]");
         break;
 
-      case Token.PARAM_LIST:
+      case Token.LP:
         add("(");
         addList(first);
         add(")");
@@ -238,7 +219,7 @@
 
       case Token.COMMA:
         Preconditions.checkState(childCount == 2);
-        unrollBinaryOperator(n, Token.COMMA, ",", context, Context.OTHER, 0, 0);
+        addList(first, false, context);
         break;
 
       case Token.NUMBER:
@@ -254,7 +235,7 @@
         // All of these unary operators are right-associative
         Preconditions.checkState(childCount == 1);
         cc.addOp(NodeUtil.opToStrNoFail(type), false);
-        addExpr(first, NodeUtil.precedence(type), Context.OTHER);
+        addExpr(first, NodeUtil.precedence(type));
         break;
       }
 
@@ -264,11 +245,11 @@
         // It's important to our sanity checker that the code
         // we print produces the same AST as the code we parse back.
         // NEG is a weird case because Rhino parses "- -2" as "2".
-        if (n.getFirstChild().isNumber()) {
+        if (n.getFirstChild().getType() == Token.NUMBER) {
           cc.addNumber(-n.getFirstChild().getDouble());
         } else {
           cc.addOp(NodeUtil.opToStrNoFail(type), false);
-          addExpr(first, NodeUtil.precedence(type), Context.OTHER);
+          addExpr(first, NodeUtil.precedence(type));
         }
 
         break;
@@ -277,17 +258,17 @@
       case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
-        addExpr(first, p + 1, context);
+        addLeftExpr(first, p + 1, context);
         cc.addOp("?", true);
-        addExpr(first.getNext(), 1, Context.OTHER);
+        addExpr(first.getNext(), 1);
         cc.addOp(":", true);
-        addExpr(last, 1, Context.OTHER);
+        addExpr(last, 1);
         break;
       }
 
       case Token.REGEXP:
-        if (!first.isString() ||
-            !last.isString()) {
+        if (first.getType() != Token.STRING ||
+            last.getType() != Token.STRING) {
           throw new Error("Expected children to be strings");
         }
 
@@ -302,6 +283,17 @@
         }
         break;
 
+      case Token.GET_REF:
+        add(first);
+        break;
+
+      case Token.REF_SPECIAL:
+        Preconditions.checkState(childCount == 1);
+        add(first);
+        add(".");
+        add((String) n.getProp(Node.NAME_PROP));
+        break;
+
       case Token.FUNCTION:
         if (n.getClass() != Node.class) {
           throw new Error("Unexpected Node subclass.");
@@ -324,15 +316,15 @@
         }
         break;
 
-      case Token.GETTER_DEF:
-      case Token.SETTER_DEF:
-        Preconditions.checkState(n.getParent().isObjectLit());
+      case Token.GET:
+      case Token.SET:
+        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);
         Preconditions.checkState(childCount == 1);
-        Preconditions.checkState(first.isFunction());
+        Preconditions.checkState(first.getType() == Token.FUNCTION);
 
         // Get methods are unnamed
         Preconditions.checkState(first.getFirstChild().getString().isEmpty());
-        if (type == Token.GETTER_DEF) {
+        if (type == Token.GET) {
           // Get methods have no parameters.
           Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
           add("get ");
@@ -352,7 +344,7 @@
         if (!n.isQuotedString() &&
             TokenStream.isJSIdentifier(name) &&
             // do not encode literally any non-literal characters that were
-            // Unicode escaped.
+            // unicode escaped.
             NodeUtil.isLatin(name)) {
           add(name);
         } else {
@@ -361,7 +353,7 @@
           if (!Double.isNaN(d)) {
             cc.addNumber(d);
           } else {
-            addJsString(n);
+            addJsString(n.getString());
           }
         }
 
@@ -384,21 +376,21 @@
             (type == Token.BLOCK &&
                 !preserveBlock &&
                 n.getParent() != null &&
-                n.getParent().isScript());
+                n.getParent().getType() == Token.SCRIPT);
         for (Node c = first; c != null; c = c.getNext()) {
           add(c, Context.STATEMENT);
 
           // VAR doesn't include ';' since it gets used in expressions
-          if (c.isVar()) {
+          if (c.getType() == Token.VAR) {
             cc.endStatement();
           }
 
-          if (c.isFunction()) {
+          if (c.getType() == Token.FUNCTION) {
             cc.maybeLineBreak();
           }
 
           // Prefer to break lines in between top-level statements
-          // because top-level statements are more homogeneous.
+          // because top level statements are more homogeneous.
           if (preferLineBreaks) {
             cc.notePreferredLineBreak();
           }
@@ -412,7 +404,7 @@
       case Token.FOR:
         if (childCount == 4) {
           add("for(");
-          if (first.isVar()) {
+          if (first.getType() == Token.VAR) {
             add(first, Context.IN_FOR_INIT_CLAUSE);
           } else {
             addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
@@ -464,13 +456,13 @@
             childCount == 2,
             "Bad GETPROP: expected 2 children, but got %s", childCount);
         Preconditions.checkState(
-            last.isString(),
+            last.getType() == Token.STRING,
             "Bad GETPROP: RHS should be STRING");
-        boolean needsParens = (first.isNumber());
+        boolean needsParens = (first.getType() == Token.NUMBER);
         if (needsParens) {
           add("(");
         }
-        addExpr(first, NodeUtil.precedence(type), context);
+        addLeftExpr(first, NodeUtil.precedence(type), context);
         if (needsParens) {
           add(")");
         }
@@ -483,7 +475,7 @@
         Preconditions.checkState(
             childCount == 2,
             "Bad GETELEM: expected 2 children but got %s", childCount);
-        addExpr(first, NodeUtil.precedence(type), context);
+        addLeftExpr(first, NodeUtil.precedence(type), context);
         add("[");
         add(first.getNext());
         add("]");
@@ -506,7 +498,7 @@
         // A non-zero post-prop value indicates a post inc/dec, default of zero
         // is a pre-inc/dec.
         if (postProp != 0) {
-          addExpr(first, NodeUtil.precedence(type), context);
+          addLeftExpr(first, NodeUtil.precedence(type), context);
           cc.addOp(o, false);
         } else {
           cc.addOp(o, false);
@@ -528,10 +520,10 @@
         if (isIndirectEval(first)
             || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
           add("(0,");
-          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
+          addExpr(first, NodeUtil.precedence(Token.COMMA));
           add(")");
         } else {
-          addExpr(first, NodeUtil.precedence(type), context);
+          addLeftExpr(first, NodeUtil.precedence(type), context);
         }
         add("(");
         addList(first.getNext());
@@ -567,30 +559,18 @@
         break;
 
       case Token.NULL:
-        Preconditions.checkState(childCount == 0);
-        cc.addConstant("null");
-        break;
-
       case Token.THIS:
-        Preconditions.checkState(childCount == 0);
-        add("this");
-        break;
-
       case Token.FALSE:
-        Preconditions.checkState(childCount == 0);
-        cc.addConstant("false");
-        break;
-
       case Token.TRUE:
         Preconditions.checkState(childCount == 0);
-        cc.addConstant("true");
+        add(Node.tokenToName(type));
         break;
 
       case Token.CONTINUE:
         Preconditions.checkState(childCount <= 1);
         add("continue");
         if (childCount == 1) {
-          if (!first.isLabelName()) {
+          if (first.getType() != Token.LABEL_NAME) {
             throw new Error("Unexpected token type. Should be LABEL_NAME.");
           }
           add(" ");
@@ -609,7 +589,7 @@
         Preconditions.checkState(childCount <= 1);
         add("break");
         if (childCount == 1) {
-          if (!first.isLabelName()) {
+          if (first.getType() != Token.LABEL_NAME) {
             throw new Error("Unexpected token type. Should be LABEL_NAME.");
           }
           add(" ");
@@ -618,6 +598,9 @@
         cc.endStatement();
         break;
 
+      case Token.EXPR_VOID:
+        throw new Error("Unexpected EXPR_VOID. Should be EXPR_RESULT.");
+
       case Token.EXPR_RESULT:
         Preconditions.checkState(childCount == 1);
         add(first, Context.START_OF_EXPR);
@@ -631,11 +614,10 @@
         // If the first child contains a CALL, then claim higher precedence
         // to force parentheses. Otherwise, when parsed, NEW will bind to the
         // first viable parentheses (don't traverse into functions).
-        if (NodeUtil.containsType(
-            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
+        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {
           precedence = NodeUtil.precedence(first.getType()) + 1;
         }
-        addExpr(first, precedence, Context.OTHER);
+        addExpr(first, precedence);
 
         // '()' is optional when no arguments are present
         Node next = first.getNext();
@@ -646,16 +628,14 @@
         }
         break;
 
-      case Token.STRING_KEY:
-        Preconditions.checkState(
-            childCount == 1, "Object lit key must have 1 child");
-        addJsString(n);
-        break;
-
       case Token.STRING:
-        Preconditions.checkState(
-            childCount == 0, "A string may not have children");
-        addJsString(n);
+        if (childCount !=
+            ((n.getParent() != null &&
+              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {
+          throw new IllegalStateException(
+              "Unexpected String children: " + n.getParent().toStringTree());
+        }
+        addJsString(n.getString());
         break;
 
       case Token.DELPROP:
@@ -675,10 +655,10 @@
             cc.listSeparator();
           }
 
-          if (c.isGetterDef() || c.isSetterDef()) {
+          if (c.getType() == Token.GET || c.getType() == Token.SET) {
             add(c);
           } else {
-            Preconditions.checkState(c.isStringKey());
+            Preconditions.checkState(c.getType() == Token.STRING);
             String key = c.getString();
             // Object literal property names don't have to be quoted if they
             // are not JavaScript keywords
@@ -686,7 +666,7 @@
                 !TokenStream.isKeyword(key) &&
                 TokenStream.isJSIdentifier(key) &&
                 // do not encode literally any non-literal characters that
-                // were Unicode escaped.
+                // were unicode escaped.
                 NodeUtil.isLatin(key)) {
               add(key);
             } else {
@@ -695,11 +675,11 @@
               if (!Double.isNaN(d)) {
                 cc.addNumber(d);
               } else {
-                addExpr(c, 1, Context.OTHER);
+                addExpr(c, 1);
               }
             }
             add(":");
-            addExpr(c.getFirstChild(), 1, Context.OTHER);
+            addExpr(c.getFirstChild(), 1);
           }
         }
         add("}");
@@ -725,7 +705,7 @@
         addCaseBody(last);
         break;
 
-      case Token.DEFAULT_CASE:
+      case Token.DEFAULT:
         Preconditions.checkState(childCount == 1);
         add("default");
         addCaseBody(first);
@@ -733,7 +713,7 @@
 
       case Token.LABEL:
         Preconditions.checkState(childCount == 2);
-        if (!first.isLabelName()) {
+        if (first.getType() != Token.LABEL_NAME) {
           throw new Error("Unexpected token type. Should be LABEL_NAME.");
         }
         add(first);
@@ -742,10 +722,9 @@
             last, getContextForNonEmptyExpression(context), true);
         break;
 
-      case Token.CAST:
-        add("(");
-        add(first);
-        add(")");
+      // This node is auto generated in anonymous functions and should just get
+      // ignored for our purposes.
+      case Token.SETNAME:
         break;
 
       default:
@@ -755,31 +734,6 @@
     cc.endSourceMapping(n);
   }
 
-  /**
-   * We could use addList recursively here, but sometimes we produce
-   * very deeply nested operators and run out of stack space, so we
-   * just unroll the recursion when possible.
-   *
-   * We assume nodes are left-recursive.
-   */
-  private void unrollBinaryOperator(
-      Node n, int op, String opStr, Context context,
-      Context rhsContext, int leftPrecedence, int rightPrecedence) {
-    Node firstNonOperator = n.getFirstChild();
-    while (firstNonOperator.getType() == op) {
-      firstNonOperator = firstNonOperator.getFirstChild();
-    }
-
-    addExpr(firstNonOperator, leftPrecedence, context);
-
-    Node current = firstNonOperator;
-    do {
-      current = current.getParent();
-      cc.addOp(opStr, true);
-      addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);
-    } while (current != n);
-  }
-
   static boolean isSimpleNumber(String s) {
     int len = s.length();
     for (int index = 0; index < len; index++) {
@@ -809,7 +763,7 @@
    * @return Whether the name is an indirect eval.
    */
   private boolean isIndirectEval(Node n) {
-    return n.isName() && "eval".equals(n.getString()) &&
+    return n.getType() == Token.NAME && "eval".equals(n.getString()) &&
         !n.getBooleanProp(Node.DIRECT_EVAL);
   }
 
@@ -824,13 +778,13 @@
       Node n, Context context, boolean allowNonBlockChild) {
     Node nodeToProcess = n;
 
-    if (!allowNonBlockChild && !n.isBlock()) {
+    if (!allowNonBlockChild && n.getType() != Token.BLOCK) {
       throw new Error("Missing BLOCK child.");
     }
 
     // Strip unneeded blocks, that is blocks with <2 children unless
     // the CodePrinter specifically wants to keep them.
-    if (n.isBlock()) {
+    if (n.getType() == Token.BLOCK) {
       int count = getNonEmptyChildCount(n, 2);
       if (count == 0) {
         if (cc.shouldPreserveExtraBlocks()) {
@@ -865,14 +819,14 @@
       }
     }
 
-    if (nodeToProcess.isEmpty()) {
+    if (nodeToProcess.getType() == Token.EMPTY) {
       cc.endStatement(true);
     } else {
       add(nodeToProcess, context);
 
       // VAR doesn't include ';' since it gets used in expressions - so any
       // VAR in a statement context needs a call to endStatement() here.
-      if (nodeToProcess.isVar()) {
+      if (nodeToProcess.getType() == Token.VAR) {
         cc.endStatement();
       }
     }
@@ -883,9 +837,9 @@
    * labels).
    */
   private boolean isOneExactlyFunctionOrDo(Node n) {
-    if (n.isLabel()) {
+    if (n.getType() == Token.LABEL) {
       Node labeledStatement = n.getLastChild();
-      if (!labeledStatement.isBlock()) {
+      if (labeledStatement.getType() != Token.BLOCK) {
         return isOneExactlyFunctionOrDo(labeledStatement);
       } else {
         // For labels with block children, we need to ensure that a
@@ -900,15 +854,33 @@
         }
       }
     } else {
-      return (n.isFunction() || n.isDo());
+      return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);
     }
   }
 
+  /**
+   * Adds a node at the left-hand side of an expression. Unlike
+   * {@link #addExpr(Node,int)}, this preserves information about the context.
+   *
+   * The left side of an expression is special because in the JavaScript
+   * grammar, certain tokens may be parsed differently when they are at
+   * the beginning of a statement. For example, "{}" is parsed as a block,
+   * but "{'x': 'y'}" is parsed as an object literal.
+   */
+  void addLeftExpr(Node n, int minPrecedence, Context context) {
+    addExpr(n, minPrecedence, context);
+  }
+
+  void addExpr(Node n, int minPrecedence) {
+    addExpr(n, minPrecedence, Context.OTHER);
+  }
+
   private void addExpr(Node n, int minPrecedence, Context context) {
     if ((NodeUtil.precedence(n.getType()) < minPrecedence) ||
-        ((context == Context.IN_FOR_INIT_CLAUSE) && n.isIn())){
+        ((context == Context.IN_FOR_INIT_CLAUSE) &&
+        (n.getType() == Token.IN))){
       add("(");
-      add(n, Context.OTHER);
+      add(n, clearContextForNoInOperator(context));
       add(")");
     } else {
       add(n, context);
@@ -928,10 +900,10 @@
     for (Node n = firstInList; n != null; n = n.getNext()) {
       boolean isFirst = n == firstInList;
       if (isFirst) {
-        addExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext);
+        addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext);
       } else {
         cc.listSeparator();
-        addExpr(n, isArrayOrFunctionArgument ? 1 : 0, Context.OTHER);
+        addExpr(n, isArrayOrFunctionArgument ? 1 : 0);
       }
     }
   }
@@ -950,8 +922,8 @@
       if (n != firstInList) {
         cc.listSeparator();
       }
-      addExpr(n, 1, Context.OTHER);
-      lastWasEmpty = n.isEmpty();
+      addExpr(n, 1);
+      lastWasEmpty = n.getType() == Token.EMPTY;
     }
 
     if (lastWasEmpty) {
@@ -971,23 +943,17 @@
     }
   }
 
-  /** Outputs a JS string, using the optimal (single/double) quote character */
-  private void addJsString(Node n) {
-    String s = n.getString();
-    boolean useSlashV = n.getBooleanProp(Node.SLASH_V);
-    if (useSlashV) {
-      add(jsString(n.getString(), useSlashV));
-    } else {
-      String cached = ESCAPED_JS_STRINGS.get(s);
-      if (cached == null) {
-        cached = jsString(n.getString(), useSlashV);
-        ESCAPED_JS_STRINGS.put(s, cached);
-      }
-      add(cached);
+  /** Outputs a js string, using the optimal (single/double) quote character */
+  void addJsString(String s) {
+    String cached = ESCAPED_JS_STRINGS.get(s);
+    if (cached == null) {
+      cached = jsString(s);
+      ESCAPED_JS_STRINGS.put(s, cached);
     }
+    add(cached);
   }
 
-  private String jsString(String s, boolean useSlashV) {
+  String jsString(String s) {
     int singleq = 0, doubleq = 0;
 
     // could count the quotes and pick the optimal quote character
@@ -1000,9 +966,8 @@
 
     String doublequote, singlequote;
     char quote;
-    if (preferSingleQuotes ?
-        (singleq <= doubleq) : (singleq < doubleq)) {
-      // more double quotes so enclose in single quotes.
+    if (singleq < doubleq) {
+      // more double quotes so escape the single quotes
       quote = '\'';
       doublequote = "\"";
       singlequote = "\\\'";
@@ -1014,110 +979,57 @@
     }
 
     return strEscape(s, quote, doublequote, singlequote, "\\\\",
-        outputCharsetEncoder, useSlashV, false);
+        outputCharsetEncoder);
   }
 
   /** Escapes regular expression */
-  String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) {
-    return strEscape(s, '/', "\"", "'", "\\", outputCharsetEncoder, false, true);
+  static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) {
+    return strEscape(s, '/', "\"", "'", "\\", outputCharsetEncoder);
   }
 
   /**
    * Escapes the given string to a double quoted (") JavaScript/JSON string
    */
-  String escapeToDoubleQuotedJsString(String s) {
-    return strEscape(s, '"',  "\\\"", "\'", "\\\\", null, false, false);
+  static String escapeToDoubleQuotedJsString(String s) {
+    return strEscape(s, '"',  "\\\"", "\'", "\\\\", null);
   }
 
   /* If the user doesn't want to specify an output charset encoder, assume
      they want Latin/ASCII characters only.
    */
-  String regexpEscape(String s) {
+  static String regexpEscape(String s) {
     return regexpEscape(s, null);
   }
 
-  /** Helper to escape JavaScript string as well as regular expression */
-  private String strEscape(
-      String s,
-      char quote,
-      String doublequoteEscape,
-      String singlequoteEscape,
-      String backslashEscape,
-      CharsetEncoder outputCharsetEncoder,
-      boolean useSlashV,
-      boolean isRegexp) {
+  /** Helper to escape javascript string as well as regular expression */
+  static String strEscape(String s, char quote,
+                          String doublequoteEscape,
+                          String singlequoteEscape,
+                          String backslashEscape,
+                          CharsetEncoder outputCharsetEncoder) {
     StringBuilder sb = new StringBuilder(s.length() + 2);
     sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\0': sb.append("\\x00"); break;
-        case '\u000B':
-          if (useSlashV) {
-            sb.append("\\v");
-          } else {
-            sb.append("\\x0B");
-          }
-          break;
-        // From the SingleEscapeCharacter grammar production.
-        case '\b': sb.append("\\b"); break;
-        case '\f': sb.append("\\f"); break;
         case '\n': sb.append("\\n"); break;
         case '\r': sb.append("\\r"); break;
         case '\t': sb.append("\\t"); break;
         case '\\': sb.append(backslashEscape); break;
         case '\"': sb.append(doublequoteEscape); break;
         case '\'': sb.append(singlequoteEscape); break;
-
-        // From LineTerminators (ES5 Section 7.3, Table 3)
-        case '\u2028': sb.append("\\u2028"); break;
-        case '\u2029': sb.append("\\u2029"); break;
-
-        case '=':
-          // '=' is a syntactically signficant regexp character.
-          if (trustedStrings || isRegexp) {
-            sb.append(c);
-          } else {
-            sb.append("\\x3d");
-          }
-          break;
-
-        case '&':
-          if (trustedStrings || isRegexp) {
-            sb.append(c);
-          } else {
-            sb.append("\\x26");
-          }
-          break;
-
-        case '>':
-          if (!trustedStrings && !isRegexp) {
-            sb.append(GT_ESCAPED);
-            break;
-          }
-
-          // Break --> into --\> or ]]> into ]]\>
-          //
-          // This is just to prevent developers from shooting themselves in the
-          // foot, and does not provide the level of security that you get
-          // with trustedString == false.
+        case '>':                       // Break --> into --\> or ]]> into ]]\>
           if (i >= 2 &&
               ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||
                (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
-            sb.append(GT_ESCAPED);
+            sb.append("\\>");
           } else {
             sb.append(c);
           }
           break;
         case '<':
-          if (!trustedStrings && !isRegexp) {
-            sb.append(LT_ESCAPED);
-            break;
-          }
-
           // Break </script into <\/script
-          // As above, this is just to prevent developers from doing this
-          // accidentally.
           final String END_SCRIPT = "/script";
 
           // Break <!-- into <\!--
@@ -1125,10 +1037,10 @@
 
           if (s.regionMatches(true, i + 1, END_SCRIPT, 0,
                               END_SCRIPT.length())) {
-            sb.append(LT_ESCAPED);
+            sb.append("<\\");
           } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,
                                      START_COMMENT.length())) {
-            sb.append(LT_ESCAPED);
+            sb.append("<\\");
           } else {
             sb.append(c);
           }
@@ -1144,15 +1056,15 @@
               appendHexJavaScriptRepresentation(sb, c);
             }
           } else {
-            // No charsetEncoder provided - pass straight Latin characters
+            // No charsetEncoder provided - pass straight latin characters
             // through, and escape the rest.  Doing the explicit character
             // check is measurably faster than using the CharsetEncoder.
             if (c > 0x1f && c < 0x7f) {
               sb.append(c);
             } else {
-              // Other characters can be misinterpreted by some JS parsers,
+              // Other characters can be misinterpreted by some js parsers,
               // or perhaps mangled by proxies along the way,
-              // so we play it safe and Unicode escape them.
+              // so we play it safe and unicode escape them.
               appendHexJavaScriptRepresentation(sb, c);
             }
           }
@@ -1168,7 +1080,7 @@
       return s;
     }
 
-    // Now going through the string to escape non-Latin characters if needed.
+    // Now going through the string to escape non-latin characters if needed.
     StringBuilder sb = new StringBuilder();
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
@@ -1192,9 +1104,9 @@
     int i = 0;
     Node c = n.getFirstChild();
     for (; c != null && i < maxCount; c = c.getNext()) {
-      if (c.isBlock()) {
+      if (c.getType() == Token.BLOCK) {
         i += getNonEmptyChildCount(c, maxCount-i);
-      } else if (!c.isEmpty()) {
+      } else if (c.getType() != Token.EMPTY) {
         i++;
       }
     }
@@ -1204,12 +1116,12 @@
   /** Gets the first non-empty child of the given node. */
   private static Node getFirstNonEmptyChild(Node n) {
     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
-      if (c.isBlock()) {
+      if (c.getType() == Token.BLOCK) {
         Node result = getFirstNonEmptyChild(c);
         if (result != null) {
           return result;
         }
-      } else if (!c.isEmpty()) {
+      } else if (c.getType() != Token.EMPTY) {
         return c;
       }
     }
@@ -1246,6 +1158,17 @@
   }
 
   /**
+   * If we're in a IN_FOR_INIT_CLAUSE, (and thus can't permit in operators
+   * in the expression), but have added parentheses, the expressions within
+   * the parens have no limits.  Clear the context flag  Be safe and don't
+   * clear the flag if it held another value.
+   */
+  private  Context clearContextForNoInOperator(Context context) {
+    return (context == Context.IN_FOR_INIT_CLAUSE
+        ? Context.OTHER : context);
+  }
+
+  /**
    * @see #appendHexJavaScriptRepresentation(int, Appendable)
    */
   private static void appendHexJavaScriptRepresentation(
@@ -1259,19 +1182,19 @@
   }
 
   /**
-   * Returns a JavaScript representation of the character in a hex escaped
+   * Returns a javascript representation of the character in a hex escaped
    * format.
    *
-   * @param codePoint The code point to append.
+   * @param codePoint The codepoint to append.
    * @param out The buffer to which the hex representation should be appended.
    */
   private static void appendHexJavaScriptRepresentation(
       int codePoint, Appendable out)
       throws IOException {
     if (Character.isSupplementaryCodePoint(codePoint)) {
-      // Handle supplementary Unicode values which are not representable in
-      // JavaScript.  We deal with these by escaping them as two 4B sequences
-      // so that they will round-trip properly when sent from Java to JavaScript
+      // Handle supplementary unicode values which are not representable in
+      // javascript.  We deal with these by escaping them as two 4B sequences
+      // so that they will round-trip properly when sent from java to javascript
       // and back.
       char[] surrogates = Character.toChars(codePoint);
       appendHexJavaScriptRepresentation(surrogates[0], out);
diff -r -u buggy/test/com/google/javascript/jscomp/CodePrinterTest.java inducing/test/com/google/javascript/jscomp/CodePrinterTest.java
--- buggy/test/com/google/javascript/jscomp/CodePrinterTest.java	2023-06-12 11:34:35.610387893 +0800
+++ inducing/test/com/google/javascript/jscomp/CodePrinterTest.java	2023-06-12 11:34:36.146397682 +0800
@@ -16,8 +16,6 @@
 
 package com.google.javascript.jscomp;
 
-import com.google.common.base.Joiner;
-import com.google.common.collect.Lists;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.rhino.InputId;
 import com.google.javascript.rhino.Node;
@@ -25,27 +23,14 @@
 
 import junit.framework.TestCase;
 
-import java.util.List;
-
 public class CodePrinterTest extends TestCase {
-  private boolean trustedStrings = true;
-  private Compiler lastCompiler = null;
-
-  @Override public void setUp() {
-    trustedStrings = true;
-    lastCompiler = null;
-  }
-
-  Node parse(String js) {
+  static Node parse(String js) {
     return parse(js, false);
   }
 
-  Node parse(String js, boolean checkTypes) {
+  static Node parse(String js, boolean checkTypes) {
     Compiler compiler = new Compiler();
-    lastCompiler = compiler;
     CompilerOptions options = new CompilerOptions();
-    options.setTrustedStrings(trustedStrings);
-
     // Allow getters and setters.
     options.setLanguageIn(LanguageMode.ECMASCRIPT5);
     compiler.initOptions(options);
@@ -56,6 +41,7 @@
       CompilerPass typeResolver = passConfig.resolveTypes.create(compiler);
       Node externs = new Node(Token.SCRIPT);
       externs.setInputId(new InputId("externs"));
+      externs.setIsSyntheticBlock(true);
       Node externAndJsRoot = new Node(Token.BLOCK, externs, n);
       externAndJsRoot.setIsSyntheticBlock(true);
       typeResolver.process(externs, n);
@@ -83,72 +69,38 @@
   }
 
   String parsePrint(String js, boolean prettyprint, int lineThreshold) {
-    CompilerOptions options = new CompilerOptions();
-    options.setTrustedStrings(trustedStrings);
-    options.setPrettyPrint(prettyprint);
-    options.setLineLengthThreshold(lineThreshold);
-    return new CodePrinter.Builder(parse(js)).setCompilerOptions(options)
-        .build();
+    return new CodePrinter.Builder(parse(js)).setPrettyPrint(prettyprint)
+        .setLineLengthThreshold(lineThreshold).build();
   }
 
   String parsePrint(String js, boolean prettyprint, boolean lineBreak,
       int lineThreshold) {
-    CompilerOptions options = new CompilerOptions();
-    options.setTrustedStrings(trustedStrings);
-    options.setPrettyPrint(prettyprint);
-    options.setLineLengthThreshold(lineThreshold);
-    options.setLineBreak(lineBreak);
-    return new CodePrinter.Builder(parse(js)).setCompilerOptions(options)
-        .build();
-  }
-
-  String parsePrint(String js, boolean prettyprint, boolean lineBreak,
-      boolean preferLineBreakAtEof, int lineThreshold) {
-    CompilerOptions options = new CompilerOptions();
-    options.setTrustedStrings(trustedStrings);
-    options.setPrettyPrint(prettyprint);
-    options.setLineLengthThreshold(lineThreshold);
-    options.setPreferLineBreakAtEndOfFile(preferLineBreakAtEof);
-    options.setLineBreak(lineBreak);
-    return new CodePrinter.Builder(parse(js)).setCompilerOptions(options)
-        .build();
+    return new CodePrinter.Builder(parse(js)).setPrettyPrint(prettyprint)
+        .setLineLengthThreshold(lineThreshold).setLineBreak(lineBreak).build();
   }
 
   String parsePrint(String js, boolean prettyprint, boolean lineBreak,
       int lineThreshold, boolean outputTypes) {
-    Node node = parse(js, true);
-    CompilerOptions options = new CompilerOptions();
-    options.setTrustedStrings(trustedStrings);
-    options.setPrettyPrint(prettyprint);
-    options.setLineLengthThreshold(lineThreshold);
-    options.setLineBreak(lineBreak);
-    return new CodePrinter.Builder(node).setCompilerOptions(options)
+    return new CodePrinter.Builder(parse(js, true)).setPrettyPrint(prettyprint)
         .setOutputTypes(outputTypes)
-        .setTypeRegistry(lastCompiler.getTypeRegistry())
+        .setLineLengthThreshold(lineThreshold).setLineBreak(lineBreak)
         .build();
   }
 
   String parsePrint(String js, boolean prettyprint, boolean lineBreak,
                     int lineThreshold, boolean outputTypes,
                     boolean tagAsStrict) {
-    Node node = parse(js, true);
-    CompilerOptions options = new CompilerOptions();
-    options.setTrustedStrings(trustedStrings);
-    options.setPrettyPrint(prettyprint);
-    options.setLineLengthThreshold(lineThreshold);
-    options.setLineBreak(lineBreak);
-    return new CodePrinter.Builder(node).setCompilerOptions(options)
+    return new CodePrinter.Builder(parse(js, true)).setPrettyPrint(prettyprint)
         .setOutputTypes(outputTypes)
-        .setTypeRegistry(lastCompiler.getTypeRegistry())
+        .setLineLengthThreshold(lineThreshold).setLineBreak(lineBreak)
         .setTagAsStrict(tagAsStrict)
         .build();
   }
 
 
   String printNode(Node n) {
-    CompilerOptions options = new CompilerOptions();
-    options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
-    return new CodePrinter.Builder(n).setCompilerOptions(options).build();
+    return new CodePrinter.Builder(n).setLineLengthThreshold(
+        CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD).build();
   }
 
   void assertPrintNode(String expectedJs, Node ast) {
@@ -199,6 +151,21 @@
     assertPrint("var a,b,c; a *= (b -= c);",
         "var a,b,c;a*=b-=c");
 
+    // Break scripts
+    assertPrint("'<script>'", "\"<script>\"");
+    assertPrint("'</script>'", "\"<\\/script>\"");
+    assertPrint("\"</script> </SCRIPT>\"", "\"<\\/script> <\\/SCRIPT>\"");
+
+    assertPrint("'-->'", "\"--\\>\"");
+    assertPrint("']]>'", "\"]]\\>\"");
+    assertPrint("' --></script>'", "\" --\\><\\/script>\"");
+
+    assertPrint("/--> <\\/script>/g", "/--\\> <\\/script>/g");
+
+    // Break HTML start comments. Certain versions of Webkit
+    // begin an HTML comment when they see this.
+    assertPrint("'<!-- I am a string -->'", "\"<\\!-- I am a string --\\>\"");
+
     // Precedence
     assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");
     assertPrint("(delete a[0])/10", "delete a[0]/10");
@@ -270,7 +237,7 @@
     // Function declaration.
     assertPrint("function f(){}", "function f(){}");
 
-    // Make sure we don't treat non-Latin character escapes as raw strings.
+    // Make sure we don't treat non-latin character escapes as raw strings.
     assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");
     assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");
 
@@ -359,49 +326,6 @@
     assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");
   }
 
-  public void testBreakTrustedStrings() {
-    // Break scripts
-    assertPrint("'<script>'", "\"<script>\"");
-    assertPrint("'</script>'", "\"\\x3c/script>\"");
-    assertPrint("\"</script> </SCRIPT>\"", "\"\\x3c/script> \\x3c/SCRIPT>\"");
-
-    assertPrint("'-->'", "\"--\\x3e\"");
-    assertPrint("']]>'", "\"]]\\x3e\"");
-    assertPrint("' --></script>'", "\" --\\x3e\\x3c/script>\"");
-
-    assertPrint("/--> <\\/script>/g", "/--\\x3e <\\/script>/g");
-
-    // Break HTML start comments. Certain versions of WebKit
-    // begin an HTML comment when they see this.
-    assertPrint("'<!-- I am a string -->'",
-        "\"\\x3c!-- I am a string --\\x3e\"");
-
-    assertPrint("'<=&>'", "\"<=&>\"");
-  }
-
-  public void testBreakUntrustedStrings() {
-    trustedStrings = false;
-
-    // Break scripts
-    assertPrint("'<script>'", "\"\\x3cscript\\x3e\"");
-    assertPrint("'</script>'", "\"\\x3c/script\\x3e\"");
-    assertPrint("\"</script> </SCRIPT>\"", "\"\\x3c/script\\x3e \\x3c/SCRIPT\\x3e\"");
-
-    assertPrint("'-->'", "\"--\\x3e\"");
-    assertPrint("']]>'", "\"]]\\x3e\"");
-    assertPrint("' --></script>'", "\" --\\x3e\\x3c/script\\x3e\"");
-
-    assertPrint("/--> <\\/script>/g", "/--\\x3e <\\/script>/g");
-
-    // Break HTML start comments. Certain versions of WebKit
-    // begin an HTML comment when they see this.
-    assertPrint("'<!-- I am a string -->'",
-        "\"\\x3c!-- I am a string --\\x3e\"");
-
-    assertPrint("'<=&>'", "\"\\x3c\\x3d\\x26\\x3e\"");
-    assertPrint("/(?=x)/", "/(?=x)/");
-  }
-
   public void testPrintArray() {
     assertPrint("[void 0, void 0]", "[void 0,void 0]");
     assertPrint("[undefined, undefined]", "[undefined,undefined]");
@@ -461,15 +385,11 @@
   }
 
   private void assertPrint(String js, String expected) {
-    parse(expected); // validate the expected string is valid JS
+    parse(expected); // validate the expected string is valid js
     assertEquals(expected,
         parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
   }
 
-  private void assertPrintSame(String js) {
-    assertPrint(js, js);
-  }
-
   // Make sure that the code generator doesn't associate an
   // else clause with the wrong if clause.
   public void testAmbiguousElseClauses() {
@@ -543,44 +463,6 @@
             CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
   }
 
-  public void testPreferLineBreakAtEndOfFile() {
-    // short final line, no previous break, do nothing
-    assertLineBreakAtEndOfFile(
-        "\"1234567890\";",
-        "\"1234567890\"",
-        "\"1234567890\"");
-
-    // short final line, shift previous break to end
-    assertLineBreakAtEndOfFile(
-        "\"123456789012345678901234567890\";\"1234567890\"",
-        "\"123456789012345678901234567890\";\n\"1234567890\"",
-        "\"123456789012345678901234567890\"; \"1234567890\";\n");
-    assertLineBreakAtEndOfFile(
-        "var12345678901234567890123456 instanceof Object;",
-        "var12345678901234567890123456 instanceof\nObject",
-        "var12345678901234567890123456 instanceof Object;\n");
-
-    // long final line, no previous break, add a break at end
-    assertLineBreakAtEndOfFile(
-        "\"1234567890\";\"12345678901234567890\";",
-        "\"1234567890\";\"12345678901234567890\"",
-        "\"1234567890\";\"12345678901234567890\";\n");
-
-    // long final line, previous break, add a break at end
-    assertLineBreakAtEndOfFile(
-        "\"123456789012345678901234567890\";\"12345678901234567890\";",
-        "\"123456789012345678901234567890\";\n\"12345678901234567890\"",
-        "\"123456789012345678901234567890\";\n\"12345678901234567890\";\n");
-  }
-
-  private void assertLineBreakAtEndOfFile(String js,
-      String expectedWithoutBreakAtEnd, String expectedWithBreakAtEnd) {
-    assertEquals(expectedWithoutBreakAtEnd,
-        parsePrint(js, false, false, false, 30));
-    assertEquals(expectedWithBreakAtEnd,
-        parsePrint(js, false, false, true, 30));
-  }
-
   public void testPrettyPrinter() {
     // Ensure that the pretty printer inserts line breaks at appropriate
     // places.
@@ -786,7 +668,7 @@
         + "function f(a){};\n",
         "goog.java.Long;\n"
         + "/**\n"
-        + " * @param {(Array.<number>|null)} a\n"
+        + " * @param {(Array|null)} a\n"
         + " * @return {undefined}\n"
         + " */\n"
         + "function f(a) {\n}\n");
@@ -933,27 +815,17 @@
         "};\n");
   }
 
-  public void testU2UFunctionTypeAnnotation1() {
+  public void testU2UFunctionTypeAnnotation() {
     assertTypeAnnotations(
         "/** @type {!Function} */ var x = function() {}",
-        "/** @type {!Function} */\n" +
-        "var x = function() {\n};\n");
-  }
-
-  public void testU2UFunctionTypeAnnotation2() {
-    // TODO(johnlenz): we currently report the type of the RHS which is not
-    // correct, we should export the type of the LHS.
-    assertTypeAnnotations(
-        "/** @type {Function} */ var x = function() {}",
-        "/** @type {!Function} */\n" +
-        "var x = function() {\n};\n");
+        "/**\n * @constructor\n */\nvar x = function() {\n};\n");
   }
 
   public void testEmitUnknownParamTypesAsAllType() {
     assertTypeAnnotations(
         "var a = function(x) {}",
         "/**\n" +
-        " * @param {?} x\n" +
+        " * @param {*} x\n" +
         " * @return {undefined}\n" +
         " */\n" +
         "var a = function(x) {\n};\n");
@@ -999,22 +871,6 @@
     );
   }
 
-  public void testEnumAnnotation1() {
-    assertTypeAnnotations(
-        "/** @enum {string} */ var Enum = {FOO: 'x', BAR: 'y'};",
-        "/** @enum {string} */\nvar Enum = {FOO:\"x\", BAR:\"y\"};\n");
-  }
-
-  public void testEnumAnnotation2() {
-    assertTypeAnnotations(
-        "var goog = goog || {};" +
-        "/** @enum {string} */ goog.Enum = {FOO: 'x', BAR: 'y'};" +
-        "/** @const */ goog.Enum2 = goog.x ? {} : goog.Enum;",
-        "var goog = goog || {};\n" +
-        "/** @enum {string} */\ngoog.Enum = {FOO:\"x\", BAR:\"y\"};\n" +
-        "/** @type {(Object|{})} */\ngoog.Enum2 = goog.x ? {} : goog.Enum;\n");
-  }
-
   private void assertPrettyPrint(String js, String expected) {
     assertEquals(expected,
         parsePrint(js, true, false,
@@ -1034,7 +890,8 @@
 
     assertEquals(
         "x- -4",
-        printNode(n));
+        new CodePrinter.Builder(n).setLineLengthThreshold(
+            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD).build());
   }
 
   public void testFunctionWithCall() {
@@ -1218,9 +1075,7 @@
     assertPrintNumber("1E5", 100000.0);
     assertPrintNumber("100000.1", 100000.1);
 
-    assertPrintNumber("1E-6", 0.000001);
-    assertPrintNumber("-0x38d7ea4c68001", -0x38d7ea4c68001L);
-    assertPrintNumber("0x38d7ea4c68001", 0x38d7ea4c68001L);
+    assertPrintNumber("1.0E-6", 0.000001);
   }
 
   // Make sure to test as both a String and a Node, because
@@ -1256,7 +1111,7 @@
     Node n = parse("foo(a);");
     assertPrintNode("foo(a)", n);
     Node call =  n.getFirstChild().getFirstChild();
-    assertTrue(call.isCall());
+    assertTrue(call.getType() == Token.CALL);
     call.putBooleanProp(Node.FREE_CALL, true);
     assertPrintNode("foo(a)", n);
   }
@@ -1265,7 +1120,7 @@
     Node n = parse("x.foo(a);");
     assertPrintNode("x.foo(a)", n);
     Node call =  n.getFirstChild().getFirstChild();
-    assertTrue(call.isCall());
+    assertTrue(call.getType() == Token.CALL);
     call.putBooleanProp(Node.FREE_CALL, true);
     assertPrintNode("(0,x.foo)(a)", n);
   }
@@ -1285,7 +1140,6 @@
     assertPrint("var x=({x:1})", "var x={x:1}");
     assertPrint("var x={'x':1}", "var x={\"x\":1}");
     assertPrint("var x={1:1}", "var x={1:1}");
-    assertPrint("({},42)+0", "({},42)+0");
   }
 
   public void testObjectLit2() {
@@ -1414,102 +1268,4 @@
     assertPrint("var x = {0.2: 1};", "var x={\"0.2\":1}");
     assertPrint("var x = {'0.2': 1};", "var x={\"0.2\":1}");
   }
-
-  public void testIssue582() {
-    assertPrint("var x = -0.0;", "var x=-0");
-  }
-
-  public void testIssue601() {
-    assertPrint("'\\v' == 'v'", "\"\\v\"==\"v\"");
-    assertPrint("'\\u000B' == '\\v'", "\"\\x0B\"==\"\\v\"");
-    assertPrint("'\\x0B' == '\\v'", "\"\\x0B\"==\"\\v\"");
-  }
-
-  public void testIssue620() {
-    assertPrint("alert(/ / / / /);", "alert(/ // / /)");
-    assertPrint("alert(/ // / /);", "alert(/ // / /)");
-  }
-
-  public void testIssue5746867() {
-    assertPrint("var a = { '$\\\\' : 5 };", "var a={\"$\\\\\":5}");
-  }
-
-  public void testCommaSpacing() {
-    assertPrint("var a = (b = 5, c = 5);",
-        "var a=(b=5,c=5)");
-    assertPrettyPrint("var a = (b = 5, c = 5);",
-        "var a = (b = 5, c = 5);\n");
-  }
-
-  public void testManyCommas() {
-    int numCommas = 10000;
-    List<String> numbers = Lists.newArrayList("0", "1");
-    Node current = new Node(Token.COMMA, Node.newNumber(0), Node.newNumber(1));
-    for (int i = 2; i < numCommas; i++) {
-      current = new Node(Token.COMMA, current);
-
-      // 1000 is printed as 1E3, and screws up our test.
-      int num = i % 1000;
-      numbers.add(String.valueOf(num));
-      current.addChildToBack(Node.newNumber(num));
-    }
-
-    String expected = Joiner.on(",").join(numbers);
-    String actual = printNode(current).replace("\n", "");
-    assertEquals(expected, actual);
-  }
-
-  public void testManyAdds() {
-    int numAdds = 10000;
-    List<String> numbers = Lists.newArrayList("0", "1");
-    Node current = new Node(Token.ADD, Node.newNumber(0), Node.newNumber(1));
-    for (int i = 2; i < numAdds; i++) {
-      current = new Node(Token.ADD, current);
-
-      // 1000 is printed as 1E3, and screws up our test.
-      int num = i % 1000;
-      numbers.add(String.valueOf(num));
-      current.addChildToBack(Node.newNumber(num));
-    }
-
-    String expected = Joiner.on("+").join(numbers);
-    String actual = printNode(current).replace("\n", "");
-    assertEquals(expected, actual);
-  }
-
-  public void testMinusNegativeZero() {
-    // Negative zero is weird, because we have to be able to distinguish
-    // it from positive zero (there are some subtle differences in behavior).
-    assertPrint("x- -0", "x- -0");
-  }
-
-  public void testStringEscapeSequences() {
-    // From the SingleEscapeCharacter grammar production.
-    assertPrintSame("var x=\"\\b\"");
-    assertPrintSame("var x=\"\\f\"");
-    assertPrintSame("var x=\"\\n\"");
-    assertPrintSame("var x=\"\\r\"");
-    assertPrintSame("var x=\"\\t\"");
-    assertPrintSame("var x=\"\\v\"");
-    assertPrint("var x=\"\\\"\"", "var x='\"'");
-    assertPrint("var x=\"\\\'\"", "var x=\"'\"");
-
-    // From the LineTerminator grammar
-    assertPrint("var x=\"\\u000A\"", "var x=\"\\n\"");
-    assertPrint("var x=\"\\u000D\"", "var x=\"\\r\"");
-    assertPrintSame("var x=\"\\u2028\"");
-    assertPrintSame("var x=\"\\u2029\"");
-
-    // Now with regular expressions.
-    assertPrintSame("var x=/\\b/");
-    assertPrintSame("var x=/\\f/");
-    assertPrintSame("var x=/\\n/");
-    assertPrintSame("var x=/\\r/");
-    assertPrintSame("var x=/\\t/");
-    assertPrintSame("var x=/\\v/");
-    assertPrintSame("var x=/\\u000A/");
-    assertPrintSame("var x=/\\u000D/");
-    assertPrintSame("var x=/\\u2028/");
-    assertPrintSame("var x=/\\u2029/");
-  }
 }
