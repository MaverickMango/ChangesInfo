diff -r -u inducing/src/com/google/javascript/jscomp/DisambiguateProperties.java buggy/src/com/google/javascript/jscomp/DisambiguateProperties.java
--- inducing/src/com/google/javascript/jscomp/DisambiguateProperties.java	2023-06-12 11:40:30.954509073 +0800
+++ buggy/src/com/google/javascript/jscomp/DisambiguateProperties.java	2023-06-12 11:40:30.690521129 +0800
@@ -16,12 +16,17 @@
 package com.google.javascript.jscomp;
 
 import static com.google.common.base.Preconditions.checkState;
+
+import com.google.common.base.Joiner;
+import com.google.common.base.Preconditions;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Sets;
+import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;
 import com.google.javascript.jscomp.ConcreteType.ConcreteFunctionType;
 import com.google.javascript.jscomp.ConcreteType.ConcreteInstanceType;
 import com.google.javascript.jscomp.ConcreteType.ConcreteUnionType;
@@ -31,15 +36,12 @@
 import com.google.javascript.jscomp.graph.StandardUnionFind;
 import com.google.javascript.jscomp.graph.UnionFind;
 import com.google.javascript.rhino.Node;
-import com.google.javascript.rhino.Token;
-import com.google.javascript.rhino.jstype.FunctionPrototypeType;
 import com.google.javascript.rhino.jstype.FunctionType;
 import com.google.javascript.rhino.jstype.JSType;
 import com.google.javascript.rhino.jstype.JSTypeNative;
 import com.google.javascript.rhino.jstype.JSTypeRegistry;
 import com.google.javascript.rhino.jstype.ObjectType;
 import com.google.javascript.rhino.jstype.StaticScope;
-import com.google.javascript.rhino.jstype.UnionType;
 
 import java.util.Collection;
 import java.util.List;
@@ -74,21 +76,46 @@
  *
  */
 class DisambiguateProperties<T> implements CompilerPass {
+  // To prevent the logs from filling up, we cap the number of warnings
+  // that we tell the user to fix per-property.
+  private static final int MAX_INVALDIATION_WARNINGS_PER_PROPERTY = 10;
+
   private static final Logger logger = Logger.getLogger(
       DisambiguateProperties.class.getName());
 
   static class Warnings {
+    // TODO(user): {1} and {2} are not exactly useful for most people.
     static final DiagnosticType INVALIDATION = DiagnosticType.disabled(
         "JSC_INVALIDATION",
         "Property disambiguator skipping all instances of property {0} "
-        + "because of type {1} node {2}");
-  }
+        + "because of type {1} node {2}. {3}");
 
-  private final boolean showInvalidationWarnings;
+    static final DiagnosticType INVALIDATION_ON_TYPE = DiagnosticType.disabled(
+        "JSC_INVALIDATION_TYPE",
+        "Property disambiguator skipping instances of property {0} "
+        + "on type {1}. {2}");
+  }
 
   private final AbstractCompiler compiler;
   private final TypeSystem<T> typeSystem;
 
+  /**
+   * Map of a type to all the related errors that invalidated the type
+   * for disambiguation. It has be Object because of the generic nature of
+   * this pass.
+   */
+  private Multimap<Object, JSError> invalidationMap;
+
+  /**
+   * In practice any large code base will have thousands and thousands of
+   * type invalidations, which makes reporting all of the errors useless.
+   * However, certain properties are worth specifically guarding because of the
+   * large amount of code that can be removed as dead code. This list contains
+   * the properties (eg: "toString") that we care about; if any of these
+   * properties is invalidated it causes an error.
+   */
+  private final Map<String, CheckLevel> propertiesToErrorFor;
+
   private class Property {
     /** The name of the property. */
     final String name;
@@ -254,15 +281,18 @@
   private Map<String, Property> properties = Maps.newHashMap();
 
   static DisambiguateProperties<JSType> forJSTypeSystem(
-      AbstractCompiler compiler) {
+      AbstractCompiler compiler,
+      Map<String, CheckLevel> propertiesToErrorFor) {
     return new DisambiguateProperties<JSType>(
-        compiler, new JSTypeSystem(compiler));
+        compiler, new JSTypeSystem(compiler), propertiesToErrorFor);
   }
 
   static DisambiguateProperties<ConcreteType> forConcreteTypeSystem(
-      AbstractCompiler compiler, TightenTypes tt) {
+      AbstractCompiler compiler, TightenTypes tt,
+      Map<String, CheckLevel> propertiesToErrorFor) {
     return new DisambiguateProperties<ConcreteType>(
-        compiler, new ConcreteTypeSystem(tt, compiler.getCodingConvention()));
+        compiler, new ConcreteTypeSystem(tt, compiler.getCodingConvention()),
+            propertiesToErrorFor);
   }
 
   /**
@@ -270,41 +300,60 @@
    * above for either the JSType system, or the concrete type system.
    */
   private DisambiguateProperties(AbstractCompiler compiler,
-                                 TypeSystem<T> typeSystem) {
+      TypeSystem<T> typeSystem, Map<String, CheckLevel> propertiesToErrorFor) {
     this.compiler = compiler;
     this.typeSystem = typeSystem;
-    this.showInvalidationWarnings = compiler.getErrorLevel(
-        JSError.make("", 0, 0, Warnings.INVALIDATION)) != CheckLevel.OFF;
+    this.propertiesToErrorFor = propertiesToErrorFor;
+    if (!this.propertiesToErrorFor.isEmpty()) {
+      this.invalidationMap = LinkedHashMultimap.create();
+    } else {
+      this.invalidationMap = null;
+    }
   }
 
+  @Override
   public void process(Node externs, Node root) {
+    Preconditions.checkState(
+        compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);
     for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) {
-      addInvalidatingType(mis.typeA);
-      addInvalidatingType(mis.typeB);
+      addInvalidatingType(mis.typeA, mis.src);
+      addInvalidatingType(mis.typeB, mis.src);
     }
 
-    StaticScope<T> scope = typeSystem.getRootScope();
     NodeTraversal.traverse(compiler, externs, new FindExternProperties());
     NodeTraversal.traverse(compiler, root, new FindRenameableProperties());
     renameProperties();
   }
 
+  private void recordInvalidationError(JSType t, JSError error) {
+    if (!t.isObject()) {
+      return;
+    }
+    if (invalidationMap != null) {
+      invalidationMap.put(t, error);
+    }
+  }
+
   /**
    * Invalidates the given type, so that no properties on it will be renamed.
    */
-  private void addInvalidatingType(JSType type) {
+  private void addInvalidatingType(JSType type, JSError error) {
     type = type.restrictByNotNullOrUndefined();
-    if (type instanceof UnionType) {
-      for (JSType alt : ((UnionType) type).getAlternates()) {
-        addInvalidatingType(alt);
+    if (type.isUnionType()) {
+      for (JSType alt : type.toMaybeUnionType().getAlternates()) {
+        addInvalidatingType(alt, error);
+      }
+    } else if (type.isEnumElementType()) {
+      addInvalidatingType(
+          type.toMaybeEnumElementType().getPrimitiveType(), error);
+    } else {
+      typeSystem.addInvalidatingType(type);
+      recordInvalidationError(type, error);
+      ObjectType objType = ObjectType.cast(type);
+      if (objType != null && objType.getImplicitPrototype() != null) {
+        typeSystem.addInvalidatingType(objType.getImplicitPrototype());
+        recordInvalidationError(objType.getImplicitPrototype(), error);
       }
-      return;
-    }
-
-    typeSystem.addInvalidatingType(type);
-    ObjectType objType = ObjectType.cast(type);
-    if (objType != null && objType.getImplicitPrototype() != null) {
-      typeSystem.addInvalidatingType(objType.getImplicitPrototype());
     }
   }
 
@@ -327,10 +376,12 @@
     protected final Stack<StaticScope<T>> scopes =
         new Stack<StaticScope<T>>();
 
+    @Override
     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       return true;
     }
 
+    @Override
     public void enterScope(NodeTraversal t) {
       if (t.inGlobalScope()) {
         scopes.push(typeSystem.getRootScope());
@@ -339,6 +390,7 @@
       }
     }
 
+    @Override
     public void exitScope(NodeTraversal t) {
       scopes.pop();
     }
@@ -356,7 +408,7 @@
   private class FindExternProperties extends AbstractScopingCallback {
     @Override public void visit(NodeTraversal t, Node n, Node parent) {
       // TODO(johnlenz): Support object-literal property definitions.
-      if (n.getType() == Token.GETPROP) {
+      if (n.isGetProp()) {
         String field = n.getLastChild().getString();
         T type = typeSystem.getType(getScope(), n.getFirstChild(), field);
         Property prop = getProperty(field);
@@ -384,9 +436,9 @@
   private class FindRenameableProperties extends AbstractScopingCallback {
     @Override
     public void visit(NodeTraversal t, Node n, Node parent) {
-      if (n.getType() == Token.GETPROP) {
+      if (n.isGetProp()) {
         handleGetProp(t, n);
-      } else if (n.getType() == Token.OBJECTLIT) {
+      } else if (n.isObjectLit()) {
         handleObjectLit(t, n);
       }
     }
@@ -401,10 +453,33 @@
       Property prop = getProperty(name);
       if (!prop.scheduleRenaming(n.getLastChild(),
                                  processProperty(t, prop, type, null))) {
-        if (showInvalidationWarnings) {
+        if (propertiesToErrorFor.containsKey(name)) {
+          String suggestion = "";
+          if (type instanceof JSType) {
+            JSType jsType = (JSType) type;
+            if (jsType.isAllType() || jsType.isUnknownType()) {
+              if (n.getFirstChild().isThis()) {
+                suggestion = "The \"this\" object is unknown in the function," +
+                    "consider using @this";
+              } else {
+                String qName = n.getFirstChild().getQualifiedName();
+                suggestion = "Consider casting " + qName +
+                    " if you know it's type.";
+              }
+            } else {
+              List<String> errors = Lists.newArrayList();
+              printErrorLocations(errors, jsType);
+              if (!errors.isEmpty()) {
+                suggestion = "Consider fixing errors for the following types:\n";
+                suggestion += Joiner.on("\n").join(errors);
+              }
+            }
+          }
           compiler.report(JSError.make(
-              t.getSourceName(), n, Warnings.INVALIDATION, name,
-              (type == null ? "null" : type.toString()), n.toString()));
+              t.getSourceName(), n, propertiesToErrorFor.get(name),
+              Warnings.INVALIDATION, name,
+              (type == null ? "null" : type.toString()),
+              n.toString(), suggestion));
         }
       }
     }
@@ -424,17 +499,41 @@
         Property prop = getProperty(name);
         if (!prop.scheduleRenaming(child,
                                    processProperty(t, prop, type, null))) {
-          if (showInvalidationWarnings) {
+          // TODO(user): It doesn't look like the user can do much in this
+          // case right now.
+          if (propertiesToErrorFor.containsKey(name)) {
             compiler.report(JSError.make(
-                t.getSourceName(), child, Warnings.INVALIDATION, name,
-                (type == null ? "null" : type.toString()), n.toString()));
+                t.getSourceName(), child, propertiesToErrorFor.get(name),
+                Warnings.INVALIDATION, name,
+                (type == null ? "null" : type.toString()), n.toString(), ""));
           }
         }
-
         child = child.getNext();
       }
     }
 
+    private void printErrorLocations(List<String> errors, JSType t) {
+      if (!t.isObject() || t.isAllType()) {
+        return;
+      }
+
+      if (t.isUnionType()) {
+        for (JSType alt : t.toMaybeUnionType().getAlternates()) {
+          printErrorLocations(errors, alt);
+        }
+        return;
+      }
+
+      for (JSError error : invalidationMap.get(t)) {
+        if (errors.size() > MAX_INVALDIATION_WARNINGS_PER_PROPERTY) {
+          return;
+        }
+
+        errors.add(
+            t.toString() + " at " + error.sourceName + ":" + error.lineNumber);
+      }
+    }
+
     /**
      * Processes a property, adding it to the list of properties to rename.
      * @return a representative type for the property reference, which will be
@@ -475,13 +574,13 @@
     int propsRenamed = 0, propsSkipped = 0, instancesRenamed = 0,
         instancesSkipped = 0, singleTypeProps = 0;
 
+    Set<String> reported = Sets.newHashSet();
     for (Property prop : properties.values()) {
       if (prop.shouldRename()) {
         Map<T, String> propNames = buildPropNames(prop.getTypes(), prop.name);
 
         ++propsRenamed;
         prop.expandTypesToSkip();
-        UnionFind<T> types = prop.getTypes();
         for (Node node : prop.renameNodes) {
           T rootType = prop.rootTypes.get(node);
           if (prop.shouldRename(rootType)) {
@@ -491,6 +590,18 @@
             ++instancesRenamed;
           } else {
             ++instancesSkipped;
+
+            CheckLevel checkLevelForProp = propertiesToErrorFor.get(prop.name);
+            if (checkLevelForProp != null &&
+                checkLevelForProp != CheckLevel.OFF &&
+                !reported.contains(prop.name)) {
+              reported.add(prop.name);
+              compiler.report(JSError.make(
+                  NodeUtil.getSourceName(node), node,
+                  checkLevelForProp,
+                  Warnings.INVALIDATION_ON_TYPE, prop.name,
+                  rootType.toString(), ""));
+            }
           }
         }
       } else {
@@ -501,9 +612,9 @@
         }
       }
     }
-    logger.info("Renamed " + instancesRenamed + " instances of "
+    logger.fine("Renamed " + instancesRenamed + " instances of "
                 + propsRenamed + " properties.");
-    logger.info("Skipped renaming " + instancesSkipped + " invalidated "
+    logger.fine("Skipped renaming " + instancesSkipped + " invalidated "
                 + "properties, " + propsSkipped + " instances of properties "
                 + "that were skipped for specific types and " + singleTypeProps
                 + " properties that were referenced from only one type.");
@@ -542,7 +653,7 @@
   /** Returns a map from field name to types for which it will be renamed. */
   Multimap<String, Collection<T>> getRenamedTypesForTesting() {
     Multimap<String, Collection<T>> ret = HashMultimap.create();
-    for (Map.Entry<String, Property> entry: properties.entrySet()) {
+    for (Map.Entry<String, Property> entry : properties.entrySet()) {
       Property prop = entry.getValue();
       if (!prop.skipRenaming) {
         for (Collection<T> c : prop.getTypes().allEquivalenceClasses()) {
@@ -577,7 +688,7 @@
     T getType(StaticScope<T> scope, Node node, String prop);
 
     /**
-     * Returns true if a field reference on this type will invalidiate all
+     * Returns true if a field reference on this type will invalidate all
      * references to that field as candidates for renaming. This is true if the
      * type is unknown or all-inclusive, as variables with such a type could be
      * references to any object.
@@ -683,12 +794,15 @@
 
     @Override public ImmutableSet<JSType> getTypesToSkipForType(JSType type) {
       type = type.restrictByNotNullOrUndefined();
-      if (type instanceof UnionType) {
+      if (type.isUnionType()) {
         Set<JSType> types = Sets.newHashSet(type);
-        for (JSType alt : ((UnionType) type).getAlternates()) {
-          types.addAll(getTypesToSkipForTypeNonUnion(type));
+        for (JSType alt : type.toMaybeUnionType().getAlternates()) {
+          types.addAll(getTypesToSkipForTypeNonUnion(alt));
         }
         return ImmutableSet.copyOf(types);
+      } else if (type.isEnumElementType()) {
+        return getTypesToSkipForType(
+            type.toMaybeEnumElementType().getPrimitiveType());
       }
       return ImmutableSet.copyOf(getTypesToSkipForTypeNonUnion(type));
     }
@@ -719,7 +833,7 @@
 
     @Override public Iterable<JSType> getTypeAlternatives(JSType type) {
       if (type.isUnionType()) {
-        return ((UnionType) type).getAlternates();
+        return type.toMaybeUnionType().getAlternates();
       } else {
         ObjectType objType = type.toObjectType();
         if (objType != null &&
@@ -738,6 +852,15 @@
     }
 
     @Override public ObjectType getTypeWithProperty(String field, JSType type) {
+      if (type == null) {
+        return null;
+      }
+
+      if (type.isEnumElementType()) {
+        return getTypeWithProperty(
+            field, type.toMaybeEnumElementType().getPrimitiveType());
+      }
+
       if (!(type instanceof ObjectType)) {
         if (type.autoboxesTo() != null) {
           type = type.autoboxesTo();
@@ -752,16 +875,26 @@
       }
 
       // We look up the prototype chain to find the highest place (if any) that
-      // this appears.  This will make references to overriden properties look
+      // this appears.  This will make references to overridden properties look
       // like references to the initial property, so they are renamed alike.
       ObjectType foundType = null;
       ObjectType objType = ObjectType.cast(type);
-      while (objType != null && objType.getImplicitPrototype() != objType) {
-        if (objType.hasOwnProperty(field)) {
-          foundType = objType;
+      if (objType != null && objType.getConstructor() != null
+          && objType.getConstructor().isInterface()) {
+        ObjectType topInterface = FunctionType.getTopDefiningInterface(
+            objType, field);
+        if (topInterface != null && topInterface.getConstructor() != null) {
+          foundType = topInterface.getConstructor().getPrototype();
+        }
+      } else {
+        while (objType != null && objType.getImplicitPrototype() != objType) {
+          if (objType.hasOwnProperty(field)) {
+            foundType = objType;
+          }
+          objType = objType.getImplicitPrototype();
         }
-        objType = objType.getImplicitPrototype();
       }
+
       // If the property does not exist on the referenced type but the original
       // type is an object type, see if any subtype has the property.
       if (foundType == null) {
@@ -779,11 +912,10 @@
 
     @Override public JSType getInstanceFromPrototype(JSType type) {
       if (type.isFunctionPrototypeType()) {
-        FunctionPrototypeType prototype = (FunctionPrototypeType) type;
+        ObjectType prototype = (ObjectType) type;
         FunctionType owner = prototype.getOwnerFunction();
         if (owner.isConstructor() || owner.isInterface()) {
-          return ((FunctionPrototypeType) type).getOwnerFunction()
-              .getInstanceType();
+          return prototype.getOwnerFunction().getInstanceType();
         }
       }
       return null;
@@ -795,10 +927,10 @@
       ObjectType objType = ObjectType.cast(type);
       if (objType != null) {
         FunctionType constructor;
-        if (objType instanceof FunctionType) {
-          constructor = (FunctionType) objType;
-        } else if (objType instanceof FunctionPrototypeType) {
-          constructor = ((FunctionPrototypeType) objType).getOwnerFunction();
+        if (objType.isFunctionType()) {
+          constructor = objType.toMaybeFunctionType();
+        } else if (objType.isFunctionPrototypeType()) {
+          constructor = objType.getOwnerFunction();
         } else {
           constructor = objType.getConstructor();
         }
@@ -812,7 +944,9 @@
             }
 
             // If this interface invalidated this property, return now.
-            if (p.skipRenaming) return;
+            if (p.skipRenaming) {
+              return;
+            }
           }
           if (constructor.isInterface() || constructor.isConstructor()) {
             constructor = constructor.getSuperClassConstructor();
@@ -898,10 +1032,14 @@
     private ConcreteType maybeAddAutoboxes(
         ConcreteType cType, JSType jsType, String prop) {
       jsType = jsType.restrictByNotNullOrUndefined();
-      if (jsType instanceof UnionType) {
-        for (JSType alt : ((UnionType) jsType).getAlternates()) {
-          return maybeAddAutoboxes(cType, alt, prop);
+      if (jsType.isUnionType()) {
+        for (JSType alt : jsType.toMaybeUnionType().getAlternates()) {
+          cType = maybeAddAutoboxes(cType, alt, prop);
         }
+        return cType;
+      } else if (jsType.isEnumElementType()) {
+        return maybeAddAutoboxes(
+            cType, jsType.toMaybeEnumElementType().getPrimitiveType(), prop);
       }
 
       if (jsType.autoboxesTo() != null) {
diff -r -u inducing/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java buggy/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java
--- inducing/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java	2023-06-12 11:40:30.958508890 +0800
+++ buggy/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java	2023-06-12 11:40:30.698520764 +0800
@@ -15,7 +15,6 @@
  */
 package com.google.javascript.jscomp;
 
-import com.google.common.base.Joiner;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Sets;
@@ -26,12 +25,13 @@
 import com.google.javascript.rhino.testing.TestErrorReporter;
 
 import java.util.Collection;
+import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
 import java.util.TreeSet;
 
 /**
- * Unit test for the Compiler DisambiguateProprties pass.
+ * Unit test for the Compiler DisambiguateProperties pass.
  *
  */
 public class DisambiguatePropertiesTest extends CompilerTestCase {
@@ -43,25 +43,32 @@
   }
 
   @Override
+  protected void setUp() throws Exception {
+    super.setUp();
+    super.enableNormalize(true);
+    super.enableTypeCheck(CheckLevel.WARNING);
+  }
+
+  @Override
   public CompilerPass getProcessor(final Compiler compiler) {
-    final TypeCheck checker = new TypeCheck(compiler,
-        new SemanticReverseAbstractInterpreter(
-            compiler.getCodingConvention(), compiler.getTypeRegistry()),
-        compiler.getTypeRegistry());
 
     return new CompilerPass() {
+      @Override
       public void process(Node externs, Node root) {
-        checker.processForTesting(externs, root);
+        Map<String, CheckLevel> propertiesToErrorFor =
+            Maps.<String, CheckLevel>newHashMap();
+        propertiesToErrorFor.put("foobar", CheckLevel.ERROR);
 
         if (runTightenTypes) {
           TightenTypes tightener = new TightenTypes(compiler);
           tightener.process(externs, root);
           lastPass = DisambiguateProperties.forConcreteTypeSystem(compiler,
-                                                                  tightener);
+              tightener, propertiesToErrorFor);
         } else {
           // This must be created after type checking is run as it depends on
           // any mismatches found during checking.
-          lastPass = DisambiguateProperties.forJSTypeSystem(compiler);
+          lastPass = DisambiguateProperties.forJSTypeSystem(
+              compiler, propertiesToErrorFor);
         }
 
         lastPass.process(externs, root);
@@ -92,14 +99,9 @@
         + "/** @type Foo */\n"
         + "var F = new Foo;\n"
         + "F.a = 0;";
-    // TODO(johnlenz): fix this. Doing nothing is safe, but
-    // handling this would be better.
-    String desired = "{a=[[Foo.prototype]]}";
-    String expected = "{}";
+    String expected = "{a=[[Foo.prototype]]}";
     testSets(false, js, js, expected);
-
-    // Tighten types fails here.
-    // testSets(true, js, js, expected);
+    testSets(true, js, js, expected);
   }
 
   public void testOneType3() {
@@ -110,14 +112,9 @@
         + "/** @type Foo */\n"
         + "var F = new Foo;\n"
         + "F.a = 0;";
-    // TODO(johnlenz): fix this. Doing nothing is safe, but
-    // handling this would be better.
-    String desired = "{a=[[Foo.prototype]]}";
-    String expected = "{}";
+    String expected = "{a=[[Foo.prototype]]}";
     testSets(false, js, js, expected);
-
-    // Tighten types fails here.
-    // testSets(true, js, js, expected);
+    testSets(true, js, js, expected);
   }
 
   public void testPrototypeAndInstance() {
@@ -131,6 +128,15 @@
     testSets(true, js, js, "{a=[[Foo.prototype]]}");
   }
 
+  public void testPrototypeAndInstance2() {
+    String js = ""
+        + "/** @constructor */ function Foo() {}\n"
+        + "Foo.prototype.a = 0;\n"
+        + "new Foo().a = 0;";
+    testSets(false, js, js, "{a=[[Foo.prototype]]}");
+    testSets(true, js, js, "{a=[[Foo.prototype]]}");
+  }
+
   public void testTwoTypes1() {
     String js = ""
         + "/** @constructor */ function Foo() {}\n"
@@ -179,11 +185,8 @@
         + "var B=new Bar;"
         + "B.Bar_prototype$a=0";
 
-    // Would like it to be (but doing nothing is safe):
-    // testSets(false, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}");
-    testSets(false, js, js, "{}");
-    // TODO(johnlenz): If tighten types is completed, this needs to be fixed.
-    // testSets(true, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}");
+    testSets(false, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}");
+    testSets(true, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}");
   }
 
   public void testTwoTypes3() {
@@ -213,11 +216,8 @@
         + "var B=new Bar;"
         + "B.Bar_prototype$a=0";
 
-    // Would like it to be (but doing nothing is safe):
-    // testSets(false, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}");
-    testSets(false, js, js, "{}");
-    // TODO(johnlenz): If tighten types is completed, this needs to be fixed.
-    // testSets(true, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}");
+    testSets(false, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}");
+    testSets(true, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}");
   }
 
   public void testTwoFields() {
@@ -306,6 +306,48 @@
         js, expected, "{}");
   }
 
+  public void testIgnoreUnknownType1() {
+    String js = ""
+        + "/** @constructor */\n"
+        + "function Foo() {}\n"
+        + "Foo.prototype.blah = 3;\n"
+        + "/** @type {Foo} */\n"
+        + "var F = new Foo;\n"
+        + "F.blah = 0;\n"
+        + "/** @return {Object} */\n"
+        + "var U = function() { return {} };\n"
+        + "U().blah();";
+    String expected = ""
+        + "function Foo(){}Foo.prototype.blah=3;var F = new Foo;F.blah=0;"
+        + "var U=function(){return{}};U().blah()";
+    testSets(false, js, expected, "{blah=[[Foo.prototype]]}");
+    testSets(true, BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES,
+        js, expected, "{}");
+  }
+
+  public void testIgnoreUnknownType2() {
+    String js = ""
+        + "/** @constructor */\n"
+        + "function Foo() {}\n"
+        + "Foo.prototype.blah = 3;\n"
+        + "/** @type {Foo} */\n"
+        + "var F = new Foo;\n"
+        + "F.blah = 0;\n"
+        + "/** @constructor */\n"
+        + "function Bar() {}\n"
+        + "Bar.prototype.blah = 3;\n"
+        + "/** @return {Object} */\n"
+        + "var U = function() { return {} };\n"
+        + "U().blah();";
+    String expected = ""
+        + "function Foo(){}Foo.prototype.blah=3;var F = new Foo;F.blah=0;"
+        + "function Bar(){}Bar.prototype.blah=3;"
+        + "var U=function(){return{}};U().blah()";
+    testSets(false, js, expected, "{}");
+    testSets(true, BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES,
+        js, expected, "{}");
+  }
+
   public void testUnionTypeTwoFields() {
     String js = ""
         + "/** @constructor */ function Foo() {}\n"
@@ -322,19 +364,6 @@
         + "/** @constructor */ function Baz() {}\n"
         + "Baz.prototype.a = 0;\n"
         + "Baz.prototype.b = 0;\n";
-    String output = ""
-        + "function Foo(){}"
-        + "Foo.prototype.Bar_prototype$a=0;"
-        + "Foo.prototype.Bar_prototype$b=0;"
-        + "function Bar(){}"
-        + "Bar.prototype.Bar_prototype$a=0;"
-        + "Bar.prototype.Bar_prototype$b=0;"
-        + "var B=new Bar;"
-        + "B.Bar_prototype$a=0;"
-        + "B.Bar_prototype$b=0;"
-        + "function Baz(){}"
-        + "Baz.prototype.a$Baz_prototype=0;"
-        + "Baz.prototype.b$Baz_prototype=0;";
     testSets(false, js, "{a=[[Bar.prototype, Foo.prototype], [Baz.prototype]],"
                  + " b=[[Bar.prototype, Foo.prototype], [Baz.prototype]]}");
     testSets(true, js, "{a=[[Bar.prototype, Foo.prototype], [Baz.prototype]],"
@@ -460,6 +489,8 @@
         + "Foo.prototype.Foo_prototype$a=0;"
         + "var Bar=function(){};"
         + "Bar.prototype.Bar_prototype$a=0;";
+
+    setExpectParseWarningsThisTest();
     testSets(false, BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES,
         js, output, "{a=[[Bar.prototype], [Foo.prototype]]}");
     testSets(true, BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES,
@@ -507,15 +538,15 @@
 
   public void testEnum() {
     String js = ""
-      + "/** @enum {string} */ var En = {\n"
-      + "  A: 'first',\n"
-      + "  B: 'second'\n"
-      + "};\n"
-      + "var EA = En.A;\n"
-      + "var EB = En.B;\n"
-      + "/** @constructor */ function Foo(){};\n"
-      + "Foo.prototype.A = 0;\n"
-      + "Foo.prototype.B = 0;\n";
+        + "/** @enum {string} */ var En = {\n"
+        + "  A: 'first',\n"
+        + "  B: 'second'\n"
+        + "};\n"
+        + "var EA = En.A;\n"
+        + "var EB = En.B;\n"
+        + "/** @constructor */ function Foo(){};\n"
+        + "Foo.prototype.A = 0;\n"
+        + "Foo.prototype.B = 0;\n";
     String output = ""
         + "var En={A:'first',B:'second'};"
         + "var EA=En.A;"
@@ -534,6 +565,99 @@
     testSets(true, js, ttOutput, "{A=[[Foo.prototype]], B=[[Foo.prototype]]}");
   }
 
+  public void testEnumOfObjects() {
+    String js = ""
+        + "/** @constructor */ function Formatter() {}"
+        + "Formatter.prototype.format = function() {};"
+        + "/** @constructor */ function Unrelated() {}"
+        + "Unrelated.prototype.format = function() {};"
+        + "/** @enum {!Formatter} */ var Enum = {\n"
+        + "  A: new Formatter()\n"
+        + "};\n"
+        + "Enum.A.format();\n";
+    String output = ""
+        + "/** @constructor */ function Formatter() {}"
+        + "Formatter.prototype.Formatter_prototype$format = function() {};"
+        + "/** @constructor */ function Unrelated() {}"
+        + "Unrelated.prototype.Unrelated_prototype$format = function() {};"
+        + "/** @enum {!Formatter} */ var Enum = {\n"
+        + "  A: new Formatter()\n"
+        + "};\n"
+        + "Enum.A.Formatter_prototype$format();\n";
+    testSets(false, js, output,
+        "{format=[[Formatter.prototype], [Unrelated.prototype]]}");
+
+    // TODO(nicksantos): Fix the type tightener to handle this case.
+    // It currently doesn't work, because getSubTypes is broken for enums.
+  }
+
+  public void testEnumOfObjects2() {
+    String js = ""
+        + "/** @constructor */ function Formatter() {}"
+        + "Formatter.prototype.format = function() {};"
+        + "/** @constructor */ function Unrelated() {}"
+        + "Unrelated.prototype.format = function() {};"
+        + "/** @enum {?Formatter} */ var Enum = {\n"
+        + "  A: new Formatter(),\n"
+        + "  B: new Formatter()\n"
+        + "};\n"
+        + "function f() {\n"
+        + "  var formatter = window.toString() ? Enum.A : Enum.B;\n"
+        + "  formatter.format();\n"
+        + "}";
+    String output = ""
+        + "/** @constructor */ function Formatter() {}"
+        + "Formatter.prototype.format = function() {};"
+        + "/** @constructor */ function Unrelated() {}"
+        + "Unrelated.prototype.format = function() {};"
+        + "/** @enum {?Formatter} */ var Enum = {\n"
+        + "  A: new Formatter(),\n"
+        + "  B: new Formatter()\n"
+        + "};\n"
+        + "function f() {\n"
+        + "  var formatter = window.toString() ? Enum.A : Enum.B;\n"
+        + "  formatter.format();\n"
+        + "}";
+    testSets(false, js, output, "{}");
+  }
+
+  public void testEnumOfObjects3() {
+    String js = ""
+        + "/** @constructor */ function Formatter() {}"
+        + "Formatter.prototype.format = function() {};"
+        + "/** @constructor */ function Unrelated() {}"
+        + "Unrelated.prototype.format = function() {};"
+        + "/** @enum {!Formatter} */ var Enum = {\n"
+        + "  A: new Formatter(),\n"
+        + "  B: new Formatter()\n"
+        + "};\n"
+        + "/** @enum {!Enum} */ var SubEnum = {\n"
+        + "  C: Enum.A\n"
+        + "};\n"
+        + "function f() {\n"
+        + "  var formatter = SubEnum.C\n"
+        + "  formatter.format();\n"
+        + "}";
+    String output = ""
+        + "/** @constructor */ function Formatter() {}"
+        + "Formatter.prototype.Formatter_prototype$format = function() {};"
+        + "/** @constructor */ function Unrelated() {}"
+        + "Unrelated.prototype.Unrelated_prototype$format = function() {};"
+        + "/** @enum {!Formatter} */ var Enum = {\n"
+        + "  A: new Formatter(),\n"
+        + "  B: new Formatter()\n"
+        + "};\n"
+        + "/** @enum {!Enum} */ var SubEnum = {\n"
+        + "  C: Enum.A\n"
+        + "};\n"
+        + "function f() {\n"
+        + "  var formatter = SubEnum.C\n"
+        + "  formatter.Formatter_prototype$format();\n"
+        + "}";
+    testSets(false, js, output,
+        "{format=[[Formatter.prototype], [Unrelated.prototype]]}");
+  }
+
   public void testUntypedExterns() {
     String externs =
         BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES
@@ -646,7 +770,7 @@
       + "/** @type {Buz|Foo} */ var d;\n"
       + "b.a = 5; c.a = 6; d.a = 7;";
 
-    // We are testing the skipping of multiple types caused by unioning with
+    // We are testing the skipping of multiple types caused by unionizing with
     // extern types.
     testSets(false, externs, js, output, "{a=[[T1], [T2]]}");
   }
@@ -702,8 +826,8 @@
         + "function Foo() {}\n"
         + "function Bar() {}\n"
         + "Bar.prototype.Bar_prototype$a;\n"
-        + "function foo(foo) {\n"
-        + "  var x = foo.Bar_prototype$a;\n"
+        + "function foo(foo$$1) {\n"
+        + "  var x = foo$$1.Bar_prototype$a;\n"
         + "}\n";
     testSets(false, externs, js, result, "{a=[[Bar.prototype]]}");
   }
@@ -761,7 +885,7 @@
   public void testClosureInherits() {
     String js = ""
         + "var goog = {};"
-        + "/* @param {Function} childCtor Child class.\n"
+        + "/** @param {Function} childCtor Child class.\n"
         + " * @param {Function} parentCtor Parent class. */\n"
         + "goog.inherits = function(childCtor, parentCtor) {\n"
         + "  /** @constructor */\n"
@@ -775,11 +899,13 @@
         + "Top.prototype.f = function() {};"
         + "/** @constructor \n@extends Top*/ function Foo() {}\n"
         + "goog.inherits(Foo, Top);\n"
+        + "/** @override */\n"
         + "Foo.prototype.f = function() {"
         + "  Foo.superClass_.f();"
         + "};\n"
         + "/** @constructor \n* @extends Foo */ function Bar() {}\n"
         + "goog.inherits(Bar, Foo);\n"
+        + "/** @override */\n"
         + "Bar.prototype.f = function() {"
         + "  Bar.superClass_.f();"
         + "};\n"
@@ -925,12 +1051,13 @@
         + "var i = new Bar;\n" // Make I invalidating
         + "/** @constructor \n @implements I \n @implements I2 */"
         + "function Foo() {};\n"
+        + "/** @override */\n"
         + "Foo.prototype.a = 0;\n"
         + "(new Foo).a = 0;"
         + "/** @interface */ function I() {};\n"
         + "I.prototype.a;\n";
-    testSets(false, js, "{}");
-    testSets(true, js, "{}");
+    testSets(false, js, "{}", TypeValidator.TYPE_MISMATCH_WARNING);
+    testSets(true, js, "{}", TypeValidator.TYPE_MISMATCH_WARNING);
   }
 
   public void testMultipleInterfaces() {
@@ -940,6 +1067,7 @@
         + "I2.prototype.a;\n"
         + "/** @constructor \n @implements I \n @implements I2 */"
         + "function Foo() {};\n"
+        + "/** @override */"
         + "Foo.prototype.a = 0;\n"
         + "(new Foo).a = 0";
     testSets(false, js, "{a=[[Foo.prototype, I2.prototype]]}");
@@ -964,9 +1092,10 @@
     String js = ""
         + "/** @interface */ function I() {};\n"
         + "I.prototype.a;\n"
-        + "/** @interface \n @implements I */ function I2() {};\n"
+        + "/** @interface \n @extends I */ function I2() {};\n"
         + "/** @constructor \n @implements I2 */"
         + "function Foo() {};\n"
+        + "/** @override */\n"
         + "Foo.prototype.a = 0;\n"
         + "(new Foo).a = 0";
     testSets(false, js, "{a=[[Foo.prototype, I.prototype]]}");
@@ -1146,9 +1275,51 @@
     testSets(false, js, output, "{}");
   }
 
+  public void testErrorOnProtectedProperty() {
+    test("function addSingletonGetter(foo) { foo.foobar = 'a'; };", null,
+         DisambiguateProperties.Warnings.INVALIDATION);
+    assertTrue(getLastCompiler().getErrors()[0].toString().contains("foobar"));
+  }
+
+  public void testMismatchForbiddenInvalidation() {
+    test("/** @constructor */ function F() {}" +
+         "/** @type {number} */ F.prototype.foobar = 3;" +
+         "/** @return {number} */ function g() { return new F(); }",
+         null,
+         DisambiguateProperties.Warnings.INVALIDATION);
+    assertTrue(getLastCompiler().getErrors()[0].toString()
+        .contains("Consider fixing errors"));
+  }
+
+  public void testUnionTypeInvalidationError() {
+    String externs = ""
+        + "/** @constructor */ function Baz() {}"
+        + "Baz.prototype.foobar";
+    String js = ""
+        + "/** @constructor */ function Ind() {this.foobar=0}\n"
+        + "/** @constructor */ function Foo() {}\n"
+        + "Foo.prototype.foobar = 0;\n"
+        + "/** @constructor */ function Bar() {}\n"
+        + "Bar.prototype.foobar = 0;\n"
+        + "/** @type {Foo|Bar} */\n"
+        + "var F = new Foo;\n"
+        + "F.foobar = 1\n;"
+        + "F = new Bar;\n"
+        + "/** @type {Baz} */\n"
+        + "var Z = new Baz;\n"
+        + "Z.foobar = 1\n;";
+
+    test(
+        externs, js, "",
+        DisambiguateProperties.Warnings.INVALIDATION_ON_TYPE, null);
+    assertTrue(getLastCompiler().getErrors()[0].toString()
+        .contains("foobar"));
+   }
+
   public void runFindHighestTypeInChain() {
     // Check that this doesn't go into an infinite loop.
-    DisambiguateProperties.forJSTypeSystem(new Compiler())
+    DisambiguateProperties.forJSTypeSystem(new Compiler(),
+        Maps.<String, CheckLevel>newHashMap())
         .getTypeWithProperty("no",
             new JSTypeRegistry(new TestErrorReporter(null, null))
             .getNativeType(JSTypeNative.OBJECT_PROTOTYPE));
@@ -1186,27 +1357,27 @@
    * <p>The format for the set of types for fields is:
    * {field=[[Type1, Type2]]}
    */
-  @SuppressWarnings("unchecked")
   private void testSets(boolean runTightenTypes, String js, String fieldTypes) {
     this.runTightenTypes = runTightenTypes;
-    Compiler compiler = new Compiler();
-    CompilerOptions options = new CompilerOptions();
-    compiler.init(new JSSourceFile[]{JSSourceFile.fromCode("externs", "")},
-                  new JSSourceFile[]{
-                      JSSourceFile.fromCode("testcode", js)}, options);
-
-    Node root = compiler.parseInputs();
-    assertTrue("Unexpected parse error(s): " +
-        Joiner.on("\n").join(compiler.getErrors()), root != null);
-
-    Node externsRoot = root.getFirstChild();
-    Node mainRoot = externsRoot.getNext();
-    getProcessor(compiler).process(externsRoot, mainRoot);
+    test(js, null, null, null);
+    assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));
+  }
 
+  /**
+   * Compiles the code and checks that the set of types for each field matches
+   * the expected value.
+   *
+   * <p>The format for the set of types for fields is:
+   * {field=[[Type1, Type2]]}
+   */
+  private void testSets(boolean runTightenTypes, String js, String fieldTypes,
+      DiagnosticType warning) {
+    this.runTightenTypes = runTightenTypes;
+    test(js, null, null, warning);
     assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));
   }
 
-  /** Sorts the map and converts to a string for comparision purposes. */
+  /** Sorts the map and converts to a string for comparison purposes. */
   private <T> String mapToString(Multimap<String, Collection<T>> map) {
     TreeMap<String, String> retMap = Maps.newTreeMap();
     for (String key : map.keySet()) {
