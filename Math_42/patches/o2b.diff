diff -r -u original/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java
--- original/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java	2023-06-13 15:31:53.595151326 +0800
+++ buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java	2023-06-12 11:40:44.749889395 +0800
@@ -27,17 +27,17 @@
 import java.util.List;
 import java.util.Set;
 
+import org.apache.commons.math.linear.Array2DRowRealMatrix;
 import org.apache.commons.math.linear.MatrixUtils;
 import org.apache.commons.math.linear.RealMatrix;
-import org.apache.commons.math.linear.Array2DRowRealMatrix;
 import org.apache.commons.math.linear.RealVector;
 import org.apache.commons.math.optimization.GoalType;
 import org.apache.commons.math.optimization.RealPointValuePair;
-import org.apache.commons.math.util.MathUtils;
+import org.apache.commons.math.util.Precision;
 
 /**
  * A tableau for use in the Simplex method.
- * 
+ *
  * <p>
  * Example:
  * <pre>
@@ -57,11 +57,17 @@
  * a1: Artificial variable</br>
  * RHS: Right hand side</br>
  * </p>
- * @version $Revision$ $Date$
+ * @version $Id$
  * @since 2.0
  */
 class SimplexTableau implements Serializable {
 
+    /** Column label for negative vars. */
+    private static final String NEGATIVE_VAR_COLUMN_LABEL = "x-";
+
+    /** Default amount of error to accept in floating point comparisons (as ulps). */
+    private static final int DEFAULT_ULPS = 10;
+
     /** Serializable version identifier. */
     private static final long serialVersionUID = -1369660067587938365L;
 
@@ -69,26 +75,32 @@
     private final LinearObjectiveFunction f;
 
     /** Linear constraints. */
-    private final Collection<LinearConstraint> constraints;
+    private final List<LinearConstraint> constraints;
 
     /** Whether to restrict the variables to non-negative values. */
     private final boolean restrictToNonNegative;
 
+    /** The variables each column represents */
+    private final List<String> columnLabels = new ArrayList<String>();
+
     /** Simple tableau. */
-    protected transient RealMatrix tableau;
+    private transient RealMatrix tableau;
 
     /** Number of decision variables. */
-    protected final int numDecisionVariables;
+    private final int numDecisionVariables;
 
     /** Number of slack variables. */
-    protected final int numSlackVariables;
+    private final int numSlackVariables;
 
     /** Number of artificial variables. */
-    protected int numArtificialVariables;
+    private int numArtificialVariables;
+
+    /** Amount of error to accept when checking for optimality. */
+    private final double epsilon;
+
+    /** Amount of error to accept in floating point comparisons. */
+    private final int maxUlps;
 
-    /** Amount of error to accept in floating point comparisons. */ 
-    protected final double epsilon;
-    
     /**
      * Build a tableau for a linear problem.
      * @param f linear objective function
@@ -96,23 +108,66 @@
      * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}
      * or {@link GoalType#MINIMIZE}
      * @param restrictToNonNegative whether to restrict the variables to non-negative values
-     * @param epsilon amount of error to accept in floating point comparisons
+     * @param epsilon amount of error to accept when checking for optimality
      */
     SimplexTableau(final LinearObjectiveFunction f,
                    final Collection<LinearConstraint> constraints,
                    final GoalType goalType, final boolean restrictToNonNegative,
                    final double epsilon) {
+        this(f, constraints, goalType, restrictToNonNegative, epsilon, DEFAULT_ULPS);
+    }
+
+    /**
+     * Build a tableau for a linear problem.
+     * @param f linear objective function
+     * @param constraints linear constraints
+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}
+     * or {@link GoalType#MINIMIZE}
+     * @param restrictToNonNegative whether to restrict the variables to non-negative values
+     * @param epsilon amount of error to accept when checking for optimality
+     * @param maxUlps amount of error to accept in floating point comparisons
+     */
+    SimplexTableau(final LinearObjectiveFunction f,
+                   final Collection<LinearConstraint> constraints,
+                   final GoalType goalType, final boolean restrictToNonNegative,
+                   final double epsilon,
+                   final int maxUlps) {
         this.f                      = f;
-        this.constraints            = constraints;
+        this.constraints            = normalizeConstraints(constraints);
         this.restrictToNonNegative  = restrictToNonNegative;
         this.epsilon                = epsilon;
-        this.numDecisionVariables   = getNumVariables() + (restrictToNonNegative ? 0 : 1);
+        this.maxUlps                = maxUlps;
+        this.numDecisionVariables   = f.getCoefficients().getDimension() +
+                                      (restrictToNonNegative ? 0 : 1);
         this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +
                                       getConstraintTypeCounts(Relationship.GEQ);
         this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +
                                       getConstraintTypeCounts(Relationship.GEQ);
-        this.tableau = new Array2DRowRealMatrix(createTableau(goalType == GoalType.MAXIMIZE));
-        initialize();
+        this.tableau = createTableau(goalType == GoalType.MAXIMIZE);
+        initializeColumnLabels();
+    }
+
+    /**
+     * Initialize the labels for the columns.
+     */
+    protected void initializeColumnLabels() {
+      if (getNumObjectiveFunctions() == 2) {
+        columnLabels.add("W");
+      }
+      columnLabels.add("Z");
+      for (int i = 0; i < getOriginalNumDecisionVariables(); i++) {
+        columnLabels.add("x" + i);
+      }
+      if (!restrictToNonNegative) {
+        columnLabels.add(NEGATIVE_VAR_COLUMN_LABEL);
+      }
+      for (int i = 0; i < getNumSlackVariables(); i++) {
+        columnLabels.add("s" + i);
+      }
+      for (int i = 0; i < getNumArtificialVariables(); i++) {
+        columnLabels.add("a" + i);
+      }
+      columnLabels.add("RHS");
     }
 
     /**
@@ -120,83 +175,77 @@
      * @param maximize if true, goal is to maximize the objective function
      * @return created tableau
      */
-    protected double[][] createTableau(final boolean maximize) {
+    protected RealMatrix createTableau(final boolean maximize) {
 
         // create a matrix of the correct size
-        List<LinearConstraint> constraints = getNormalizedConstraints();
         int width = numDecisionVariables + numSlackVariables +
         numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS
         int height = constraints.size() + getNumObjectiveFunctions();
-        double[][] matrix = new double[height][width];
+        Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);
 
         // initialize the objective function rows
         if (getNumObjectiveFunctions() == 2) {
-            matrix[0][0] = -1;
+            matrix.setEntry(0, 0, -1);
         }
         int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;
-        matrix[zIndex][zIndex] = maximize ? 1 : -1;
+        matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);
         RealVector objectiveCoefficients =
             maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
-            copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());
-            matrix[zIndex][width - 1] =
-                maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();
-
-                if (!restrictToNonNegative) {
-                    matrix[zIndex][getSlackVariableOffset() - 1] =
-                        getInvertedCoeffiecientSum(objectiveCoefficients);
-                }
-
-                // initialize the constraint rows
-                int slackVar = 0;
-                int artificialVar = 0;
-                for (int i = 0; i < constraints.size(); i++) {
-                    LinearConstraint constraint = constraints.get(i);
-                    int row = getNumObjectiveFunctions() + i;
-
-                    // decision variable coefficients
-                    copyArray(constraint.getCoefficients().getData(), matrix[row], 1);
-
-                    // x-
-                    if (!restrictToNonNegative) {
-                        matrix[row][getSlackVariableOffset() - 1] =
-                            getInvertedCoeffiecientSum(constraint.getCoefficients());
-                    }
-
-                    // RHS
-                    matrix[row][width - 1] = constraint.getValue();
-
-                    // slack variables
-                    if (constraint.getRelationship() == Relationship.LEQ) {
-                        matrix[row][getSlackVariableOffset() + slackVar++] = 1;  // slack
-                    } else if (constraint.getRelationship() == Relationship.GEQ) {
-                        matrix[row][getSlackVariableOffset() + slackVar++] = -1; // excess
-                    }
-
-                    // artificial variables
-                    if ((constraint.getRelationship() == Relationship.EQ) ||
-                        (constraint.getRelationship() == Relationship.GEQ)) {
-                        matrix[0][getArtificialVariableOffset() + artificialVar] = 1; 
-                        matrix[row][getArtificialVariableOffset() + artificialVar++] = 1; 
-                    }
-                }
+        copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);
+        matrix.setEntry(zIndex, width - 1,
+            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());
+
+        if (!restrictToNonNegative) {
+            matrix.setEntry(zIndex, getSlackVariableOffset() - 1,
+                getInvertedCoefficientSum(objectiveCoefficients));
+        }
+
+        // initialize the constraint rows
+        int slackVar = 0;
+        int artificialVar = 0;
+        for (int i = 0; i < constraints.size(); i++) {
+            LinearConstraint constraint = constraints.get(i);
+            int row = getNumObjectiveFunctions() + i;
+
+            // decision variable coefficients
+            copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]);
+
+            // x-
+            if (!restrictToNonNegative) {
+                matrix.setEntry(row, getSlackVariableOffset() - 1,
+                    getInvertedCoefficientSum(constraint.getCoefficients()));
+            }
 
-                return matrix;
-    }
+            // RHS
+            matrix.setEntry(row, width - 1, constraint.getValue());
 
-    /** Get the number of variables.
-     * @return number of variables
-     */
-    public int getNumVariables() {
-        return f.getCoefficients().getDimension();
+            // slack variables
+            if (constraint.getRelationship() == Relationship.LEQ) {
+                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  // slack
+            } else if (constraint.getRelationship() == Relationship.GEQ) {
+                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess
+            }
+
+            // artificial variables
+            if ((constraint.getRelationship() == Relationship.EQ) ||
+                    (constraint.getRelationship() == Relationship.GEQ)) {
+                matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);
+                matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);
+                matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));
+            }
+        }
+
+        return matrix;
     }
 
     /**
      * Get new versions of the constraints which have positive right hand sides.
+     * @param originalConstraints original (not normalized) constraints
      * @return new versions of the constraints
      */
-    public List<LinearConstraint> getNormalizedConstraints() {
+    public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints) {
         List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();
-        for (LinearConstraint constraint : constraints) {
+        for (LinearConstraint constraint : originalConstraints) {
             normalized.add(normalize(constraint));
         }
         return normalized;
@@ -213,7 +262,7 @@
                                         constraint.getRelationship().oppositeRelationship(),
                                         -1 * constraint.getValue());
         }
-        return new LinearConstraint(constraint.getCoefficients(), 
+        return new LinearConstraint(constraint.getCoefficients(),
                                     constraint.getRelationship(), constraint.getValue());
     }
 
@@ -241,24 +290,13 @@
     }
 
     /**
-     * Puts the tableau in proper form by zeroing out the artificial variables
-     * in the objective function via elementary row operations.
-     */
-    private void initialize() {
-        for (int artificialVar = 0; artificialVar < numArtificialVariables; artificialVar++) {
-            int row = getBasicRow(getArtificialVariableOffset() + artificialVar);
-            subtractRow(0, row, 1.0);
-        }
-    }
-
-    /**
      * Get the -1 times the sum of all coefficients in the given array.
      * @param coefficients coefficients to sum
      * @return the -1 times the sum of all coefficients in the given array.
      */
-    protected static double getInvertedCoeffiecientSum(final RealVector coefficients) {
+    protected static double getInvertedCoefficientSum(final RealVector coefficients) {
         double sum = 0;
-        for (double coefficient : coefficients.getData()) {
+        for (double coefficient : coefficients.toArray()) {
             sum -= coefficient;
         }
         return sum;
@@ -269,12 +307,13 @@
      * @param col index of the column to check
      * @return the row that the variable is basic in.  null if the column is not basic
      */
-    private Integer getBasicRow(final int col) {
+    protected Integer getBasicRow(final int col) {
         Integer row = null;
-        for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
-            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
+        for (int i = 0; i < getHeight(); i++) {
+            final double entry = getEntry(i, col);
+            if (Precision.equals(entry, 1d, maxUlps) && (row == null)) {
                 row = i;
-            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
+            } else if (!Precision.equals(entry, 0d, maxUlps)) {
                 return null;
             }
         }
@@ -282,61 +321,104 @@
     }
 
     /**
-     * Removes the phase 1 objective function and artificial variables from this tableau.
+     * Removes the phase 1 objective function, positive cost non-artificial variables,
+     * and the non-basic artificial variables from this tableau.
      */
-    protected void discardArtificialVariables() {
-        if (numArtificialVariables == 0) {
+    protected void dropPhase1Objective() {
+        if (getNumObjectiveFunctions() == 1) {
             return;
         }
-        int width = getWidth() - numArtificialVariables - 1;
-        int height = getHeight() - 1;
-        double[][] matrix = new double[height][width];
-        for (int i = 0; i < height; i++) {
-            for (int j = 0; j < width - 1; j++) {
-                matrix[i][j] = getEntry(i + 1, j + 1);
+
+        List<Integer> columnsToDrop = new ArrayList<Integer>();
+        columnsToDrop.add(0);
+
+        // positive cost non-artificial variables
+        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
+            final double entry = tableau.getEntry(0, i);
+            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
+                columnsToDrop.add(i);
+            }
+        }
+
+        // non-basic artificial variables
+        for (int i = 0; i < getNumArtificialVariables(); i++) {
+          int col = i + getArtificialVariableOffset();
+          if (getBasicRow(col) == null) {
+            columnsToDrop.add(col);
+          }
+        }
+
+        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
+        for (int i = 1; i < getHeight(); i++) {
+          int col = 0;
+          for (int j = 0; j < getWidth(); j++) {
+            if (!columnsToDrop.contains(j)) {
+              matrix[i - 1][col++] = tableau.getEntry(i, j);
             }
-            matrix[i][width - 1] = getEntry(i + 1, getRhsOffset());
+          }
         }
+
+        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
+          columnLabels.remove((int) columnsToDrop.get(i));
+        }
+
         this.tableau = new Array2DRowRealMatrix(matrix);
         this.numArtificialVariables = 0;
     }
 
-
     /**
      * @param src the source array
      * @param dest the destination array
-     * @param destPos the destination position
      */
-    private void copyArray(final double[] src, final double[] dest,
-                           final int destPos) {
-        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); 
+    private void copyArray(final double[] src, final double[] dest) {
+        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);
+    }
+
+    /**
+     * Returns whether the problem is at an optimal state.
+     * @return whether the model has been solved
+     */
+    boolean isOptimal() {
+        for (int i = getNumObjectiveFunctions(); i < getWidth() - 1; i++) {
+            final double entry = tableau.getEntry(0, i);
+            if (Precision.compareTo(entry, 0d, epsilon) < 0) {
+                return false;
+            }
+        }
+        return true;
     }
 
     /**
      * Get the current solution.
-     * 
+     *
      * @return current solution
      */
     protected RealPointValuePair getSolution() {
-        double[] coefficients = new double[getOriginalNumDecisionVariables()];
-        Integer basicRow =
-            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
-        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
-        Set<Integer> basicRows = new HashSet<Integer>();
-        for (int i = 0; i < coefficients.length; i++) {
-            basicRow = getBasicRow(getNumObjectiveFunctions() + i);
-            if (basicRows.contains(basicRow)) {
-                // if multiple variables can take a given value 
-                // then we choose the first and set the rest equal to 0
-                coefficients[i] = 0;
-            } else {
-                basicRows.add(basicRow);
-                coefficients[i] =
-                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
-                    (restrictToNonNegative ? 0 : mostNegative);
-            }
-        }
-        return new RealPointValuePair(coefficients, f.getValue(coefficients));
+      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
+      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;
+      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
+
+      Set<Integer> basicRows = new HashSet<Integer>();
+      double[] coefficients = new double[getOriginalNumDecisionVariables()];
+      for (int i = 0; i < coefficients.length; i++) {
+          int colIndex = columnLabels.indexOf("x" + i);
+          if (colIndex < 0) {
+            coefficients[i] = 0;
+            continue;
+          }
+          Integer basicRow = getBasicRow(colIndex);
+          if (basicRows.contains(basicRow)) {
+              // if multiple variables can take a given value
+              // then we choose the first and set the rest equal to 0
+              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
+          } else {
+              basicRows.add(basicRow);
+              coefficients[i] =
+                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
+                  (restrictToNonNegative ? 0 : mostNegative);
+          }
+      }
+      return new RealPointValuePair(coefficients, f.getValue(coefficients));
     }
 
     /**
@@ -366,10 +448,8 @@
      */
     protected void subtractRow(final int minuendRow, final int subtrahendRow,
                                final double multiple) {
-        for (int j = 0; j < getWidth(); j++) {
-            tableau.setEntry(minuendRow, j, tableau.getEntry(minuendRow, j) -
-                             multiple * tableau.getEntry(subtrahendRow, j));
-        }
+        tableau.setRowVector(minuendRow, tableau.getRowVector(minuendRow)
+            .subtract(tableau.getRowVector(subtrahendRow).mapMultiply(multiple)));
     }
 
     /**
@@ -451,7 +531,7 @@
      * @see #getNumDecisionVariables()
      */
     protected final int getOriginalNumDecisionVariables() {
-        return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;
+        return f.getCoefficients().getDimension();
     }
 
     /**
@@ -482,33 +562,25 @@
     @Override
     public boolean equals(Object other) {
 
-      if (this == other) { 
+      if (this == other) {
         return true;
       }
 
-      if (other == null) {
-        return false;
-      }
-
-      try {
-
+      if (other instanceof SimplexTableau) {
           SimplexTableau rhs = (SimplexTableau) other;
           return (restrictToNonNegative  == rhs.restrictToNonNegative) &&
                  (numDecisionVariables   == rhs.numDecisionVariables) &&
                  (numSlackVariables      == rhs.numSlackVariables) &&
                  (numArtificialVariables == rhs.numArtificialVariables) &&
                  (epsilon                == rhs.epsilon) &&
+                 (maxUlps                == rhs.maxUlps) &&
                  f.equals(rhs.f) &&
                  constraints.equals(rhs.constraints) &&
                  tableau.equals(rhs.tableau);
-
-      } catch (ClassCastException ex) {
-          // ignore exception
-          return false;
       }
-
+      return false;
     }
-    
+
     /** {@inheritDoc} */
     @Override
     public int hashCode() {
@@ -517,6 +589,7 @@
                numSlackVariables ^
                numArtificialVariables ^
                Double.valueOf(epsilon).hashCode() ^
+               maxUlps ^
                f.hashCode() ^
                constraints.hashCode() ^
                tableau.hashCode();
diff -r -u original/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java buggy/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java
--- original/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java	2023-06-13 15:31:53.595151326 +0800
+++ buggy/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java	2023-06-12 11:40:44.757889041 +0800
@@ -17,22 +17,92 @@
 
 package org.apache.commons.math.optimization.linear;
 
-import static org.junit.Assert.assertEquals;
+import org.junit.Assert;
 
 import java.util.ArrayList;
 import java.util.Collection;
 
-import org.apache.commons.math.linear.RealVector;
-import org.apache.commons.math.linear.ArrayRealVector;
 import org.apache.commons.math.optimization.GoalType;
-import org.apache.commons.math.optimization.OptimizationException;
 import org.apache.commons.math.optimization.RealPointValuePair;
+import org.apache.commons.math.util.Precision;
 import org.junit.Test;
 
 public class SimplexSolverTest {
 
     @Test
-    public void testMath272() throws OptimizationException {
+    public void testMath434NegativeVariable() {
+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {0.0, 0.0, 1.0}, 0.0d);
+        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
+        constraints.add(new LinearConstraint(new double[] {1, 1, 0}, Relationship.EQ, 5));
+        constraints.add(new LinearConstraint(new double[] {0, 0, 1}, Relationship.GEQ, -10));
+
+        double epsilon = 1e-6;
+        SimplexSolver solver = new SimplexSolver();
+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);
+
+        Assert.assertEquals(5.0, solution.getPoint()[0] + solution.getPoint()[1], epsilon);
+        Assert.assertEquals(-10.0, solution.getPoint()[2], epsilon);
+        Assert.assertEquals(-10.0, solution.getValue(), epsilon);
+
+    }
+
+    @Test(expected = NoFeasibleSolutionException.class)
+    public void testMath434UnfeasibleSolution() {
+        double epsilon = 1e-6;
+
+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0, 0.0}, 0.0);
+        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
+        constraints.add(new LinearConstraint(new double[] {epsilon/2, 0.5}, Relationship.EQ, 0));
+        constraints.add(new LinearConstraint(new double[] {1e-3, 0.1}, Relationship.EQ, 10));
+
+        SimplexSolver solver = new SimplexSolver();
+        // allowing only non-negative values, no feasible solution shall be found
+        solver.optimize(f, constraints, GoalType.MINIMIZE, true);
+    }
+
+    @Test
+    public void testMath434PivotRowSelection() {
+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0}, 0.0);
+
+        double epsilon = 1e-6;
+        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
+        constraints.add(new LinearConstraint(new double[] {200}, Relationship.GEQ, 1));
+        constraints.add(new LinearConstraint(new double[] {100}, Relationship.GEQ, 0.499900001));
+
+        SimplexSolver solver = new SimplexSolver();
+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);
+        
+        Assert.assertTrue(Precision.compareTo(solution.getPoint()[0] * 200.d, 1.d, epsilon) >= 0);
+        Assert.assertEquals(0.0050, solution.getValue(), epsilon);
+    }
+
+    @Test
+    public void testMath434PivotRowSelection2() {
+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {0.0d, 1.0d, 1.0d, 0.0d, 0.0d, 0.0d, 0.0d}, 0.0d);
+
+        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
+        constraints.add(new LinearConstraint(new double[] {1.0d, -0.1d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.EQ, -0.1d));
+        constraints.add(new LinearConstraint(new double[] {1.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, -1e-18d));
+        constraints.add(new LinearConstraint(new double[] {0.0d, 1.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));
+        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 0.0d, 1.0d, 0.0d, -0.0128588d, 1e-5d}, Relationship.EQ, 0.0d));
+        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 0.0d, 0.0d, 1.0d, 1e-5d, -0.0128586d}, Relationship.EQ, 1e-10d));
+        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, -1.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));
+        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 1.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));
+        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 0.0d, -1.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));
+        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 0.0d, 1.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));
+
+        double epsilon = 1e-7;
+        SimplexSolver simplex = new SimplexSolver();
+        RealPointValuePair solution = simplex.optimize(f, constraints, GoalType.MINIMIZE, false);
+        
+        Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], -1e-18d, epsilon) >= 0);
+        Assert.assertEquals(1.0d, solution.getPoint()[1], epsilon);        
+        Assert.assertEquals(0.0d, solution.getPoint()[2], epsilon);
+        Assert.assertEquals(1.0d, solution.getValue(), epsilon);
+    }
+    
+    @Test
+    public void testMath272() {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ,  1));
@@ -41,15 +111,122 @@
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);
-        
-        assertEquals(0.0, solution.getPoint()[0], .0000001);
-        assertEquals(1.0, solution.getPoint()[1], .0000001);
-        assertEquals(1.0, solution.getPoint()[2], .0000001);
-        assertEquals(3.0, solution.getValue(), .0000001);
-      }
+
+        Assert.assertEquals(0.0, solution.getPoint()[0], .0000001);
+        Assert.assertEquals(1.0, solution.getPoint()[1], .0000001);
+        Assert.assertEquals(1.0, solution.getPoint()[2], .0000001);
+        Assert.assertEquals(3.0, solution.getValue(), .0000001);
+    }
+
+    @Test
+    public void testMath286() {
+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.6, 0.4 }, 0 );
+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
+        constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 23.0));
+        constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 23.0));
+        constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0, 0, 0 }, Relationship.GEQ, 10.0));
+        constraints.add(new LinearConstraint(new double[] { 0, 0, 1, 0, 0, 0 }, Relationship.GEQ, 8.0));
+        constraints.add(new LinearConstraint(new double[] { 0, 0, 0, 0, 1, 0 }, Relationship.GEQ, 5.0));
+
+        SimplexSolver solver = new SimplexSolver();
+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);
+
+        Assert.assertEquals(25.8, solution.getValue(), .0000001);
+        Assert.assertEquals(23.0, solution.getPoint()[0] + solution.getPoint()[2] + solution.getPoint()[4], 0.0000001);
+        Assert.assertEquals(23.0, solution.getPoint()[1] + solution.getPoint()[3] + solution.getPoint()[5], 0.0000001);
+        Assert.assertTrue(solution.getPoint()[0] >= 10.0 - 0.0000001);
+        Assert.assertTrue(solution.getPoint()[2] >= 8.0 - 0.0000001);
+        Assert.assertTrue(solution.getPoint()[4] >= 5.0 - 0.0000001);
+    }
 
     @Test
-    public void testSimplexSolver() throws OptimizationException {
+    public void testDegeneracy() {
+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.7 }, 0 );
+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
+        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.LEQ, 18.0));
+        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.GEQ, 10.0));
+        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 8.0));
+
+        SimplexSolver solver = new SimplexSolver();
+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);
+        Assert.assertEquals(13.6, solution.getValue(), .0000001);
+    }
+
+    @Test
+    public void testMath288() {
+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 7, 3, 0, 0 }, 0 );
+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
+        constraints.add(new LinearConstraint(new double[] { 3, 0, -5, 0 }, Relationship.LEQ, 0.0));
+        constraints.add(new LinearConstraint(new double[] { 2, 0, 0, -5 }, Relationship.LEQ, 0.0));
+        constraints.add(new LinearConstraint(new double[] { 0, 3, 0, -5 }, Relationship.LEQ, 0.0));
+        constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0 }, Relationship.LEQ, 1.0));
+        constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0));
+
+        SimplexSolver solver = new SimplexSolver();
+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);
+        Assert.assertEquals(10.0, solution.getValue(), .0000001);
+    }
+
+    @Test
+    public void testMath290GEQ() {
+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 5 }, 0 );
+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
+        constraints.add(new LinearConstraint(new double[] { 2, 0 }, Relationship.GEQ, -1.0));
+        SimplexSolver solver = new SimplexSolver();
+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);
+        Assert.assertEquals(0, solution.getValue(), .0000001);
+        Assert.assertEquals(0, solution.getPoint()[0], .0000001);
+        Assert.assertEquals(0, solution.getPoint()[1], .0000001);
+    }
+
+    @Test(expected=NoFeasibleSolutionException.class)
+    public void testMath290LEQ() {
+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 5 }, 0 );
+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
+        constraints.add(new LinearConstraint(new double[] { 2, 0 }, Relationship.LEQ, -1.0));
+        SimplexSolver solver = new SimplexSolver();
+        solver.optimize(f, constraints, GoalType.MINIMIZE, true);
+    }
+
+    @Test
+    public void testMath293() {
+      LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.4, 0.6}, 0 );
+      Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
+      constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 30.0));
+      constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 30.0));
+      constraints.add(new LinearConstraint(new double[] { 0.8, 0.2, 0.0, 0.0, 0.0, 0.0 }, Relationship.GEQ, 10.0));
+      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, 10.0));
+      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, 10.0));
+
+      SimplexSolver solver = new SimplexSolver();
+      RealPointValuePair solution1 = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);
+
+      Assert.assertEquals(15.7143, solution1.getPoint()[0], .0001);
+      Assert.assertEquals(0.0, solution1.getPoint()[1], .0001);
+      Assert.assertEquals(14.2857, solution1.getPoint()[2], .0001);
+      Assert.assertEquals(0.0, solution1.getPoint()[3], .0001);
+      Assert.assertEquals(0.0, solution1.getPoint()[4], .0001);
+      Assert.assertEquals(30.0, solution1.getPoint()[5], .0001);
+      Assert.assertEquals(40.57143, solution1.getValue(), .0001);
+
+      double valA = 0.8 * solution1.getPoint()[0] + 0.2 * solution1.getPoint()[1];
+      double valB = 0.7 * solution1.getPoint()[2] + 0.3 * solution1.getPoint()[3];
+      double valC = 0.4 * solution1.getPoint()[4] + 0.6 * solution1.getPoint()[5];
+
+      f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.4, 0.6}, 0 );
+      constraints = new ArrayList<LinearConstraint>();
+      constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 30.0));
+      constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 30.0));
+      constraints.add(new LinearConstraint(new double[] { 0.8, 0.2, 0.0, 0.0, 0.0, 0.0 }, Relationship.GEQ, valA));
+      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, valB));
+      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, valC));
+
+      RealPointValuePair solution2 = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);
+      Assert.assertEquals(40.57143, solution2.getValue(), .0001);
+    }
+
+    @Test
+    public void testSimplexSolver() {
         LinearObjectiveFunction f =
             new LinearObjectiveFunction(new double[] { 15, 10 }, 7);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
@@ -59,29 +236,29 @@
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);
-        assertEquals(2.0, solution.getPoint()[0], 0.0);
-        assertEquals(2.0, solution.getPoint()[1], 0.0);
-        assertEquals(57.0, solution.getValue(), 0.0);
+        Assert.assertEquals(2.0, solution.getPoint()[0], 0.0);
+        Assert.assertEquals(2.0, solution.getPoint()[1], 0.0);
+        Assert.assertEquals(57.0, solution.getValue(), 0.0);
     }
 
     @Test
-    public void testSingleVariableAndConstraint() throws OptimizationException {
+    public void testSingleVariableAndConstraint() {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 3 }, 0);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 10));
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);
-        assertEquals(10.0, solution.getPoint()[0], 0.0);
-        assertEquals(30.0, solution.getValue(), 0.0);
+        Assert.assertEquals(10.0, solution.getPoint()[0], 0.0);
+        Assert.assertEquals(30.0, solution.getValue(), 0.0);
     }
-    
+
     /**
      * With no artificial variables needed (no equals and no greater than
      * constraints) we can go straight to Phase 2.
      */
     @Test
-    public void testModelWithNoArtificialVars() throws OptimizationException {
+    public void testModelWithNoArtificialVars() {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2));
@@ -90,13 +267,13 @@
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);
-        assertEquals(2.0, solution.getPoint()[0], 0.0);
-        assertEquals(2.0, solution.getPoint()[1], 0.0);
-        assertEquals(50.0, solution.getValue(), 0.0);
+        Assert.assertEquals(2.0, solution.getPoint()[0], 0.0);
+        Assert.assertEquals(2.0, solution.getPoint()[1], 0.0);
+        Assert.assertEquals(50.0, solution.getValue(), 0.0);
     }
 
     @Test
-    public void testMinimization() throws OptimizationException {
+    public void testMinimization() {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, -5);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 6));
@@ -105,13 +282,13 @@
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);
-        assertEquals(4.0, solution.getPoint()[0], 0.0);
-        assertEquals(0.0, solution.getPoint()[1], 0.0);
-        assertEquals(-13.0, solution.getValue(), 0.0);
+        Assert.assertEquals(4.0, solution.getPoint()[0], 0.0);
+        Assert.assertEquals(0.0, solution.getPoint()[1], 0.0);
+        Assert.assertEquals(-13.0, solution.getValue(), 0.0);
     }
 
     @Test
-    public void testSolutionWithNegativeDecisionVariable() throws OptimizationException {
+    public void testSolutionWithNegativeDecisionVariable() {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, 0);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.GEQ, 6));
@@ -119,13 +296,13 @@
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);
-        assertEquals(-2.0, solution.getPoint()[0], 0.0);
-        assertEquals(8.0, solution.getPoint()[1], 0.0);
-        assertEquals(12.0, solution.getValue(), 0.0);
+        Assert.assertEquals(-2.0, solution.getPoint()[0], 0.0);
+        Assert.assertEquals(8.0, solution.getPoint()[1], 0.0);
+        Assert.assertEquals(12.0, solution.getValue(), 0.0);
     }
 
     @Test(expected = NoFeasibleSolutionException.class)
-    public void testInfeasibleSolution() throws OptimizationException {
+    public void testInfeasibleSolution() {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15 }, 0);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 1));
@@ -136,7 +313,7 @@
     }
 
     @Test(expected = UnboundedSolutionException.class)
-    public void testUnboundedSolution() throws OptimizationException {
+    public void testUnboundedSolution() {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.EQ, 2));
@@ -146,7 +323,7 @@
     }
 
     @Test
-    public void testRestrictVariablesToNonNegative() throws OptimizationException {
+    public void testRestrictVariablesToNonNegative() {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 409, 523, 70, 204, 339 }, 0);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] {    43,   56, 345,  56,    5 }, Relationship.LEQ,  4567456));
@@ -157,16 +334,16 @@
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);
-        assertEquals(2902.92783505155, solution.getPoint()[0], .0000001);
-        assertEquals(480.419243986254, solution.getPoint()[1], .0000001);
-        assertEquals(0.0, solution.getPoint()[2], .0000001);
-        assertEquals(0.0, solution.getPoint()[3], .0000001);
-        assertEquals(0.0, solution.getPoint()[4], .0000001);
-        assertEquals(1438556.7491409, solution.getValue(), .0000001);
+        Assert.assertEquals(2902.92783505155, solution.getPoint()[0], .0000001);
+        Assert.assertEquals(480.419243986254, solution.getPoint()[1], .0000001);
+        Assert.assertEquals(0.0, solution.getPoint()[2], .0000001);
+        Assert.assertEquals(0.0, solution.getPoint()[3], .0000001);
+        Assert.assertEquals(0.0, solution.getPoint()[4], .0000001);
+        Assert.assertEquals(1438556.7491409, solution.getValue(), .0000001);
     }
 
     @Test
-    public void testEpsilon() throws OptimizationException {
+    public void testEpsilon() {
       LinearObjectiveFunction f =
           new LinearObjectiveFunction(new double[] { 10, 5, 1 }, 0);
       Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
@@ -176,25 +353,25 @@
 
       SimplexSolver solver = new SimplexSolver();
       RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);
-      assertEquals(1.0, solution.getPoint()[0], 0.0);
-      assertEquals(1.0, solution.getPoint()[1], 0.0);
-      assertEquals(0.0, solution.getPoint()[2], 0.0);
-      assertEquals(15.0, solution.getValue(), 0.0);
+      Assert.assertEquals(1.0, solution.getPoint()[0], 0.0);
+      Assert.assertEquals(1.0, solution.getPoint()[1], 0.0);
+      Assert.assertEquals(0.0, solution.getPoint()[2], 0.0);
+      Assert.assertEquals(15.0, solution.getValue(), 0.0);
   }
-    
+
     @Test
-    public void testTrivialModel() throws OptimizationException {
+    public void testTrivialModel() {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 1 }, 0);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ,  0));
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);
-        assertEquals(0, solution.getValue(), .0000001);
+        Assert.assertEquals(0, solution.getValue(), .0000001);
     }
 
     @Test
-    public void testLargeModel() throws OptimizationException {
+    public void testLargeModel() {
         double[] objective = new double[] {
                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                                            1, 1, 12, 1, 1, 1, 1, 1, 1, 1,
@@ -317,9 +494,9 @@
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);
-        assertEquals(7518.0, solution.getValue(), .0000001);
+        Assert.assertEquals(7518.0, solution.getValue(), .0000001);
     }
-    
+
     /**
      * Converts a test string to a {@link LinearConstraint}.
      * Ex: x0 + x1 + x2 + x3 - x12 = 0
@@ -339,13 +516,13 @@
         String[] equationParts = s.split("[>|<]?=");
         double rhs = Double.parseDouble(equationParts[1].trim());
 
-        RealVector lhs = new ArrayRealVector(numCoefficients);
+        double[] lhs = new double[numCoefficients];
         String left = equationParts[0].replaceAll(" ?x", "");
         String[] coefficients = left.split(" ");
         for (String coefficient : coefficients) {
             double value = coefficient.charAt(0) == '-' ? -1 : 1;
             int index = Integer.parseInt(coefficient.replaceFirst("[+|-]", "").trim());
-            lhs.setEntry(index, value);
+            lhs[index] = value;
         }
         return new LinearConstraint(lhs, relationship, rhs);
     }
