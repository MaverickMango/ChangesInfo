diff -r -u buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java inducing/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java
--- buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java	2023-06-12 11:34:47.186599211 +0800
+++ inducing/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java	2023-06-12 11:34:47.462604247 +0800
@@ -27,17 +27,17 @@
 import java.util.List;
 import java.util.Set;
 
-import org.apache.commons.math.linear.Array2DRowRealMatrix;
 import org.apache.commons.math.linear.MatrixUtils;
 import org.apache.commons.math.linear.RealMatrix;
+import org.apache.commons.math.linear.Array2DRowRealMatrix;
 import org.apache.commons.math.linear.RealVector;
 import org.apache.commons.math.optimization.GoalType;
 import org.apache.commons.math.optimization.RealPointValuePair;
-import org.apache.commons.math.util.Precision;
+import org.apache.commons.math.util.MathUtils;
 
 /**
  * A tableau for use in the Simplex method.
- *
+ * 
  * <p>
  * Example:
  * <pre>
@@ -57,17 +57,11 @@
  * a1: Artificial variable</br>
  * RHS: Right hand side</br>
  * </p>
- * @version $Id$
+ * @version $Revision$ $Date$
  * @since 2.0
  */
 class SimplexTableau implements Serializable {
 
-    /** Column label for negative vars. */
-    private static final String NEGATIVE_VAR_COLUMN_LABEL = "x-";
-
-    /** Default amount of error to accept in floating point comparisons (as ulps). */
-    private static final int DEFAULT_ULPS = 10;
-
     /** Serializable version identifier. */
     private static final long serialVersionUID = -1369660067587938365L;
 
@@ -75,32 +69,26 @@
     private final LinearObjectiveFunction f;
 
     /** Linear constraints. */
-    private final List<LinearConstraint> constraints;
+    private final Collection<LinearConstraint> constraints;
 
     /** Whether to restrict the variables to non-negative values. */
     private final boolean restrictToNonNegative;
 
-    /** The variables each column represents */
-    private final List<String> columnLabels = new ArrayList<String>();
-
     /** Simple tableau. */
-    private transient RealMatrix tableau;
+    protected transient RealMatrix tableau;
 
     /** Number of decision variables. */
-    private final int numDecisionVariables;
+    protected final int numDecisionVariables;
 
     /** Number of slack variables. */
-    private final int numSlackVariables;
+    protected final int numSlackVariables;
 
     /** Number of artificial variables. */
-    private int numArtificialVariables;
-
-    /** Amount of error to accept when checking for optimality. */
-    private final double epsilon;
-
-    /** Amount of error to accept in floating point comparisons. */
-    private final int maxUlps;
+    protected int numArtificialVariables;
 
+    /** Amount of error to accept in floating point comparisons. */ 
+    protected final double epsilon;
+    
     /**
      * Build a tableau for a linear problem.
      * @param f linear objective function
@@ -108,66 +96,23 @@
      * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}
      * or {@link GoalType#MINIMIZE}
      * @param restrictToNonNegative whether to restrict the variables to non-negative values
-     * @param epsilon amount of error to accept when checking for optimality
+     * @param epsilon amount of error to accept in floating point comparisons
      */
     SimplexTableau(final LinearObjectiveFunction f,
                    final Collection<LinearConstraint> constraints,
                    final GoalType goalType, final boolean restrictToNonNegative,
                    final double epsilon) {
-        this(f, constraints, goalType, restrictToNonNegative, epsilon, DEFAULT_ULPS);
-    }
-
-    /**
-     * Build a tableau for a linear problem.
-     * @param f linear objective function
-     * @param constraints linear constraints
-     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}
-     * or {@link GoalType#MINIMIZE}
-     * @param restrictToNonNegative whether to restrict the variables to non-negative values
-     * @param epsilon amount of error to accept when checking for optimality
-     * @param maxUlps amount of error to accept in floating point comparisons
-     */
-    SimplexTableau(final LinearObjectiveFunction f,
-                   final Collection<LinearConstraint> constraints,
-                   final GoalType goalType, final boolean restrictToNonNegative,
-                   final double epsilon,
-                   final int maxUlps) {
         this.f                      = f;
-        this.constraints            = normalizeConstraints(constraints);
+        this.constraints            = constraints;
         this.restrictToNonNegative  = restrictToNonNegative;
         this.epsilon                = epsilon;
-        this.maxUlps                = maxUlps;
-        this.numDecisionVariables   = f.getCoefficients().getDimension() +
-                                      (restrictToNonNegative ? 0 : 1);
+        this.numDecisionVariables   = getNumVariables() + (restrictToNonNegative ? 0 : 1);
         this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +
                                       getConstraintTypeCounts(Relationship.GEQ);
         this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +
                                       getConstraintTypeCounts(Relationship.GEQ);
-        this.tableau = createTableau(goalType == GoalType.MAXIMIZE);
-        initializeColumnLabels();
-    }
-
-    /**
-     * Initialize the labels for the columns.
-     */
-    protected void initializeColumnLabels() {
-      if (getNumObjectiveFunctions() == 2) {
-        columnLabels.add("W");
-      }
-      columnLabels.add("Z");
-      for (int i = 0; i < getOriginalNumDecisionVariables(); i++) {
-        columnLabels.add("x" + i);
-      }
-      if (!restrictToNonNegative) {
-        columnLabels.add(NEGATIVE_VAR_COLUMN_LABEL);
-      }
-      for (int i = 0; i < getNumSlackVariables(); i++) {
-        columnLabels.add("s" + i);
-      }
-      for (int i = 0; i < getNumArtificialVariables(); i++) {
-        columnLabels.add("a" + i);
-      }
-      columnLabels.add("RHS");
+        this.tableau = new Array2DRowRealMatrix(createTableau(goalType == GoalType.MAXIMIZE));
+        initialize();
     }
 
     /**
@@ -175,77 +120,83 @@
      * @param maximize if true, goal is to maximize the objective function
      * @return created tableau
      */
-    protected RealMatrix createTableau(final boolean maximize) {
+    protected double[][] createTableau(final boolean maximize) {
 
         // create a matrix of the correct size
+        List<LinearConstraint> constraints = getNormalizedConstraints();
         int width = numDecisionVariables + numSlackVariables +
         numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS
         int height = constraints.size() + getNumObjectiveFunctions();
-        Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);
+        double[][] matrix = new double[height][width];
 
         // initialize the objective function rows
         if (getNumObjectiveFunctions() == 2) {
-            matrix.setEntry(0, 0, -1);
+            matrix[0][0] = -1;
         }
         int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;
-        matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);
+        matrix[zIndex][zIndex] = maximize ? 1 : -1;
         RealVector objectiveCoefficients =
             maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
-        copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);
-        matrix.setEntry(zIndex, width - 1,
-            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());
-
-        if (!restrictToNonNegative) {
-            matrix.setEntry(zIndex, getSlackVariableOffset() - 1,
-                getInvertedCoefficientSum(objectiveCoefficients));
-        }
-
-        // initialize the constraint rows
-        int slackVar = 0;
-        int artificialVar = 0;
-        for (int i = 0; i < constraints.size(); i++) {
-            LinearConstraint constraint = constraints.get(i);
-            int row = getNumObjectiveFunctions() + i;
-
-            // decision variable coefficients
-            copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]);
-
-            // x-
-            if (!restrictToNonNegative) {
-                matrix.setEntry(row, getSlackVariableOffset() - 1,
-                    getInvertedCoefficientSum(constraint.getCoefficients()));
-            }
-
-            // RHS
-            matrix.setEntry(row, width - 1, constraint.getValue());
-
-            // slack variables
-            if (constraint.getRelationship() == Relationship.LEQ) {
-                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  // slack
-            } else if (constraint.getRelationship() == Relationship.GEQ) {
-                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess
-            }
+            copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());
+            matrix[zIndex][width - 1] =
+                maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();
+
+                if (!restrictToNonNegative) {
+                    matrix[zIndex][getSlackVariableOffset() - 1] =
+                        getInvertedCoeffiecientSum(objectiveCoefficients);
+                }
+
+                // initialize the constraint rows
+                int slackVar = 0;
+                int artificialVar = 0;
+                for (int i = 0; i < constraints.size(); i++) {
+                    LinearConstraint constraint = constraints.get(i);
+                    int row = getNumObjectiveFunctions() + i;
+
+                    // decision variable coefficients
+                    copyArray(constraint.getCoefficients().getData(), matrix[row], 1);
+
+                    // x-
+                    if (!restrictToNonNegative) {
+                        matrix[row][getSlackVariableOffset() - 1] =
+                            getInvertedCoeffiecientSum(constraint.getCoefficients());
+                    }
+
+                    // RHS
+                    matrix[row][width - 1] = constraint.getValue();
+
+                    // slack variables
+                    if (constraint.getRelationship() == Relationship.LEQ) {
+                        matrix[row][getSlackVariableOffset() + slackVar++] = 1;  // slack
+                    } else if (constraint.getRelationship() == Relationship.GEQ) {
+                        matrix[row][getSlackVariableOffset() + slackVar++] = -1; // excess
+                    }
+
+                    // artificial variables
+                    if ((constraint.getRelationship() == Relationship.EQ) ||
+                        (constraint.getRelationship() == Relationship.GEQ)) {
+                        matrix[0][getArtificialVariableOffset() + artificialVar] = 1; 
+                        matrix[row][getArtificialVariableOffset() + artificialVar++] = 1; 
+                    }
+                }
 
-            // artificial variables
-            if ((constraint.getRelationship() == Relationship.EQ) ||
-                    (constraint.getRelationship() == Relationship.GEQ)) {
-                matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);
-                matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);
-                matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));
-            }
-        }
+                return matrix;
+    }
 
-        return matrix;
+    /** Get the number of variables.
+     * @return number of variables
+     */
+    public int getNumVariables() {
+        return f.getCoefficients().getDimension();
     }
 
     /**
      * Get new versions of the constraints which have positive right hand sides.
-     * @param originalConstraints original (not normalized) constraints
      * @return new versions of the constraints
      */
-    public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints) {
+    public List<LinearConstraint> getNormalizedConstraints() {
         List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();
-        for (LinearConstraint constraint : originalConstraints) {
+        for (LinearConstraint constraint : constraints) {
             normalized.add(normalize(constraint));
         }
         return normalized;
@@ -262,7 +213,7 @@
                                         constraint.getRelationship().oppositeRelationship(),
                                         -1 * constraint.getValue());
         }
-        return new LinearConstraint(constraint.getCoefficients(),
+        return new LinearConstraint(constraint.getCoefficients(), 
                                     constraint.getRelationship(), constraint.getValue());
     }
 
@@ -290,13 +241,24 @@
     }
 
     /**
+     * Puts the tableau in proper form by zeroing out the artificial variables
+     * in the objective function via elementary row operations.
+     */
+    private void initialize() {
+        for (int artificialVar = 0; artificialVar < numArtificialVariables; artificialVar++) {
+            int row = getBasicRow(getArtificialVariableOffset() + artificialVar);
+            subtractRow(0, row, 1.0);
+        }
+    }
+
+    /**
      * Get the -1 times the sum of all coefficients in the given array.
      * @param coefficients coefficients to sum
      * @return the -1 times the sum of all coefficients in the given array.
      */
-    protected static double getInvertedCoefficientSum(final RealVector coefficients) {
+    protected static double getInvertedCoeffiecientSum(final RealVector coefficients) {
         double sum = 0;
-        for (double coefficient : coefficients.toArray()) {
+        for (double coefficient : coefficients.getData()) {
             sum -= coefficient;
         }
         return sum;
@@ -307,13 +269,31 @@
      * @param col index of the column to check
      * @return the row that the variable is basic in.  null if the column is not basic
      */
-    protected Integer getBasicRow(final int col) {
+    private Integer getBasicRow(final int col) {
+        return getBasicRow(col, true);
+    }
+
+    /**
+     * Checks whether the given column is basic.
+     * @param col index of the column to check
+     * @return the row that the variable is basic in.  null if the column is not basic
+     */
+    private Integer getBasicRowForSolution(final int col) {
+        return getBasicRow(col, false);
+    }
+    
+    /**
+     * Checks whether the given column is basic.
+     * @param col index of the column to check
+     * @return the row that the variable is basic in.  null if the column is not basic
+     */
+    private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {
         Integer row = null;
-        for (int i = 0; i < getHeight(); i++) {
-            final double entry = getEntry(i, col);
-            if (Precision.equals(entry, 1d, maxUlps) && (row == null)) {
+        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;
+        for (int i = start; i < getHeight(); i++) {
+            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
                 row = i;
-            } else if (!Precision.equals(entry, 0d, maxUlps)) {
+            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                 return null;
             }
         }
@@ -321,96 +301,52 @@
     }
 
     /**
-     * Removes the phase 1 objective function, positive cost non-artificial variables,
-     * and the non-basic artificial variables from this tableau.
+     * Removes the phase 1 objective function and artificial variables from this tableau.
      */
-    protected void dropPhase1Objective() {
-        if (getNumObjectiveFunctions() == 1) {
+    protected void discardArtificialVariables() {
+        if (numArtificialVariables == 0) {
             return;
         }
-
-        List<Integer> columnsToDrop = new ArrayList<Integer>();
-        columnsToDrop.add(0);
-
-        // positive cost non-artificial variables
-        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
-            final double entry = tableau.getEntry(0, i);
-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
-                columnsToDrop.add(i);
+        int width = getWidth() - numArtificialVariables - 1;
+        int height = getHeight() - 1;
+        double[][] matrix = new double[height][width];
+        for (int i = 0; i < height; i++) {
+            for (int j = 0; j < width - 1; j++) {
+                matrix[i][j] = getEntry(i + 1, j + 1);
             }
+            matrix[i][width - 1] = getEntry(i + 1, getRhsOffset());
         }
-
-        // non-basic artificial variables
-        for (int i = 0; i < getNumArtificialVariables(); i++) {
-          int col = i + getArtificialVariableOffset();
-          if (getBasicRow(col) == null) {
-            columnsToDrop.add(col);
-          }
-        }
-
-        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
-        for (int i = 1; i < getHeight(); i++) {
-          int col = 0;
-          for (int j = 0; j < getWidth(); j++) {
-            if (!columnsToDrop.contains(j)) {
-              matrix[i - 1][col++] = tableau.getEntry(i, j);
-            }
-          }
-        }
-
-        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
-          columnLabels.remove((int) columnsToDrop.get(i));
-        }
-
         this.tableau = new Array2DRowRealMatrix(matrix);
         this.numArtificialVariables = 0;
     }
 
+
     /**
      * @param src the source array
      * @param dest the destination array
+     * @param destPos the destination position
      */
-    private void copyArray(final double[] src, final double[] dest) {
-        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);
-    }
-
-    /**
-     * Returns whether the problem is at an optimal state.
-     * @return whether the model has been solved
-     */
-    boolean isOptimal() {
-        for (int i = getNumObjectiveFunctions(); i < getWidth() - 1; i++) {
-            final double entry = tableau.getEntry(0, i);
-            if (Precision.compareTo(entry, 0d, epsilon) < 0) {
-                return false;
-            }
-        }
-        return true;
+    private void copyArray(final double[] src, final double[] dest,
+                           final int destPos) {
+        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); 
     }
 
     /**
      * Get the current solution.
-     *
+     * 
      * @return current solution
      */
     protected RealPointValuePair getSolution() {
-      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
-      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;
+      double[] coefficients = new double[getOriginalNumDecisionVariables()];
+      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());
       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
-
       Set<Integer> basicRows = new HashSet<Integer>();
-      double[] coefficients = new double[getOriginalNumDecisionVariables()];
       for (int i = 0; i < coefficients.length; i++) {
-          int colIndex = columnLabels.indexOf("x" + i);
-          if (colIndex < 0) {
-            coefficients[i] = 0;
-            continue;
-          }
-          Integer basicRow = getBasicRow(colIndex);
+          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);
           if (basicRows.contains(basicRow)) {
-              // if multiple variables can take a given value
+              // if multiple variables can take a given value 
               // then we choose the first and set the rest equal to 0
-              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
+              coefficients[i] = 0;
           } else {
               basicRows.add(basicRow);
               coefficients[i] =
@@ -418,7 +354,7 @@
                   (restrictToNonNegative ? 0 : mostNegative);
           }
       }
-      return new RealPointValuePair(coefficients, f.getValue(coefficients));
+        return new RealPointValuePair(coefficients, f.getValue(coefficients));
     }
 
     /**
@@ -448,8 +384,10 @@
      */
     protected void subtractRow(final int minuendRow, final int subtrahendRow,
                                final double multiple) {
-        tableau.setRowVector(minuendRow, tableau.getRowVector(minuendRow)
-            .subtract(tableau.getRowVector(subtrahendRow).mapMultiply(multiple)));
+        for (int j = 0; j < getWidth(); j++) {
+            tableau.setEntry(minuendRow, j, tableau.getEntry(minuendRow, j) -
+                             multiple * tableau.getEntry(subtrahendRow, j));
+        }
     }
 
     /**
@@ -510,6 +448,15 @@
     protected final int getRhsOffset() {
         return getWidth() - 1;
     }
+    
+    /**
+     * Returns the offset of the extra decision variable added when there is a
+     * negative decision variable in the original problem.
+     * @return the offset of x-
+     */
+    protected final int getNegativeDecisionVariableOffset() {
+      return getNumObjectiveFunctions() + getOriginalNumDecisionVariables();
+    }
 
     /**
      * Get the number of decision variables.
@@ -531,7 +478,7 @@
      * @see #getNumDecisionVariables()
      */
     protected final int getOriginalNumDecisionVariables() {
-        return f.getCoefficients().getDimension();
+        return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;
     }
 
     /**
@@ -562,25 +509,33 @@
     @Override
     public boolean equals(Object other) {
 
-      if (this == other) {
+      if (this == other) { 
         return true;
       }
 
-      if (other instanceof SimplexTableau) {
+      if (other == null) {
+        return false;
+      }
+
+      try {
+
           SimplexTableau rhs = (SimplexTableau) other;
           return (restrictToNonNegative  == rhs.restrictToNonNegative) &&
                  (numDecisionVariables   == rhs.numDecisionVariables) &&
                  (numSlackVariables      == rhs.numSlackVariables) &&
                  (numArtificialVariables == rhs.numArtificialVariables) &&
                  (epsilon                == rhs.epsilon) &&
-                 (maxUlps                == rhs.maxUlps) &&
                  f.equals(rhs.f) &&
                  constraints.equals(rhs.constraints) &&
                  tableau.equals(rhs.tableau);
+
+      } catch (ClassCastException ex) {
+          // ignore exception
+          return false;
       }
-      return false;
-    }
 
+    }
+    
     /** {@inheritDoc} */
     @Override
     public int hashCode() {
@@ -589,7 +544,6 @@
                numSlackVariables ^
                numArtificialVariables ^
                Double.valueOf(epsilon).hashCode() ^
-               maxUlps ^
                f.hashCode() ^
                constraints.hashCode() ^
                tableau.hashCode();
diff -r -u buggy/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java inducing/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java
--- buggy/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java	2023-06-12 11:34:47.230600013 +0800
+++ inducing/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java	2023-06-12 11:34:47.478604538 +0800
@@ -17,92 +17,22 @@
 
 package org.apache.commons.math.optimization.linear;
 
-import org.junit.Assert;
+import static org.junit.Assert.assertEquals;
 
 import java.util.ArrayList;
 import java.util.Collection;
 
+import org.apache.commons.math.linear.RealVector;
+import org.apache.commons.math.linear.ArrayRealVector;
 import org.apache.commons.math.optimization.GoalType;
+import org.apache.commons.math.optimization.OptimizationException;
 import org.apache.commons.math.optimization.RealPointValuePair;
-import org.apache.commons.math.util.Precision;
 import org.junit.Test;
 
 public class SimplexSolverTest {
 
     @Test
-    public void testMath434NegativeVariable() {
-        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {0.0, 0.0, 1.0}, 0.0d);
-        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
-        constraints.add(new LinearConstraint(new double[] {1, 1, 0}, Relationship.EQ, 5));
-        constraints.add(new LinearConstraint(new double[] {0, 0, 1}, Relationship.GEQ, -10));
-
-        double epsilon = 1e-6;
-        SimplexSolver solver = new SimplexSolver();
-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);
-
-        Assert.assertEquals(5.0, solution.getPoint()[0] + solution.getPoint()[1], epsilon);
-        Assert.assertEquals(-10.0, solution.getPoint()[2], epsilon);
-        Assert.assertEquals(-10.0, solution.getValue(), epsilon);
-
-    }
-
-    @Test(expected = NoFeasibleSolutionException.class)
-    public void testMath434UnfeasibleSolution() {
-        double epsilon = 1e-6;
-
-        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0, 0.0}, 0.0);
-        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
-        constraints.add(new LinearConstraint(new double[] {epsilon/2, 0.5}, Relationship.EQ, 0));
-        constraints.add(new LinearConstraint(new double[] {1e-3, 0.1}, Relationship.EQ, 10));
-
-        SimplexSolver solver = new SimplexSolver();
-        // allowing only non-negative values, no feasible solution shall be found
-        solver.optimize(f, constraints, GoalType.MINIMIZE, true);
-    }
-
-    @Test
-    public void testMath434PivotRowSelection() {
-        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0}, 0.0);
-
-        double epsilon = 1e-6;
-        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
-        constraints.add(new LinearConstraint(new double[] {200}, Relationship.GEQ, 1));
-        constraints.add(new LinearConstraint(new double[] {100}, Relationship.GEQ, 0.499900001));
-
-        SimplexSolver solver = new SimplexSolver();
-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);
-        
-        Assert.assertTrue(Precision.compareTo(solution.getPoint()[0] * 200.d, 1.d, epsilon) >= 0);
-        Assert.assertEquals(0.0050, solution.getValue(), epsilon);
-    }
-
-    @Test
-    public void testMath434PivotRowSelection2() {
-        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {0.0d, 1.0d, 1.0d, 0.0d, 0.0d, 0.0d, 0.0d}, 0.0d);
-
-        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
-        constraints.add(new LinearConstraint(new double[] {1.0d, -0.1d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.EQ, -0.1d));
-        constraints.add(new LinearConstraint(new double[] {1.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, -1e-18d));
-        constraints.add(new LinearConstraint(new double[] {0.0d, 1.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));
-        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 0.0d, 1.0d, 0.0d, -0.0128588d, 1e-5d}, Relationship.EQ, 0.0d));
-        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 0.0d, 0.0d, 1.0d, 1e-5d, -0.0128586d}, Relationship.EQ, 1e-10d));
-        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, -1.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));
-        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 1.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));
-        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 0.0d, -1.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));
-        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 0.0d, 1.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));
-
-        double epsilon = 1e-7;
-        SimplexSolver simplex = new SimplexSolver();
-        RealPointValuePair solution = simplex.optimize(f, constraints, GoalType.MINIMIZE, false);
-        
-        Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], -1e-18d, epsilon) >= 0);
-        Assert.assertEquals(1.0d, solution.getPoint()[1], epsilon);        
-        Assert.assertEquals(0.0d, solution.getPoint()[2], epsilon);
-        Assert.assertEquals(1.0d, solution.getValue(), epsilon);
-    }
-    
-    @Test
-    public void testMath272() {
+    public void testMath272() throws OptimizationException {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ,  1));
@@ -111,122 +41,25 @@
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);
-
-        Assert.assertEquals(0.0, solution.getPoint()[0], .0000001);
-        Assert.assertEquals(1.0, solution.getPoint()[1], .0000001);
-        Assert.assertEquals(1.0, solution.getPoint()[2], .0000001);
-        Assert.assertEquals(3.0, solution.getValue(), .0000001);
-    }
-
-    @Test
-    public void testMath286() {
-        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.6, 0.4 }, 0 );
-        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
-        constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 23.0));
-        constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 23.0));
-        constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0, 0, 0 }, Relationship.GEQ, 10.0));
-        constraints.add(new LinearConstraint(new double[] { 0, 0, 1, 0, 0, 0 }, Relationship.GEQ, 8.0));
-        constraints.add(new LinearConstraint(new double[] { 0, 0, 0, 0, 1, 0 }, Relationship.GEQ, 5.0));
-
-        SimplexSolver solver = new SimplexSolver();
-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);
-
-        Assert.assertEquals(25.8, solution.getValue(), .0000001);
-        Assert.assertEquals(23.0, solution.getPoint()[0] + solution.getPoint()[2] + solution.getPoint()[4], 0.0000001);
-        Assert.assertEquals(23.0, solution.getPoint()[1] + solution.getPoint()[3] + solution.getPoint()[5], 0.0000001);
-        Assert.assertTrue(solution.getPoint()[0] >= 10.0 - 0.0000001);
-        Assert.assertTrue(solution.getPoint()[2] >= 8.0 - 0.0000001);
-        Assert.assertTrue(solution.getPoint()[4] >= 5.0 - 0.0000001);
-    }
-
-    @Test
-    public void testDegeneracy() {
-        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.7 }, 0 );
-        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
-        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.LEQ, 18.0));
-        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.GEQ, 10.0));
-        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 8.0));
-
-        SimplexSolver solver = new SimplexSolver();
-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);
-        Assert.assertEquals(13.6, solution.getValue(), .0000001);
-    }
-
-    @Test
-    public void testMath288() {
-        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 7, 3, 0, 0 }, 0 );
-        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
-        constraints.add(new LinearConstraint(new double[] { 3, 0, -5, 0 }, Relationship.LEQ, 0.0));
-        constraints.add(new LinearConstraint(new double[] { 2, 0, 0, -5 }, Relationship.LEQ, 0.0));
-        constraints.add(new LinearConstraint(new double[] { 0, 3, 0, -5 }, Relationship.LEQ, 0.0));
-        constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0 }, Relationship.LEQ, 1.0));
-        constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0));
-
-        SimplexSolver solver = new SimplexSolver();
-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);
-        Assert.assertEquals(10.0, solution.getValue(), .0000001);
-    }
-
-    @Test
-    public void testMath290GEQ() {
-        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 5 }, 0 );
-        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
-        constraints.add(new LinearConstraint(new double[] { 2, 0 }, Relationship.GEQ, -1.0));
-        SimplexSolver solver = new SimplexSolver();
-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);
-        Assert.assertEquals(0, solution.getValue(), .0000001);
-        Assert.assertEquals(0, solution.getPoint()[0], .0000001);
-        Assert.assertEquals(0, solution.getPoint()[1], .0000001);
-    }
-
-    @Test(expected=NoFeasibleSolutionException.class)
-    public void testMath290LEQ() {
-        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 5 }, 0 );
-        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
-        constraints.add(new LinearConstraint(new double[] { 2, 0 }, Relationship.LEQ, -1.0));
-        SimplexSolver solver = new SimplexSolver();
-        solver.optimize(f, constraints, GoalType.MINIMIZE, true);
+        
+        assertEquals(0.0, solution.getPoint()[0], .0000001);
+        assertEquals(1.0, solution.getPoint()[1], .0000001);
+        assertEquals(1.0, solution.getPoint()[2], .0000001);
+        assertEquals(3.0, solution.getValue(), .0000001);
     }
 
     @Test
-    public void testMath293() {
-      LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.4, 0.6}, 0 );
+    public void testMath286() throws OptimizationException {
+      LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.2, 0.3 }, 0 );
       Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
-      constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 30.0));
-      constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 30.0));
-      constraints.add(new LinearConstraint(new double[] { 0.8, 0.2, 0.0, 0.0, 0.0, 0.0 }, Relationship.GEQ, 10.0));
-      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, 10.0));
-      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, 10.0));
-
-      SimplexSolver solver = new SimplexSolver();
-      RealPointValuePair solution1 = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);
+      constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 23.0));
 
-      Assert.assertEquals(15.7143, solution1.getPoint()[0], .0001);
-      Assert.assertEquals(0.0, solution1.getPoint()[1], .0001);
-      Assert.assertEquals(14.2857, solution1.getPoint()[2], .0001);
-      Assert.assertEquals(0.0, solution1.getPoint()[3], .0001);
-      Assert.assertEquals(0.0, solution1.getPoint()[4], .0001);
-      Assert.assertEquals(30.0, solution1.getPoint()[5], .0001);
-      Assert.assertEquals(40.57143, solution1.getValue(), .0001);
-
-      double valA = 0.8 * solution1.getPoint()[0] + 0.2 * solution1.getPoint()[1];
-      double valB = 0.7 * solution1.getPoint()[2] + 0.3 * solution1.getPoint()[3];
-      double valC = 0.4 * solution1.getPoint()[4] + 0.6 * solution1.getPoint()[5];
-
-      f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.4, 0.6}, 0 );
-      constraints = new ArrayList<LinearConstraint>();
-      constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 30.0));
-      constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 30.0));
-      constraints.add(new LinearConstraint(new double[] { 0.8, 0.2, 0.0, 0.0, 0.0, 0.0 }, Relationship.GEQ, valA));
-      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, valB));
-      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, valC));
-
-      RealPointValuePair solution2 = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);
-      Assert.assertEquals(40.57143, solution2.getValue(), .0001);
+      RealPointValuePair solution = new SimplexSolver().optimize(f, constraints, GoalType.MAXIMIZE, true);
+      assertEquals(6.9, solution.getValue(), .0000001);
     }
-
+    
     @Test
-    public void testSimplexSolver() {
+    public void testSimplexSolver() throws OptimizationException {
         LinearObjectiveFunction f =
             new LinearObjectiveFunction(new double[] { 15, 10 }, 7);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
@@ -236,29 +69,29 @@
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);
-        Assert.assertEquals(2.0, solution.getPoint()[0], 0.0);
-        Assert.assertEquals(2.0, solution.getPoint()[1], 0.0);
-        Assert.assertEquals(57.0, solution.getValue(), 0.0);
+        assertEquals(2.0, solution.getPoint()[0], 0.0);
+        assertEquals(2.0, solution.getPoint()[1], 0.0);
+        assertEquals(57.0, solution.getValue(), 0.0);
     }
 
     @Test
-    public void testSingleVariableAndConstraint() {
+    public void testSingleVariableAndConstraint() throws OptimizationException {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 3 }, 0);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 10));
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);
-        Assert.assertEquals(10.0, solution.getPoint()[0], 0.0);
-        Assert.assertEquals(30.0, solution.getValue(), 0.0);
+        assertEquals(10.0, solution.getPoint()[0], 0.0);
+        assertEquals(30.0, solution.getValue(), 0.0);
     }
-
+    
     /**
      * With no artificial variables needed (no equals and no greater than
      * constraints) we can go straight to Phase 2.
      */
     @Test
-    public void testModelWithNoArtificialVars() {
+    public void testModelWithNoArtificialVars() throws OptimizationException {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2));
@@ -267,13 +100,13 @@
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);
-        Assert.assertEquals(2.0, solution.getPoint()[0], 0.0);
-        Assert.assertEquals(2.0, solution.getPoint()[1], 0.0);
-        Assert.assertEquals(50.0, solution.getValue(), 0.0);
+        assertEquals(2.0, solution.getPoint()[0], 0.0);
+        assertEquals(2.0, solution.getPoint()[1], 0.0);
+        assertEquals(50.0, solution.getValue(), 0.0);
     }
 
     @Test
-    public void testMinimization() {
+    public void testMinimization() throws OptimizationException {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, -5);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 6));
@@ -282,13 +115,13 @@
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);
-        Assert.assertEquals(4.0, solution.getPoint()[0], 0.0);
-        Assert.assertEquals(0.0, solution.getPoint()[1], 0.0);
-        Assert.assertEquals(-13.0, solution.getValue(), 0.0);
+        assertEquals(4.0, solution.getPoint()[0], 0.0);
+        assertEquals(0.0, solution.getPoint()[1], 0.0);
+        assertEquals(-13.0, solution.getValue(), 0.0);
     }
 
     @Test
-    public void testSolutionWithNegativeDecisionVariable() {
+    public void testSolutionWithNegativeDecisionVariable() throws OptimizationException {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, 0);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.GEQ, 6));
@@ -296,13 +129,13 @@
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);
-        Assert.assertEquals(-2.0, solution.getPoint()[0], 0.0);
-        Assert.assertEquals(8.0, solution.getPoint()[1], 0.0);
-        Assert.assertEquals(12.0, solution.getValue(), 0.0);
+        assertEquals(-2.0, solution.getPoint()[0], 0.0);
+        assertEquals(8.0, solution.getPoint()[1], 0.0);
+        assertEquals(12.0, solution.getValue(), 0.0);
     }
 
     @Test(expected = NoFeasibleSolutionException.class)
-    public void testInfeasibleSolution() {
+    public void testInfeasibleSolution() throws OptimizationException {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15 }, 0);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 1));
@@ -313,7 +146,7 @@
     }
 
     @Test(expected = UnboundedSolutionException.class)
-    public void testUnboundedSolution() {
+    public void testUnboundedSolution() throws OptimizationException {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.EQ, 2));
@@ -323,7 +156,7 @@
     }
 
     @Test
-    public void testRestrictVariablesToNonNegative() {
+    public void testRestrictVariablesToNonNegative() throws OptimizationException {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 409, 523, 70, 204, 339 }, 0);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] {    43,   56, 345,  56,    5 }, Relationship.LEQ,  4567456));
@@ -334,16 +167,16 @@
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);
-        Assert.assertEquals(2902.92783505155, solution.getPoint()[0], .0000001);
-        Assert.assertEquals(480.419243986254, solution.getPoint()[1], .0000001);
-        Assert.assertEquals(0.0, solution.getPoint()[2], .0000001);
-        Assert.assertEquals(0.0, solution.getPoint()[3], .0000001);
-        Assert.assertEquals(0.0, solution.getPoint()[4], .0000001);
-        Assert.assertEquals(1438556.7491409, solution.getValue(), .0000001);
+        assertEquals(2902.92783505155, solution.getPoint()[0], .0000001);
+        assertEquals(480.419243986254, solution.getPoint()[1], .0000001);
+        assertEquals(0.0, solution.getPoint()[2], .0000001);
+        assertEquals(0.0, solution.getPoint()[3], .0000001);
+        assertEquals(0.0, solution.getPoint()[4], .0000001);
+        assertEquals(1438556.7491409, solution.getValue(), .0000001);
     }
 
     @Test
-    public void testEpsilon() {
+    public void testEpsilon() throws OptimizationException {
       LinearObjectiveFunction f =
           new LinearObjectiveFunction(new double[] { 10, 5, 1 }, 0);
       Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
@@ -353,25 +186,25 @@
 
       SimplexSolver solver = new SimplexSolver();
       RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);
-      Assert.assertEquals(1.0, solution.getPoint()[0], 0.0);
-      Assert.assertEquals(1.0, solution.getPoint()[1], 0.0);
-      Assert.assertEquals(0.0, solution.getPoint()[2], 0.0);
-      Assert.assertEquals(15.0, solution.getValue(), 0.0);
+      assertEquals(1.0, solution.getPoint()[0], 0.0);
+      assertEquals(1.0, solution.getPoint()[1], 0.0);
+      assertEquals(0.0, solution.getPoint()[2], 0.0);
+      assertEquals(15.0, solution.getValue(), 0.0);
   }
-
+    
     @Test
-    public void testTrivialModel() {
+    public void testTrivialModel() throws OptimizationException {
         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 1 }, 0);
         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
         constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ,  0));
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);
-        Assert.assertEquals(0, solution.getValue(), .0000001);
+        assertEquals(0, solution.getValue(), .0000001);
     }
 
     @Test
-    public void testLargeModel() {
+    public void testLargeModel() throws OptimizationException {
         double[] objective = new double[] {
                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                                            1, 1, 12, 1, 1, 1, 1, 1, 1, 1,
@@ -494,9 +327,9 @@
 
         SimplexSolver solver = new SimplexSolver();
         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);
-        Assert.assertEquals(7518.0, solution.getValue(), .0000001);
+        assertEquals(7518.0, solution.getValue(), .0000001);
     }
-
+    
     /**
      * Converts a test string to a {@link LinearConstraint}.
      * Ex: x0 + x1 + x2 + x3 - x12 = 0
@@ -516,13 +349,13 @@
         String[] equationParts = s.split("[>|<]?=");
         double rhs = Double.parseDouble(equationParts[1].trim());
 
-        double[] lhs = new double[numCoefficients];
+        RealVector lhs = new ArrayRealVector(numCoefficients);
         String left = equationParts[0].replaceAll(" ?x", "");
         String[] coefficients = left.split(" ");
         for (String coefficient : coefficients) {
             double value = coefficient.charAt(0) == '-' ? -1 : 1;
             int index = Integer.parseInt(coefficient.replaceFirst("[+|-]", "").trim());
-            lhs[index] = value;
+            lhs.setEntry(index, value);
         }
         return new LinearConstraint(lhs, relationship, rhs);
     }
