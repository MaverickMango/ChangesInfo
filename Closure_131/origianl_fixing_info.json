{
  "logger": {
    "currentLogLevel": 20,
    "name": "root.bean.benchmarks.Defects4JBug"
  },
  "d4jCmd": "/home/liumengjiao/Desktop/defects4j/framework/bin/defects4j",
  "dataDir": "/home/liumengjiao/Desktop/CI/Benchmark/data/changesInfo/",
  "properties": {
    "trigger.tests": "com.google.javascript.jscomp.ConvertToDottedPropertiesTest::testQuotedProps,com.google.javascript.jscomp.ConvertToDottedPropertiesTest::testDoNotConvert",
    "test.dir": "test",
    "clz.modified": "com.google.javascript.rhino.TokenStream",
    "src.dir": "src"
  },
  "timeoutSecond": 100,
  "proj": "Closure",
  "id": "131",
  "workingDir": "../bugs/Closure_131_buggy",
  "buggyCommit": "602dc3845e92d39a0701396666635ccc4a321599",
  "inducingCommit": "a2715a52745d816a87c05d3007ed8bfe7ef18491",
  "originalCommit": "e4cf805a6a27301672660756202e8dedee1e012b",
  "bug_name": "Closure_131",
  "derive": "defects4j",
  "original_fixing_commit": "7f6700e2b54af3af409f3e8851a0d98a72beef4b",
  "buildFiles_changed": false,
  "regression": false,
  "inducing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/CheckRegExp.java",
        "src/com/google/javascript/jscomp/CheckRegExp.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.CheckRegExp:visit:[NodeTraversal t, Node n, Node parent]:void"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.CheckRegExp:visit:[NodeTraversal t, Node n, Node parent]:void"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "25",
            "57"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "25",
            "57"
          ],
          "num": 2
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/CheckRegExp.java b/src/com/google/javascript/jscomp/CheckRegExp.java\nindex 72febcf..264d3c1 100644\n--- a/src/com/google/javascript/jscomp/CheckRegExp.java\n+++ b/src/com/google/javascript/jscomp/CheckRegExp.java\n@@ -22,7 +22,7 @@\n /**\n  * Look for references to the global RegExp object that would cause\n  * regular expressions to be unoptimizable.\n- * \n+ *\n  * @author johnlenz@google.com (John Lenz)\n  */\n class CheckRegExp extends AbstractPostOrderCallback implements CompilerPass {\n@@ -54,7 +54,7 @@\n       String name \u003d n.getString();\n       if (name.equals(\"RegExp\") \u0026\u0026 t.getScope().getVar(name) \u003d\u003d null) {\n         int parentType \u003d parent.getType();\n-        boolean first \u003d (n \u003d\u003d parent.getFirstChild()); \n+        boolean first \u003d (n \u003d\u003d parent.getFirstChild());\n         if (!((parentType \u003d\u003d Token.NEW \u0026\u0026 first)\n                || (parentType \u003d\u003d Token.CALL \u0026\u0026 first)\n                || (parentType \u003d\u003d Token.INSTANCEOF \u0026\u0026 !first))) {\n",
      "operations": []
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/JsMessageVisitor.java",
        "src/com/google/javascript/jscomp/JsMessageVisitor.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.JsMessageVisitor:visit:[NodeTraversal traversal, Node node, Node parent]:void"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.JsMessageVisitor:visit:[NodeTraversal traversal, Node node, Node parent]:void"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "250",
            "251",
            "254",
            "255"
          ],
          "num": 4
        },
        {
          "qualified_names": [
            "250",
            "251",
            "254",
            "255"
          ],
          "num": 4
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/JsMessageVisitor.java b/src/com/google/javascript/jscomp/JsMessageVisitor.java\nindex a217e24..6e47634 100644\n--- a/src/com/google/javascript/jscomp/JsMessageVisitor.java\n+++ b/src/com/google/javascript/jscomp/JsMessageVisitor.java\n@@ -247,12 +247,12 @@\n     JsMessage extractedMessage \u003d builder.build(idGenerator);\n \n     // If asked to check named internal messages.\n-    if (needToCheckDuplications \n-        \u0026\u0026 !isUnnamedMsg \n+    if (needToCheckDuplications\n+        \u0026\u0026 !isUnnamedMsg\n         \u0026\u0026 !extractedMessage.isExternal()) {\n       checkIfMessageDuplicated(traversal.getSourceName(), messageKey, msgNode);\n-    }    \n-    \n+    }\n+\n     if (extractedMessage.isEmpty()) {\n       // value of the message is an empty string. Translators do not like it.\n       compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n",
      "operations": []
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.MakeDeclaredNamesUnique\\$ContextualRenameInverter:findReplacementName:[String name]:String"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.MakeDeclaredNamesUnique\\$ContextualRenameInverter:findReplacementName:[String name]:String"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "331",
            "340",
            "552"
          ],
          "num": 3
        },
        {
          "qualified_names": [
            "331",
            "340",
            "552"
          ],
          "num": 3
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\nindex eab4ba7..6e4990f 100644\n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n@@ -328,7 +328,7 @@\n         nameMap.remove(name);\n       }\n     }\n- \n+\n     /**\n      * Find a name usable in the local scope.\n      */\n@@ -337,7 +337,7 @@\n       String newName \u003d original;\n       int i \u003d 0;\n       while (!isValidName(newName)) {\n-        newName \u003d original + \n+        newName \u003d original +\n             ContextualRenamer.UNIQUE_ID_SEPARATOR + String.valueOf(i++);\n       }\n       return newName;\n@@ -549,7 +549,7 @@\n   static class BoilerplateRenamer extends ContextualRenamer {\n     private final Supplier\u003cString\u003e uniqueIdSupplier;\n     private final String idPrefix;\n-    \n+\n     BoilerplateRenamer(\n         Supplier\u003cString\u003e uniqueIdSupplier,\n         String idPrefix) {\n",
      "operations": []
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java",
        "src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.PeepholeFoldWithTypes:tryFoldTypeof:[Node typeofNode]:Node"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.PeepholeFoldWithTypes:tryFoldTypeof:[Node typeofNode]:Node"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "26",
            "30",
            "35",
            "38",
            "52",
            "56",
            "69",
            "76",
            "78",
            "84",
            "86",
            "105",
            "110",
            "113",
            "114"
          ],
          "num": 15
        },
        {
          "qualified_names": [
            "26",
            "30",
            "35",
            "38",
            "52",
            "56",
            "69",
            "76",
            "78",
            "84",
            "86",
            "105",
            "110",
            "113",
            "114"
          ],
          "num": 15
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java b/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java\nindex 91e1892..c85f96f 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java\n@@ -23,19 +23,19 @@\n \n /**\n  * Performs type-aware peephole optimizations.\n- * \n+ *\n  * These peephole optimizations are in their own class because\n  * type information may not always be available (such as during pre-processing)\n  * or may not be turned on.\n- * \n+ *\n  * Currently only Token.TYPEOF is folded -- in the future it may be possible to\n  * fold Token.INSTANCEOF as well. Another possibility is folding when\n  * non-nullable objects are used in boolean logic, such as:\n  * \"if (x) {\" or \"(!x) ? a : b\" or \"x \u0026\u0026 foo()\"\n- * \n+ *\n  * TODO(dcc): Support folding Token.INSTANCEOF and non-nullable objects\n  * in boolean logic.\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n class PeepholeFoldWithTypes extends AbstractPeepholeOptimization {\n@@ -49,11 +49,11 @@\n         return subtree;\n     }\n   }\n-  \n+\n   /**\n    * Folds \"typeof expression\" based on the JSType of \"expression\" if the\n    * expression  has no side effects.\n-   * \n+   *\n    * \u003cp\u003eE.g.,\n    * \u003cpre\u003e\n    * var x \u003d 6;\n@@ -66,24 +66,24 @@\n    * if (\"number\" \u003d\u003d \"number\") {\n    * }\n    * \u003c/pre\u003e\n-   * \n+   *\n    * \u003cp\u003eThis method doesn\u0027t fold literal values -- we leave that to\n    * PeepholeFoldConstants.\n    */\n   private Node tryFoldTypeof(Node typeofNode) {\n     Preconditions.checkArgument(typeofNode.getType() \u003d\u003d Token.TYPEOF);\n     Preconditions.checkArgument(typeofNode.getFirstChild() !\u003d null);\n-    \n+\n     Node argumentNode \u003d typeofNode.getFirstChild();\n-    \n+\n     // We\u0027ll let PeepholeFoldConstants handle folding literals\n     // and we can\u0027t remove arguments with possible side effects.\n     if (!NodeUtil.isLiteralValue(argumentNode, true) \u0026\u0026\n         !mayHaveSideEffects(argumentNode)) {\n       JSType argumentType \u003d argumentNode.getJSType();\n-            \n+\n       String typeName \u003d null;\n-      \n+\n       if (argumentType !\u003d null) {\n         // typeof null is \"object\" in JavaScript\n         if (argumentType.isObject() || argumentType.isNullType()) {\n@@ -102,16 +102,16 @@\n           // in the future.\n           typeName \u003d null;\n         }\n-               \n+\n         if (typeName !\u003d null) {\n           Node newNode \u003d Node.newString(typeName);\n           typeofNode.getParent().replaceChild(typeofNode, newNode);\n           reportCodeChange();\n-          \n+\n           return newNode;\n         }\n-      }     \n-    }  \n+      }\n+    }\n     return typeofNode;\n   }\n }\n",
      "operations": []
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/SideEffectsAnalysis.java",
        "src/com/google/javascript/jscomp/SideEffectsAnalysis.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.SideEffectsAnalysis:createVisibilityAbstraction:[Node externs, Node root]:LocationAbstraction",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VariableUseDeclarationMap:findDeclaringNameNodeForUse:[Node usingNameNode]:Node",
            "com.google.javascript.jscomp.SideEffectsAnalysis:nodeHasAncestor:[Node node, Node possibleAncestor]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VisibilityLocationAbstraction:storageNodeIsRValue:[Node node]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis:isControlDependentChild:[Node child]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VariableUseDeclarationMap:mapUses:[Node root]:void",
            "com.google.javascript.jscomp.SideEffectsAnalysis:nodesHaveSameControlFlow:[Node node1, Node node2]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VisibilityLocationAbstraction:calculateLocationSummary:[Node node]:LocationSummary",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VisibilityLocationAbstraction\\$VisibilityBasedEffectLocation:intersectsLocation:[EffectLocation otherLocation]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$IntraproceduralMotionEnvironment:calculateEnvironment:[]:Set\u003cNode\u003e",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$IntraproceduralMotionEnvironment:IntraproceduralMotionEnvironment:[ControlFlowGraph\u003cNode\u003e controlFlowGraph, Node cfgSource, Node cfgDestination]:null",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VisibilityLocationAbstraction:storageNodeIsLValue:[Node node]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis:safeToMoveBefore:[Node source, AbstractMotionEnvironment environment, Node destination]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$LocationSummary:getRefSet:[]:EffectLocation",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VisibilityLocationAbstraction:findStorageLocationReferences:[Node root]:Set\u003cNode\u003e",
            "com.google.javascript.jscomp.SideEffectsAnalysis:isPure:[Node node]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis:closestControlDependentAncestor:[Node node]:Node",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VisibilityLocationAbstraction:isStorageNode:[Node node]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis:SideEffectsAnalysis:[AbstractCompiler compiler, LocationAbstractionMode locationAbstractionMode]:null",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$LocationAbstraction:calculateLocationSummary:[Set\u003cNode\u003e nodes]:LocationSummary",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VisibilityLocationAbstraction\\$VisibilityBasedEffectLocation:join:[EffectLocation otherLocation]:EffectLocation",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$CrossModuleMotionEnvironment:CrossModuleMotionEnvironment:[Node sourceNode, JSModule sourceModule, Node destinationNode, JSModule destinationModule, JSModuleGraph moduleGraph]:null",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$EffectLocation:intersectsLocation:[EffectLocation otherLocation]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$LocationAbstraction:getBottomLocation:[]:EffectLocation",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VisibilityLocationAbstraction:effectMaskForVariableReference:[Node variableReference]:int",
            "com.google.javascript.jscomp.SideEffectsAnalysis:process:[Node externs, Node root]:void"
          ],
          "num": 26
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.SideEffectsAnalysis:nodesHaveSameControlFlow:[Node node1, Node node2]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$CrossModuleMotionEnvironment:CrossModuleMotionEnvironment:[Node sourceNode, JSModule sourceModule, Node destinationNode, JSModule destinationModule, JSModuleGraph moduleGraph]:null",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VisibilityLocationAbstraction:isStorageNode:[Node node]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis:isPure:[Node node]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$LocationSummary:getRefSet:[]:EffectLocation",
            "com.google.javascript.jscomp.SideEffectsAnalysis:nodeHasAncestor:[Node node, Node possibleAncestor]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VisibilityLocationAbstraction\\$VisibilityBasedEffectLocation:intersectsLocation:[EffectLocation otherLocation]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis:SideEffectsAnalysis:[AbstractCompiler compiler, LocationAbstractionMode locationAbstractionMode]:null",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VisibilityLocationAbstraction:findStorageLocationReferences:[Node root]:Set\u003cNode\u003e",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VisibilityLocationAbstraction:effectMaskForVariableReference:[Node variableReference]:int",
            "com.google.javascript.jscomp.SideEffectsAnalysis:process:[Node externs, Node root]:void",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VisibilityLocationAbstraction\\$VisibilityBasedEffectLocation:join:[EffectLocation otherLocation]:EffectLocation",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VariableUseDeclarationMap:mapUses:[Node root]:void",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VisibilityLocationAbstraction:storageNodeIsLValue:[Node node]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VisibilityLocationAbstraction:storageNodeIsRValue:[Node node]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis:safeToMoveBefore:[Node source, AbstractMotionEnvironment environment, Node destination]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$LocationAbstraction:getBottomLocation:[]:EffectLocation",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VisibilityLocationAbstraction:calculateLocationSummary:[Node node]:LocationSummary",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$EffectLocation:intersectsLocation:[EffectLocation otherLocation]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$IntraproceduralMotionEnvironment:calculateEnvironment:[]:Set\u003cNode\u003e",
            "com.google.javascript.jscomp.SideEffectsAnalysis:createVisibilityAbstraction:[Node externs, Node root]:LocationAbstraction",
            "com.google.javascript.jscomp.SideEffectsAnalysis:isControlDependentChild:[Node child]:boolean",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$VariableUseDeclarationMap:findDeclaringNameNodeForUse:[Node usingNameNode]:Node",
            "com.google.javascript.jscomp.SideEffectsAnalysis:closestControlDependentAncestor:[Node node]:Node",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$IntraproceduralMotionEnvironment:IntraproceduralMotionEnvironment:[ControlFlowGraph\u003cNode\u003e controlFlowGraph, Node cfgSource, Node cfgDestination]:null",
            "com.google.javascript.jscomp.SideEffectsAnalysis\\$LocationAbstraction:calculateLocationSummary:[Set\u003cNode\u003e nodes]:LocationSummary"
          ],
          "num": 26
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "39",
            "43",
            "45",
            "48",
            "50",
            "54",
            "64",
            "65",
            "72",
            "74",
            "77",
            "80",
            "83",
            "88",
            "93",
            "96",
            "100",
            "108",
            "114",
            "120",
            "125",
            "127",
            "130",
            "132",
            "136",
            "138",
            "141",
            "142",
            "145",
            "146",
            "147",
            "154",
            "159",
            "165",
            "169",
            "172",
            "185",
            "191",
            "194",
            "213",
            "217",
            "219",
            "227",
            "229",
            "235",
            "239",
            "246",
            "250",
            "252",
            "256",
            "258",
            "261",
            "264",
            "265",
            "267",
            "277",
            "287",
            "303",
            "309",
            "319",
            "323",
            "326",
            "332",
            "336",
            "338",
            "340",
            "359",
            "364",
            "365",
            "369",
            "376",
            "379",
            "386",
            "392",
            "395",
            "407",
            "411",
            "415",
            "421",
            "427",
            "436",
            "439",
            "443",
            "450",
            "452",
            "457",
            "459",
            "471",
            "483",
            "485",
            "504",
            "510",
            "513",
            "518",
            "521",
            "526",
            "530",
            "533",
            "535",
            "539",
            "544",
            "550",
            "553",
            "558",
            "567",
            "573",
            "577",
            "578",
            "583",
            "588",
            "592",
            "598",
            "602",
            "605",
            "608",
            "612",
            "620",
            "625",
            "627",
            "630",
            "633",
            "638",
            "643",
            "651",
            "659",
            "668",
            "672",
            "678",
            "681",
            "684",
            "689",
            "692",
            "698",
            "700",
            "705",
            "710",
            "713",
            "715",
            "717",
            "719",
            "721",
            "723",
            "726",
            "734",
            "741",
            "742",
            "745",
            "750",
            "753",
            "757",
            "761",
            "762",
            "765",
            "768",
            "778",
            "785",
            "786",
            "788",
            "791",
            "795",
            "797",
            "799",
            "800",
            "802",
            "804",
            "806",
            "823",
            "830",
            "833",
            "838",
            "841",
            "847",
            "853",
            "858",
            "860",
            "865",
            "866",
            "868",
            "869",
            "871",
            "873",
            "876",
            "882",
            "884",
            "891",
            "895",
            "898",
            "902",
            "905",
            "909",
            "912",
            "914",
            "915",
            "917",
            "928",
            "930",
            "931",
            "933",
            "935",
            "936",
            "937",
            "940",
            "948",
            "951",
            "955",
            "959",
            "965",
            "966",
            "967",
            "969",
            "971",
            "975",
            "976",
            "978",
            "984",
            "992"
          ],
          "num": 216
        },
        {
          "qualified_names": [
            "39",
            "43",
            "45",
            "48",
            "50",
            "54",
            "64",
            "65",
            "72",
            "74",
            "77",
            "80",
            "83",
            "88",
            "93",
            "96",
            "100",
            "108",
            "114",
            "120",
            "125",
            "127",
            "130",
            "132",
            "136",
            "138",
            "141",
            "142",
            "145",
            "146",
            "147",
            "154",
            "159",
            "165",
            "169",
            "172",
            "185",
            "191",
            "194",
            "213",
            "217",
            "219",
            "227",
            "229",
            "235",
            "239",
            "246",
            "250",
            "252",
            "256",
            "258",
            "261",
            "264",
            "265",
            "267",
            "277",
            "287",
            "303",
            "309",
            "319",
            "323",
            "326",
            "332",
            "336",
            "338",
            "340",
            "359",
            "364",
            "365",
            "369",
            "376",
            "379",
            "386",
            "392",
            "395",
            "407",
            "411",
            "415",
            "421",
            "427",
            "436",
            "439",
            "443",
            "450",
            "452",
            "457",
            "459",
            "471",
            "483",
            "485",
            "504",
            "510",
            "513",
            "518",
            "521",
            "526",
            "530",
            "533",
            "535",
            "539",
            "544",
            "550",
            "553",
            "558",
            "567",
            "573",
            "577",
            "578",
            "583",
            "588",
            "592",
            "598",
            "602",
            "605",
            "608",
            "612",
            "620",
            "625",
            "627",
            "630",
            "633",
            "638",
            "643",
            "651",
            "659",
            "668",
            "672",
            "678",
            "681",
            "684",
            "689",
            "692",
            "698",
            "700",
            "705",
            "710",
            "713",
            "715",
            "717",
            "719",
            "721",
            "723",
            "726",
            "734",
            "741",
            "742",
            "745",
            "750",
            "753",
            "757",
            "761",
            "762",
            "765",
            "768",
            "778",
            "785",
            "786",
            "788",
            "791",
            "795",
            "797",
            "799",
            "800",
            "802",
            "804",
            "806",
            "823",
            "830",
            "833",
            "838",
            "841",
            "847",
            "853",
            "858",
            "860",
            "865",
            "866",
            "868",
            "869",
            "871",
            "873",
            "876",
            "882",
            "884",
            "891",
            "895",
            "898",
            "902",
            "905",
            "909",
            "912",
            "914",
            "915",
            "917",
            "928",
            "930",
            "931",
            "933",
            "935",
            "936",
            "937",
            "940",
            "948",
            "951",
            "955",
            "959",
            "965",
            "966",
            "967",
            "969",
            "971",
            "975",
            "976",
            "978",
            "984",
            "992"
          ],
          "num": 216
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/SideEffectsAnalysis.java b/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\nindex 8bcd435..8fd4916 100644\n--- a/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n+++ b/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n@@ -36,22 +36,22 @@\n /**\n  * A pass that analyzes side effects to determine when it is safe to move\n  * code from one program point to another.\n- * \n+ *\n  * In its current form, SideEffectsAnalysis is very incomplete; this is\n  * mostly a sketch to prototype the interface and the broad strokes of\n  * a possible implementation based on flow-insensitive MOD and REF sets.\n- * \n+ *\n  * See:\n- * \n+ *\n  * Banning, John. “An efficient way to find the side effects of procedure\n  *      calls and the aliases of variables.” POPL ‘79.\n- * \n+ *\n  * For an introduction to MOD and REF sets.\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n  class SideEffectsAnalysis implements CompilerPass {\n-  \n+\n    /**\n     * The type of location abstraction to use for this analysis.\n     */\n@@ -61,43 +61,43 @@\n     /** See {@link VisibilityLocationAbstraction} for details. */\n     VISIBILITY_BASED\n   }\n-  \n-  private static final Predicate\u003cNode\u003e NOT_FUNCTION_PREDICATE \u003d \n+\n+  private static final Predicate\u003cNode\u003e NOT_FUNCTION_PREDICATE \u003d\n       new Predicate\u003cNode\u003e() {\n     @Override\n     public boolean apply(Node input) {\n       return !NodeUtil.isFunction(input);\n     }\n   };\n-  \n+\n   private AbstractCompiler compiler;\n-  \n+\n   /** The location abstraction used to calculate the effects of code */\n   private LocationAbstraction locationAbstraction;\n-  \n+\n   /** The kind of location abstraction to use */\n   private final LocationAbstractionMode locationAbstractionIdentifier;\n-  \n+\n   /**\n    * Constructs a new SideEffectsAnalysis with the given location abstraction.\n-   * \n+   *\n    * @param compiler A compiler instance\n    * @param locationAbstractionMode The location abstration to use. {@code\n    *    DEGENERATE} will use {@link DegenerateLocationAbstraction} while\n    *    {@code VISIBILITY_BASED} will use {@link VisibilityLocationAbstraction}\n-   *    \n+   *\n    */\n   public SideEffectsAnalysis(AbstractCompiler compiler,\n       LocationAbstractionMode locationAbstractionMode) {\n     this.compiler \u003d compiler;\n-    \n+\n     this.locationAbstractionIdentifier \u003d locationAbstractionMode;\n   }\n-  \n+\n   public SideEffectsAnalysis(AbstractCompiler compiler) {\n     this(compiler, LocationAbstractionMode.DEGENERATE);\n   }\n-  \n+\n   @Override\n   public void process(Node externs, Node root) {\n     switch(locationAbstractionIdentifier) {\n@@ -105,71 +105,71 @@\n         locationAbstraction \u003d new DegenerateLocationAbstraction();\n         break;\n       case VISIBILITY_BASED:\n-        locationAbstraction \u003d createVisibilityAbstraction(externs, root); \n+        locationAbstraction \u003d createVisibilityAbstraction(externs, root);\n         break;\n       default:\n         throw new IllegalStateException(\"Unrecognized location abstraction \" +\n             \"identifier: \" + locationAbstractionIdentifier);\n     }\n-    \n+\n     // In the future, this method\n     // will construct a callgraph and calculate side effects summaries\n     // for all functions.\n     // TODO(dcc): Add per-function side effects summaries.\n   }\n-  \n+\n   private LocationAbstraction createVisibilityAbstraction(Node externs,\n       Node root) {\n     VariableVisibilityAnalysis variableVisibility \u003d\n         new VariableVisibilityAnalysis(compiler);\n-  \n+\n     variableVisibility.process(externs, root);\n-  \n+\n     VariableUseDeclarationMap variableMap \u003d\n         new VariableUseDeclarationMap(compiler);\n-  \n+\n     variableMap.mapUses(root);\n-  \n+\n    return new VisibilityLocationAbstraction(compiler,\n        variableVisibility, variableMap);\n   }\n-  \n+\n   /**\n-   * Determines whether it is safe to move code ({@code source}) across \n+   * Determines whether it is safe to move code ({@code source}) across\n    * an environment to another program point (immediately preceding\n    * {@code destination}).\n-   * \n-   * \u003cp\u003eThe notion of \"environment\" is optimization-specific, but it should \n+   *\n+   * \u003cp\u003eThe notion of \"environment\" is optimization-specific, but it should\n    * include any code that could be executed between the source program point\n    * and the destination program point.\n-   * \n-   * {@code destination} must not be a descendant of {@code source}. \n-   *  \n+   *\n+   * {@code destination} must not be a descendant of {@code source}.\n+   *\n    * @param source The node that would be moved\n    * @param environment An environment representing the code across which\n    *    the source will be moved.\n    * @param destination The node before which the source would be moved\n    * @return Whether it is safe to move the source to the destination\n    */\n-  public boolean safeToMoveBefore(Node source, \n+  public boolean safeToMoveBefore(Node source,\n       AbstractMotionEnvironment environment,\n       Node destination) {\n     Preconditions.checkNotNull(locationAbstraction);\n     Preconditions.checkArgument(!nodeHasAncestor(destination, source));\n-    \n+\n     // It is always safe to move pure code.\n     if (isPure(source)) {\n       return true;\n     }\n \n-    // Don\u0027t currently support interprocedural analysis   \n+    // Don\u0027t currently support interprocedural analysis\n     if (nodeHasCall(source)) {\n       return false;\n     }\n-    \n+\n     LocationSummary sourceLocationSummary \u003d\n         locationAbstraction.calculateLocationSummary(source);\n-    \n+\n     EffectLocation sourceModSet \u003d sourceLocationSummary.getModSet();\n \n     // If the source has side effects, then we require that the source\n@@ -182,16 +182,16 @@\n     EffectLocation sourceRefSet \u003d sourceLocationSummary.getRefSet();\n \n     Set\u003cNode\u003e environmentNodes \u003d environment.calculateEnvironment();\n-    \n+\n     for (Node environmentNode : environmentNodes) {\n       if (nodeHasCall(environmentNode)) {\n         return false;\n       }\n     }\n-      \n+\n     LocationSummary environmentLocationSummary \u003d\n         locationAbstraction.calculateLocationSummary(environmentNodes);\n-    \n+\n     EffectLocation environmentModSet \u003d environmentLocationSummary.getModSet();\n \n     EffectLocation environmentRefSet \u003d environmentLocationSummary.getRefSet();\n@@ -210,13 +210,13 @@\n         \u0026\u0026 !environmentRefSet.intersectsLocation(sourceModSet)\n         \u0026\u0026 !environmentModSet.intersectsLocation(sourceModSet)) {\n       return true;\n-    } \n+    }\n \n     return false;\n   }\n-  \n+\n   /**\n-   * Returns true if the node is pure, that is it side effect free and does it \n+   * Returns true if the node is pure, that is it side effect free and does it\n    * not depend on its environment?\n    */\n   private boolean isPure(Node node) {\n@@ -224,47 +224,47 @@\n     // TODO(dcc): Implement isPure().\n     return false;\n   }\n-  \n+\n   /**\n-   * Returns true if the two nodes have the same control flow properties, \n+   * Returns true if the two nodes have the same control flow properties,\n    * that is, is node1 be executed every time node2 is executed and vice versa?\n    */\n   private static boolean nodesHaveSameControlFlow(Node node1, Node node2) {\n     /*\n      * We conservatively approximate this with the following criteria:\n-     * \n+     *\n      * Define the \"deepest control dependent block\" for a node to be the\n      * closest ancestor whose *parent* is a control structure and where that\n      * ancestor may or may be executed depending on the parent.\n-     * \n+     *\n      * So, for example, in:\n      * if (a) {\n      *  b;\n      * } else {\n      *  c;\n      * }\n-     * \n+     *\n      * a has not deepest control dependent block.\n      * b\u0027s deepest control dependent block is the \"then\" block of the IF.\n      * c\u0027s deepest control dependent block is the \"else\" block of the IF.\n-     * \n+     *\n      * We\u0027ll say two nodes have the same control flow if\n-     * \n+     *\n      * 1) they have the same deepest control dependent block\n      * 2) that block is either a CASE (which can\u0027t have early exits) or it\n      * doesn\u0027t have any early exits (e.g. breaks, continues, returns.)\n-     * \n+     *\n      */\n-    \n+\n     Node node1DeepestControlDependentBlock \u003d\n         closestControlDependentAncestor(node1);\n-    \n+\n     Node node2DeepestControlDependentBlock \u003d\n       closestControlDependentAncestor(node2);\n-    \n-    if (node1DeepestControlDependentBlock \u003d\u003d \n+\n+    if (node1DeepestControlDependentBlock \u003d\u003d\n         node2DeepestControlDependentBlock) {\n-      \n+\n       if (node2DeepestControlDependentBlock !\u003d null) {\n         // CASE is complicated because we have to deal with fall through and\n         // because some BREAKs are early exits and some are not.\n@@ -274,7 +274,7 @@\n         if (node2DeepestControlDependentBlock.getType() \u003d\u003d Token.CASE) {\n           return false;\n         }\n-        \n+\n         // Don\u0027t allow breaks, continues, returns in control dependent\n         // block because we don\u0027t actually create a control-flow graph\n         // and so don\u0027t know if early exits site between the source\n@@ -284,7 +284,7 @@\n         // moving in the following case:\n         // while (a) {\n         //   source();\n-        //  \n+        //\n         //   while(b) {\n         //     break;\n         //   }\n@@ -300,13 +300,13 @@\n           @Override\n           public boolean apply(Node input) {\n             int nodeType \u003d input.getType();\n-            \n+\n             return nodeType \u003d\u003d Token.RETURN\n                 || nodeType \u003d\u003d Token.BREAK\n                 || nodeType \u003d\u003d Token.CONTINUE;\n           }\n         };\n-        \n+\n         return !NodeUtil.has(node2DeepestControlDependentBlock,\n             isEarlyExitPredicate, NOT_FUNCTION_PREDICATE);\n       } else {\n@@ -316,28 +316,28 @@\n       return false;\n     }\n   }\n-  \n+\n   /**\n    * Returns true if the number of times the child executes depends on the\n    * parent.\n-   * \n+   *\n    * For example, the guard of an IF is not control dependent on the\n    * IF, but its two THEN/ELSE blocks are.\n-   * \n+   *\n    * Also, the guard of WHILE and DO are control dependent on the parent\n    * since the number of times it executes depends on the parent.\n    */\n   private static boolean isControlDependentChild(Node child) {\n     Node parent \u003d child.getParent();\n-    \n+\n     if (parent \u003d\u003d null) {\n       return false;\n     }\n-    \n+\n     ArrayList\u003cNode\u003e siblings \u003d Lists.newArrayList(parent.children());\n-    \n+\n     int indexOfChildInParent \u003d siblings.indexOf(child);\n-    \n+\n     switch(parent.getType()) {\n       case Token.IF:\n       case Token.HOOK:\n@@ -356,43 +356,43 @@\n         return true;\n       case Token.FUNCTION:\n         return true;\n-      \n+\n       default:\n         return false;\n     }\n   }\n-  \n-  private static Node closestControlDependentAncestor(Node node) { \n+\n+  private static Node closestControlDependentAncestor(Node node) {\n     if (isControlDependentChild(node)) {\n       return node;\n     }\n-    \n+\n     // Note: node is not considered one of its ancestors\n     for (Node ancestor : node.getAncestors()) {\n       if (isControlDependentChild(ancestor)) {\n         return ancestor;\n       }\n     }\n-      \n+\n     return null;\n   }\n-  \n+\n   /**\n    * Returns true if {@code possibleAncestor} is an ancestor of{@code node}.\n    * A node is not considered to be an ancestor of itself.\n    */\n   private static boolean nodeHasAncestor(Node node, Node possibleAncestor) {\n     // Note node is not in node.getAncestors()\n-    \n+\n     for (Node ancestor : node.getAncestors()) {\n       if (ancestor \u003d\u003d possibleAncestor) {\n         return true;\n       }\n     }\n-   \n+\n     return false;\n   }\n-  \n+\n   /**\n    * Returns true if a node has a CALL or a NEW descendant.\n    */\n@@ -404,27 +404,27 @@\n       }},\n       NOT_FUNCTION_PREDICATE);\n   }\n-   \n+\n   /**\n    * Represents an environment across which code might be moved, i.e. the set\n    * of code that could be run in between the source and the destination.\n-   * \n+   *\n    * SideEffectAnalysis characterizes the code to be moved and the environment\n    * in order to determine if they interact in such a way as to make the move\n    * unsafe.\n-   * \n+   *\n    * Since determining the environment for an optimization can be tricky,\n    * we provide several concrete subclasses that common classes of optimizations\n    * may be able to reuse.\n    */\n   public abstract static class AbstractMotionEnvironment {\n-    \n+\n     /**\n      * Calculates the set of nodes that this environment represnts.\n      */\n     public abstract Set\u003cNode\u003e calculateEnvironment();\n   }\n-  \n+\n   /**\n    * An environment for motion within a function. Given a\n    * control flow graph and a source and destination node in the control\n@@ -433,30 +433,30 @@\n    */\n   public static class IntraproceduralMotionEnvironment\n       extends AbstractMotionEnvironment {\n-       \n+\n     /**\n      * Creates an intraprocedural motion environment.\n-     * \n+     *\n      * @param controlFlowGraph A control flow graph for function in which\n      * code will be moved\n      * @param cfgSource The code to be moved\n-     * @param cfgDestination The node immediately before which cfgSource \n+     * @param cfgDestination The node immediately before which cfgSource\n      * will be moved\n      */\n     public IntraproceduralMotionEnvironment(\n         ControlFlowGraph\u003cNode\u003e controlFlowGraph,\n         Node cfgSource,\n         Node cfgDestination) {\n-      \n+\n     }\n-    \n+\n     @Override\n     public Set\u003cNode\u003e calculateEnvironment() {\n       // TODO(dcc): Implement IntraproceduralMotionEnvironment\n       return null;\n-    } \n+    }\n   }\n-  \n+\n   /**\n    * An environment for motion between modules. Given a\n    * module graph and as well as source and destination nodes and modules,\n@@ -468,7 +468,7 @@\n \n     /**\n      * Creates a cross module code motion environment.\n-     * \n+     *\n      * @param sourceNode The code to be moved\n      * @param sourceModule The module for the code to be moved\n      * @param destinationNode The node before which sourceNode will be inserted\n@@ -480,9 +480,9 @@\n         Node destinationNode,\n         JSModule destinationModule,\n         JSModuleGraph moduleGraph) {\n-      \n+\n     }\n-    \n+\n     @Override\n     public Set\u003cNode\u003e calculateEnvironment() {\n       // TODO(dcc): Implement CrossModuleMotionEnvironment\n@@ -501,61 +501,61 @@\n     public RawMotionEnvironment(Set\u003cNode\u003e environment) {\n       this.environment \u003d environment;\n     }\n-    \n+\n     @Override\n     public Set\u003cNode\u003e calculateEnvironment() {\n       return environment;\n     }\n   }\n-  \n+\n   /*\n    * A combined representation for location set summaries.\n-   * \n+   *\n    * Basically, it is often easier to shuffle MOD/REF around together; this is\n    * a value class for that purpose.\n    */\n   private static class LocationSummary {\n-    \n+\n     private EffectLocation modSet;\n     private EffectLocation refSet;\n-    \n+\n     public LocationSummary(EffectLocation modSet, EffectLocation refSet) {\n       this.modSet \u003d modSet;\n       this.refSet \u003d refSet;\n     }\n-    \n+\n     public EffectLocation getModSet() {\n       return modSet;\n     }\n-    \n+\n     public EffectLocation getRefSet() {\n       return refSet;\n-    }   \n+    }\n   }\n-  \n+\n   /**\n    * Interface representing the notion of an effect location -- an abstract\n    * location that can be modified or referenced.\n-   * \n+   *\n    * \u003cp\u003eSince there are an infinite number of possible concrete locations\n    * in a running program, this abstraction must be imprecise (i.e. there\n    * will be some distinct concrete locations that are indistinguishable\n    * under the abstraction).\n-   * \n+   *\n    * \u003cp\u003eDifferent location abstractions will provide their\n    * own implementations of this interface, based on the level and kind\n    * of precision they provide.\n    */\n   private static interface EffectLocation {\n-    \n+\n     /**\n      * Does the receiver\u0027s effect location intersect a given effect location?\n-     * That is, could any of the concrete storage locations (fields, variables, \n+     * That is, could any of the concrete storage locations (fields, variables,\n      * etc.) represented by the receiver be contained in the set of concrete\n      * storage locations represented by the given abstract effect location.\n      */\n     public boolean intersectsLocation(EffectLocation otherLocation);\n-    \n+\n     /**\n      * Returns the result of merging the given effect location with\n      * the receiver. The concrete locations represented by the result must\n@@ -564,52 +564,52 @@\n      * introduce a loss of precision).\n      */\n     public EffectLocation join(EffectLocation otherLocation);\n-    \n+\n     /**\n      * Does the effect location represent any possible concrete locations?\n      */\n     public boolean isEmpty();\n   }\n-  \n+\n   /**\n    * An abstract class representing a location abstraction. (Here \"abstraction\"\n    * means an imprecise representation of concrete side effects.)\n-   * \n-   * \u003cp\u003eImplementations of this class will each provide own their \n+   *\n+   * \u003cp\u003eImplementations of this class will each provide own their\n    * implementation(s) of SideEffectLocation and methods to determine the side\n    * effect locations of a given piece of code.\n    */\n   private abstract static class LocationAbstraction  {\n-       \n+\n     /** Calculates the abstraction-specific side effects\n      * for the node.\n      */\n     abstract LocationSummary calculateLocationSummary(Node node);\n-    \n+\n     /**\n      * Returns an abstraction-specific EffectLocation representing\n      * no location.\n-     * \n+     *\n      * \u003cp\u003eThe bottom location joined with any location should return\n      * that location.\n      */\n     abstract EffectLocation getBottomLocation();\n \n-    /** \n+    /**\n      * Calculates the abstraction-specific side effects\n      * for the node.\n      */\n-    public LocationSummary calculateLocationSummary(Set\u003cNode\u003e nodes) {     \n+    public LocationSummary calculateLocationSummary(Set\u003cNode\u003e nodes) {\n       EffectLocation modAccumulator \u003d getBottomLocation();\n       EffectLocation refAccumulator \u003d getBottomLocation();\n-          \n+\n       for (Node node : nodes) {\n         LocationSummary nodeLocationSummary \u003d calculateLocationSummary(node);\n-         \n+\n         modAccumulator \u003d modAccumulator.join(nodeLocationSummary.getModSet());\n         refAccumulator \u003d refAccumulator.join(nodeLocationSummary.getRefSet());\n       }\n-     \n+\n       return new LocationSummary(modAccumulator, refAccumulator);\n     }\n   }\n@@ -617,30 +617,30 @@\n    * A very imprecise location abstraction in which there are only two abstract\n    * locations: one representing all concrete locations and one for bottom\n    * (no concrete locations).\n-   * \n+   *\n    * This implementation is a thin wrapper on NodeUtil.mayHaveSideEffects()\n    * and NodeUtil.canBeSideEffected() -- it doesn\u0027t add any real value other\n    * than to prototype the LocationAbstraction interface.\n    */\n-  private static class DegenerateLocationAbstraction \n+  private static class DegenerateLocationAbstraction\n       extends LocationAbstraction {\n-    \n+\n     private static final EffectLocation EVERY_LOCATION \u003d\n         new DegenerateEffectLocation();\n-    \n+\n     private static final EffectLocation NO_LOCATION \u003d\n         new DegenerateEffectLocation();\n-    \n+\n     @Override\n     EffectLocation getBottomLocation() {\n       return NO_LOCATION;\n     }\n-    \n+\n     @Override\n     public LocationSummary calculateLocationSummary(Node node) {\n       return new LocationSummary(calculateModSet(node), calculateRefSet(node));\n     }\n-    \n+\n     EffectLocation calculateRefSet(Node node) {\n       if (NodeUtil.canBeSideEffected(node)) {\n         return EVERY_LOCATION;\n@@ -648,7 +648,7 @@\n         return NO_LOCATION;\n       }\n     }\n-    \n+\n     EffectLocation calculateModSet(Node node) {\n       if (NodeUtil.mayHaveSideEffects(node)) {\n         return EVERY_LOCATION;\n@@ -656,7 +656,7 @@\n         return NO_LOCATION;\n       }\n     }\n-    \n+\n     private static class DegenerateEffectLocation implements EffectLocation {\n        public EffectLocation join(EffectLocation otherLocation) {\n         if (otherLocation \u003d\u003d EVERY_LOCATION) {\n@@ -665,65 +665,65 @@\n           return this;\n         }\n       }\n-      \n+\n       public boolean intersectsLocation(EffectLocation otherLocation) {\n         return this \u003d\u003d EVERY_LOCATION \u0026\u0026 otherLocation \u003d\u003d EVERY_LOCATION;\n       }\n-      \n+\n       public boolean isEmpty() {\n         return this \u003d\u003d NO_LOCATION;\n       }\n     }\n   }\n-  \n+\n   /**\n    * A location abstraction based on the visibility of concrete locations.\n-   * \n+   *\n    * A global variables are treated as one common location, as are all heap\n    * storage locations.\n-   * \n+   *\n    * Local variables are broken up into two classes, one for truly local\n    * variables and one for local variables captured by an inner scope. Each\n    * of these classes has their own separate location representing the\n    * variables in the class.\n-   * \n+   *\n    * Parameter variables are considered to be heap locations since they\n    * can be accessed via the arguments object which itself can be aliased.\n-   * \n+   *\n    * A more precise analysis could:\n    *    1) put parameters on the heap only when \"arguments\" is actually used\n    *        in a method\n    *    2) recognize that GETPROPs cannot access or modify parameters, only\n    *        GETELEMs\n-   *        \n+   *\n    * TODO(dcc): Don\u0027t merge parameters with the heap unless necessary.\n-   * \n+   *\n    * Internally, abstract locations are represented as integers\n    * with bits set (masks) representing the storage classes in the location, so\n    * that joining is bit-wise ORing and intersection is bitwise AND.\n    */\n-  private static class VisibilityLocationAbstraction \n+  private static class VisibilityLocationAbstraction\n       extends LocationAbstraction {\n \n     /** The \"bottom\" location. Used to signify an empty location set */\n     private static final int VISIBILITY_LOCATION_NONE \u003d 0;\n-    \n+\n     /** The \"top\" location. Used to signify the set containing all locations */\n     private static final int UNKNOWN_LOCATION_MASK \u003d 0xFFFFFFFF;\n-    \n+\n     private static final int LOCAL_VARIABLE_LOCATION_MASK \u003d 1 \u003c\u003c 1;\n-        \n+\n     private static final int CAPTURED_LOCAL_VARIABLE_LOCATION_MASK \u003d 1 \u003c\u003c 2;\n-    \n+\n     private static final int GLOBAL_VARIABLE_LOCATION_MASK \u003d 1 \u003c\u003c 3;\n-    \n+\n     private static final int HEAP_LOCATION_MASK \u003d 1 \u003c\u003c 4;\n-    \n+\n     AbstractCompiler compiler;\n-    \n+\n     VariableVisibilityAnalysis variableVisibilityAnalysis;\n     VariableUseDeclarationMap variableUseMap;\n-    \n+\n     private VisibilityLocationAbstraction(AbstractCompiler compiler,\n         VariableVisibilityAnalysis variableVisibilityAnalysis,\n         VariableUseDeclarationMap variableUseMap) {\n@@ -731,41 +731,41 @@\n       this.variableVisibilityAnalysis \u003d variableVisibilityAnalysis;\n       this.variableUseMap \u003d variableUseMap;\n     }\n-    \n+\n     /**\n      * Calculates the MOD/REF summary for the given node.\n      */\n     @Override\n     LocationSummary calculateLocationSummary(Node node) {\n       int visibilityRefLocations \u003d VISIBILITY_LOCATION_NONE;\n-      int visibilityModLocations \u003d VISIBILITY_LOCATION_NONE;    \n-      \n+      int visibilityModLocations \u003d VISIBILITY_LOCATION_NONE;\n+\n       for (Node reference : findStorageLocationReferences(node)) {\n         int effectMask;\n-        \n+\n         if (NodeUtil.isName(reference)) {\n           // Variable access\n           effectMask \u003d effectMaskForVariableReference(reference);\n          } else {\n-          // Heap access       \n+          // Heap access\n           effectMask \u003d HEAP_LOCATION_MASK;\n         }\n-        \n+\n         if (storageNodeIsLValue(reference)) {\n           visibilityModLocations |\u003d effectMask;\n         }\n-        \n+\n         if (storageNodeIsRValue(reference)) {\n           visibilityRefLocations |\u003d effectMask;\n         }\n-      }      \n-          \n+      }\n+\n       VisibilityBasedEffectLocation modSet \u003d\n           new VisibilityBasedEffectLocation(visibilityModLocations);\n-      \n+\n       VisibilityBasedEffectLocation refSet \u003d\n         new VisibilityBasedEffectLocation(visibilityRefLocations);\n-            \n+\n       return new LocationSummary(modSet, refSet);\n     }\n \n@@ -775,35 +775,35 @@\n      */\n     private Set\u003cNode\u003e findStorageLocationReferences(Node root) {\n       final Set\u003cNode\u003e references \u003d Sets.newHashSet();\n- \n+\n       NodeTraversal.traverse(compiler, root, new AbstractShallowCallback() {\n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n           if (NodeUtil.isGet(n)\n               || (NodeUtil.isName(n) \u0026\u0026 !NodeUtil.isFunction(parent))) {\n             references.add(n);\n-          } \n-        }       \n+          }\n+        }\n       });\n-      \n+\n       return references;\n     }\n-    \n+\n     /**\n      * Calculates the effect mask for a variable reference.\n      */\n-    private int effectMaskForVariableReference(Node variableReference) { \n+    private int effectMaskForVariableReference(Node variableReference) {\n       Preconditions.checkArgument(NodeUtil.isName(variableReference));\n-      \n+\n       int effectMask \u003d VISIBILITY_LOCATION_NONE;\n-      \n-      Node declaringNameNode \u003d \n+\n+      Node declaringNameNode \u003d\n         variableUseMap.findDeclaringNameNodeForUse(variableReference);\n-      \n+\n       if (declaringNameNode !\u003d null) {\n-        VariableVisibility visibility \u003d \n+        VariableVisibility visibility \u003d\n           variableVisibilityAnalysis.getVariableVisibility(declaringNameNode);\n-                  \n+\n         switch (visibility) {\n           case LOCAL:\n             effectMask \u003d LOCAL_VARIABLE_LOCATION_MASK;\n@@ -820,101 +820,101 @@\n             effectMask \u003d GLOBAL_VARIABLE_LOCATION_MASK;\n             break;\n           default:\n-            throw new IllegalStateException(\"Unrecognized variable\" + \n+            throw new IllegalStateException(\"Unrecognized variable\" +\n                 \" visibility: \" + visibility);\n         }\n       } else {\n         // Couldn\u0027t find a variable for the reference\n         effectMask \u003d UNKNOWN_LOCATION_MASK;\n       }\n-           \n+\n       return effectMask;\n     }\n-    \n+\n     @Override\n     EffectLocation getBottomLocation() {\n       return new VisibilityBasedEffectLocation(VISIBILITY_LOCATION_NONE);\n     }\n-    \n+\n     /**\n      * Returns true if the node is a storage node.\n-     * \n+     *\n      * Only NAMEs, GETPROPs, and GETELEMs are storage nodes.\n      */\n     private static boolean isStorageNode(Node node) {\n       return NodeUtil.isName(node) || NodeUtil.isGet(node);\n     }\n-    \n+\n     /**\n      * Return true if the storage node is an r-value.\n      */\n     private static boolean storageNodeIsRValue(Node node) {\n       Preconditions.checkArgument(isStorageNode(node));\n-        \n+\n       // We consider all names to be r-values unless\n       // LHS of Token.ASSIGN\n       // LHS of of for in expression\n       // Child of VAR\n-      \n+\n       Node parent \u003d node.getParent();\n-      \n+\n       if (storageNodeIsLValue(node)) {\n         // Assume l-value is NOT an r-value\n         // unless it is a non-simple assign\n         // or an increment/decrement\n-        \n-        boolean nonSimpleAssign \u003d \n+\n+        boolean nonSimpleAssign \u003d\n           NodeUtil.isAssignmentOp(parent) \u0026\u0026 parent.getType() !\u003d Token.ASSIGN;\n-          \n-        return (nonSimpleAssign \n+\n+        return (nonSimpleAssign\n             || parent.getType() \u003d\u003d Token.DEC\n-            || parent.getType() \u003d\u003d Token.INC);      \n+            || parent.getType() \u003d\u003d Token.INC);\n       }\n-        \n+\n       return true;\n     }\n-    \n+\n     /**\n      * Return true if the storage node is an l-value.\n      */\n     private static boolean storageNodeIsLValue(Node node) {\n       Preconditions.checkArgument(isStorageNode(node));\n-     \n+\n       Node parent \u003d node.getParent();\n-   \n+\n       return (NodeUtil.isAssignmentOp(parent) \u0026\u0026 parent.getFirstChild() \u003d\u003d node)\n           || (NodeUtil.isForIn(parent) \u0026\u0026 parent.getFirstChild() \u003d\u003d node)\n           || NodeUtil.isVar(parent)\n           || parent.getType() \u003d\u003d Token.DEC\n           || parent.getType() \u003d\u003d Token.INC;\n     }\n-    \n+\n     /**\n      * An abstract effect location based the visibility of the\n      * concrete storage location.\n-     * \n+     *\n      * See {@link VisibilityLocationAbstraction} for deeper description\n      * of this abstraction.\n-     * \n+     *\n      * The effect locations are stored as bits set on an integer, so\n      * intersect, join, etc. are the standard bitwise operations.\n      */\n-    private static class VisibilityBasedEffectLocation \n+    private static class VisibilityBasedEffectLocation\n         implements EffectLocation {\n       int visibilityMask \u003d VISIBILITY_LOCATION_NONE;\n-      \n+\n       public VisibilityBasedEffectLocation(int visibilityMask) {\n         this.visibilityMask \u003d visibilityMask;\n       }\n-      \n+\n       @Override\n       public boolean intersectsLocation(EffectLocation otherLocation) {\n-        Preconditions.checkArgument(otherLocation instanceof \n+        Preconditions.checkArgument(otherLocation instanceof\n             VisibilityBasedEffectLocation);\n-        \n-        int otherMask \u003d \n+\n+        int otherMask \u003d\n             ((VisibilityBasedEffectLocation) otherLocation).visibilityMask;\n-        \n+\n         return (visibilityMask \u0026 otherMask) \u003e 0;\n       }\n \n@@ -925,19 +925,19 @@\n \n       @Override\n       public EffectLocation join(EffectLocation otherLocation) {\n-        Preconditions.checkArgument(otherLocation instanceof \n+        Preconditions.checkArgument(otherLocation instanceof\n             VisibilityBasedEffectLocation);\n-        \n-        int otherMask \u003d \n+\n+        int otherMask \u003d\n             ((VisibilityBasedEffectLocation) otherLocation).visibilityMask;\n-        \n+\n         int joinedMask \u003d visibilityMask | otherMask;\n-        \n-        return new VisibilityBasedEffectLocation(joinedMask);       \n-      }   \n+\n+        return new VisibilityBasedEffectLocation(joinedMask);\n+      }\n     }\n   }\n-  \n+\n   /**\n    * Maps NAME nodes that refer to variables to the NAME\n    * nodes that declared them.\n@@ -945,43 +945,43 @@\n   private static class VariableUseDeclarationMap {\n \n     private AbstractCompiler compiler;\n-    \n+\n     // Maps a using name to its declaring name\n     private Map\u003cNode, Node\u003e referencesByNameNode;\n-    \n+\n     public VariableUseDeclarationMap(AbstractCompiler compiler) {\n       this.compiler \u003d compiler;\n     }\n-    \n+\n     /**\n      * Adds a map from each use NAME in {@code root} to its corresponding\n      * declaring name, *provided the declaration is also under root*.\n-     * \n+     *\n      * If the declaration is not under root, then the reference will\n      * not be added to the map.\n      */\n     public void mapUses(Node root) {\n       referencesByNameNode \u003d Maps.newHashMap();\n-      \n-      ReferenceCollectingCallback callback \u003d \n-        new ReferenceCollectingCallback(compiler, \n+\n+      ReferenceCollectingCallback callback \u003d\n+        new ReferenceCollectingCallback(compiler,\n             ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);\n-      \n+\n       NodeTraversal.traverse(compiler, root, callback);\n-      \n+\n       for (Var variable : callback.getReferencedVariables()) {\n         ReferenceCollection referenceCollection \u003d\n             callback.getReferenceCollection(variable);\n-             \n-        for (Reference reference : referenceCollection.references) {      \n+\n+        for (Reference reference : referenceCollection.references) {\n          Node referenceNameNode \u003d reference.getNameNode();\n-          \n+\n           // Note that this counts a declaration as a reference to itself\n           referencesByNameNode.put(referenceNameNode, variable.getNameNode());\n         }\n       }\n     }\n-    \n+\n     /**\n      * Returns the NAME node for the declaration of the variable\n      * that {@code usingNameNode} refers to, if it is in the map,\n@@ -989,7 +989,7 @@\n      */\n     public Node findDeclaringNameNodeForUse(Node usingNameNode) {\n       Preconditions.checkArgument(NodeUtil.isName(usingNameNode));\n-      \n+\n       return referencesByNameNode.get(usingNameNode);\n     }\n   }\n",
      "operations": [
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/SimpleFunctionAliasAnalysis.java",
        "src/com/google/javascript/jscomp/SimpleFunctionAliasAnalysis.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.SimpleFunctionAliasAnalysis:isExposedToCallOrApply:[Node functionNode]:boolean",
            "com.google.javascript.jscomp.SimpleFunctionAliasAnalysis:analyze:[SimpleDefinitionFinder finder]:void",
            "com.google.javascript.jscomp.SimpleFunctionAliasAnalysis:updateFunctionForUse:[Node function, Node useNode]:void",
            "com.google.javascript.jscomp.SimpleFunctionAliasAnalysis:isAliased:[Node functionNode]:boolean"
          ],
          "num": 4
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.SimpleFunctionAliasAnalysis:isExposedToCallOrApply:[Node functionNode]:boolean",
            "com.google.javascript.jscomp.SimpleFunctionAliasAnalysis:updateFunctionForUse:[Node function, Node useNode]:void",
            "com.google.javascript.jscomp.SimpleFunctionAliasAnalysis:analyze:[SimpleDefinitionFinder finder]:void",
            "com.google.javascript.jscomp.SimpleFunctionAliasAnalysis:isAliased:[Node functionNode]:boolean"
          ],
          "num": 4
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "29",
            "34",
            "36",
            "39",
            "46",
            "49",
            "52",
            "59",
            "62",
            "69",
            "72",
            "75",
            "78",
            "81",
            "84",
            "85",
            "87",
            "89",
            "93",
            "100",
            "107"
          ],
          "num": 21
        },
        {
          "qualified_names": [
            "29",
            "34",
            "36",
            "39",
            "46",
            "49",
            "52",
            "59",
            "62",
            "69",
            "72",
            "75",
            "78",
            "81",
            "84",
            "85",
            "87",
            "89",
            "93",
            "100",
            "107"
          ],
          "num": 21
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/SimpleFunctionAliasAnalysis.java b/src/com/google/javascript/jscomp/SimpleFunctionAliasAnalysis.java\nindex 33704f8..11a8f88 100644\n--- a/src/com/google/javascript/jscomp/SimpleFunctionAliasAnalysis.java\n+++ b/src/com/google/javascript/jscomp/SimpleFunctionAliasAnalysis.java\n@@ -26,85 +26,85 @@\n /**\n  * Uses {@link SimpleDefinitionFinder} to determine if a function has been\n  * aliased or exposed to .call() or .apply().\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n class SimpleFunctionAliasAnalysis {\n   private Set\u003cNode\u003e aliasedFunctions;\n-  \n+\n   private Set\u003cNode\u003e functionsExposedToCallOrApply;\n-  \n+\n   /**\n    * Returns true if the function is aliased.\n-   * \n+   *\n    * Must only be called after {@link #analyze(SimpleDefinitionFinder)}\n    * has been called.\n    */\n   public boolean isAliased(Node functionNode) {\n     Preconditions.checkNotNull(aliasedFunctions);\n     Preconditions.checkArgument(NodeUtil.isFunction(functionNode));\n-    \n+\n     return aliasedFunctions.contains(functionNode);\n   }\n-  \n+\n   /**\n    * Returns true if the function ever exposed to .call() or .apply().\n-   * \n+   *\n    * Must only be called after {@link #analyze(SimpleDefinitionFinder)}\n    * has been called.\n    */\n   public boolean isExposedToCallOrApply(Node functionNode) {\n     Preconditions.checkNotNull(functionsExposedToCallOrApply);\n     Preconditions.checkArgument(NodeUtil.isFunction(functionNode));\n-    \n+\n     return functionsExposedToCallOrApply.contains(functionNode);\n   }\n-  \n+\n   /**\n    * Uses the provided {@link SimpleDefinitionFinder} to determine\n    * which functions are aliased or exposed to .call() or .apply().\n    */\n   public void analyze(SimpleDefinitionFinder finder) {\n     Preconditions.checkState(aliasedFunctions \u003d\u003d null);\n-    \n+\n     aliasedFunctions \u003d Sets.newHashSet();\n     functionsExposedToCallOrApply \u003d Sets.newHashSet();\n-    \n+\n     for (DefinitionSite definitionSite : finder.getDefinitionSites()) {\n       Definition definition \u003d definitionSite.definition;\n-      \n+\n       if (!definition.isExtern()) {\n         Node rValue \u003d definition.getRValue();\n-        \n+\n         if (rValue !\u003d null \u0026\u0026 NodeUtil.isFunction(rValue)) {\n           // rValue is a Token.FUNCTION from a definition\n-          \n+\n           for (UseSite useSite : finder.getUseSites(definition)) {\n             updateFunctionForUse(rValue, useSite.node);\n-          }          \n-        }     \n+          }\n+        }\n       }\n-    }   \n+    }\n   }\n-  \n+\n   /**\n    * Updates alias and exposure information based a site where the function is\n    * used.\n-   * \n+   *\n    * Note: this method may be called multiple times per Function, each time\n    * with a different useNode.\n    */\n   private void updateFunctionForUse(Node function, Node useNode) {\n     Node useParent \u003d useNode.getParent();\n     int parentType \u003d useParent.getType();\n-    \n+\n     if ((parentType \u003d\u003d Token.CALL || parentType \u003d\u003d Token.NEW)\n         \u0026\u0026 useParent.getFirstChild() \u003d\u003d useNode) {\n       // Regular call sites don\u0027t count as aliases\n     } else if (NodeUtil.isGet(useParent)) {\n       // GET{PROP,ELEM} don\u0027t count as aliases\n       // but we have to check for using them in .call and .apply.\n-      \n+\n       if (NodeUtil.isGetProp(useParent)) {\n         Node gramps \u003d useParent.getParent();\n         if (NodeUtil.isFunctionObjectApply(gramps) ||\n",
      "operations": []
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/Tracer.java",
        "src/com/google/javascript/jscomp/Tracer.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.Tracer:clearTracingStatisticsTestingOnly:[]:void",
            "com.google.javascript.jscomp.Tracer\\$TracingStatistic:enable:[]:boolean",
            "com.google.javascript.jscomp.Tracer:addTracingStatistic:[TracingStatistic tracingStatistic]:int",
            "com.google.javascript.jscomp.Tracer\\$AtomicTracerStatMap:incrementBy:[String key, long delta]:void",
            "com.google.javascript.jscomp.Tracer:stop:[int silence_threshold]:long",
            "com.google.javascript.jscomp.Tracer\\$TracingStatistic:getUnits:[]:String",
            "com.google.javascript.jscomp.Tracer\\$Event:toString:[long prevEventTime, String indent, int digitsColWidth]:String",
            "com.google.javascript.jscomp.Tracer\\$TracingStatistic:start:[Thread thread]:long",
            "com.google.javascript.jscomp.Tracer\\$ThreadTrace:endEvent:[Tracer t, int silenceThreshold]:void",
            "com.google.javascript.jscomp.Tracer\\$TracingStatistic:stop:[Thread thread]:long"
          ],
          "num": 10
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.Tracer\\$AtomicTracerStatMap:incrementBy:[String key, long delta]:void",
            "com.google.javascript.jscomp.Tracer\\$ThreadTrace:endEvent:[Tracer t, int silenceThreshold]:void",
            "com.google.javascript.jscomp.Tracer\\$Event:toString:[long prevEventTime, String indent, int digitsColWidth]:String",
            "com.google.javascript.jscomp.Tracer\\$TracingStatistic:stop:[Thread thread]:long",
            "com.google.javascript.jscomp.Tracer\\$TracingStatistic:getUnits:[]:String",
            "com.google.javascript.jscomp.Tracer\\$TracingStatistic:enable:[]:boolean",
            "com.google.javascript.jscomp.Tracer:addTracingStatistic:[TracingStatistic tracingStatistic]:int",
            "com.google.javascript.jscomp.Tracer:clearTracingStatisticsTestingOnly:[]:void",
            "com.google.javascript.jscomp.Tracer:stop:[int silence_threshold]:long",
            "com.google.javascript.jscomp.Tracer\\$TracingStatistic:start:[Thread thread]:long"
          ],
          "num": 10
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "124",
            "125",
            "126",
            "127",
            "128",
            "129",
            "130",
            "131",
            "132",
            "133",
            "134",
            "135",
            "136",
            "137",
            "138",
            "139",
            "140",
            "189",
            "190",
            "393",
            "401",
            "402",
            "431",
            "432",
            "683",
            "838",
            "841",
            "961",
            "982",
            "983",
            "985",
            "986",
            "991",
            "992",
            "994",
            "999",
            "1000",
            "1001",
            "1003",
            "1008",
            "1009",
            "1011",
            "1021",
            "1034",
            "1042",
            "1057"
          ],
          "num": 46
        },
        {
          "qualified_names": [
            "123",
            "172",
            "173",
            "174",
            "377",
            "378",
            "386",
            "387",
            "388",
            "417",
            "418",
            "419",
            "670",
            "671",
            "826",
            "827",
            "830",
            "831",
            "951",
            "952",
            "973",
            "974",
            "976",
            "977",
            "982",
            "983",
            "984",
            "986",
            "987",
            "992",
            "993",
            "994",
            "995",
            "997",
            "998",
            "1003",
            "1004",
            "1005",
            "1007",
            "1008",
            "1018",
            "1019",
            "1032",
            "1033",
            "1041",
            "1042",
            "1057",
            "1058"
          ],
          "num": 48
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/Tracer.java b/src/com/google/javascript/jscomp/Tracer.java\nindex 0f69695..7559850 100644\n--- a/src/com/google/javascript/jscomp/Tracer.java\n+++ b/src/com/google/javascript/jscomp/Tracer.java\n@@ -121,23 +121,6 @@\n  * several useful statistics such as cpu time, wait time, and memory usage.\n  * If you add your own tracing statistics, the output is not quite as pretty,\n  * but includes additional useful information.\n- * \u003cpre\u003e\n- *    31.980 Start        [LockManager] Waiting for user lock\n- *   9 31.989 Done    9 ms    0ms cpu;  5944bytes;  [LockManager] Waiting for user lock\n- *   0 31.989 Start        [CssClientImpl] ThreadGet (1 thread)\n- *   5 31.994 Done    5 ms    0ms cpu;  2832bytes;  [CssClientImpl] ThreadGet (1 thread)\n- *   0 31.994 Start        [MessageSorter] sort\n- *   0 31.994 Done    0 ms    0ms cpu;   600bytes;  [MessageSorter] sort\n- *   0 31.994 Start        [ConversationView] getMessageSummaries\n- *   0 31.994 Start        [ConversationView] creating message summary 0\n- *   1 31.995 Done    1 ms    0ms cpu;  5800bytes;  [ConversationView] creating message summary 0\n- *   0 31.995 Start        [ConversationView] creating message summary 1\n- *   0 31.995 Done    0 ms    0ms cpu;  5464bytes;  [ConversationView] creating message summary 1\n- *   . . .\n- * TOTAL NameDetector 3 (0 ms; 0 ms cpu;  784 bytes)\n- * TOTAL Format 4 (1 ms; 0 ms cpu; 7344 bytes)\n- * TOTAL ConversationView 5 (4 ms; 0 ms cpu; 55456 bytes)\n- \u003c/pre\u003e\n \n  * \u003cp\u003eIf a Trace is given a type (the first argument to the constructor) and\n  * multiple Traces are done on that type then a \"TOTAL line will be\n@@ -186,8 +169,9 @@\n    */\n   private static volatile boolean defaultPrettyPrint;\n \n-  /* This list is guaranteed to only increase in length.  It contains a list of additional\n-   * statistics that the user wants to keep track of.\n+  /* This list is guaranteed to only increase in length.  It contains\n+   * a list of additional statistics that the user wants to keep track\n+   * of.\n    */\n   private static List\u003cTracingStatistic\u003e extraTracingStatistics \u003d\n       new CopyOnWriteArrayList\u003cTracingStatistic\u003e();\n@@ -390,7 +374,8 @@\n     if (tracingStatistic.enable()) {\n       // No synchronization needed, since this is a copy-on-write array.\n       extraTracingStatistics.add(tracingStatistic);\n-      // 99.9% of the time, this will be O(1) and return extraTracingStatistics.length - 1\n+      // 99.9% of the time, this will be O(1) and return\n+      // extraTracingStatistics.length - 1\n       return extraTracingStatistics.lastIndexOf(tracingStatistic);\n     } else {\n       return -1;\n@@ -398,8 +383,9 @@\n   }\n \n   /**\n-   * For testing purposes only.  These removes all current tracers.  Severe errors can occur\n-   * if there are any active tracers going on when this is called.\n+   * For testing purposes only.  These removes all current tracers.\n+   * Severe errors can occur if there are any active tracers going on\n+   * when this is called.\n    *\n    * The test suite uses this to remove any tracers that it has added.\n    */\n@@ -428,8 +414,9 @@\n \n     stopTimeMs \u003d clock.currentTimeMillis();\n     if (extraTracingValues !\u003d null) {\n-      // We use extraTracingValues.length rather than extraTracingStatistics.size() because\n-      // a new statistic may have been added\n+      // We use extraTracingValues.length rather than\n+      // extraTracingStatistics.size() because a new statistic may\n+      // have been added\n       for (int i \u003d 0; i \u003c extraTracingValues.length; i++) {\n         long value \u003d extraTracingStatistics.get(i).stop(startThread);\n         extraTracingValues[i] \u003d value - extraTracingValues[i];\n@@ -680,7 +667,8 @@\n       if (prevEventTime \u003d\u003d -1) {\n         appendSpaces(sb, digitsColWidth);\n       } else {\n-        sb.append(longToPaddedString(eventTime() - prevEventTime, digitsColWidth));\n+        sb.append(longToPaddedString(\n+            eventTime() - prevEventTime, digitsColWidth));\n       }\n \n       sb.append(\u0027 \u0027);\n@@ -835,10 +823,12 @@\n         }\n \n         if (stat.extraInfo !\u003d null \u0026\u0026 t.extraTracingValues !\u003d null) {\n-          int overlapLength \u003d Math.min(stat.extraInfo.length, t.extraTracingValues.length);\n+          int overlapLength \u003d\n+              Math.min(stat.extraInfo.length, t.extraTracingValues.length);\n           for (int i \u003d 0; i \u003c overlapLength; i++) {\n             stat.extraInfo[i] +\u003d t.extraTracingValues[i];\n-            AtomicTracerStatMap map \u003d extraTracingStatistics.get(i).getTracingStat();\n+            AtomicTracerStatMap map \u003d\n+                extraTracingStatistics.get(i).getTracingStat();\n             if (map !\u003d null) {\n               map.incrementBy(t.type, t.extraTracingValues[i]);\n             }\n@@ -958,7 +948,8 @@\n   }\n \n   /** Holds the ThreadTrace for each thread.  */\n-  private static ThreadLocal\u003cThreadTrace\u003e traces \u003d new ThreadLocal\u003cThreadTrace\u003e();\n+  private static ThreadLocal\u003cThreadTrace\u003e traces \u003d\n+      new ThreadLocal\u003cThreadTrace\u003e();\n \n   /**\n    * Get the ThreadTrace for the current thread, creating one if necessary.\n@@ -979,36 +970,42 @@\n   }\n \n   /**\n-   * A TracingStatistic allows the program to add additional optional statistics to the trace\n-   * output.\n+   * A TracingStatistic allows the program to add additional optional\n+   * statistics to the trace output.\n    *\n-   * The class {@link com.google.monitoring.tracing.TracingStatistics} contains several\n-   * useful tracing statistics\n+   * The class {@link com.google.monitoring.tracing.TracingStatistics}\n+   * contains several useful tracing statistics\n    *\n    */\n   static interface TracingStatistic {\n     /**\n-     * This method is called at the start of the trace.  It should return a numeric result\n-     * indicating the amount of the specific resource in use before the call started\n+     * This method is called at the start of the trace.  It should\n+     * return a numeric result indicating the amount of the specific\n+     * resource in use before the call started\n      * @param thread  The current thread\n-     * @return   A numeric value indicating the amount of the resource already used.\n+     * @return A numeric value indicating the amount of the resource\n+     * already used.\n      */\n     long start(Thread thread);\n \n     /**\n-     * This method is called at the end of the trace.  It should return a numeric result\n-     * indicating the amount of the specific resource in use after the call ends. The actual\n-     * reported result will be the result end() - start()\n+     * This method is called at the end of the trace.  It should\n+     * return a numeric result indicating the amount of the specific\n+     * resource in use after the call ends. The actual reported result\n+     * will be the result end() - start()\n      * @param thread  The current thread\n-     * @return   A numeric value indicating the amount of the resource currently used.\n+     * @return A numeric value indicating the amount of the resource\n+     * currently used.\n      */\n     long stop(Thread thread);\n \n     /**\n-     * Called when this tracing statistic is first enabled.  A return value of True indicates that\n-     * this statistic can successfully run in the current JVM.\n+     * Called when this tracing statistic is first enabled.  A return\n+     * value of True indicates that this statistic can successfully\n+     * run in the current JVM.\n      *\n-     * @return  An indication of whether this statistic can be implemented in the current JVM.\n+     * @return An indication of whether this statistic can be\n+     * implemented in the current JVM.\n      */\n     boolean enable();\n \n@@ -1018,7 +1015,8 @@\n      */\n     AtomicTracerStatMap getTracingStat();\n \n-    /** A string that should be appended to the numeric output indicating what this is.\n+    /** A string that should be appended to the numeric output\n+     * indicating what this is.\n      *\n      * @return  A string indicating the units of this statistic and what it is.\n      */\n@@ -1031,7 +1029,8 @@\n    *\n    */\n   static final class AtomicTracerStatMap {\n-    private ConcurrentMap\u003cString, Long\u003e map \u003d new ConcurrentHashMap\u003cString, Long\u003e();\n+    private ConcurrentMap\u003cString, Long\u003e map \u003d\n+        new ConcurrentHashMap\u003cString, Long\u003e();\n \n     /**\n      * Atomically increment the specified field by the specified amount.\n@@ -1039,7 +1038,8 @@\n      * @param key      the name of the field\n      * @param delta    the amount by which to increment the field\n      */\n-    // Nullness checker is not powerful enough to prove null-safety of this method\n+    // Nullness checker is not powerful enough to prove null-safety of\n+    // this method\n     @SuppressWarnings(\"nullness\")\n         void incrementBy(String key, long delta) {\n       // We use a compareAndSet strategy to update the map, which is much\n@@ -1054,7 +1054,8 @@\n           // The slot was still empty when we set it\n           return;\n         } else {\n-          // Someone filled in the slot behind our back.  oldValue has its current value\n+          // Someone filled in the slot behind our back.  oldValue has\n+          // its current value\n         }\n       }\n       while (true) {\n",
      "operations": [
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Javadoc [12932,13181]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Javadoc [30906,31151]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TagElement [12941,13175]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TagElement [30915,31140]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Javadoc [31194,31519]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Javadoc [31556,31947]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Javadoc [31983,32271]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Javadoc [32460,32645]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: For testing purposes only.  These removes all current tracers. [12941,13003]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: Severe errors can occur if there are any active tracers going on [13009,13073]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: when this is called. [13079,13099]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: A TracingStatistic allows the program to add additional optional [30915,30979]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: statistics to the trace output. [30985,31016]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: contains several useful tracing statistics [31098,31140]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [31205,31380]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [31429,31511]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [31567,31806]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [31855,31939]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "TagElement [32464,32550]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: \u003c/pre\u003e [3374,3380]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: \u003cpre\u003e [3783,3788]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: 31.980 Start        [LockManager] Waiting for user lock [4225,4280]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: 9 31.989 Done    9 ms    0ms cpu;  5944bytes;  [LockManager] Waiting for user lock [4286,4368]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: 0 31.989 Start        [CssClientImpl] ThreadGet (1 thread) [4374,4432]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: 5 31.994 Done    5 ms    0ms cpu;  2832bytes;  [CssClientImpl] ThreadGet (1 thread) [4438,4521]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: 0 31.994 Start        [MessageSorter] sort [4527,4569]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: 0 31.994 Done    0 ms    0ms cpu;   600bytes;  [MessageSorter] sort [4575,4642]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: 0 31.994 Start        [ConversationView] getMessageSummaries [4648,4708]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: 0 31.994 Start        [ConversationView] creating message summary 0 [4714,4781]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: 1 31.995 Done    1 ms    0ms cpu;  5800bytes;  [ConversationView] creating message summary 0 [4787,4879]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: 0 31.995 Start        [ConversationView] creating message summary 1 [4885,4952]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: 0 31.995 Done    0 ms    0ms cpu;  5464bytes;  [ConversationView] creating message summary 1 [4958,5050]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: . . . [5056,5061]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: TOTAL NameDetector 3 (0 ms; 0 ms cpu;  784 bytes) [5065,5114]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: TOTAL Format 4 (1 ms; 0 ms cpu; 7344 bytes) [5118,5161]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: TOTAL ConversationView 5 (4 ms; 0 ms cpu; 55456 bytes) [5165,5219]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: For testing purposes only.  These removes all current tracers.  Severe errors can occur [13945,14032]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: if there are any active tracers going on when this is called. [14038,14099]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TagElement [13945,14175]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Javadoc [13936,14181]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: A TracingStatistic allows the program to add additional optional statistics to the trace [31857,31945]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: output. [31951,31958]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement:  contains several [32034,32051]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TextElement: useful tracing statistics [32057,32082]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "TagElement [31857,32082]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Javadoc [31848,32093]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TagElement [32147,32315]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TagElement [32364,32441]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Javadoc [32136,32449]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TagElement [32497,32729]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TagElement [32778,32857]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Javadoc [32486,32865]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "Javadoc [32901,33176]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TagElement [33369,33448]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Javadoc [33365,33543]",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/UnreachableCodeElimination.java",
        "src/com/google/javascript/jscomp/UnreachableCodeElimination.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.UnreachableCodeElimination:removeDeadExprStatementSafely:[Node n]:void"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.UnreachableCodeElimination:removeDeadExprStatementSafely:[Node n]:void"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "209"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "209",
            "210"
          ],
          "num": 2
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\nindex e6d4320..acc4388 100644\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n@@ -206,7 +206,8 @@\n         return;\n \n       case Token.BLOCK:\n-        // BLOCKs are used in several ways including wrapping CATCH blocks in TRYs\n+        // BLOCKs are used in several ways including wrapping CATCH\n+        // blocks in TRYs\n         if (parent.getType() \u003d\u003d Token.TRY) {\n           if (NodeUtil.isTryCatchNodeContainer(n)) {\n             return;\n",
      "operations": []
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java",
        "src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.VariableVisibilityAnalysis:getVariableVisibility:[Node declaringNameNode]:VariableVisibility",
            "com.google.javascript.jscomp.VariableVisibilityAnalysis:process:[Node externs, Node root]:void",
            "com.google.javascript.jscomp.VariableVisibilityAnalysis:VariableVisibilityAnalysis:[AbstractCompiler compiler]:null",
            "com.google.javascript.jscomp.VariableVisibilityAnalysis:variableIsParameter:[Var variable]:boolean"
          ],
          "num": 4
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.VariableVisibilityAnalysis:getVariableVisibility:[Node declaringNameNode]:VariableVisibility",
            "com.google.javascript.jscomp.VariableVisibilityAnalysis:variableIsParameter:[Var variable]:boolean",
            "com.google.javascript.jscomp.VariableVisibilityAnalysis:VariableVisibilityAnalysis:[AbstractCompiler compiler]:null",
            "com.google.javascript.jscomp.VariableVisibilityAnalysis:process:[Node externs, Node root]:void"
          ],
          "num": 4
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "32",
            "36",
            "42",
            "45",
            "48",
            "49",
            "51",
            "56",
            "60",
            "62",
            "68",
            "71",
            "74",
            "78",
            "84",
            "85",
            "94",
            "95",
            "100",
            "104",
            "107",
            "113",
            "114",
            "116",
            "118",
            "122",
            "124",
            "126",
            "129",
            "131",
            "139",
            "141",
            "143",
            "149"
          ],
          "num": 34
        },
        {
          "qualified_names": [
            "32",
            "36",
            "42",
            "45",
            "48",
            "49",
            "51",
            "56",
            "60",
            "62",
            "68",
            "71",
            "74",
            "78",
            "84",
            "85",
            "94",
            "95",
            "100",
            "104",
            "107",
            "113",
            "114",
            "116",
            "118",
            "122",
            "124",
            "126",
            "129",
            "131",
            "139",
            "141",
            "143",
            "149"
          ],
          "num": 34
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java b/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java\nindex 83caf94..4562983 100644\n--- a/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java\n+++ b/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java\n@@ -29,60 +29,60 @@\n  * An analysis pass that determines the visibility of variables -- that is,\n  * whether a variable is truly local, a local captured by an inner scope, a\n  * parameter, or a global variable.\n- * \n+ *\n  * SideEffectsAnalysis uses this class to partition a potentially infinite\n  * number of concrete storage locations into a (small) finite number of\n  * abstract storage locations based on a variable\u0027s storage visibility.\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n class VariableVisibilityAnalysis implements CompilerPass {\n \n   enum VariableVisibility {\n-    \n+\n     /** Local variable, not captured by closure */\n     LOCAL,\n-    \n+\n     /** Local variable captured by a closure */\n     CAPTURED_LOCAL,\n-    \n-    /** \n+\n+    /**\n      * Formal parameter declaration variable\n-     * \n+     *\n      * Parameters are different than local variables because they can be\n      * aliased by elements of the arguments object.\n      */\n     PARAMETER,\n-    \n+\n     /** A global variable */\n     GLOBAL\n   }\n-  \n+\n   private AbstractCompiler compiler;\n-  \n+\n   /**\n    * Maps the declaring name node for a variable to that variable\u0027s\n    * visibility.\n    */\n   private Map\u003cNode, VariableVisibility\u003e visibilityByDeclaringNameNode;\n-  \n+\n   public VariableVisibilityAnalysis(AbstractCompiler compiler) {\n     this.compiler \u003d compiler;\n-   \n+\n     visibilityByDeclaringNameNode \u003d Maps.newHashMap();\n   }\n-  \n+\n   /**\n    * Returns the visibility of of a variable, given that variable\u0027s declaring\n    * name node.\n-   * \n+   *\n    * The name node\u0027s parent must be one of:\n    * \u003cpre\u003e\n    *    Token.VAR (for a variable declaration)\n    *    Token.FUNCTION (for a function declaration)\n    *    Token.LP (for a function formal parameter)\n-   * \u003c/pre\u003e \n-   * \n+   * \u003c/pre\u003e\n+   *\n    * The returned visibility will be one of:\n    * \u003cpre\u003e\n    *    LOCAL_VARIABLE : the variable is a local variable used only in its\n@@ -91,44 +91,44 @@\n    *        closure\n    *     PARAMETER_VARIABLE : the variable is a formal parameter\n    *     GLOBAL_VARIABLE : the variable is declared in the global scope\n-   *  \u003c/pre\u003e  \n-   *    \n+   *  \u003c/pre\u003e\n+   *\n    * @param declaringNameNode The name node for a declaration.\n    */\n   public VariableVisibility getVariableVisibility(Node declaringNameNode) {\n     Node parent \u003d declaringNameNode.getParent();\n-    \n+\n     Preconditions.checkArgument(NodeUtil.isVar(parent)\n         || NodeUtil.isFunction(parent)\n         || parent.getType() \u003d\u003d Token.LP);\n-    \n+\n     return visibilityByDeclaringNameNode.get(declaringNameNode);\n   }\n- \n+\n   /**\n    * Determines the visibility class for each variable in root.\n    */\n   @Override\n   public void process(Node externs, Node root) {\n-    ReferenceCollectingCallback callback \u003d \n-      new ReferenceCollectingCallback(compiler, \n+    ReferenceCollectingCallback callback \u003d\n+      new ReferenceCollectingCallback(compiler,\n           ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);\n-    \n+\n     NodeTraversal.traverse(compiler, root, callback);\n-    \n+\n     for (Var variable : callback.getReferencedVariables()) {\n       ReferenceCollection referenceCollection \u003d\n           callback.getReferenceCollection(variable);\n-      \n+\n       VariableVisibility visibility;\n-      \n+\n       if (variableIsParameter(variable)) {\n-        visibility \u003d VariableVisibility.PARAMETER;     \n+        visibility \u003d VariableVisibility.PARAMETER;\n       } else if (variable.isLocal()) {\n         if (referenceCollection.isEscaped()) {\n-          visibility \u003d VariableVisibility.CAPTURED_LOCAL;        \n+          visibility \u003d VariableVisibility.CAPTURED_LOCAL;\n         } else {\n-          visibility \u003d VariableVisibility.LOCAL;          \n+          visibility \u003d VariableVisibility.LOCAL;\n         }\n       } else if (variable.isGlobal()) {\n         visibility \u003d VariableVisibility.GLOBAL;\n@@ -136,17 +136,17 @@\n         throw new IllegalStateException(\"Un-handled variable visibility for \" +\n             variable);\n       }\n-      \n+\n       visibilityByDeclaringNameNode.put(variable.getNameNode(), visibility);\n-    }   \n+    }\n   }\n-  \n+\n   /**\n    * Returns true if the variable is a formal parameter.\n    */\n   private static boolean variableIsParameter(Var variable) {\n     Node variableParent \u003d variable.getParentNode();\n-    \n+\n     return variableParent !\u003d null \u0026\u0026 variableParent.getType() \u003d\u003d Token.LP;\n   }\n }\n",
      "operations": [
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/deps/JsFunctionParser.java",
        "src/com/google/javascript/jscomp/deps/JsFunctionParser.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.deps.JsFunctionParser:JsFunctionParser:[Collection\u003cString\u003e functions, ErrorManager errorManager]:null",
            "com.google.javascript.jscomp.deps.JsFunctionParser:getPattern:[Collection\u003cString\u003e functions]:Pattern",
            "com.google.javascript.jscomp.deps.JsFunctionParser:parseLine:[String line]:boolean",
            "com.google.javascript.jscomp.deps.JsFunctionParser:parseFile:[String filePath, String fileContents]:Collection\u003cSymbolInfo\u003e",
            "com.google.javascript.jscomp.deps.JsFunctionParser:parseReader:[String filePath, Reader fileContents]:Collection\u003cSymbolInfo\u003e"
          ],
          "num": 5
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.deps.JsFunctionParser:parseFile:[String filePath, String fileContents]:Collection\u003cSymbolInfo\u003e",
            "com.google.javascript.jscomp.deps.JsFunctionParser:JsFunctionParser:[Collection\u003cString\u003e functions, ErrorManager errorManager]:null",
            "com.google.javascript.jscomp.deps.JsFunctionParser:getPattern:[Collection\u003cString\u003e functions]:Pattern",
            "com.google.javascript.jscomp.deps.JsFunctionParser:parseReader:[String filePath, Reader fileContents]:Collection\u003cSymbolInfo\u003e",
            "com.google.javascript.jscomp.deps.JsFunctionParser:parseLine:[String line]:boolean"
          ],
          "num": 5
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "32",
            "37",
            "41",
            "48",
            "58",
            "68",
            "77",
            "83",
            "87",
            "91",
            "94",
            "104",
            "108",
            "116",
            "133",
            "139"
          ],
          "num": 16
        },
        {
          "qualified_names": [
            "32",
            "37",
            "41",
            "48",
            "49",
            "59",
            "69",
            "70",
            "79",
            "85",
            "89",
            "93",
            "96",
            "106",
            "107",
            "111",
            "112",
            "120",
            "137",
            "143"
          ],
          "num": 20
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/deps/JsFunctionParser.java b/src/com/google/javascript/jscomp/deps/JsFunctionParser.java\nindex 8697246..2a013d2 100644\n--- a/src/com/google/javascript/jscomp/deps/JsFunctionParser.java\n+++ b/src/com/google/javascript/jscomp/deps/JsFunctionParser.java\n@@ -29,23 +29,24 @@\n \n /**\n  * A parser that can extract dependency information from a .js file.\n- * \n+ *\n  * @author agrieve@google.com (Andrew Grieve)\n  * @author ielashi@google.com (Islam El-Ashi)\n  */\n public class JsFunctionParser extends JsFileLineParser {\n-  \n+\n   public static class SymbolInfo {\n     public final String functionName;\n     public final String symbol;\n-    \n+\n     private SymbolInfo(String functionName, String symbol) {\n       this.functionName \u003d functionName;\n       this.symbol \u003d symbol;\n     }\n   }\n \n-  private static Logger logger \u003d Logger.getLogger(JsFunctionParser.class.getName());\n+  private static Logger logger \u003d\n+      Logger.getLogger(JsFunctionParser.class.getName());\n \n   /** Pattern for matching functions. */\n   private Pattern pattern;\n@@ -55,7 +56,7 @@\n \n   /** Symbols parsed. */\n   private Collection\u003cSymbolInfo\u003e symbols;\n-  \n+\n   /** Functions to parse */\n   private Collection\u003cString\u003e functionsToParse;\n \n@@ -65,7 +66,8 @@\n    * @param functions Functions to parse.\n    * @param errorManager Handles parse errors.\n    */\n-  public JsFunctionParser(Collection\u003cString\u003e functions, ErrorManager errorManager) {\n+  public JsFunctionParser(\n+      Collection\u003cString\u003e functions, ErrorManager errorManager) {\n     super(errorManager);\n     functionsToParse \u003d functions;\n     pattern \u003d getPattern(functions);\n@@ -74,24 +76,24 @@\n \n   /**\n    * Constructs a pattern to extract the arguments of the given functions.\n-   * \n+   *\n    * @param functions Functions to parse.\n    * @return A pattern to extract {@code functions}\u0027 arguments.\n    */\n   private Pattern getPattern(Collection\u003cString\u003e functions) {\n     StringBuilder sb \u003d new StringBuilder(\"(?:^|;)\\\\s*(\");\n-    \n+\n     for (String function : functions) {\n       sb.append(Pattern.quote(function) + \"|\");\n     }\n-    \n+\n     // remove last \u0027|\u0027\n     sb.deleteCharAt(sb.length() - 1);\n     sb.append(\")\\\\s*\\\\((.*?)\\\\)\");\n-    \n+\n     return Pattern.compile(sb.toString());\n   }\n-  \n+\n   /**\n    * Parses the given file and returns the dependency information that it\n    * contained.\n@@ -101,11 +103,13 @@\n    * @return A collection containing all symbols found in the\n    *     file.\n    */\n-  public Collection\u003cSymbolInfo\u003e parseFile(String filePath, String fileContents) {\n+  public Collection\u003cSymbolInfo\u003e parseFile(\n+      String filePath, String fileContents) {\n     return parseReader(filePath, new StringReader(fileContents));\n   }\n \n-  private Collection\u003cSymbolInfo\u003e parseReader(String filePath, Reader fileContents) {\n+  private Collection\u003cSymbolInfo\u003e parseReader(\n+      String filePath, Reader fileContents) {\n     symbols \u003d Lists.newArrayList();\n \n     logger.fine(\"Parsing Source: \" + filePath);\n@@ -113,7 +117,7 @@\n \n     return symbols;\n   }\n-  \n+\n   /**\n    * Parses a line of javascript, extracting dependency information.\n    */\n@@ -130,13 +134,13 @@\n         break;\n       }\n     }\n-    \n+\n     if (parseLine) {\n       matcher.reset(line);\n       while (matcher.find()) {\n         hasFunctions \u003d true;\n         String functionName \u003d matcher.group(1);\n-        String arg \u003d parseJsString(matcher.group(2)); // Parse the param.  \n+        String arg \u003d parseJsString(matcher.group(2)); // Parse the param.\n         symbols.add(new SymbolInfo(functionName, arg));\n       }\n     }\n",
      "operations": []
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/rhino/Decompiler.java",
        "src/com/google/javascript/rhino/Decompiler.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.rhino.Decompiler:decompile:[String source, int flags, UintMap properties]:String"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "com.google.javascript.rhino.Decompiler:decompile:[String source, int flags, UintMap properties]:String"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "1",
            "750"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "1",
            "750"
          ],
          "num": 2
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/rhino/Decompiler.java b/src/com/google/javascript/rhino/Decompiler.java\nindex e5309b6..fe038a3 100644\n--- a/src/com/google/javascript/rhino/Decompiler.java\n+++ b/src/com/google/javascript/rhino/Decompiler.java\n@@ -1,4 +1,4 @@\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n@@ -747,7 +747,7 @@\n             case Token.CONST:\n                 result.append(\"const \");\n                 break;\n-            \n+\n             case Token.NOT:\n                 result.append(\u0027!\u0027);\n                 break;\n",
      "operations": []
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/rhino/FunctionNode.java",
        "src/com/google/javascript/rhino/FunctionNode.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [],
          "num": 0
        },
        {
          "qualified_names": [],
          "num": 0
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "1"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "1"
          ],
          "num": 1
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/rhino/FunctionNode.java b/src/com/google/javascript/rhino/FunctionNode.java\nindex f81f923..baa2218 100644\n--- a/src/com/google/javascript/rhino/FunctionNode.java\n+++ b/src/com/google/javascript/rhino/FunctionNode.java\n@@ -1,4 +1,4 @@\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n",
      "operations": []
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "src/com/google/javascript/rhino/JSDocInfoBuilder.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.rhino.JSDocInfoBuilder:markTypeNode:[Node typeNode, int lineno, int startCharno, int endCharno, boolean hasLC]:void",
            "com.google.javascript.rhino.JSDocInfoBuilder:recordThrowDescription:[JSTypeExpression type, String description]:boolean",
            "com.google.javascript.rhino.JSDocInfoBuilder:markText:[String text, int startLineno, int startCharno, int endLineno, int endCharno]:void",
            "com.google.javascript.rhino.JSDocInfoBuilder:recordParameterDescription:[String parameterName, String description]:boolean"
          ],
          "num": 4
        },
        {
          "qualified_names": [
            "com.google.javascript.rhino.JSDocInfoBuilder:markText:[String text, int startLineno, int startCharno, int endLineno, int endCharno]:void",
            "com.google.javascript.rhino.JSDocInfoBuilder:recordThrowDescription:[JSTypeExpression type, String description]:boolean",
            "com.google.javascript.rhino.JSDocInfoBuilder:recordParameterDescription:[String parameterName, String description]:boolean",
            "com.google.javascript.rhino.JSDocInfoBuilder:markTypeNode:[Node typeNode, int lineno, int startCharno, int endCharno, boolean hasLC]:void"
          ],
          "num": 4
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "162",
            "163",
            "175",
            "176",
            "246",
            "288"
          ],
          "num": 6
        },
        {
          "qualified_names": [
            "162",
            "163",
            "175",
            "176",
            "246",
            "247",
            "289",
            "290"
          ],
          "num": 8
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/rhino/JSDocInfoBuilder.java b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\nindex b452bc8..b3d50da 100644\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n@@ -159,8 +159,8 @@\n   /**\n    * Adds a textual block to the current marker.\n    */\n-  public void markText(String text, int startLineno, int startCharno, int endLineno,\n-                int endCharno) {\n+  public void markText(String text, int startLineno, int startCharno,\n+      int endLineno, int endCharno) {\n     if (currentMarker !\u003d null) {\n       currentMarker.description \u003d new JSDocInfo.StringPosition();\n       currentMarker.description.setItem(text);\n@@ -172,8 +172,8 @@\n   /**\n    * Adds a type declaration to the current marker.\n    */\n-  public void markTypeNode(Node typeNode, int lineno, int startCharno, int endCharno,\n-                    boolean hasLC) {\n+  public void markTypeNode(Node typeNode, int lineno, int startCharno,\n+      int endCharno, boolean hasLC) {\n     if (currentMarker !\u003d null) {\n       currentMarker.type \u003d new JSDocInfo.TypePosition();\n       currentMarker.type.setItem(typeNode);\n@@ -243,7 +243,8 @@\n    * @return {@code true} if the parameter\u0027s description was recorded and\n    *     {@code false} if a parameter with the same name was already defined\n    */\n-  public boolean recordParameterDescription(String parameterName, String description) {\n+  public boolean recordParameterDescription(\n+      String parameterName, String description) {\n     if (currentInfo.documentParam(parameterName, description)) {\n       populated \u003d true;\n       return true;\n@@ -285,7 +286,8 @@\n    * @return {@code true} if the type\u0027s description was recorded and\n    *     {@code false} if a description with the same type was already defined\n    */\n-  public boolean recordThrowDescription(JSTypeExpression type, String description) {\n+  public boolean recordThrowDescription(\n+      JSTypeExpression type, String description) {\n     if (currentInfo.documentThrows(type, description)) {\n       populated \u003d true;\n       return true;\n",
      "operations": []
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/rhino/Kit.java",
        "src/com/google/javascript/rhino/Kit.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [],
          "num": 0
        },
        {
          "qualified_names": [],
          "num": 0
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "1"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "1"
          ],
          "num": 1
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/rhino/Kit.java b/src/com/google/javascript/rhino/Kit.java\nindex 19c6fd4..5570d37 100644\n--- a/src/com/google/javascript/rhino/Kit.java\n+++ b/src/com/google/javascript/rhino/Kit.java\n@@ -1,4 +1,4 @@\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n",
      "operations": []
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/rhino/ObjArray.java",
        "src/com/google/javascript/rhino/ObjArray.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [],
          "num": 0
        },
        {
          "qualified_names": [],
          "num": 0
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "1",
            "47",
            "48",
            "49"
          ],
          "num": 4
        },
        {
          "qualified_names": [
            "1",
            "47",
            "48",
            "49",
            "50"
          ],
          "num": 5
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/rhino/ObjArray.java b/src/com/google/javascript/rhino/ObjArray.java\nindex 4cd30fd..b896464 100644\n--- a/src/com/google/javascript/rhino/ObjArray.java\n+++ b/src/com/google/javascript/rhino/ObjArray.java\n@@ -1,4 +1,4 @@\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n@@ -44,9 +44,10 @@\n import java.io.ObjectOutputStream;\n \n /**\n-Implementation of resizable array with focus on minimizing memory usage by storing few initial array elements in object fields. Can also be used as a stack.\n-*/\n-\n+ * Implementation of resizable array with focus on minimizing memory\n+ * usage by storing few initial array elements in object fields. Can also\n+ * be used as a stack.\n+ */\n public class ObjArray implements Serializable\n {\n     static final long serialVersionUID \u003d 4174889037736658296L;\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "Javadoc [1733,1906]"
        },
        {
          "type": "delete-tree",
          "from": "Javadoc [1734,1897]",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/rhino/Parser.java",
        "src/com/google/javascript/rhino/Parser.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.rhino.Parser:bitXorExpr:[boolean inForInit]:Node",
            "com.google.javascript.rhino.Parser:memberExpr:[boolean allowCallSyntax]:Node",
            "com.google.javascript.rhino.Parser:statementHelper:[Node statementLabel]:Node",
            "com.google.javascript.rhino.Parser:memberExprTail:[boolean allowCallSyntax, Node pn]:Node"
          ],
          "num": 4
        },
        {
          "qualified_names": [
            "com.google.javascript.rhino.Parser:memberExprTail:[boolean allowCallSyntax, Node pn]:Node",
            "com.google.javascript.rhino.Parser:statementHelper:[Node statementLabel]:Node",
            "com.google.javascript.rhino.Parser:memberExpr:[boolean allowCallSyntax]:Node",
            "com.google.javascript.rhino.Parser:bitXorExpr:[boolean inForInit]:Node"
          ],
          "num": 4
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "1043",
            "1044",
            "1517",
            "1883",
            "1884",
            "1885",
            "1944"
          ],
          "num": 7
        },
        {
          "qualified_names": [
            "1043",
            "1044",
            "1045",
            "1518",
            "1519",
            "1885",
            "1886",
            "1887",
            "1888",
            "1889",
            "1948",
            "1949"
          ],
          "num": 12
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/rhino/Parser.java b/src/com/google/javascript/rhino/Parser.java\nindex dcd046b..95b720f 100644\n--- a/src/com/google/javascript/rhino/Parser.java\n+++ b/src/com/google/javascript/rhino/Parser.java\n@@ -1040,8 +1040,9 @@\n                     decompiler.addEOL(Token.LC);\n \n                     nf.addChildToBack(catchblocks,\n-                        nf.createCatch(varName, nameLineno, nameCharno, catchCond,\n-                             statements(), catchLineno, catchCharno));\n+                        nf.createCatch(\n+                            varName, nameLineno, nameCharno, catchCond,\n+                            statements(), catchLineno, catchCharno));\n \n                     mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n                     decompiler.addEOL(Token.RC);\n@@ -1514,7 +1515,8 @@\n             int lineno \u003d ts.getLineno();\n             int charno \u003d ts.getCharno();\n             decompiler.addToken(Token.BITXOR);\n-            pn \u003d nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit), lineno,\n+            pn \u003d nf.createBinary(\n+                Token.BITXOR, pn, bitAndExpr(inForInit), lineno,\n                 charno);\n         }\n         return pn;\n@@ -1880,9 +1882,11 @@\n              * do we claim to support?\n              */\n \n-            /* Experimental syntax:  allow an object literal to follow a new expression,\n-             * which will mean a kind of anonymous class built with the JavaAdapter.\n-             * the object literal will be passed as an additional argument to the constructor.\n+            /* Experimental syntax: allow an object literal to follow\n+             * a new expression, which will mean a kind of anonymous\n+             * class built with the JavaAdapter.  the object literal\n+             * will be passed as an additional argument to the\n+             * constructor.\n              */\n             tt \u003d peekToken();\n             if (tt \u003d\u003d Token.LC) {\n@@ -1941,7 +1945,8 @@\n                             // Dot\u0027s position\n                             lineno, charno,\n                             // Name\u0027s position\n-                            ts.getLineno(), ts.getCharno());                        break;\n+                            ts.getLineno(), ts.getCharno());\n+                        break;\n \n                       // handles: *, *::name, *::*, *::[expr]\n                       case Token.MUL:\n",
      "operations": []
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/rhino/ScriptOrFnNode.java",
        "src/com/google/javascript/rhino/ScriptOrFnNode.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [],
          "num": 0
        },
        {
          "qualified_names": [],
          "num": 0
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "1"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "1"
          ],
          "num": 1
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/rhino/ScriptOrFnNode.java b/src/com/google/javascript/rhino/ScriptOrFnNode.java\nindex 8939122..b242bbb 100644\n--- a/src/com/google/javascript/rhino/ScriptOrFnNode.java\n+++ b/src/com/google/javascript/rhino/ScriptOrFnNode.java\n@@ -1,4 +1,4 @@\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n",
      "operations": []
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/rhino/TokenStream.java",
        "src/com/google/javascript/rhino/TokenStream.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.rhino.TokenStream:stringToKeyword:[String name]:int"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "com.google.javascript.rhino.TokenStream:stringToKeyword:[String name]:int"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "196",
            "197",
            "198",
            "199",
            "200",
            "207",
            "208",
            "213",
            "222"
          ],
          "num": 9
        },
        {
          "qualified_names": [
            "196",
            "197",
            "198",
            "199",
            "200",
            "201",
            "202",
            "203",
            "204",
            "205",
            "206",
            "207",
            "208",
            "209",
            "210",
            "211",
            "212",
            "213",
            "214",
            "215",
            "222",
            "223",
            "224",
            "225",
            "226",
            "231",
            "232",
            "241",
            "242"
          ],
          "num": 29
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/rhino/TokenStream.java b/src/com/google/javascript/rhino/TokenStream.java\nindex b215cfb..23e3149 100644\n--- a/src/com/google/javascript/rhino/TokenStream.java\n+++ b/src/com/google/javascript/rhino/TokenStream.java\n@@ -193,24 +193,43 @@\n                 else if (c\u003d\u003d\u0027o\u0027) { if (s.charAt(0)\u003d\u003d\u0027d\u0027) {id\u003dId_do; break L0;} }\n                 break L;\n             case 3: switch (s.charAt(0)) {\n-                case \u0027f\u0027: if (s.charAt(2)\u003d\u003d\u0027r\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027o\u0027) {id\u003dId_for; break L0;} break L;\n-                case \u0027i\u0027: if (s.charAt(2)\u003d\u003d\u0027t\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027n\u0027) {id\u003dId_int; break L0;} break L;\n-                case \u0027n\u0027: if (s.charAt(2)\u003d\u003d\u0027w\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027e\u0027) {id\u003dId_new; break L0;} break L;\n-                case \u0027t\u0027: if (s.charAt(2)\u003d\u003d\u0027y\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027r\u0027) {id\u003dId_try; break L0;} break L;\n-                case \u0027v\u0027: if (s.charAt(2)\u003d\u003d\u0027r\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027a\u0027) {id\u003dId_var; break L0;} break L;\n+                case \u0027f\u0027:\n+                  if (s.charAt(2)\u003d\u003d\u0027r\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027o\u0027) {\n+                    id\u003dId_for; break L0;\n+                  } break L;\n+                case \u0027i\u0027:\n+                  if (s.charAt(2)\u003d\u003d\u0027t\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027n\u0027) {\n+                    id\u003dId_int; break L0;\n+                  } break L;\n+                case \u0027n\u0027:\n+                  if (s.charAt(2)\u003d\u003d\u0027w\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027e\u0027) {\n+                    id\u003dId_new; break L0;\n+                  } break L;\n+                case \u0027t\u0027:\n+                  if (s.charAt(2)\u003d\u003d\u0027y\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027r\u0027) {\n+                    id\u003dId_try; break L0;\n+                  } break L;\n+                case \u0027v\u0027:\n+                  if (s.charAt(2)\u003d\u003d\u0027r\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027a\u0027) {\n+                    id\u003dId_var; break L0;\n+                  } break L;\n                 } break L;\n             case 4: switch (s.charAt(0)) {\n                 case \u0027b\u0027: X\u003d\"byte\";id\u003dId_byte; break L;\n                 case \u0027c\u0027: c\u003ds.charAt(3);\n                     if (c\u003d\u003d\u0027e\u0027) { if (s.charAt(2)\u003d\u003d\u0027s\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027a\u0027) {\n                             id\u003dId_case; break L0;} }\n-                    else if (c\u003d\u003d\u0027r\u0027) { if (s.charAt(2)\u003d\u003d\u0027a\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027h\u0027) {\n-                            id\u003dId_char; break L0;} }\n+                    else if (c\u003d\u003d\u0027r\u0027) {\n+                      if (s.charAt(2)\u003d\u003d\u0027a\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027h\u0027) {\n+                        id\u003dId_char; break L0;\n+                      }\n+                    }\n                     break L;\n                 case \u0027e\u0027: c\u003ds.charAt(3);\n                     if (c\u003d\u003d\u0027e\u0027) { if (s.charAt(2)\u003d\u003d\u0027s\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027l\u0027) {\n                             id\u003dId_else; break L0;} }\n-                    else if (c\u003d\u003d\u0027m\u0027) { if (s.charAt(2)\u003d\u003d\u0027u\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027n\u0027) {\n+                    else if (c\u003d\u003d\u0027m\u0027) {\n+                      if (s.charAt(2)\u003d\u003d\u0027u\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027n\u0027) {\n                             id\u003dId_enum; break L0;} }\n                     break L;\n                 case \u0027g\u0027: X\u003d\"goto\";id\u003dId_goto; break L;\n@@ -219,7 +238,8 @@\n                 case \u0027t\u0027: c\u003ds.charAt(3);\n                     if (c\u003d\u003d\u0027e\u0027) { if (s.charAt(2)\u003d\u003d\u0027u\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027r\u0027) {\n                             id\u003dId_true; break L0;} }\n-                    else if (c\u003d\u003d\u0027s\u0027) { if (s.charAt(2)\u003d\u003d\u0027i\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027h\u0027) {\n+                    else if (c\u003d\u003d\u0027s\u0027) {\n+                      if (s.charAt(2)\u003d\u003d\u0027i\u0027 \u0026\u0026 s.charAt(1)\u003d\u003d\u0027h\u0027) {\n                             id\u003dId_this; break L0;} }\n                     break L;\n                 case \u0027v\u0027: X\u003d\"void\";id\u003dId_void; break L;\n",
      "operations": []
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/rhino/jstype/SimpleSlot.java",
        "src/com/google/javascript/rhino/jstype/SimpleSlot.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [],
          "num": 0
        },
        {
          "qualified_names": [],
          "num": 0
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "1",
            "39"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "1",
            "39"
          ],
          "num": 2
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/rhino/jstype/SimpleSlot.java b/src/com/google/javascript/rhino/jstype/SimpleSlot.java\nindex 5056753..d2dd726 100644\n--- a/src/com/google/javascript/rhino/jstype/SimpleSlot.java\n+++ b/src/com/google/javascript/rhino/jstype/SimpleSlot.java\n@@ -1,4 +1,4 @@\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n@@ -36,7 +36,7 @@\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n /**\n",
      "operations": []
    }
  ],
  "inducing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [],
      "num": 0
    },
    "add_functions": {
      "qualified_names": [],
      "num": 0
    },
    "delete_functions": {
      "qualified_names": [],
      "num": 0
    }
  },
  "trigger_tests": [
    {
      "test_class": "com.google.javascript.jscomp.ConvertToDottedPropertiesTest",
      "test_function": "testQuotedProps",
      "assertion_line": "72",
      "exception": "junit.framework.AssertionFailedError",
      "message": "Expected: ({\"a\\u0004b\":0})\nResult: ({a\u0004b:0})"
    },
    {
      "test_class": "com.google.javascript.jscomp.ConvertToDottedPropertiesTest",
      "test_function": "testDoNotConvert",
      "assertion_line": "58",
      "exception": "junit.framework.AssertionFailedError",
      "message": "Expected: a[\"A\\u0004\"]\nResult: a.A\u0004"
    }
  ],
  "fixing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/rhino/TokenStream.java",
        "src/com/google/javascript/rhino/TokenStream.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.rhino.TokenStream:isJSIdentifier:[String s]:boolean"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "com.google.javascript.rhino.TokenStream:isJSIdentifier:[String s]:boolean"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "193",
            "197"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "193",
            "194",
            "195",
            "197",
            "200",
            "201"
          ],
          "num": 6
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/rhino/TokenStream.java b/src/com/google/javascript/rhino/TokenStream.java\nindex 73fed17..cadb536 100644\n--- a/src/com/google/javascript/rhino/TokenStream.java\n+++ b/src/com/google/javascript/rhino/TokenStream.java\n@@ -190,11 +190,15 @@\n     public static boolean isJSIdentifier(String s) {\n       int length \u003d s.length();\n \n-      if (length \u003d\u003d 0 || !Character.isJavaIdentifierStart(s.charAt(0)))\n+      if (length \u003d\u003d 0 ||\n+          Character.isIdentifierIgnorable(s.charAt(0)) ||\n+          !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n+      }\n \n       for (int i \u003d 1; i \u003c length; i++) {\n-        if (!Character.isJavaIdentifierPart(s.charAt(i))) {\n+        if (Character.isIdentifierIgnorable(s.charAt(i)) ||\n+            !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n",
      "operations": [
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [8447,8478]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "InfixExpression [8317,8386]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "INFIX_EXPRESSION_OPERATOR: || [8329,8331]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodInvocation [8342,8386]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "InfixExpression [8533,8637]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodInvocation [8533,8577]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "INFIX_EXPRESSION_OPERATOR: || [8578,8580]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        }
      ]
    }
  ],
  "fixing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [],
      "num": 0
    },
    "add_functions": {
      "qualified_names": [],
      "num": 0
    },
    "delete_functions": {
      "qualified_names": [],
      "num": 0
    }
  },
  "patch_changed_mths": {
    "qualified_names": [],
    "num": 0
  }
}