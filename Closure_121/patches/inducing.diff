diff --git a/lib/google_common_deploy.jar b/lib/google_common_deploy.jar
index 07afade..eadc6c0 100755
--- a/lib/google_common_deploy.jar
+++ b/lib/google_common_deploy.jar
Binary files differ
diff --git a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java
index 3a51574..2f13758 100644
--- a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java
+++ b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java
@@ -494,7 +494,9 @@
           pathPrefix.charAt(pathPrefix.length() - 1) == File.separatorChar
               ? pathPrefix.substring(0, pathPrefix.length() - 1) : new File(
                   pathPrefix).getParent();
-      new File(dirName).mkdirs();
+      if (dirName != null) {
+        new File(dirName).mkdirs();
+      }
     }
   }
 
diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java
index 0e51823..881a640 100644
--- a/src/com/google/javascript/jscomp/CollapseProperties.java
+++ b/src/com/google/javascript/jscomp/CollapseProperties.java
@@ -210,7 +210,9 @@
 
       ReferenceCollection aliasRefs =
           collector.getReferenceCollection(aliasVar);
-      if (aliasRefs.isWellDefined() && aliasRefs.isNeverReassigned()) {
+      if (aliasRefs.isWellDefined()
+          && aliasRefs.firstReferenceIsAssigningDeclaration()
+          && aliasRefs.isAssignedOnce()) {
         // The alias is well-formed, so do the inlining now.
         int size = aliasRefs.references.size();
         Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);
diff --git a/src/com/google/javascript/jscomp/ExpressionDecomposer.java b/src/com/google/javascript/jscomp/ExpressionDecomposer.java
index 1e1b19a..a22bbf6 100644
--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java
+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java
@@ -17,8 +17,6 @@
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
-import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
 import com.google.common.base.Supplier;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
@@ -67,6 +65,8 @@
     this.knownConstants = constNames;
   }
 
+  private static final int MAX_INTERATIONS = 100;
+
   /**
    * If required, rewrite the statement containing the expression.
    * @param expression The expression to be exposed.
@@ -74,8 +74,14 @@
    */
   void maybeDecomposeExpression(Node expression) {
     // If the expression needs to exposed.
+    int i = 0;
     while (DecompositionType.DECOMPOSABLE == canExposeExpression(expression)) {
       exposeExpression(expression);
+      if (i > MAX_INTERATIONS) {
+        throw new IllegalStateException(
+            "DecomposeExpression depth exceeded on :\n" + 
+            expression.toStringTree());
+      }
     }
   }
 
@@ -153,7 +159,7 @@
       Preconditions.checkState(
           !isConditionalOp(parent) || child == parent.getFirstChild());
       if (parentType == Token.ASSIGN) {
-          if (parent.getFirstChild().getType() == Token.NAME) {
+          if (isSafeAssign(parent, state.sideEffects)) {
             // It is always safe to inline "foo()" for expressions such as
             // "a = b = c = foo();"
             // As the assignment is unaffected by side effect of "foo()"
@@ -178,19 +184,26 @@
           }
       } else if (parentType == Token.CALL
           && NodeUtil.isGet(parent.getFirstChild())) {
-        Node functionExpression = parent.getFirstChild();
-        decomposeSubExpressions(
-            functionExpression.getNext(), child, state);
-        // Now handle the call expression
-        if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {
-          // Either there were preexisting side-effects, or this node has
-          // side-effects.
-          state.sideEffects = true;
-
-          // Rewrite the call so "this" is preserved.
-          Node replacement = rewriteCallExpression(parent, state);
-          // Continue from here.
-          parent = replacement;
+        // TODO(johnlenz): In Internet Explorer, non-javascript objects such
+        // as DOM objects can not be decomposed.
+        if (!maybeExternMethod(parent.getFirstChild())) {
+          throw new IllegalStateException(
+              "External object method calls can not be decomposed.");
+        } else {
+          Node functionExpression = parent.getFirstChild();
+          decomposeSubExpressions(
+              functionExpression.getNext(), child, state);
+          // Now handle the call expression
+          if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {
+            // Either there were preexisting side-effects, or this node has
+            // side-effects.
+            state.sideEffects = true;
+  
+            // Rewrite the call so "this" is preserved.
+            Node replacement = rewriteCallExpression(parent, state);
+            // Continue from here.
+            parent = replacement;
+          }
         }
       } else {
         decomposeSubExpressions(
@@ -217,6 +230,14 @@
   }
 
   /**
+   * @return Whether the node may represent an external method.
+   */
+  private boolean maybeExternMethod(Node node) {
+    // TODO(johnlenz): Provide some mechanism for determining this.
+    return true;
+  }
+
+  /**
    * @return "expression" or the node closest to "expression", that does not
    * have a conditional ancestor.
    */
@@ -589,11 +610,7 @@
   DecompositionType canExposeExpression(Node subExpression) {
     Node expressionRoot = findExpressionRoot(subExpression);
     if (expressionRoot != null) {
-      if (isSubexpressionMovable(expressionRoot, subExpression)) {
-        return DecompositionType.MOVABLE;
-      } else {
-        return DecompositionType.DECOMPOSABLE;
-      }
+      return isSubexpressionMovable(expressionRoot, subExpression);
     }
     return DecompositionType.UNDECOMPOSABLE;
   }
@@ -620,20 +637,23 @@
    * by x().  Note: this is true even if b is a local variable; the object that
    * b refers to may have a global alias.
    *
-   * @return Whether the call can be moved before the expression.
+   * @return UNDECOMPOSABLE if the expression can not be moved, DECOMPOSABLE if
+   * decomposition is required before the expression can be moved, otherwise
+   * MOVABLE.
    */
-  private boolean isSubexpressionMovable(
+  private DecompositionType isSubexpressionMovable(
       Node expressionRoot, Node subExpression) {
-
-    boolean callExpressionHasSideEffects = NodeUtil.mayHaveSideEffects(
-        subExpression);
+    boolean requiresDecomposition = false;
+    boolean seenSideEffects = NodeUtil.mayHaveSideEffects(subExpression);
 
     Node child = subExpression;
     for (Node parent : child.getAncestors()) {
       if (parent == expressionRoot) {
         // Done. The walk back to the root of the expression is complete, and
         // nothing was encountered that blocks the call from being moved.
-        return true;
+        return requiresDecomposition
+            ? DecompositionType.DECOMPOSABLE
+            : DecompositionType.MOVABLE;
       }
 
       int parentType = parent.getType();
@@ -642,7 +662,7 @@
         // Only the first child is always executed, otherwise it must be
         // decomposed.
         if (child != parent.getFirstChild()) {
-          return false;
+          requiresDecomposition = true;
         }
       } else {
         // Only inline the call if none of the preceding siblings in the
@@ -652,8 +672,7 @@
         // are evaluated.
 
         // SPECIAL CASE: Assignment to a simple name
-        if (parentType == Token.ASSIGN
-            && parent.getFirstChild().getType() == Token.NAME) {
+        if (isSafeAssign(parent, seenSideEffects)) {
           // It is always safe to inline "foo()" for expressions such as
           //   "a = b = c = foo();"
           // As the assignment is unaffected by side effect of "foo()"
@@ -674,8 +693,35 @@
             }
 
             if (isExpressionTreeUnsafe(
-                n, callExpressionHasSideEffects)) {
-              return false;
+                n, seenSideEffects)) {
+              seenSideEffects = true;
+              requiresDecomposition = true;
+            }
+          }
+
+          // In Internet Explorer, DOM objects and other external objects
+          // methods can not be called indirectly, as is required when the 
+          // object or its property can be side-effected.  For example,
+          // when exposing expression f() (with side-effects) in: x.m(f())
+          // either the value of x or its property m might have changed, so
+          // both the 'this' value ('x') and the function to be called ('x.m') 
+          // need to be preserved. Like so:
+          //   var t1 = x, t2 = x.m, t3 = f();
+          //   t2.call(t1, t3);
+          // As IE doesn't support the call to these non-javascript objects 
+          // methods in this way. We can't do this.
+          // We don't currently distinguish between these types of objects
+          // in the extern definitions and if we did we would need accurate
+          // type information.
+          //
+          Node first = parent.getFirstChild();
+          if (requiresDecomposition 
+              && parent.getType() == Token.CALL 
+              && NodeUtil.isGet(first)) {
+            if (maybeExternMethod(first)) {
+              return DecompositionType.UNDECOMPOSABLE;
+            } else {
+              return DecompositionType.DECOMPOSABLE;
             }
           }
         }
@@ -689,45 +735,40 @@
   }
 
   /**
-   * @return Whether the tree can be affect by side-effects occuring elsewhere.
+   * It is always safe to inline "foo()" for expressions such as
+   *    "a = b = c = foo();"
+   * As the assignment is unaffected by side effect of "foo()"
+   * and the names assigned-to can not influence the state before
+   * the call to foo.
+   * 
+   * It is also safe in cases like where the object is constant:
+   *    CONST_NAME.a = foo()
+   *    CONST_NAME[CONST_VALUE] = foo(); 
+   * 
+   * This is not true of more complex LHS values, such as
+   *     a.x = foo();
+   *     next().x = foo();
+   * in these cases the checks below are necessary.
+   * 
+   * @param seenSideEffects If true, check to see if node-tree maybe affected by
+   * side-effects, otherwise if the tree has side-effects. @see 
+   * isExpressionTreeUnsafe
+   * @return Whether the assignment is safe from side-effects.
    */
-  private boolean canBeSideEffected(Node n) {
-    return NodeUtil.has(
-        n, new SideEffected(this.knownConstants),
-        Predicates.<Node>alwaysTrue());
-  }
-
-  /**
-   * Predicate for detecting logic that may be affect by side-effects.
-   */
-  private static class SideEffected implements Predicate<Node> {
-    final Set<String> additionalConsts;
-
-    SideEffected(Set<String> additionalConsts) {
-      this.additionalConsts = additionalConsts;
-    }
-
-    /**
-     * @return Whether the node can be affect by side-effects.
-     */
-    public boolean apply(Node n) {
-      switch (n.getType()) {
-        case Token.CALL:
-        case Token.NEW:
-          // Function calls or constructor can reference changed values.
-          // TODO(johnlenz): Add some mechanism for determining that functions
-          // are unaffected by side effects.
-          return true;
+  private boolean isSafeAssign(Node n, boolean seenSideEffects) {
+    if (n.getType() == Token.ASSIGN) {
+      Node lhs = n.getFirstChild();
+      switch (lhs.getType()) {
         case Token.NAME:
-          // Non-constant names values may have been changed.
-          // TODO(johnlenz): A constant Named object may still have
-          // properties that are non-constant.
-          return !NodeUtil.isConstantName(n)
-              && !additionalConsts.contains(n.getString());
-        default:
-          return false;
+          return true;
+        case Token.GETPROP:
+          return !isExpressionTreeUnsafe(lhs.getFirstChild(), seenSideEffects);
+        case Token.GETELEM:
+          return !isExpressionTreeUnsafe(lhs.getFirstChild(), seenSideEffects) 
+              && !isExpressionTreeUnsafe(lhs.getLastChild(), seenSideEffects);
       }
     }
+    return false;
   }
 
   /**
@@ -741,7 +782,7 @@
       // expression tree can be affected by any side-effects.
 
       // This is a superset of "NodeUtil.mayHaveSideEffects".
-      return canBeSideEffected(n);
+      return NodeUtil.canBeSideEffected(n, this.knownConstants);
     } else {
       // The function called doesn't have side-effects but check to see if there
       // are side-effects that that may affect it.
diff --git a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java
index 5747f32..c442a07 100644
--- a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java
+++ b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java
@@ -244,7 +244,7 @@
         // Even if there are no references, we still need to evaluate the
         // expression if it has side-effects.
         safe = false;
-      } else if (canBeSideEffected(cArg)
+      } else if (NodeUtil.canBeSideEffected(cArg)
           && namesAfterSideEffects.contains(argName)) {
         safe = false;
       } else if (references > 1) {
@@ -445,39 +445,6 @@
     }
   }
 
-  // TODO(johnlenz): Move this function to a better location.
-  /**
-   * @return Whether the tree can be affect by side-effects occuring elsewhere.
-   */
-  private static boolean canBeSideEffected(Node n) {
-    switch (n.getType()) {
-      case Token.CALL:
-        if (!n.isNoSideEffectsCall()) {
-          return true;
-        }
-        // The function itself is a pure function, check the parameters.
-        break;
-      case Token.NEW:
-        // TODO(johnlenz): Add some mechanism for determining that constructors
-        // are unaffected by side effects.
-        return true;
-      case Token.NAME:
-        // Non-constant names values may have been changed.
-        if (!NodeUtil.isConstantName(n)) {
-          return true;
-        }
-        break;
-    }
-
-    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
-      if (canBeSideEffected(c)) {
-        return true;
-      }
-    }
-
-    return false;
-  }
-
   /**
    * Get a set of function parameter names.
    */
diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java
index edd59d8..6f0d5f2 100644
--- a/src/com/google/javascript/jscomp/InlineVariables.java
+++ b/src/com/google/javascript/jscomp/InlineVariables.java
@@ -61,11 +61,6 @@
   // Inlines all strings, even if they increase the size of the gzipped binary.
   private final boolean inlineAllStrings;
 
-  // All declared constant variables with immutable values.
-  // These should be inlined even if we can't prove that they're written before
-  // first use.
-  private final Set<Var> declaredConstants = Sets.newHashSet();
-
   private final IdentifyConstants identifyConstants = new IdentifyConstants();
 
   InlineVariables(AbstractCompiler compiler, boolean onlyConstants,
@@ -80,12 +75,8 @@
     ReferenceCollectingCallback callback = new ReferenceCollectingCallback(
         compiler, new InliningBehavior(),
         onlyConstants ?
-            // Filter all constants, and put them in the declaredConstants map.
             identifyConstants :
-            // Put all the constants in declaredConstants, but accept
-            // all variables.
-            Predicates.<Var>or(
-                identifyConstants, Predicates.<Var>alwaysTrue()));
+            Predicates.<Var>alwaysTrue());
     callback.process(externs, root);
   }
 
@@ -100,28 +91,7 @@
   private class IdentifyConstants implements Predicate<Var> {
     @Override
     public boolean apply(Var var) {
-      if (declaredConstants.contains(var)) {
-        return true;
-      }
-
-      if (!var.isConst()) {
-        return false;
-      }
-
-      if (var.getInitialValue() == null) {
-        // This constant is either externally defined or initialized shortly
-        // after being declared (e.g. in an anonymous function used to hide
-        // temporary variables), so the constant is ineligible for inlining.
-        return false;
-      }
-
-      // Is the constant's value immutable?
-      if (!NodeUtil.isImmutableValue(var.getInitialValue())) {
-        return false;
-      }
-
-      declaredConstants.add(var);
-      return true;
+      return var.isConst();
     }
   }
 
@@ -178,11 +148,10 @@
           // another pass that handles unused variables much more elegantly.
           if (referenceInfo != null && referenceInfo.references.size() >= 2 &&
               referenceInfo.isWellDefined() &&
-              referenceInfo.isNeverReassigned()) {
-            Reference declaration = referenceInfo.references.get(0);
-            Node value = declaration.getNameNode().getFirstChild();
-            if (declaration.getParent().getType() == Token.VAR &&
-                value != null && value.getType() == Token.NAME) {
+              referenceInfo.isAssignedOnce()) {
+            Reference init = referenceInfo.getInitializingReference();
+            Node value = init.getAssignedValue();
+            if (value != null && value.getType() == Token.NAME) {
               aliasCandidates.put(value, new AliasCandidate(v, referenceInfo));
             }
           }
@@ -209,43 +178,52 @@
           // Never try to inline exported variables or variables that
           // were not collected or variables that have already been inlined.
           continue;
-        } else if (isInlineableDeclaredConstant(v, referenceInfo.references)) {
-          inlineDeclaredConstant(v, referenceInfo.references);
+        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {
+          Reference init = referenceInfo.getInitializingReferenceForConstants();
+          Node value = init.getAssignedValue();
+          inlineDeclaredConstant(v, value, referenceInfo.references);
           staleVars.add(v);
         } else if (onlyConstants) {
           // If we're in constants-only mode, don't run more aggressive
           // inlining heuristics. See InlineConstantsTest.
           continue;
         } else {
-          inlineNonConstants(t.getScope(), v, referenceInfo);
+          inlineNonConstants(v, referenceInfo);
         }
       }
     }
 
-    private void inlineNonConstants(Scope scope,
+    private void inlineNonConstants(
         Var v, ReferenceCollection referenceInfo) {
-      if (referenceInfo.references.size() >= 2 &&
+      int refCount = referenceInfo.references.size();
+      Reference declaration = referenceInfo.references.get(0);
+      Reference init = referenceInfo.getInitializingReference();
+      int firstRefAfterInit = (declaration == init) ? 2 : 3;
+
+      if (refCount > 1 &&
           isImmutableAndWellDefinedVariable(v, referenceInfo)) {
-        // if the variable is defined more than twice, we can only
+        // if the variable is referenced more than once, we can only
         // inline it if it's immutable and never defined before referenced.
-        inlineWellDefinedVariable(v, referenceInfo.references);
+        Node value = init.getAssignedValue();
+        Preconditions.checkNotNull(value);
+        inlineWellDefinedVariable(v, value, referenceInfo.references);
         staleVars.add(v);
-      } else if (referenceInfo.references.size() == 2) {
-        // if the variable is only referenced once, we can try some more
+      } else if (refCount == firstRefAfterInit) {
+        // The variable likely only read once, try some more
         // complex inlining heuristics.
-        Reference declaration = referenceInfo.references.get(0);
-        Reference reference = referenceInfo.references.get(1);
-
-        if (canInline(declaration, reference)) {
-          // If the value being inlined contains references to variables
-          // that have not yet been considered for inlining, we won't
-          // be able to inline them later because the reference collection
-          // will be wrong. So blacklist those variables from inlining.
-          // We'll pick them up on the next pass.
-          blacklistVarReferencesInTree(
-              declaration.getNameNode().getFirstChild(), scope);
-
-          inline(v, declaration, reference);
+        Reference reference = referenceInfo.references.get(
+            firstRefAfterInit - 1);
+        if (canInline(declaration, init, reference)) {
+          inline(v, declaration, init, reference);
+          staleVars.add(v);
+        }
+      } else if (declaration != init && refCount == 2) {
+        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
+          // The only reference is the initialization, remove the assignment and
+          // the variable declaration.
+          Node value = init.getAssignedValue();
+          Preconditions.checkNotNull(value);
+          inlineWellDefinedVariable(v, value, referenceInfo.references);
           staleVars.add(v);
         }
       }
@@ -255,15 +233,20 @@
       // reference data is out of sync. We're better off just waiting for
       // the next pass.)
       if (!staleVars.contains(v) && referenceInfo.isWellDefined() &&
-          referenceInfo.isNeverReassigned()) {
+          referenceInfo.isAssignedOnce()) {
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 /* start from a read */; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNameNode();
           if (aliasCandidates.containsKey(nameNode)) {
             AliasCandidate candidate = aliasCandidates.get(nameNode);
             if (!staleVars.contains(candidate.alias)) {
-              inlineWellDefinedVariable(
-                  candidate.alias, candidate.refInfo.references);
+              Reference aliasInit;
+              aliasInit = candidate.refInfo.getInitializingReference();
+              Node value = aliasInit.getAssignedValue();
+              Preconditions.checkNotNull(value);
+              inlineWellDefinedVariable(candidate.alias,
+                  value,
+                  candidate.refInfo.references);
               staleVars.add(candidate.alias);
             }
           }
@@ -302,24 +285,28 @@
      * Do the actual work of inlining a single declaration into a single
      * reference.
      */
-    private void inline(Var v, Reference declaration, Reference reference) {
-      Node name = declaration.getNameNode();
-      Preconditions.checkState(name.getFirstChild() != null);
-      Node value = name.removeFirstChild();
-      inlineValue(v, reference, value);
+    private void inline(Var v, Reference declaration,
+                        Reference init, Reference reference) {
+      Node value = init.getAssignedValue();
+      Preconditions.checkState(value != null);
+
+      inlineValue(v, reference, value.detachFromParent());
+      if (declaration != init) {
+        Node expressRoot = init.getGrandparent();
+        Preconditions.checkState(expressRoot.getType() == Token.EXPR_RESULT);
+        NodeUtil.removeChild(expressRoot.getParent(), expressRoot);
+      }
       removeDeclaration(declaration);
     }
 
     /**
      * Inline an immutable variable into all of its references.
      */
-    private void inlineWellDefinedVariable(Var v,
+    private void inlineWellDefinedVariable(Var v, Node value,
         List<Reference> refSet) {
       Reference decl = refSet.get(0);
-
       for (int i = 1; i < refSet.size(); i++) {
-        inlineValue(v, refSet.get(i),
-            decl.getNameNode().getFirstChild().cloneTree());
+        inlineValue(v, refSet.get(i), value.cloneTree());
       }
       removeDeclaration(decl);
     }
@@ -327,7 +314,8 @@
     /**
      * Inline a declared constant.
      */
-    private void inlineDeclaredConstant(Var v, List<Reference> refSet) {
+    private void inlineDeclaredConstant(Var v, Node value,
+        List<Reference> refSet) {
       // Replace the references with the constant value
       Reference decl = null;
 
@@ -335,7 +323,7 @@
         if (r.getNameNode() == v.getNameNode()) {
           decl = r;
         } else {
-          inlineValue(v, r, v.getInitialValue().cloneTree());
+          inlineValue(v, r, value.cloneTree());
         }
       }
 
@@ -369,7 +357,13 @@
      *     to re-parent.
      */
     private void inlineValue(Var v, Reference ref, Node value) {
-      ref.getParent().replaceChild(ref.getNameNode(), value);
+      Node parent = ref.getParent();
+      if (ref.isSimpleAssignmentToName()) {
+        // This is the initial assignment.
+        ref.getGrandparent().replaceChild(parent, value);
+      } else {
+        ref.getParent().replaceChild(ref.getNameNode(), value);
+      }
       blacklistVarReferencesInTree(value, v.scope);
       compiler.reportCodeChange();
     }
@@ -379,14 +373,36 @@
      * and may be inlined.
      */
     private boolean isInlineableDeclaredConstant(Var var,
-        List<Reference> refs) {
+        ReferenceCollection refInfo) {
       if (!identifyConstants.apply(var)) {
         return false;
       }
 
+      if (!refInfo.isAssignedOnce()) {
+        return false;
+      }
+
+      Reference init = refInfo.getInitializingReferenceForConstants();
+      if (init == null) {
+        return false;
+      }
+
+      Node value = init.getAssignedValue();
+      if (value == null) {
+        // This constant is either externally defined or initialized indirectly
+        // (e.g. in an anonymous function used to hide
+        // temporary variables), so the constant is ineligible for inlining.
+        return false;
+      }
+
+      // Is the constant's value immutable?
+      if (!NodeUtil.isImmutableValue(value)) {
+        return false;
+      }
+
       // Determine if we should really inline a String or not.
-      return var.getInitialValue().getType() != Token.STRING ||
-          isStringWorthInlining(var, refs);
+      return value.getType() != Token.STRING ||
+          isStringWorthInlining(var, refInfo.references);
     }
 
     /**
@@ -421,39 +437,58 @@
      * @return true if the provided reference and declaration can be safely
      *         inlined according to our criteria
      */
-    private boolean canInline(Reference declaration, Reference reference) {
-      if (!isValidDeclaration(declaration) || !isValidReference(reference)) {
+    private boolean canInline(
+        Reference declaration,
+        Reference initialization,
+        Reference reference) {
+      if (!isValidDeclaration(declaration)
+          || !isValidInitialization(initialization)
+          || !isValidReference(reference)) {
+        return false;
+      }
+
+      // If the value is read more than once, skip it.
+      // VAR declarations and EXPR_RESULT don't need the value, but other
+      // ASSIGN expressions parents do.
+      if (declaration != initialization &&
+          initialization.getGrandparent().getType() != Token.EXPR_RESULT) {
         return false;
       }
 
       // Be very conservative and do no cross control structures or
       // scope boundaries
-      if (declaration.getBasicBlock() != reference.getBasicBlock()) {
+      if (declaration.getBasicBlock() != initialization.getBasicBlock()
+          || declaration.getBasicBlock() != reference.getBasicBlock()) {
         return false;
       }
 
       // Do not inline into a call node. This would change
       // the context in which it was being called. For example,
-      // var a = b.c;
-      // a();
+      //   var a = b.c;
+      //   a();
       // should not be inlined, because it calls a in the context of b
       // rather than the context of the window.
-      if (declaration.getNameNode().getFirstChild().getType() == Token.GETPROP
-          && reference.getParent().getType() == Token.CALL) {
+      //   var a = b.c;
+      //   f(a)
+      // is ok.
+      Node value = initialization.getAssignedValue();
+      Preconditions.checkState(value != null);
+      if (value.getType() == Token.GETPROP
+          && reference.getParent().getType() == Token.CALL
+          && reference.getParent().getFirstChild() == reference.getNameNode()) {
         return false;
       }
 
-      return canMoveAggressively(declaration) ||
-          canMoveModerately(declaration, reference);
+      return canMoveAggressively(value) ||
+          canMoveModerately(initialization, reference);
     }
 
     /**
      * If the value is a literal, we can cross more boundaries to inline it.
      */
-    private boolean canMoveAggressively(Reference declaration) {
-      // Anonymous functions and other mutable objects can move within 
+    private boolean canMoveAggressively(Node value) {
+      // Anonymous functions and other mutable objects can move within
       // the same basic block.
-      Node value = declaration.getNameNode().getFirstChild();
       return NodeUtil.isLiteralValue(value)
           || value.getType() == Token.FUNCTION;
     }
@@ -463,14 +498,28 @@
      * state. Therefore it cannot be moved past anything else that may modify
      * the value being read or read values that are modified.
      */
-    private boolean canMoveModerately(Reference declaration,
+    private boolean canMoveModerately(
+        Reference initialization,
         Reference reference) {
       // Check if declaration can be inlined without passing
       // any side-effect causing nodes.
-      Iterator<Node> it = new NodeIterators.LocalVarMotion(
-          declaration.getNameNode(),
-          declaration.getParent(),
-          declaration.getGrandparent());
+      Iterator<Node> it;
+      if (initialization.getParent().getType() == Token.VAR) {
+        it = NodeIterators.LocalVarMotion.forVar(
+            initialization.getNameNode(),     // NAME
+            initialization.getParent(),       // VAR
+            initialization.getGrandparent()); // VAR container
+      } else if (initialization.getParent().getType() == Token.ASSIGN) {
+        Preconditions.checkState(
+            initialization.getGrandparent().getType() == Token.EXPR_RESULT);
+        it = NodeIterators.LocalVarMotion.forAssign(
+            initialization.getNameNode(),     // NAME
+            initialization.getParent(),       // ASSIGN
+            initialization.getGrandparent(),  // EXPR_RESULT
+            initialization.getGrandparent().getParent()); // EXPR container
+      } else {
+        throw new IllegalStateException("Unexpected initialiation parent");
+      }
       Node targetName = reference.getNameNode();
       while (it.hasNext()) {
         Node curNode = it.next();
@@ -483,12 +532,30 @@
     }
 
     /**
-     * @return true if the reference is a normal VAR declaration with
-     *    initial value. (Only normal VARs can be inlined.)
+     * @return true if the reference is a normal VAR declaration (only normal
+     * VARs can be inlined).
      */
     private boolean isValidDeclaration(Reference declaration) {
-      return declaration.isDeclaration() &&
-          declaration.getNameNode().getFirstChild() != null;
+      return declaration.getParent().getType() == Token.VAR
+          && declaration.getGrandparent().getType() != Token.FOR;
+    }
+
+    /**
+     * @return Whether
+     */
+    private boolean isValidInitialization(Reference initialization) {
+      if (initialization == null) {
+        return false;
+      } else if (initialization.isDeclaration()) {
+        // The reference is a normal VAR declaration with
+        return initialization.getNameNode().getFirstChild() != null;
+      } else {
+        Node parent = initialization.getParent();
+        Preconditions.checkState(
+            parent.getType() == Token.ASSIGN
+            && parent.getFirstChild() == initialization.getNameNode());
+        return true;
+      }
     }
 
     /**
@@ -506,11 +573,23 @@
     private boolean isImmutableAndWellDefinedVariable(Var v,
         ReferenceCollection refInfo) {
       List<Reference> refSet = refInfo.references;
-      if (!isValidDeclaration(refSet.get(0))) {
+      int startingReadRef = 1;
+      Reference refDecl = refSet.get(0);
+      if (!isValidDeclaration(refDecl)) {
         return false;
       }
 
-      for (int i = 1; i < refSet.size(); i++) {
+      Reference refInit = refInfo.getInitializingReference();
+      if (!isValidInitialization(refInit)) {
+        return false;
+      }
+
+      if (refDecl != refInit) {
+        Preconditions.checkState(refInit == refSet.get(1));
+        startingReadRef = 2;
+      }
+
+      for (int i = startingReadRef; i < refSet.size(); i++) {
         Reference ref = refSet.get(i);
         if (!isValidReference(ref)) {
           return false;
@@ -521,7 +600,8 @@
         return false;
       }
 
-      Node value = refSet.get(0).getNameNode().getFirstChild();
+      Node value = refInit.getAssignedValue();
+      Preconditions.checkNotNull(value);
       return NodeUtil.isImmutableValue(value) &&
           (value.getType() != Token.STRING ||
            isStringWorthInlining(v, refInfo.references));
diff --git a/src/com/google/javascript/jscomp/NodeIterators.java b/src/com/google/javascript/jscomp/NodeIterators.java
index b0593d1..787eeb7 100644
--- a/src/com/google/javascript/jscomp/NodeIterators.java
+++ b/src/com/google/javascript/jscomp/NodeIterators.java
@@ -157,23 +157,46 @@
     private Node lookAhead;
 
     /**
-     * @param ancestors The ancestors of the point where iteration will start,
-     *     beginning with the deepest ancestor. The start node will not be
-     *     exposed in the iteration.
+     * @return Create a LocalVarMotion for use with moving a value assigned
+     * at a variable declaration.
      */
-    LocalVarMotion(Node ... ancestors) {
-      Preconditions.checkArgument(ancestors.length >= 2);
-      Preconditions.checkArgument(ancestors[0].getType() == Token.NAME);
-      Preconditions.checkArgument(ancestors[1].getType() == Token.VAR);
+    static LocalVarMotion forVar(
+        Node name, Node var, Node block) {
+      Preconditions.checkArgument(var.getType() == Token.VAR);
+      Preconditions.checkArgument(NodeUtil.isStatement(var));
+      // The FunctionlessLocalScope must start at "name" as this may be used
+      // before the Normalize pass, and thus the VAR node may define multiple
+      // names and the "name" node may have siblings.  The actual assigned
+      // value is skipped as it is a child of name.
+      return new LocalVarMotion(
+          name, new FunctionlessLocalScope(name, var, block));
+    }
 
-      this.iterator = new FunctionlessLocalScope(ancestors);
+    /**
+     * @return Create a LocalVarMotion for use with moving a value assigned
+     * as part of a simple assignment expression ("a = b;").
+     */
+    static LocalVarMotion forAssign(
+        Node name, Node assign, Node expr, Node block) {
+      Preconditions.checkArgument(assign.getType() == Token.ASSIGN);
+      Preconditions.checkArgument(expr.getType() == Token.EXPR_RESULT);
+      // The FunctionlessLocalScope must start at "assign", to skip the value
+      // assigned to "name" (which would be its sibling).
+      return new LocalVarMotion(
+          name, new FunctionlessLocalScope(assign, expr, block));
+    }
 
-      Node nameNode = ancestors[0];
-      Node valueNode = nameNode.getFirstChild();
+    /**
+     * @param iterator The to use while inspecting the node
+     *     beginning with the deepest ancestor.
+     */
+    private LocalVarMotion(Node nameNode, FunctionlessLocalScope iterator) {
+      Preconditions.checkArgument(nameNode.getType() == Token.NAME);
+      Node valueNode = NodeUtil.getAssignedValue(nameNode);
       this.varName = nameNode.getString();
       this.valueHasSideEffects = valueNode != null &&
           NodeUtil.mayHaveSideEffects(valueNode);
-
+      this.iterator = iterator;
       advanceLookAhead(true);
     }
 
diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java
index 4e8e256..0ec71df 100644
--- a/src/com/google/javascript/jscomp/NodeUtil.java
+++ b/src/com/google/javascript/jscomp/NodeUtil.java
@@ -28,6 +28,7 @@
 
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
@@ -541,6 +542,49 @@
     }
   }
 
+  /**
+   * @return Whether the tree can be affected by side-effects or
+   * has side-effects.
+   */
+  static boolean canBeSideEffected(Node n) {
+    Set<String> emptySet = Collections.emptySet();
+    return canBeSideEffected(n, emptySet);
+  }
+
+  /**
+   * @param knownConstants A set of names known to be constant value at
+   * node 'n' (such as locals that are last written before n can execute).
+   * @return Whether the tree can be affected by side-effects or
+   * has side-effects.
+   */
+  static boolean canBeSideEffected(Node n, Set<String> knownConstants) {
+    switch (n.getType()) {
+      case Token.CALL:
+      case Token.NEW:
+        // Function calls or constructor can reference changed values.
+        // TODO(johnlenz): Add some mechanism for determining that functions
+        // are unaffected by side effects.
+        return true;
+      case Token.NAME:
+        // Non-constant names values may have been changed.
+        return !NodeUtil.isConstantName(n)
+            && !knownConstants.contains(n.getString());
+
+      // Properties on constant NAMEs can still be side-effected.
+      case Token.GETPROP:
+      case Token.GETELEM:
+        return true;
+    }
+
+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
+      if (canBeSideEffected(c, knownConstants)) {
+        return true;
+      }
+    }
+
+    return false;    
+  }
+
   /*
    *  0 comma ,
    *  1 assignment = += -= *= /= %= <<= >>= >>>= &= ^= |=
@@ -740,6 +784,22 @@
   }
 
   /**
+   * For an assignment or variable declaration get the assigned value.
+   * @return The value node representing the new value.
+   */
+  static Node getAssignedValue(Node n) {
+    Preconditions.checkState(isName(n));
+    Node parent = n.getParent();
+    if (isVar(parent)) {
+      return n.getFirstChild();
+    } else if (isAssign(parent) && parent.getFirstChild() == n) {
+      return n.getNext();
+    } else {
+      return null;
+    }
+  }
+  
+  /**
    * Is this a STRING node?
    */
   static boolean isString(Node n) {
@@ -953,6 +1013,8 @@
       if (parent.hasMoreThanOneChild()) {
         parent.removeChild(node);
       } else {
+        // Remove the node from the parent, so it can be reused.
+        parent.removeChild(node);
         // This would leave an empty VAR, remove the VAR itself.
         removeChild(parent.getParent(), parent);
       }
@@ -962,6 +1024,8 @@
       node.detachChildren();
     } else if (parent.getType() == Token.LABEL
         && node == parent.getLastChild()) {
+      // Remove the node from the parent, so it can be reused.
+      parent.removeChild(node);
       // A LABEL without children can not be referred to, remove it.
       removeChild(parent.getParent(), parent);
     } else if (parent.getType() == Token.FOR
diff --git a/src/com/google/javascript/jscomp/Normalize.java b/src/com/google/javascript/jscomp/Normalize.java
index d903f35..cadcadc 100644
--- a/src/com/google/javascript/jscomp/Normalize.java
+++ b/src/com/google/javascript/jscomp/Normalize.java
@@ -68,8 +68,6 @@
   private final AbstractCompiler compiler;
   private final boolean assertOnChange;
   private static final boolean CONVERT_WHILE_TO_FOR = true;
-  // TODO(johnlenz): Remove assignment splitting support.
-  private static final boolean ALLOW_ASSIGNMENT_SPLITTING = false;
   static final boolean MAKE_LOCAL_NAMES_UNIQUE = true;
 
   Normalize(AbstractCompiler compiler, boolean assertOnChange) {
@@ -258,9 +256,6 @@
     if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {
       extractForInitializer(n, null, null);
       splitVarDeclarations(n);
-      if (ALLOW_ASSIGNMENT_SPLITTING) {
-        splitAssignments(n);
-      }
     }
   }
 
@@ -338,53 +333,6 @@
     }
   }
 
-
-  /**
-   * Split a compound assignment into individual statements.  This does not
-   * split assignments within conditions, such as "while(a = b = foo()){ blah }"
-   * which would require moving the code into the code while block.
-   *
-   * @param n The assignment node to break down.
-   */
-  private void splitAssignments(Node n) {
-    for (Node next, c = n.getFirstChild(); c != null; c = next) {
-      next = c.getNext();
-      if (NodeUtil.isExpressionNode(c)) {
-        Node expression = c;
-        while (isCompoundAssignment(expression.getFirstChild())) {
-          Node assign = expression.getFirstChild();
-          Node rhs = assign.getLastChild();
-          Node nameNode = rhs.getFirstChild();
-
-          // Verify this is something safe to split.
-          if (NodeUtil.mayEffectMutableState(nameNode)) {
-            break;
-          }
-
-          // Split it. For example change "a = b = c = foo();"
-          // into "b = c = foo(); a = b;"
-          assign.removeChild(rhs);
-          assign.addChildToBack(nameNode.cloneTree());
-
-          Node newChild = NodeUtil.newExpr(rhs);
-          n.addChildBefore(newChild, expression);
-          expression = newChild;  // next iteration.
-          compiler.reportCodeChange();
-        }
-      }
-    }
-  }
-
-  /**
-   * @param n The node to check.
-   * @return Whether n is an assignment and the RHS is also an
-   *     assignment.
-   */
-  private static boolean isCompoundAssignment(Node n) {
-    return (NodeUtil.isAssignmentOp(n)
-        && NodeUtil.isAssignmentOp(n.getLastChild()));
-  }
-
   /**
    * Remove duplicate VAR declarations.
    */
diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
index 8eccd0f..28d6763 100644
--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
@@ -16,6 +16,7 @@
 
 package com.google.javascript.jscomp;
 
+import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableSet;
@@ -247,14 +248,15 @@
 
       // If this is a declaration that does not instantiate the variable,
       // it's not well-defined.
-      Reference decl = references.get(0);
-      if (!decl.isInitializingDeclaration()) {
+      Reference init = getInitializingReference();
+      if (init == null) {
         return false;
       }
 
-      BasicBlock declBlock = decl.getBasicBlock();
+      Preconditions.checkState(references.get(0).isDeclaration());
+      BasicBlock initBlock = init.getBasicBlock();
       for (int i = 1; i < size; i++) {
-        if (!declBlock.provablyExecutesBefore(
+        if (!initBlock.provablyExecutesBefore(
                 references.get(i).getBasicBlock())) {
           return false;
         }
@@ -263,15 +265,98 @@
       return true;
     }
 
-    boolean isNeverReassigned() {
-      int size = references.size();
-      for (int i = 1; i < size; i++) {
-        if (references.get(i).isLvalue()) {
-          return false;
+    /**
+     * @param index The index into the references array to look for an 
+     * assigning declaration.
+     *
+     * This is either the declaration if a value is assigned (such as
+     * "var a = 2", "function a()...", "... catch (a)...").
+     */
+    private boolean isInitializingDeclarationAt(int index) {
+      Reference maybeInit = references.get(index);
+      if (maybeInit.isInitializingDeclaration()) {
+        // This is a declaration that represents the initial value. 
+        // Specifically, var declarations without assignments such as "var a;"
+        // are not.
+        return true;
+      }
+      return false;
+    }
+    
+    /**
+     * @param index The index into the references array to look for an 
+     * initialized assignment reference. That is, an assignment immediately
+     * follow a variable declaration that itself does not initialize the
+     * variable.
+     */
+    private boolean isInitializingAssignmentAt(int index) {
+      if (index < references.size() && index > 0) {
+        Reference maybeDecl = references.get(index-1);
+        if (maybeDecl.isVarDeclaration()) {
+          Preconditions.checkState(!maybeDecl.isInitializingDeclaration());
+          Reference maybeInit = references.get(index);
+          if (maybeInit.isSimpleAssignmentToName()) {
+            return true;
+          }
         }
       }
+      return false;
+    }    
 
-      return true;
+    /**
+     * @return The reference that provides the value for the variable at the
+     * time of the first read, if known, otherwise null.
+     *
+     * This is either the variable declaration ("var a = ...") or first
+     * reference following the declaration if it is an assignment.
+     */
+    Reference getInitializingReference() {
+      if (isInitializingDeclarationAt(0)) {
+        return references.get(0);
+      } else if (isInitializingAssignmentAt(1)) {
+        return references.get(1);
+      }
+      return null;
+    }
+
+    /**
+     * Constants are allowed to be defined after their first use.
+     */
+    Reference getInitializingReferenceForConstants() {
+      int size = references.size();
+      for (int i = 0; i < size; i++) {
+        if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) {
+          return references.get(i);
+        }
+      }
+      return null;
+    }
+
+    /**
+     * @return Whether the variable is only assigned a value once.
+     */
+    boolean isAssignedOnce() {
+      boolean assigned = false;
+      int size = references.size();
+      for (int i = 0; i < size; i++) {
+        Reference ref = references.get(i);
+        if (ref.isLvalue() || ref.isInitializingDeclaration()) {
+          if (!assigned) {
+            assigned = true;
+          } else {
+            return false;
+          }
+        }
+      }
+      return assigned;
+    }
+
+    boolean firstReferenceIsAssigningDeclaration() {
+      int size = references.size();
+      if (size > 0 && references.get(0).isInitializingDeclaration()) {
+        return true;
+      }
+      return false;
     }
   }
 
@@ -320,6 +405,16 @@
           grandparent.getType() == Token.FUNCTION;
     }
 
+    boolean isVarDeclaration() {
+      return parent.getType() == Token.VAR;
+    }
+
+    boolean isHoistedFunction() {
+      return NodeUtil.isFunctionDeclaration(parent) &&
+          (grandparent.getType() == Token.SCRIPT ||
+           grandparent.getParent().getType() == Token.FUNCTION);
+    }
+
     /**
      * Determines whether the variable is initialized at the declaration.
      */
@@ -330,6 +425,14 @@
           (parent.getType() != Token.VAR || nameNode.getFirstChild() != null);
     }
 
+   /**
+    * @return For an assignment or variable declaration return the assigned
+    * value, otherwise null.
+    */
+    Node getAssignedValue() {
+      return NodeUtil.getAssignedValue(getNameNode());
+    }
+
     BasicBlock getBasicBlock() {
       return basicBlock;
     }
@@ -349,18 +452,23 @@
     private static boolean isForIn(Node n) {
       return n.getType() == Token.FOR && n.getChildCount() == 3;
     }
-    
+
     private static boolean isLhsOfForInExpression(Node n) {
       Node parent = n.getParent();
       if (parent.getType() == Token.VAR) {
         return isLhsOfForInExpression(parent);
-      } 
+      }
       return isForIn(parent) && parent.getFirstChild() == n;
     }
-    
+
+    boolean isSimpleAssignmentToName() {
+      return parent.getType() == Token.ASSIGN
+          && parent.getFirstChild() == nameNode;
+    }
+
     boolean isLvalue() {
       int parentType = parent.getType();
-      return parentType == Token.VAR 
+      return (parentType == Token.VAR && nameNode.getFirstChild() != null)
           || parentType == Token.INC
           || parentType == Token.DEC
           || (NodeUtil.isAssignmentOp(parent)
diff --git a/src/com/google/javascript/jscomp/Scope.java b/src/com/google/javascript/jscomp/Scope.java
index c8e57ab..c9f6719 100644
--- a/src/com/google/javascript/jscomp/Scope.java
+++ b/src/com/google/javascript/jscomp/Scope.java
@@ -322,6 +322,14 @@
     return parent;
   }
 
+  Scope getGlobalScope() {
+    Scope result = this;
+    while (result.getParent() != null) {
+      result = result.getParent();
+    }
+    return result;
+  }
+
   @Override
   public StaticScope<JSType> getParentScope() {
     return parent;
diff --git a/src/com/google/javascript/jscomp/VarCheck.java b/src/com/google/javascript/jscomp/VarCheck.java
index 55c0a4a..9630502 100644
--- a/src/com/google/javascript/jscomp/VarCheck.java
+++ b/src/com/google/javascript/jscomp/VarCheck.java
@@ -127,7 +127,7 @@
           Node nameNode = Node.newString(Token.NAME, varName);
           getSynthesizedExternsRoot().addChildToBack(
               new Node(Token.VAR, nameNode));
-          scope.declare(varName, nameNode,
+          scope.getGlobalScope().declare(varName, nameNode,
               null, getSynthesizedExternsInput());
         }
       }
diff --git a/src/com/google/javascript/jscomp/VariableReferenceCheck.java b/src/com/google/javascript/jscomp/VariableReferenceCheck.java
index 32dbd4e..68c9c62 100644
--- a/src/com/google/javascript/jscomp/VariableReferenceCheck.java
+++ b/src/com/google/javascript/jscomp/VariableReferenceCheck.java
@@ -95,8 +95,23 @@
     private void checkVar(NodeTraversal t, Var v, List<Reference> references) {
       blocksWithDeclarations.clear();
       boolean isDeclaredInScope = false;
+      Reference hoistedFn = null;
+
+      // Look for hoisted functions.
+      for (Reference reference : references) {
+        if (reference.isHoistedFunction()) {
+          blocksWithDeclarations.add(reference.getBasicBlock());
+          isDeclaredInScope = true;
+          hoistedFn = reference;
+          break;
+        }
+      }
 
       for (Reference reference : references) {
+        if (reference == hoistedFn) {
+          continue;
+        }
+
         BasicBlock basicBlock = reference.getBasicBlock();
         boolean isDeclaration = reference.isDeclaration();
 
diff --git a/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java b/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java
index 474122a..1274358 100644
--- a/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java
+++ b/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java
@@ -102,6 +102,24 @@
         "function (){ return goo() && foo();}", "foo");
   }
 
+  public void testCanExposeExpression4() {
+    // 'this' must be preserved in call.
+    helperCanExposeExpression(
+        DecompositionType.UNDECOMPOSABLE, "if (goo.a(1, foo()));", "foo");    
+  }
+
+  public void testCanExposeExpression5() {
+    // 'this' must be preserved in call.
+    helperCanExposeExpression(
+        DecompositionType.UNDECOMPOSABLE, "if (goo['a'](foo()));", "foo");    
+  }
+
+  public void testCanExposeExpression6() {
+    // 'this' must be preserved in call.
+    helperCanExposeExpression(
+        DecompositionType.UNDECOMPOSABLE, "z:if (goo.a(1, foo()));", "foo");    
+  }
+  
 
   public void testMoveExpression1() {
     // There isn't a reason to do this, but it works.
@@ -265,36 +283,6 @@
         "if (temp_const_1(1, temp_const_0, temp_2));");
   }
 
-  public void testExposeExpression12() {
-    // Verify that "this" is preserved...
-    helperExposeExpression(
-        "if (goo.a(1, foo()));",
-        "foo",
-        "var temp_const_1 = goo;" +
-        "var temp_const_0 = temp_const_1.a;" +
-        "if (temp_const_0.call(temp_const_1, 1, foo()));");
-  }
-
-  public void testExposeExpression13() {
-    // Verify that "this" is preserved...
-    helperExposeExpression(
-        "if (goo['a'](foo()));",
-        "foo",
-        "var temp_const_1 = goo;" +
-        "var temp_const_0 = temp_const_1['a'];" +
-        "if (temp_const_0.call(temp_const_1, foo()));");
-  }
-
-  public void testExposeExpression14() {
-    // Verify that "this" is preserved...
-    helperExposeExpression(
-        "z:if (goo.a(1, foo()));",
-        "foo",
-        "var temp_const_1 = goo;" +
-        "var temp_const_0 = temp_const_1.a;" +
-        "z:if (temp_const_0.call(temp_const_1, 1, foo()));");
-  }
-
   /** Test case helpers. */
 
   private void helperCanExposeExpression(
@@ -367,6 +355,9 @@
     Node callSite = findCall(tree, fnName);
     assertNotNull("Call to " + fnName + " was not found.", callSite);
 
+    DecompositionType result = decomposer.canExposeExpression(callSite);
+    assertTrue(result == DecompositionType.DECOMPOSABLE);
+
     compiler.resetUniqueNameId();
     decomposer.exposeExpression(callSite);
     String explanation = expectedRoot.checkTreeEquals(tree);
diff --git a/test/com/google/javascript/jscomp/FunctionInjectorTest.java b/test/com/google/javascript/jscomp/FunctionInjectorTest.java
index e611a2f..4c4a3da 100644
--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java
+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java
@@ -1074,6 +1074,48 @@
         "foo", INLINE_BLOCK, true);
   }
 
+  public void testInlineReferenceInExpression16() {
+    helperInlineReferenceToFunction(
+        "var z = {};" +
+        "function foo(a){z = {};return true;}; " +
+        "function x() { z[bar()] = foo(1) }",
+
+        "var z = {};" +
+        "function foo(a){z = {};return true;}; " +
+        "function x() {" +
+            "var JSCompiler_temp_const_1=z;" +
+            "var JSCompiler_temp_const_0=bar();" +
+            "{" +
+             "var JSCompiler_inline_result_2;" +
+             "z= {};" +
+             "JSCompiler_inline_result_2 = true;" +
+            "}" +
+            "JSCompiler_temp_const_1[JSCompiler_temp_const_0] = " +
+                "JSCompiler_inline_result_2;" +
+        "}",
+        "foo", INLINE_BLOCK, true);
+  }
+
+  public void testInlineReferenceInExpression17() {
+    helperInlineReferenceToFunction(
+        "var z = {};" +
+        "function foo(a){z = {};return true;}; " +
+        "function x() { z.y.x.gack = foo(1) }",
+
+        "var z = {};" +
+        "function foo(a){z = {};return true;}; " +
+        "function x() {" +
+            "var JSCompiler_temp_const_0=z.y.x;" +
+            "{" +
+             "var JSCompiler_inline_result_1;" +
+             "z= {};" +
+             "JSCompiler_inline_result_1 = true;" +
+            "}" +
+            "JSCompiler_temp_const_0.gack = JSCompiler_inline_result_1;" +
+        "}",
+        "foo", INLINE_BLOCK, true);
+  }
+
 
   public void testInlineWithinCalls1() {
     // Call in within a call
diff --git a/test/com/google/javascript/jscomp/InlineVariablesConstantsTest.java b/test/com/google/javascript/jscomp/InlineVariablesConstantsTest.java
index 68c9004..2c9b006 100644
--- a/test/com/google/javascript/jscomp/InlineVariablesConstantsTest.java
+++ b/test/com/google/javascript/jscomp/InlineVariablesConstantsTest.java
@@ -43,7 +43,13 @@
     test("var ABC=2; var x = ABC;", "var x=2");
     test("var AA = 'aa'; AA;", "'aa'");
     test("var A_A=10; A_A + A_A;", "10+10");
-    testSame("var AA; AA=1");
+    test("var AA=1", "");
+    test("var AA; AA=1", "1");
+    test("var AA; if (false) AA=1; AA;", "if (false) 1; 1;");
+    testSame("var AA; if (false) AA=1; else AA=2; AA;");
+
+    test("var AA;(function () {AA=1})()",
+         "(function () {1})()");
 
     // Make sure that nothing explodes if there are undeclared variables.
     testSame("var x = AA;");
@@ -66,7 +72,12 @@
     test("/** @const */var abc=2; var x = abc;", "var x=2");
     test("/** @const */var aa = 'aa'; aa;", "'aa'");
     test("/** @const */var a_a=10; a_a + a_a;", "10+10");
-    testSame("/** @const */var aa; aa=1;");
+    test("/** @const */var aa=1;", "");
+    test("/** @const */var aa; aa=1;", "1");
+    test("/** @const */var aa;(function () {aa=1})()", "(function () {1})()");
+    test("/** @const */var aa;(function () {aa=1})(); var z=aa",
+         "(function () {1})(); var z=1");
+    testSame("/** @const */var aa;(function () {var y; aa=y})(); var z=aa");
 
     // Don't inline if it will make the output larger.
     testSame("/** @const */var aa = '1234567890'; foo(aa); foo(aa); foo(aa);");
diff --git a/test/com/google/javascript/jscomp/InlineVariablesTest.java b/test/com/google/javascript/jscomp/InlineVariablesTest.java
index 27f4782..847f5e3 100644
--- a/test/com/google/javascript/jscomp/InlineVariablesTest.java
+++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java
@@ -114,11 +114,19 @@
         new String[] { "", "var b = 2;" });
   }
 
-  public void testDoNotExitConditional() {
+  public void testDoNotExitConditional1() {
     testSame("if (true) { var x = 1; } var z = x;");
+  }
+
+  public void testDoNotExitConditional2() {
     testSame("if (true) var x = 1; var z = x;");
   }
 
+
+  public void testDoNotExitConditional3() {
+    testSame("var x; if (true) x=1; var z = x;");
+  }
+
   public void testDoNotExitLoop() {
     testSame("while (z) { var x = 3; } var y = x;");
   }
@@ -159,6 +167,58 @@
 
   public void testInsideIfConditional() {
     test("var a = foo(); if (a) { alert(3); }", "if (foo()) { alert(3); }");
+    test("var a; a = foo(); if (a) { alert(3); }", "if (foo()) { alert(3); }");
+  }
+
+  public void testOnlyReadAtInitialization() {
+    test("var a; a = foo();", "foo();");
+    test("var a; if (a = foo()) { alert(3); }", "if (foo()) { alert(3); }");
+    test("var a; switch (a = foo()) {}", "switch(foo()) {}");
+    test("var a; function f(){ return a = foo(); }",
+         "function f(){ return foo(); }");
+    test("function f(){ var a; return a = foo(); }",
+         "function f(){ return foo(); }");
+    test("var a; with (a = foo()) { alert(3); }", "with (foo()) { alert(3); }");
+
+    test("var a; b = (a = foo());", "b = foo();");
+    test("var a; while(a = foo()) { alert(3); }",
+         "while(foo()) { alert(3); }");
+    test("var a; for(;a = foo();) { alert(3); }",
+         "for(;foo();) { alert(3); }");
+    test("var a; do {} while(a = foo()) { alert(3); }",
+         "do {} while(foo()) { alert(3); }");
+  }
+
+  public void testImmutableWithSingleReferenceAfterInitialzation() {
+    test("var a; a = 1;", "1;");
+    test("var a; if (a = 1) { alert(3); }", "if (1) { alert(3); }");
+    test("var a; switch (a = 1) {}", "switch(1) {}");
+    test("var a; function f(){ return a = 1; }",
+         "function f(){ return 1; }");
+    test("function f(){ var a; return a = 1; }",
+         "function f(){ return 1; }");
+    test("var a; with (a = 1) { alert(3); }", "with (1) { alert(3); }");
+
+    test("var a; b = (a = 1);", "b = 1;");
+    test("var a; while(a = 1) { alert(3); }",
+         "while(1) { alert(3); }");
+    test("var a; for(;a = 1;) { alert(3); }",
+         "for(;1;) { alert(3); }");
+    test("var a; do {} while(a = 1) { alert(3); }",
+         "do {} while(1) { alert(3); }");
+  }
+
+  public void testSingleReferenceAfterInitialzation() {
+    test("var a; a = foo();a;", "foo();");
+    testSame("var a; if (a = foo()) { alert(3); } a;");
+    testSame("var a; switch (a = foo()) {} a;");
+    testSame("var a; function f(){ return a = foo(); } a;");
+    testSame("function f(){ var a; return a = foo(); a;}");
+    testSame("var a; with (a = foo()) { alert(3); } a;");
+    testSame("var a; b = (a = foo()); a;");
+    testSame("var a; while(a = foo()) { alert(3); } a;");
+    testSame("var a; for(;a = foo();) { alert(3); } a;");
+    testSame("var a; do {} while(a = foo()) { alert(3); } a;");
   }
 
   public void testInsideIfBranch() {
@@ -263,7 +323,7 @@
   // Test movement of values that are complex but lack side effects
 
   public void testDoNotCrossAssignment() {
-    testSame("var x = {};\nvar y = x.a;\nx.a = 1;\nvar z = y;");
+    testSame("var x = {}; var y = x.a; x.a = 1; var z = y;");
     testSame("var a = this.id; foo(this.id = 3, a);");
   }
 
@@ -427,6 +487,7 @@
 
   public void testNoInlineGetpropIntoCall() {
     test("var a = b; a();", "b();");
+    test("var a = b.c; f(a);", "f(b.c);");
     testSame("var a = b.c; a();");
   }
 
@@ -459,22 +520,65 @@
          "var x = this.foo(); this.bar(); this.baz(x);");
   }
 
+  public void testInlineAliases1b() {
+    test("var x = this.foo(); this.bar(); var y; y = x; this.baz(y);",
+         "var x = this.foo(); this.bar(); x; this.baz(x);");
+  }
+
+  public void testInlineAliases1c() {
+    test("var x; x = this.foo(); this.bar(); var y = x; this.baz(y);",
+         "var x; x = this.foo(); this.bar(); this.baz(x);");
+  }
+
+  public void testInlineAliases1d() {
+    test("var x; x = this.foo(); this.bar(); var y; y = x; this.baz(y);",
+         "var x; x = this.foo(); this.bar(); x; this.baz(x);");
+  }
+
   public void testInlineAliases2() {
     test("var x = this.foo(); this.bar(); " +
          "function f() { var y = x; this.baz(y); }",
          "var x = this.foo(); this.bar(); function f() { this.baz(x); }");
   }
 
+  public void testInlineAliases2b() {
+    test("var x = this.foo(); this.bar(); " +
+         "function f() { var y; y = x; this.baz(y); }",
+         "var x = this.foo(); this.bar(); function f() { this.baz(x); }");
+  }
+
+  public void testInlineAliases2c() {
+    test("var x; x = this.foo(); this.bar(); " +
+         "function f() { var y = x; this.baz(y); }",
+         "var x; x = this.foo(); this.bar(); function f() { this.baz(x); }");
+  }
+
+  public void testInlineAliases2d() {
+    test("var x; x = this.foo(); this.bar(); " +
+         "function f() { var y; y = x; this.baz(y); }",
+         "var x; x = this.foo(); this.bar(); function f() { this.baz(x); }");
+  }
+
   public void testNoInlineAliases1() {
     testSame(
         "var x = this.foo(); this.bar(); var y = x; x = 3; this.baz(y);");
   }
 
+  public void testNoInlineAliases1b() {
+    testSame(
+        "var x = this.foo(); this.bar(); var y; y = x; x = 3; this.baz(y);");
+  }
+
   public void testNoInlineAliases2() {
     testSame(
         "var x = this.foo(); this.bar(); var y = x; y = 3; this.baz(y); ");
   }
 
+  public void testNoInlineAliases2b() {
+    testSame(
+        "var x = this.foo(); this.bar(); var y; y = x; y = 3; this.baz(y); ");
+  }
+
   public void testNoInlineAliases3() {
     testSame(
          "var x = this.foo(); this.bar(); " +
@@ -482,33 +586,167 @@
          "function g() { x = 3; }");
   }
 
+  public void testNoInlineAliases3b() {
+    testSame(
+         "var x = this.foo(); this.bar(); " +
+         "function f() { var y; y = x; g(); this.baz(y); } " +
+         "function g() { x = 3; }");
+  }
+
   public void testNoInlineAliases4() {
     testSame(
          "var x = this.foo(); this.bar(); " +
          "function f() { var y = x; y = 3; this.baz(y); }");
   }
 
+  public void testNoInlineAliases4b() {
+    testSame(
+         "var x = this.foo(); this.bar(); " +
+         "function f() { var y; y = x; y = 3; this.baz(y); }");
+  }
+
   public void testNoInlineAliases5() {
     testSame(
         "var x = this.foo(); this.bar(); var y = x; this.bing();" +
         "this.baz(y); x = 3;");
   }
 
+  public void testNoInlineAliases5b() {
+    testSame(
+        "var x = this.foo(); this.bar(); var y; y = x; this.bing();" +
+        "this.baz(y); x = 3;");
+  }
+
   public void testNoInlineAliases6() {
     testSame(
         "var x = this.foo(); this.bar(); var y = x; this.bing();" +
         "this.baz(y); y = 3;");
   }
 
+  public void testNoInlineAliases6b() {
+    testSame(
+        "var x = this.foo(); this.bar(); var y; y = x; this.bing();" +
+        "this.baz(y); y = 3;");
+  }
+
   public void testNoInlineAliases7() {
     testSame(
          "var x = this.foo(); this.bar(); " +
          "function f() { var y = x; this.bing(); this.baz(y); x = 3; }");
   }
 
+  public void testNoInlineAliases7b() {
+    testSame(
+         "var x = this.foo(); this.bar(); " +
+         "function f() { var y; y = x; this.bing(); this.baz(y); x = 3; }");
+  }
+
   public void testNoInlineAliases8() {
     testSame(
          "var x = this.foo(); this.bar(); " +
          "function f() { var y = x; this.baz(y); y = 3; }");
   }
+
+  public void testNoInlineAliases8b() {
+    testSame(
+         "var x = this.foo(); this.bar(); " +
+         "function f() { var y; y = x; this.baz(y); y = 3; }");
+  }
+
+  public void testSideEffectOrder() {
+    // z can not be changed by the call to y, so x can be inlined.
+    String EXTERNS = "var z; function f(){}";
+    test(EXTERNS,
+         "var x = f(y.a, y); z = x;",
+         "z = f(y.a, y);", null, null);
+    // z.b can be changed by the call to y, so x can not be inlined.
+    testSame(EXTERNS, "var x = f(y.a, y); z.b = x;", null, null);
+  }
+
+  public void testInlineParameterAlias1() {
+    test(
+      "function f(x) {" +
+      "  var y = x;" +
+      "  g();" +
+      "  y;y;" +
+      "}",
+      "function f(x) {" +
+      "  g();" +
+      "  x;x;" +
+      "}"
+      );
+  }
+
+  public void testInlineParameterAlias2() {
+    test(
+      "function f(x) {" +
+      "  var y; y = x;" +
+      "  g();" +
+      "  y;y;" +
+      "}",
+      "function f(x) {" +
+      "  x;" +
+      "  g();" +
+      "  x;x;" +
+      "}"
+      );
+  }
+
+  public void testInlineFunctionAlias1() {
+    test(
+      "function f(x) {};" +
+      "var y = f;" +
+      "g();" +
+      "y();y();",
+      "function f(x) {};" +
+      "g();" +
+      "f();f();"
+      );
+  }
+
+  public void testInlineFunctionAlias2() {
+    test(
+      "function f(x) {};" +
+      "var y; y = f;" +
+      "g();" +
+      "y();y();",
+      "function f(x) {};" +
+      "f;" +
+      "g();" +
+      "f();f();"
+      );
+  }
+
+  public void testInlineCatchAlias1() {
+    test(
+      "try {" +
+      "} catch (e) {" +
+      "  var y = e;" +
+      "  g();" +
+      "  y;y;" +
+      "}",
+      "try {" +
+      "} catch (e) {" +
+      "  g();" +
+      "  e;e;" +
+      "}"
+      );
+  }
+
+  public void testInlineCatchAlias2() {
+    test(
+      "try {" +
+      "} catch (e) {" +
+      "  var y; y = e;" +
+      "  g();" +
+      "  y;y;" +
+      "}",
+      "try {" +
+      "} catch (e) {" +
+      "  e;" +
+      "  g();" +
+      "  e;e;" +
+      "}"
+      );
+  }
 }
diff --git a/test/com/google/javascript/jscomp/NodeIteratorsTest.java b/test/com/google/javascript/jscomp/NodeIteratorsTest.java
index ed98a7b..0dc3251 100644
--- a/test/com/google/javascript/jscomp/NodeIteratorsTest.java
+++ b/test/com/google/javascript/jscomp/NodeIteratorsTest.java
@@ -165,8 +165,11 @@
     assertTrue("Variable X not found! " + root.toStringTree(), found);
 
     List<Node> currentAncestors = searchIt.currentAncestors();
-    Iterator<Node> moveIt = new LocalVarMotion(
-        currentAncestors.toArray(new Node[currentAncestors.size()]));
+    assert(currentAncestors.size() >= 3);
+    Iterator<Node> moveIt = LocalVarMotion.forVar(
+        currentAncestors.get(0),
+        currentAncestors.get(1),
+        currentAncestors.get(2));
     List<Integer> actualTokens = Lists.newArrayList();
     while (moveIt.hasNext()) {
       actualTokens.add(moveIt.next().getType());
diff --git a/test/com/google/javascript/jscomp/NormalizeTest.java b/test/com/google/javascript/jscomp/NormalizeTest.java
index 317a26d..8ea72cb 100644
--- a/test/com/google/javascript/jscomp/NormalizeTest.java
+++ b/test/com/google/javascript/jscomp/NormalizeTest.java
@@ -72,26 +72,6 @@
          "do{var a = foo(1); var b} while(false);");
   }
 
-  public void disable_testSplitAssign() {
-    testSame("a = 0");
-    test("a = b = 0",
-         "b = 0; a = b");
-    test("a = b = c = foo()",
-         "c = foo(); b = c; a = b");
-    test("a.a = a.b = 0",
-         "a.b = 0; a.a = a.b");
-    test("a[0] = a[1] = 0",
-         "a[1] = 0; a[0] = a[1]");
-    testSame("a[x++] = a[x++] = 0");
-    testSame("a[getNext()] = a[getNext()] = 0");
-
-    testSame("for(;a=b=0;c=d=0);");
-
-    // Verify any assign op is split.
-    test("a *= b -= c += foo()",
-         "c += foo(); b -= c; a *= b");
-  }
-
   public void testUnhandled() {
     testSame("var x = y = 1");
   }
diff --git a/test/com/google/javascript/jscomp/VarCheckTest.java b/test/com/google/javascript/jscomp/VarCheckTest.java
index 7b9c85b..58dffee 100644
--- a/test/com/google/javascript/jscomp/VarCheckTest.java
+++ b/test/com/google/javascript/jscomp/VarCheckTest.java
@@ -252,15 +252,19 @@
   }
 
   public void testParameter() {
-    checkSynthesizedExtern("function(x){}", "");
+    checkSynthesizedExtern("function f(x){}", "");
   }
 
   public void testLocalVar() {
-    checkSynthesizedExtern("function(){x}", "var x");
+    checkSynthesizedExtern("function f(){x}", "var x");
+  }
+
+  public void testTwoLocalVars() {
+    checkSynthesizedExtern("function f(){x}function g() {x}", "var x");
   }
 
   public void testInnerFunctionLocalVar() {
-    checkSynthesizedExtern("function(){function() {x}}", "var x");
+    checkSynthesizedExtern("function f(){function g() {x}}", "var x");
   }
 
   public void testNoCreateVarsForLabels() {
diff --git a/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java b/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java
index fb9a4a0..7d09f17 100644
--- a/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java
+++ b/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java
@@ -91,6 +91,18 @@
     assertRedeclare("function x() { var y; if (true) { var y; } }");
   }
 
+  public void testHoistedFunction1() {
+    assertNoWarning("f(); function f() {}");
+  }
+
+  public void testHoistedFunction2() {
+    assertNoWarning("function g() { f(); function f() {} }");
+  }
+
+  public void testNonHoistedFunction() {
+    assertUndeclared("if (true) { f(); function f() {} }");
+  }
+
   /**
    * Expects the JS to generate one bad-read error.
    */
