{
  "logger": {
    "currentLogLevel": 20,
    "name": "root.bean.benchmarks.Defects4JBug"
  },
  "d4jCmd": "/home/liumengjiao/Desktop/defects4j/framework/bin/defects4j",
  "dataDir": "/home/liumengjiao/Desktop/CI/Benchmark/data/changesInfo/",
  "properties": {
    "trigger.tests": "com.google.javascript.jscomp.InlineVariablesTest::testExternalIssue1053",
    "test.dir": "test",
    "clz.modified": "com.google.javascript.jscomp.InlineVariables",
    "src.dir": "src"
  },
  "timeoutSecond": 100,
  "proj": "Closure",
  "id": "121",
  "workingDir": "../bugs/Closure_121_buggy",
  "buggyCommit": "1af41ab430be090a9a6177648b18c1ff9fb88c3f",
  "inducingCommit": "78995bf9e88599055a8c4165d89c09dc92a44b30",
  "originalCommit": "7efb21a25bb44dcfc513d584c6b191aeacfba367",
  "bug_name": "Closure_121",
  "derive": "defects4j",
  "original_fixing_commit": "2aee36e667526ff8b0b5e6dad66506acee920ea6",
  "buildFiles_changed": false,
  "regression": true,
  "inducing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/AbstractCompilerRunner.java",
        "src/com/google/javascript/jscomp/AbstractCompilerRunner.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.AbstractCompilerRunner:maybeCreateDirsForPath:[String pathPrefix]:void"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.AbstractCompilerRunner:maybeCreateDirsForPath:[String pathPrefix]:void"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "497"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "497",
            "498",
            "499"
          ],
          "num": 3
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\nindex 3a51574..2f13758 100644\n--- a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n@@ -494,7 +494,9 @@\n           pathPrefix.charAt(pathPrefix.length() - 1) \u003d\u003d File.separatorChar\n               ? pathPrefix.substring(0, pathPrefix.length() - 1) : new File(\n                   pathPrefix).getParent();\n-      new File(dirName).mkdirs();\n+      if (dirName !\u003d null) {\n+        new File(dirName).mkdirs();\n+      }\n     }\n   }\n \n",
      "operations": [
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [17502,17568]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [17506,17521]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [17523,17568]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/CollapseProperties.java",
        "src/com/google/javascript/jscomp/CollapseProperties.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.CollapseProperties:inlineAliasIfPossible:[Ref alias, GlobalNamespace namespace]:boolean"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.CollapseProperties:inlineAliasIfPossible:[Ref alias, GlobalNamespace namespace]:boolean"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "213"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "213",
            "214",
            "215"
          ],
          "num": 3
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex 0e51823..881a640 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -210,7 +210,9 @@\n \n       ReferenceCollection aliasRefs \u003d\n           collector.getReferenceCollection(aliasVar);\n-      if (aliasRefs.isWellDefined() \u0026\u0026 aliasRefs.isNeverReassigned()) {\n+      if (aliasRefs.isWellDefined()\n+          \u0026\u0026 aliasRefs.firstReferenceIsAssigningDeclaration()\n+          \u0026\u0026 aliasRefs.isAssignedOnce()) {\n         // The alias is well-formed, so do the inlining now.\n         int size \u003d aliasRefs.references.size();\n         Set\u003cNode\u003e newNodes \u003d Sets.newHashSetWithExpectedSize(size - 1);\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodInvocation [8360,8408]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
        "src/com/google/javascript/jscomp/ExpressionDecomposer.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.ExpressionDecomposer\\$SideEffected:apply:[Node n]:boolean",
            "com.google.javascript.jscomp.ExpressionDecomposer\\$SideEffected:SideEffected:[Set\u003cString\u003e additionalConsts]:null",
            "com.google.javascript.jscomp.ExpressionDecomposer:isExpressionTreeUnsafe:[Node n, boolean followingSideEffectsExist]:boolean",
            "com.google.javascript.jscomp.ExpressionDecomposer:canBeSideEffected:[Node n]:boolean",
            "com.google.javascript.jscomp.ExpressionDecomposer:exposeExpression:[Node expressionRoot, Node subExpression]:void",
            "com.google.javascript.jscomp.ExpressionDecomposer:maybeDecomposeExpression:[Node expression]:void",
            "com.google.javascript.jscomp.ExpressionDecomposer:findNonconditionalParent:[Node subExpression, Node expressionRoot]:Node",
            "com.google.javascript.jscomp.ExpressionDecomposer:canExposeExpression:[Node subExpression]:DecompositionType",
            "com.google.javascript.jscomp.ExpressionDecomposer:isSubexpressionMovable:[Node expressionRoot, Node subExpression]:boolean"
          ],
          "num": 9
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.ExpressionDecomposer:canExposeExpression:[Node subExpression]:DecompositionType",
            "com.google.javascript.jscomp.ExpressionDecomposer:isSafeAssign:[Node n, boolean seenSideEffects]:boolean",
            "com.google.javascript.jscomp.ExpressionDecomposer:isExpressionTreeUnsafe:[Node n, boolean followingSideEffectsExist]:boolean",
            "com.google.javascript.jscomp.ExpressionDecomposer:maybeDecomposeExpression:[Node expression]:void",
            "com.google.javascript.jscomp.ExpressionDecomposer:maybeExternMethod:[Node node]:boolean",
            "com.google.javascript.jscomp.ExpressionDecomposer:isSubexpressionMovable:[Node expressionRoot, Node subExpression]:DecompositionType",
            "com.google.javascript.jscomp.ExpressionDecomposer:findNonconditionalParent:[Node subExpression, Node expressionRoot]:Node",
            "com.google.javascript.jscomp.ExpressionDecomposer:exposeExpression:[Node expressionRoot, Node subExpression]:void"
          ],
          "num": 8
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "20",
            "21",
            "69",
            "76",
            "156",
            "181",
            "182",
            "183",
            "184",
            "185",
            "186",
            "187",
            "188",
            "189",
            "190",
            "191",
            "192",
            "193",
            "219",
            "592",
            "593",
            "594",
            "595",
            "596",
            "623",
            "625",
            "627",
            "628",
            "629",
            "636",
            "645",
            "655",
            "656",
            "677",
            "678",
            "692",
            "694",
            "695",
            "696",
            "697",
            "698",
            "699",
            "700",
            "701",
            "702",
            "703",
            "704",
            "705",
            "706",
            "707",
            "708",
            "709",
            "710",
            "711",
            "712",
            "713",
            "714",
            "715",
            "716",
            "717",
            "718",
            "719",
            "720",
            "722",
            "723",
            "724",
            "725",
            "726",
            "727",
            "728",
            "744"
          ],
          "num": 71
        },
        {
          "qualified_names": [
            "19",
            "68",
            "69",
            "77",
            "80",
            "81",
            "82",
            "83",
            "84",
            "162",
            "187",
            "188",
            "189",
            "190",
            "191",
            "192",
            "193",
            "194",
            "195",
            "196",
            "197",
            "198",
            "199",
            "200",
            "201",
            "202",
            "203",
            "204",
            "205",
            "206",
            "233",
            "234",
            "235",
            "236",
            "237",
            "238",
            "239",
            "240",
            "613",
            "640",
            "641",
            "642",
            "644",
            "646",
            "647",
            "654",
            "655",
            "656",
            "665",
            "675",
            "696",
            "697",
            "698",
            "699",
            "700",
            "701",
            "702",
            "703",
            "704",
            "705",
            "706",
            "707",
            "708",
            "709",
            "710",
            "711",
            "712",
            "713",
            "714",
            "715",
            "716",
            "717",
            "718",
            "719",
            "720",
            "721",
            "722",
            "723",
            "724",
            "738",
            "739",
            "740",
            "741",
            "742",
            "743",
            "744",
            "745",
            "746",
            "747",
            "748",
            "749",
            "750",
            "751",
            "752",
            "753",
            "754",
            "755",
            "756",
            "758",
            "759",
            "760",
            "761",
            "763",
            "764",
            "765",
            "766",
            "767",
            "768",
            "771",
            "785"
          ],
          "num": 110
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/ExpressionDecomposer.java b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\nindex 1e1b19a..a22bbf6 100644\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n@@ -17,8 +17,6 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n-import com.google.common.base.Predicate;\n-import com.google.common.base.Predicates;\n import com.google.common.base.Supplier;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n@@ -67,6 +65,8 @@\n     this.knownConstants \u003d constNames;\n   }\n \n+  private static final int MAX_INTERATIONS \u003d 100;\n+\n   /**\n    * If required, rewrite the statement containing the expression.\n    * @param expression The expression to be exposed.\n@@ -74,8 +74,14 @@\n    */\n   void maybeDecomposeExpression(Node expression) {\n     // If the expression needs to exposed.\n+    int i \u003d 0;\n     while (DecompositionType.DECOMPOSABLE \u003d\u003d canExposeExpression(expression)) {\n       exposeExpression(expression);\n+      if (i \u003e MAX_INTERATIONS) {\n+        throw new IllegalStateException(\n+            \"DecomposeExpression depth exceeded on :\\n\" + \n+            expression.toStringTree());\n+      }\n     }\n   }\n \n@@ -153,7 +159,7 @@\n       Preconditions.checkState(\n           !isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n       if (parentType \u003d\u003d Token.ASSIGN) {\n-          if (parent.getFirstChild().getType() \u003d\u003d Token.NAME) {\n+          if (isSafeAssign(parent, state.sideEffects)) {\n             // It is always safe to inline \"foo()\" for expressions such as\n             // \"a \u003d b \u003d c \u003d foo();\"\n             // As the assignment is unaffected by side effect of \"foo()\"\n@@ -178,19 +184,26 @@\n           }\n       } else if (parentType \u003d\u003d Token.CALL\n           \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n-        Node functionExpression \u003d parent.getFirstChild();\n-        decomposeSubExpressions(\n-            functionExpression.getNext(), child, state);\n-        // Now handle the call expression\n-        if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {\n-          // Either there were preexisting side-effects, or this node has\n-          // side-effects.\n-          state.sideEffects \u003d true;\n-\n-          // Rewrite the call so \"this\" is preserved.\n-          Node replacement \u003d rewriteCallExpression(parent, state);\n-          // Continue from here.\n-          parent \u003d replacement;\n+        // TODO(johnlenz): In Internet Explorer, non-javascript objects such\n+        // as DOM objects can not be decomposed.\n+        if (!maybeExternMethod(parent.getFirstChild())) {\n+          throw new IllegalStateException(\n+              \"External object method calls can not be decomposed.\");\n+        } else {\n+          Node functionExpression \u003d parent.getFirstChild();\n+          decomposeSubExpressions(\n+              functionExpression.getNext(), child, state);\n+          // Now handle the call expression\n+          if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {\n+            // Either there were preexisting side-effects, or this node has\n+            // side-effects.\n+            state.sideEffects \u003d true;\n+  \n+            // Rewrite the call so \"this\" is preserved.\n+            Node replacement \u003d rewriteCallExpression(parent, state);\n+            // Continue from here.\n+            parent \u003d replacement;\n+          }\n         }\n       } else {\n         decomposeSubExpressions(\n@@ -217,6 +230,14 @@\n   }\n \n   /**\n+   * @return Whether the node may represent an external method.\n+   */\n+  private boolean maybeExternMethod(Node node) {\n+    // TODO(johnlenz): Provide some mechanism for determining this.\n+    return true;\n+  }\n+\n+  /**\n    * @return \"expression\" or the node closest to \"expression\", that does not\n    * have a conditional ancestor.\n    */\n@@ -589,11 +610,7 @@\n   DecompositionType canExposeExpression(Node subExpression) {\n     Node expressionRoot \u003d findExpressionRoot(subExpression);\n     if (expressionRoot !\u003d null) {\n-      if (isSubexpressionMovable(expressionRoot, subExpression)) {\n-        return DecompositionType.MOVABLE;\n-      } else {\n-        return DecompositionType.DECOMPOSABLE;\n-      }\n+      return isSubexpressionMovable(expressionRoot, subExpression);\n     }\n     return DecompositionType.UNDECOMPOSABLE;\n   }\n@@ -620,20 +637,23 @@\n    * by x().  Note: this is true even if b is a local variable; the object that\n    * b refers to may have a global alias.\n    *\n-   * @return Whether the call can be moved before the expression.\n+   * @return UNDECOMPOSABLE if the expression can not be moved, DECOMPOSABLE if\n+   * decomposition is required before the expression can be moved, otherwise\n+   * MOVABLE.\n    */\n-  private boolean isSubexpressionMovable(\n+  private DecompositionType isSubexpressionMovable(\n       Node expressionRoot, Node subExpression) {\n-\n-    boolean callExpressionHasSideEffects \u003d NodeUtil.mayHaveSideEffects(\n-        subExpression);\n+    boolean requiresDecomposition \u003d false;\n+    boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n \n     Node child \u003d subExpression;\n     for (Node parent : child.getAncestors()) {\n       if (parent \u003d\u003d expressionRoot) {\n         // Done. The walk back to the root of the expression is complete, and\n         // nothing was encountered that blocks the call from being moved.\n-        return true;\n+        return requiresDecomposition\n+            ? DecompositionType.DECOMPOSABLE\n+            : DecompositionType.MOVABLE;\n       }\n \n       int parentType \u003d parent.getType();\n@@ -642,7 +662,7 @@\n         // Only the first child is always executed, otherwise it must be\n         // decomposed.\n         if (child !\u003d parent.getFirstChild()) {\n-          return false;\n+          requiresDecomposition \u003d true;\n         }\n       } else {\n         // Only inline the call if none of the preceding siblings in the\n@@ -652,8 +672,7 @@\n         // are evaluated.\n \n         // SPECIAL CASE: Assignment to a simple name\n-        if (parentType \u003d\u003d Token.ASSIGN\n-            \u0026\u0026 parent.getFirstChild().getType() \u003d\u003d Token.NAME) {\n+        if (isSafeAssign(parent, seenSideEffects)) {\n           // It is always safe to inline \"foo()\" for expressions such as\n           //   \"a \u003d b \u003d c \u003d foo();\"\n           // As the assignment is unaffected by side effect of \"foo()\"\n@@ -674,8 +693,35 @@\n             }\n \n             if (isExpressionTreeUnsafe(\n-                n, callExpressionHasSideEffects)) {\n-              return false;\n+                n, seenSideEffects)) {\n+              seenSideEffects \u003d true;\n+              requiresDecomposition \u003d true;\n+            }\n+          }\n+\n+          // In Internet Explorer, DOM objects and other external objects\n+          // methods can not be called indirectly, as is required when the \n+          // object or its property can be side-effected.  For example,\n+          // when exposing expression f() (with side-effects) in: x.m(f())\n+          // either the value of x or its property m might have changed, so\n+          // both the \u0027this\u0027 value (\u0027x\u0027) and the function to be called (\u0027x.m\u0027) \n+          // need to be preserved. Like so:\n+          //   var t1 \u003d x, t2 \u003d x.m, t3 \u003d f();\n+          //   t2.call(t1, t3);\n+          // As IE doesn\u0027t support the call to these non-javascript objects \n+          // methods in this way. We can\u0027t do this.\n+          // We don\u0027t currently distinguish between these types of objects\n+          // in the extern definitions and if we did we would need accurate\n+          // type information.\n+          //\n+          Node first \u003d parent.getFirstChild();\n+          if (requiresDecomposition \n+              \u0026\u0026 parent.getType() \u003d\u003d Token.CALL \n+              \u0026\u0026 NodeUtil.isGet(first)) {\n+            if (maybeExternMethod(first)) {\n+              return DecompositionType.UNDECOMPOSABLE;\n+            } else {\n+              return DecompositionType.DECOMPOSABLE;\n             }\n           }\n         }\n@@ -689,45 +735,40 @@\n   }\n \n   /**\n-   * @return Whether the tree can be affect by side-effects occuring elsewhere.\n+   * It is always safe to inline \"foo()\" for expressions such as\n+   *    \"a \u003d b \u003d c \u003d foo();\"\n+   * As the assignment is unaffected by side effect of \"foo()\"\n+   * and the names assigned-to can not influence the state before\n+   * the call to foo.\n+   * \n+   * It is also safe in cases like where the object is constant:\n+   *    CONST_NAME.a \u003d foo()\n+   *    CONST_NAME[CONST_VALUE] \u003d foo(); \n+   * \n+   * This is not true of more complex LHS values, such as\n+   *     a.x \u003d foo();\n+   *     next().x \u003d foo();\n+   * in these cases the checks below are necessary.\n+   * \n+   * @param seenSideEffects If true, check to see if node-tree maybe affected by\n+   * side-effects, otherwise if the tree has side-effects. @see \n+   * isExpressionTreeUnsafe\n+   * @return Whether the assignment is safe from side-effects.\n    */\n-  private boolean canBeSideEffected(Node n) {\n-    return NodeUtil.has(\n-        n, new SideEffected(this.knownConstants),\n-        Predicates.\u003cNode\u003ealwaysTrue());\n-  }\n-\n-  /**\n-   * Predicate for detecting logic that may be affect by side-effects.\n-   */\n-  private static class SideEffected implements Predicate\u003cNode\u003e {\n-    final Set\u003cString\u003e additionalConsts;\n-\n-    SideEffected(Set\u003cString\u003e additionalConsts) {\n-      this.additionalConsts \u003d additionalConsts;\n-    }\n-\n-    /**\n-     * @return Whether the node can be affect by side-effects.\n-     */\n-    public boolean apply(Node n) {\n-      switch (n.getType()) {\n-        case Token.CALL:\n-        case Token.NEW:\n-          // Function calls or constructor can reference changed values.\n-          // TODO(johnlenz): Add some mechanism for determining that functions\n-          // are unaffected by side effects.\n-          return true;\n+  private boolean isSafeAssign(Node n, boolean seenSideEffects) {\n+    if (n.getType() \u003d\u003d Token.ASSIGN) {\n+      Node lhs \u003d n.getFirstChild();\n+      switch (lhs.getType()) {\n         case Token.NAME:\n-          // Non-constant names values may have been changed.\n-          // TODO(johnlenz): A constant Named object may still have\n-          // properties that are non-constant.\n-          return !NodeUtil.isConstantName(n)\n-              \u0026\u0026 !additionalConsts.contains(n.getString());\n-        default:\n-          return false;\n+          return true;\n+        case Token.GETPROP:\n+          return !isExpressionTreeUnsafe(lhs.getFirstChild(), seenSideEffects);\n+        case Token.GETELEM:\n+          return !isExpressionTreeUnsafe(lhs.getFirstChild(), seenSideEffects) \n+              \u0026\u0026 !isExpressionTreeUnsafe(lhs.getLastChild(), seenSideEffects);\n       }\n     }\n+    return false;\n   }\n \n   /**\n@@ -741,7 +782,7 @@\n       // expression tree can be affected by any side-effects.\n \n       // This is a superset of \"NodeUtil.mayHaveSideEffects\".\n-      return canBeSideEffected(n);\n+      return NodeUtil.canBeSideEffected(n, this.knownConstants);\n     } else {\n       // The function called doesn\u0027t have side-effects but check to see if there\n       // are side-effects that that may affect it.\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "FieldDeclaration [1890,1937]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [8907,9118]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [26523,27878]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SimpleType [22808,22825]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [2200,2210]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [22903,22941]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: decomposition is required before the expression can be moved, otherwise [22706,22777]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "TextElement: MOVABLE. [22783,22791]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [2333,2507]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "ReturnStatement [21582,21643]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ReturnStatement [28319,28377]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ReturnStatement [23294,23408]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "MethodInvocation [5808,5847]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [7061,7879]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "MethodInvocation [24073,24110]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: isSafeAssign [5808,5820]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "METHOD_INVOCATION_ARGUMENTS [5821,5846]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "PrefixExpression [7065,7107]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Block [7109,7233]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [7239,7879]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [23650,23679]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: isSafeAssign [24073,24085]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "METHOD_INVOCATION_ARGUMENTS [24086,24109]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [25952,25988]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [25999,26315]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "QualifiedName: state.sideEffects [5829,5846]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: seenSideEffects [24094,24109]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [26003,26113]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [26115,26315]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [24866,25028]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [26129,26303]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodInvocation [26133,26157]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [26159,26229]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [26235,26303]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "QualifiedName: DecompositionType.UNDECOMPOSABLE [26182,26214]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "QualifiedName: DecompositionType.DECOMPOSABLE [26258,26288]"
        },
        {
          "type": "delete-tree",
          "from": "ImportDeclaration [735,775]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ImportDeclaration [776,817]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "METHOD_INVOCATION_RECEIVER [5644,5650]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "SimpleName: getFirstChild [5651,5664]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "MethodInvocation [5644,5666]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "METHOD_INVOCATION_RECEIVER [5644,5666]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "SimpleName: getType [5667,5674]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "MethodInvocation [5644,5676]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "INFIX_EXPRESSION_OPERATOR: \u003d\u003d [5677,5679]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "QualifiedName: Token.NAME [5680,5690]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "InfixExpression [5644,5690]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "Block [20917,20968]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "Block [20974,21030]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "IfStatement [20858,21030]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "PrimitiveType: boolean [22090,22097]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "BooleanLiteral: true [22553,22557]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ReturnStatement [22800,22813]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "InfixExpression [23207,23233]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "INFIX_EXPRESSION_OPERATOR: \u0026\u0026 [23246,23248]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "METHOD_INVOCATION_RECEIVER [23249,23255]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "SimpleName: getFirstChild [23256,23269]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "MethodInvocation [23249,23271]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "METHOD_INVOCATION_RECEIVER [23249,23271]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "SimpleName: getType [23272,23279]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "MethodInvocation [23249,23281]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "INFIX_EXPRESSION_OPERATOR: \u003d\u003d [23282,23284]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "QualifiedName: Token.NAME [23285,23295]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "InfixExpression [23249,23295]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "InfixExpression [23207,23295]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [24051,24172]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [24392,24646]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TypeDeclaration [24650,25718]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ReturnStatement [26159,26187]",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/FunctionArgumentInjector.java",
        "src/com/google/javascript/jscomp/FunctionArgumentInjector.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.FunctionArgumentInjector:maybeAddTempsForCallArguments:[Node fnNode, Map\u003cString,Node\u003e argMap, Set\u003cString\u003e namesNeedingTemps, CodingConvention convention]:void",
            "com.google.javascript.jscomp.FunctionArgumentInjector:canBeSideEffected:[Node n]:boolean"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.FunctionArgumentInjector:maybeAddTempsForCallArguments:[Node fnNode, Map\u003cString,Node\u003e argMap, Set\u003cString\u003e namesNeedingTemps, CodingConvention convention]:void"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "247",
            "448",
            "449",
            "450",
            "451",
            "452",
            "453",
            "454",
            "455",
            "456",
            "457",
            "458",
            "459",
            "460",
            "461",
            "462",
            "463",
            "464",
            "465",
            "466",
            "467",
            "468",
            "469",
            "470",
            "471",
            "472",
            "473",
            "474",
            "475",
            "476",
            "477",
            "478",
            "479",
            "480"
          ],
          "num": 34
        },
        {
          "qualified_names": [
            "247",
            "447"
          ],
          "num": 2
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\nindex 5747f32..c442a07 100644\n--- a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n@@ -244,7 +244,7 @@\n         // Even if there are no references, we still need to evaluate the\n         // expression if it has side-effects.\n         safe \u003d false;\n-      } else if (canBeSideEffected(cArg)\n+      } else if (NodeUtil.canBeSideEffected(cArg)\n           \u0026\u0026 namesAfterSideEffects.contains(argName)) {\n         safe \u003d false;\n       } else if (references \u003e 1) {\n@@ -445,39 +445,6 @@\n     }\n   }\n \n-  // TODO(johnlenz): Move this function to a better location.\n-  /**\n-   * @return Whether the tree can be affect by side-effects occuring elsewhere.\n-   */\n-  private static boolean canBeSideEffected(Node n) {\n-    switch (n.getType()) {\n-      case Token.CALL:\n-        if (!n.isNoSideEffectsCall()) {\n-          return true;\n-        }\n-        // The function itself is a pure function, check the parameters.\n-        break;\n-      case Token.NEW:\n-        // TODO(johnlenz): Add some mechanism for determining that constructors\n-        // are unaffected by side effects.\n-        return true;\n-      case Token.NAME:\n-        // Non-constant names values may have been changed.\n-        if (!NodeUtil.isConstantName(n)) {\n-          return true;\n-        }\n-        break;\n-    }\n-\n-    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n-      if (canBeSideEffected(c)) {\n-        return true;\n-      }\n-    }\n-\n-    return false;\n-  }\n-\n   /**\n    * Get a set of function parameter names.\n    */\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "METHOD_INVOCATION_RECEIVER [8435,8443]"
        },
        {
          "type": "delete-tree",
          "from": "Javadoc [14705,14794]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Modifier: private [14797,14804]",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "PrefixExpression [14910,14934]",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "BreakStatement [15052,15058]",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "PrefixExpression [15320,15347]",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "Block [15349,15383]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "IfStatement [15316,15383]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "BreakStatement [15392,15398]",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [15479,15535]",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/InlineVariables.java",
        "src/com/google/javascript/jscomp/InlineVariables.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:canMoveAggressively:[Reference declaration]:boolean",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineNonConstants:[Scope scope, Var v, ReferenceCollection referenceInfo]:void",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:canMoveModerately:[Reference declaration, Reference reference]:boolean",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:canInline:[Reference declaration, Reference reference]:boolean",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineValue:[Var v, Reference ref, Node value]:void",
            "com.google.javascript.jscomp.InlineVariables:process:[Node externs, Node root]:void",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineWellDefinedVariable:[Var v, List\u003cReference\u003e refSet]:void",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:collectAliasCandidates:[NodeTraversal t, Map\u003cVar,ReferenceCollection\u003e referenceMap]:void",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineDeclaredConstant:[Var v, List\u003cReference\u003e refSet]:void",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:doInlinesForScope:[NodeTraversal t, Map\u003cVar,ReferenceCollection\u003e referenceMap]:void",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:isImmutableAndWellDefinedVariable:[Var v, ReferenceCollection refInfo]:boolean",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:isValidDeclaration:[Reference declaration]:boolean",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:isInlineableDeclaredConstant:[Var var, List\u003cReference\u003e refs]:boolean",
            "com.google.javascript.jscomp.InlineVariables\\$IdentifyConstants:apply:[Var var]:boolean",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inline:[Var v, Reference declaration, Reference reference]:void"
          ],
          "num": 15
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:doInlinesForScope:[NodeTraversal t, Map\u003cVar,ReferenceCollection\u003e referenceMap]:void",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:collectAliasCandidates:[NodeTraversal t, Map\u003cVar,ReferenceCollection\u003e referenceMap]:void",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineWellDefinedVariable:[Var v, Node value, List\u003cReference\u003e refSet]:void",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:isImmutableAndWellDefinedVariable:[Var v, ReferenceCollection refInfo]:boolean",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineValue:[Var v, Reference ref, Node value]:void",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:isInlineableDeclaredConstant:[Var var, ReferenceCollection refInfo]:boolean",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:isValidDeclaration:[Reference declaration]:boolean",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:isValidInitialization:[Reference initialization]:boolean",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineNonConstants:[Var v, ReferenceCollection referenceInfo]:void",
            "com.google.javascript.jscomp.InlineVariables:process:[Node externs, Node root]:void",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:canInline:[Reference declaration, Reference initialization, Reference reference]:boolean",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineDeclaredConstant:[Var v, Node value, List\u003cReference\u003e refSet]:void",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inline:[Var v, Reference declaration, Reference init, Reference reference]:void",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:canMoveAggressively:[Node value]:boolean",
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:canMoveModerately:[Reference initialization, Reference reference]:boolean",
            "com.google.javascript.jscomp.InlineVariables\\$IdentifyConstants:apply:[Var var]:boolean"
          ],
          "num": 16
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "64",
            "65",
            "66",
            "67",
            "68",
            "83",
            "85",
            "86",
            "87",
            "88",
            "103",
            "104",
            "105",
            "106",
            "107",
            "108",
            "109",
            "110",
            "111",
            "112",
            "113",
            "114",
            "115",
            "116",
            "117",
            "118",
            "119",
            "120",
            "121",
            "122",
            "123",
            "124",
            "181",
            "182",
            "183",
            "184",
            "185",
            "212",
            "213",
            "220",
            "225",
            "227",
            "229",
            "231",
            "233",
            "234",
            "236",
            "237",
            "238",
            "239",
            "240",
            "241",
            "242",
            "243",
            "244",
            "245",
            "246",
            "247",
            "248",
            "258",
            "265",
            "266",
            "305",
            "306",
            "307",
            "308",
            "309",
            "316",
            "319",
            "321",
            "322",
            "330",
            "338",
            "372",
            "382",
            "388",
            "389",
            "424",
            "425",
            "431",
            "437",
            "438",
            "441",
            "442",
            "446",
            "447",
            "453",
            "454",
            "456",
            "466",
            "470",
            "471",
            "472",
            "473",
            "486",
            "487",
            "490",
            "491",
            "509",
            "513",
            "524"
          ],
          "num": 101
        },
        {
          "qualified_names": [
            "63",
            "79",
            "94",
            "151",
            "152",
            "153",
            "154",
            "181",
            "182",
            "183",
            "184",
            "191",
            "196",
            "198",
            "199",
            "200",
            "201",
            "202",
            "203",
            "205",
            "207",
            "208",
            "209",
            "211",
            "212",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "220",
            "221",
            "222",
            "223",
            "224",
            "225",
            "226",
            "236",
            "243",
            "244",
            "245",
            "246",
            "247",
            "248",
            "249",
            "288",
            "289",
            "290",
            "291",
            "292",
            "293",
            "294",
            "295",
            "296",
            "297",
            "298",
            "305",
            "309",
            "317",
            "318",
            "326",
            "360",
            "361",
            "362",
            "363",
            "364",
            "365",
            "366",
            "376",
            "381",
            "382",
            "383",
            "384",
            "385",
            "386",
            "387",
            "388",
            "389",
            "390",
            "391",
            "392",
            "393",
            "394",
            "395",
            "396",
            "397",
            "398",
            "399",
            "400",
            "401",
            "402",
            "404",
            "405",
            "440",
            "441",
            "442",
            "443",
            "444",
            "445",
            "446",
            "447",
            "448",
            "449",
            "450",
            "451",
            "452",
            "453",
            "454",
            "460",
            "461",
            "467",
            "468",
            "471",
            "472",
            "473",
            "474",
            "475",
            "476",
            "477",
            "478",
            "482",
            "483",
            "489",
            "490",
            "501",
            "502",
            "506",
            "507",
            "508",
            "509",
            "510",
            "511",
            "512",
            "513",
            "514",
            "515",
            "516",
            "517",
            "518",
            "519",
            "520",
            "521",
            "522",
            "535",
            "536",
            "539",
            "540",
            "541",
            "542",
            "543",
            "544",
            "545",
            "546",
            "547",
            "548",
            "549",
            "550",
            "551",
            "552",
            "553",
            "554",
            "555",
            "556",
            "557",
            "558",
            "576",
            "577",
            "578",
            "582",
            "583",
            "584",
            "585",
            "586",
            "587",
            "588",
            "589",
            "590",
            "591",
            "592",
            "603",
            "604"
          ],
          "num": 182
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex edd59d8..6f0d5f2 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -61,11 +61,6 @@\n   // Inlines all strings, even if they increase the size of the gzipped binary.\n   private final boolean inlineAllStrings;\n \n-  // All declared constant variables with immutable values.\n-  // These should be inlined even if we can\u0027t prove that they\u0027re written before\n-  // first use.\n-  private final Set\u003cVar\u003e declaredConstants \u003d Sets.newHashSet();\n-\n   private final IdentifyConstants identifyConstants \u003d new IdentifyConstants();\n \n   InlineVariables(AbstractCompiler compiler, boolean onlyConstants,\n@@ -80,12 +75,8 @@\n     ReferenceCollectingCallback callback \u003d new ReferenceCollectingCallback(\n         compiler, new InliningBehavior(),\n         onlyConstants ?\n-            // Filter all constants, and put them in the declaredConstants map.\n             identifyConstants :\n-            // Put all the constants in declaredConstants, but accept\n-            // all variables.\n-            Predicates.\u003cVar\u003eor(\n-                identifyConstants, Predicates.\u003cVar\u003ealwaysTrue()));\n+            Predicates.\u003cVar\u003ealwaysTrue());\n     callback.process(externs, root);\n   }\n \n@@ -100,28 +91,7 @@\n   private class IdentifyConstants implements Predicate\u003cVar\u003e {\n     @Override\n     public boolean apply(Var var) {\n-      if (declaredConstants.contains(var)) {\n-        return true;\n-      }\n-\n-      if (!var.isConst()) {\n-        return false;\n-      }\n-\n-      if (var.getInitialValue() \u003d\u003d null) {\n-        // This constant is either externally defined or initialized shortly\n-        // after being declared (e.g. in an anonymous function used to hide\n-        // temporary variables), so the constant is ineligible for inlining.\n-        return false;\n-      }\n-\n-      // Is the constant\u0027s value immutable?\n-      if (!NodeUtil.isImmutableValue(var.getInitialValue())) {\n-        return false;\n-      }\n-\n-      declaredConstants.add(var);\n-      return true;\n+      return var.isConst();\n     }\n   }\n \n@@ -178,11 +148,10 @@\n           // another pass that handles unused variables much more elegantly.\n           if (referenceInfo !\u003d null \u0026\u0026 referenceInfo.references.size() \u003e\u003d 2 \u0026\u0026\n               referenceInfo.isWellDefined() \u0026\u0026\n-              referenceInfo.isNeverReassigned()) {\n-            Reference declaration \u003d referenceInfo.references.get(0);\n-            Node value \u003d declaration.getNameNode().getFirstChild();\n-            if (declaration.getParent().getType() \u003d\u003d Token.VAR \u0026\u0026\n-                value !\u003d null \u0026\u0026 value.getType() \u003d\u003d Token.NAME) {\n+              referenceInfo.isAssignedOnce()) {\n+            Reference init \u003d referenceInfo.getInitializingReference();\n+            Node value \u003d init.getAssignedValue();\n+            if (value !\u003d null \u0026\u0026 value.getType() \u003d\u003d Token.NAME) {\n               aliasCandidates.put(value, new AliasCandidate(v, referenceInfo));\n             }\n           }\n@@ -209,43 +178,52 @@\n           // Never try to inline exported variables or variables that\n           // were not collected or variables that have already been inlined.\n           continue;\n-        } else if (isInlineableDeclaredConstant(v, referenceInfo.references)) {\n-          inlineDeclaredConstant(v, referenceInfo.references);\n+        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {\n+          Reference init \u003d referenceInfo.getInitializingReferenceForConstants();\n+          Node value \u003d init.getAssignedValue();\n+          inlineDeclaredConstant(v, value, referenceInfo.references);\n           staleVars.add(v);\n         } else if (onlyConstants) {\n           // If we\u0027re in constants-only mode, don\u0027t run more aggressive\n           // inlining heuristics. See InlineConstantsTest.\n           continue;\n         } else {\n-          inlineNonConstants(t.getScope(), v, referenceInfo);\n+          inlineNonConstants(v, referenceInfo);\n         }\n       }\n     }\n \n-    private void inlineNonConstants(Scope scope,\n+    private void inlineNonConstants(\n         Var v, ReferenceCollection referenceInfo) {\n-      if (referenceInfo.references.size() \u003e\u003d 2 \u0026\u0026\n+      int refCount \u003d referenceInfo.references.size();\n+      Reference declaration \u003d referenceInfo.references.get(0);\n+      Reference init \u003d referenceInfo.getInitializingReference();\n+      int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n+\n+      if (refCount \u003e 1 \u0026\u0026\n           isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n-        // if the variable is defined more than twice, we can only\n+        // if the variable is referenced more than once, we can only\n         // inline it if it\u0027s immutable and never defined before referenced.\n-        inlineWellDefinedVariable(v, referenceInfo.references);\n+        Node value \u003d init.getAssignedValue();\n+        Preconditions.checkNotNull(value);\n+        inlineWellDefinedVariable(v, value, referenceInfo.references);\n         staleVars.add(v);\n-      } else if (referenceInfo.references.size() \u003d\u003d 2) {\n-        // if the variable is only referenced once, we can try some more\n+      } else if (refCount \u003d\u003d firstRefAfterInit) {\n+        // The variable likely only read once, try some more\n         // complex inlining heuristics.\n-        Reference declaration \u003d referenceInfo.references.get(0);\n-        Reference reference \u003d referenceInfo.references.get(1);\n-\n-        if (canInline(declaration, reference)) {\n-          // If the value being inlined contains references to variables\n-          // that have not yet been considered for inlining, we won\u0027t\n-          // be able to inline them later because the reference collection\n-          // will be wrong. So blacklist those variables from inlining.\n-          // We\u0027ll pick them up on the next pass.\n-          blacklistVarReferencesInTree(\n-              declaration.getNameNode().getFirstChild(), scope);\n-\n-          inline(v, declaration, reference);\n+        Reference reference \u003d referenceInfo.references.get(\n+            firstRefAfterInit - 1);\n+        if (canInline(declaration, init, reference)) {\n+          inline(v, declaration, init, reference);\n+          staleVars.add(v);\n+        }\n+      } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n+        if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n+          // The only reference is the initialization, remove the assignment and\n+          // the variable declaration.\n+          Node value \u003d init.getAssignedValue();\n+          Preconditions.checkNotNull(value);\n+          inlineWellDefinedVariable(v, value, referenceInfo.references);\n           staleVars.add(v);\n         }\n       }\n@@ -255,15 +233,20 @@\n       // reference data is out of sync. We\u0027re better off just waiting for\n       // the next pass.)\n       if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026\n-          referenceInfo.isNeverReassigned()) {\n+          referenceInfo.isAssignedOnce()) {\n         List\u003cReference\u003e refs \u003d referenceInfo.references;\n         for (int i \u003d 1 /* start from a read */; i \u003c refs.size(); i++) {\n           Node nameNode \u003d refs.get(i).getNameNode();\n           if (aliasCandidates.containsKey(nameNode)) {\n             AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n             if (!staleVars.contains(candidate.alias)) {\n-              inlineWellDefinedVariable(\n-                  candidate.alias, candidate.refInfo.references);\n+              Reference aliasInit;\n+              aliasInit \u003d candidate.refInfo.getInitializingReference();\n+              Node value \u003d aliasInit.getAssignedValue();\n+              Preconditions.checkNotNull(value);\n+              inlineWellDefinedVariable(candidate.alias,\n+                  value,\n+                  candidate.refInfo.references);\n               staleVars.add(candidate.alias);\n             }\n           }\n@@ -302,24 +285,28 @@\n      * Do the actual work of inlining a single declaration into a single\n      * reference.\n      */\n-    private void inline(Var v, Reference declaration, Reference reference) {\n-      Node name \u003d declaration.getNameNode();\n-      Preconditions.checkState(name.getFirstChild() !\u003d null);\n-      Node value \u003d name.removeFirstChild();\n-      inlineValue(v, reference, value);\n+    private void inline(Var v, Reference declaration,\n+                        Reference init, Reference reference) {\n+      Node value \u003d init.getAssignedValue();\n+      Preconditions.checkState(value !\u003d null);\n+\n+      inlineValue(v, reference, value.detachFromParent());\n+      if (declaration !\u003d init) {\n+        Node expressRoot \u003d init.getGrandparent();\n+        Preconditions.checkState(expressRoot.getType() \u003d\u003d Token.EXPR_RESULT);\n+        NodeUtil.removeChild(expressRoot.getParent(), expressRoot);\n+      }\n       removeDeclaration(declaration);\n     }\n \n     /**\n      * Inline an immutable variable into all of its references.\n      */\n-    private void inlineWellDefinedVariable(Var v,\n+    private void inlineWellDefinedVariable(Var v, Node value,\n         List\u003cReference\u003e refSet) {\n       Reference decl \u003d refSet.get(0);\n-\n       for (int i \u003d 1; i \u003c refSet.size(); i++) {\n-        inlineValue(v, refSet.get(i),\n-            decl.getNameNode().getFirstChild().cloneTree());\n+        inlineValue(v, refSet.get(i), value.cloneTree());\n       }\n       removeDeclaration(decl);\n     }\n@@ -327,7 +314,8 @@\n     /**\n      * Inline a declared constant.\n      */\n-    private void inlineDeclaredConstant(Var v, List\u003cReference\u003e refSet) {\n+    private void inlineDeclaredConstant(Var v, Node value,\n+        List\u003cReference\u003e refSet) {\n       // Replace the references with the constant value\n       Reference decl \u003d null;\n \n@@ -335,7 +323,7 @@\n         if (r.getNameNode() \u003d\u003d v.getNameNode()) {\n           decl \u003d r;\n         } else {\n-          inlineValue(v, r, v.getInitialValue().cloneTree());\n+          inlineValue(v, r, value.cloneTree());\n         }\n       }\n \n@@ -369,7 +357,13 @@\n      *     to re-parent.\n      */\n     private void inlineValue(Var v, Reference ref, Node value) {\n-      ref.getParent().replaceChild(ref.getNameNode(), value);\n+      Node parent \u003d ref.getParent();\n+      if (ref.isSimpleAssignmentToName()) {\n+        // This is the initial assignment.\n+        ref.getGrandparent().replaceChild(parent, value);\n+      } else {\n+        ref.getParent().replaceChild(ref.getNameNode(), value);\n+      }\n       blacklistVarReferencesInTree(value, v.scope);\n       compiler.reportCodeChange();\n     }\n@@ -379,14 +373,36 @@\n      * and may be inlined.\n      */\n     private boolean isInlineableDeclaredConstant(Var var,\n-        List\u003cReference\u003e refs) {\n+        ReferenceCollection refInfo) {\n       if (!identifyConstants.apply(var)) {\n         return false;\n       }\n \n+      if (!refInfo.isAssignedOnce()) {\n+        return false;\n+      }\n+\n+      Reference init \u003d refInfo.getInitializingReferenceForConstants();\n+      if (init \u003d\u003d null) {\n+        return false;\n+      }\n+\n+      Node value \u003d init.getAssignedValue();\n+      if (value \u003d\u003d null) {\n+        // This constant is either externally defined or initialized indirectly\n+        // (e.g. in an anonymous function used to hide\n+        // temporary variables), so the constant is ineligible for inlining.\n+        return false;\n+      }\n+\n+      // Is the constant\u0027s value immutable?\n+      if (!NodeUtil.isImmutableValue(value)) {\n+        return false;\n+      }\n+\n       // Determine if we should really inline a String or not.\n-      return var.getInitialValue().getType() !\u003d Token.STRING ||\n-          isStringWorthInlining(var, refs);\n+      return value.getType() !\u003d Token.STRING ||\n+          isStringWorthInlining(var, refInfo.references);\n     }\n \n     /**\n@@ -421,39 +437,58 @@\n      * @return true if the provided reference and declaration can be safely\n      *         inlined according to our criteria\n      */\n-    private boolean canInline(Reference declaration, Reference reference) {\n-      if (!isValidDeclaration(declaration) || !isValidReference(reference)) {\n+    private boolean canInline(\n+        Reference declaration,\n+        Reference initialization,\n+        Reference reference) {\n+      if (!isValidDeclaration(declaration)\n+          || !isValidInitialization(initialization)\n+          || !isValidReference(reference)) {\n+        return false;\n+      }\n+\n+      // If the value is read more than once, skip it.\n+      // VAR declarations and EXPR_RESULT don\u0027t need the value, but other\n+      // ASSIGN expressions parents do.\n+      if (declaration !\u003d initialization \u0026\u0026\n+          initialization.getGrandparent().getType() !\u003d Token.EXPR_RESULT) {\n         return false;\n       }\n \n       // Be very conservative and do no cross control structures or\n       // scope boundaries\n-      if (declaration.getBasicBlock() !\u003d reference.getBasicBlock()) {\n+      if (declaration.getBasicBlock() !\u003d initialization.getBasicBlock()\n+          || declaration.getBasicBlock() !\u003d reference.getBasicBlock()) {\n         return false;\n       }\n \n       // Do not inline into a call node. This would change\n       // the context in which it was being called. For example,\n-      // var a \u003d b.c;\n-      // a();\n+      //   var a \u003d b.c;\n+      //   a();\n       // should not be inlined, because it calls a in the context of b\n       // rather than the context of the window.\n-      if (declaration.getNameNode().getFirstChild().getType() \u003d\u003d Token.GETPROP\n-          \u0026\u0026 reference.getParent().getType() \u003d\u003d Token.CALL) {\n+      //   var a \u003d b.c;\n+      //   f(a)\n+      // is ok.\n+      Node value \u003d initialization.getAssignedValue();\n+      Preconditions.checkState(value !\u003d null);\n+      if (value.getType() \u003d\u003d Token.GETPROP\n+          \u0026\u0026 reference.getParent().getType() \u003d\u003d Token.CALL\n+          \u0026\u0026 reference.getParent().getFirstChild() \u003d\u003d reference.getNameNode()) {\n         return false;\n       }\n \n-      return canMoveAggressively(declaration) ||\n-          canMoveModerately(declaration, reference);\n+      return canMoveAggressively(value) ||\n+          canMoveModerately(initialization, reference);\n     }\n \n     /**\n      * If the value is a literal, we can cross more boundaries to inline it.\n      */\n-    private boolean canMoveAggressively(Reference declaration) {\n-      // Anonymous functions and other mutable objects can move within \n+    private boolean canMoveAggressively(Node value) {\n+      // Anonymous functions and other mutable objects can move within\n       // the same basic block.\n-      Node value \u003d declaration.getNameNode().getFirstChild();\n       return NodeUtil.isLiteralValue(value)\n           || value.getType() \u003d\u003d Token.FUNCTION;\n     }\n@@ -463,14 +498,28 @@\n      * state. Therefore it cannot be moved past anything else that may modify\n      * the value being read or read values that are modified.\n      */\n-    private boolean canMoveModerately(Reference declaration,\n+    private boolean canMoveModerately(\n+        Reference initialization,\n         Reference reference) {\n       // Check if declaration can be inlined without passing\n       // any side-effect causing nodes.\n-      Iterator\u003cNode\u003e it \u003d new NodeIterators.LocalVarMotion(\n-          declaration.getNameNode(),\n-          declaration.getParent(),\n-          declaration.getGrandparent());\n+      Iterator\u003cNode\u003e it;\n+      if (initialization.getParent().getType() \u003d\u003d Token.VAR) {\n+        it \u003d NodeIterators.LocalVarMotion.forVar(\n+            initialization.getNameNode(),     // NAME\n+            initialization.getParent(),       // VAR\n+            initialization.getGrandparent()); // VAR container\n+      } else if (initialization.getParent().getType() \u003d\u003d Token.ASSIGN) {\n+        Preconditions.checkState(\n+            initialization.getGrandparent().getType() \u003d\u003d Token.EXPR_RESULT);\n+        it \u003d NodeIterators.LocalVarMotion.forAssign(\n+            initialization.getNameNode(),     // NAME\n+            initialization.getParent(),       // ASSIGN\n+            initialization.getGrandparent(),  // EXPR_RESULT\n+            initialization.getGrandparent().getParent()); // EXPR container\n+      } else {\n+        throw new IllegalStateException(\"Unexpected initialiation parent\");\n+      }\n       Node targetName \u003d reference.getNameNode();\n       while (it.hasNext()) {\n         Node curNode \u003d it.next();\n@@ -483,12 +532,30 @@\n     }\n \n     /**\n-     * @return true if the reference is a normal VAR declaration with\n-     *    initial value. (Only normal VARs can be inlined.)\n+     * @return true if the reference is a normal VAR declaration (only normal\n+     * VARs can be inlined).\n      */\n     private boolean isValidDeclaration(Reference declaration) {\n-      return declaration.isDeclaration() \u0026\u0026\n-          declaration.getNameNode().getFirstChild() !\u003d null;\n+      return declaration.getParent().getType() \u003d\u003d Token.VAR\n+          \u0026\u0026 declaration.getGrandparent().getType() !\u003d Token.FOR;\n+    }\n+\n+    /**\n+     * @return Whether\n+     */\n+    private boolean isValidInitialization(Reference initialization) {\n+      if (initialization \u003d\u003d null) {\n+        return false;\n+      } else if (initialization.isDeclaration()) {\n+        // The reference is a normal VAR declaration with\n+        return initialization.getNameNode().getFirstChild() !\u003d null;\n+      } else {\n+        Node parent \u003d initialization.getParent();\n+        Preconditions.checkState(\n+            parent.getType() \u003d\u003d Token.ASSIGN\n+            \u0026\u0026 parent.getFirstChild() \u003d\u003d initialization.getNameNode());\n+        return true;\n+      }\n     }\n \n     /**\n@@ -506,11 +573,23 @@\n     private boolean isImmutableAndWellDefinedVariable(Var v,\n         ReferenceCollection refInfo) {\n       List\u003cReference\u003e refSet \u003d refInfo.references;\n-      if (!isValidDeclaration(refSet.get(0))) {\n+      int startingReadRef \u003d 1;\n+      Reference refDecl \u003d refSet.get(0);\n+      if (!isValidDeclaration(refDecl)) {\n         return false;\n       }\n \n-      for (int i \u003d 1; i \u003c refSet.size(); i++) {\n+      Reference refInit \u003d refInfo.getInitializingReference();\n+      if (!isValidInitialization(refInit)) {\n+        return false;\n+      }\n+\n+      if (refDecl !\u003d refInit) {\n+        Preconditions.checkState(refInit \u003d\u003d refSet.get(1));\n+        startingReadRef \u003d 2;\n+      }\n+\n+      for (int i \u003d startingReadRef; i \u003c refSet.size(); i++) {\n         Reference ref \u003d refSet.get(i);\n         if (!isValidReference(ref)) {\n           return false;\n@@ -521,7 +600,8 @@\n         return false;\n       }\n \n-      Node value \u003d refSet.get(0).getNameNode().getFirstChild();\n+      Node value \u003d refInit.getAssignedValue();\n+      Preconditions.checkNotNull(value);\n       return NodeUtil.isImmutableValue(value) \u0026\u0026\n           (value.getType() !\u003d Token.STRING ||\n            isStringWorthInlining(v, refInfo.references));\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [13546,14635]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [19712,20303]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SingleVariableDeclaration [11023,11037]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SingleVariableDeclaration [11625,11635]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SingleVariableDeclaration [11959,11969]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SingleVariableDeclaration [15916,15940]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SingleVariableDeclaration [17625,17635]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Javadoc [19392,19510]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "ReturnStatement [3323,3344]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "VariableDeclarationStatement [7143,7190]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [7260,7318]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "VariableDeclarationStatement [7325,7379]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [11219,11449]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [13185,13215]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [13222,13447]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [16319,16461]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [17077,17124]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [17131,17171]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [18285,18303]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [18310,19169]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ReturnStatement [19581,19700]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "VariableDeclarationStatement [20873,20897]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "VariableDeclarationStatement [20904,20938]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [21018,21073]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [21080,21148]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [21156,21278]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [21584,21618]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "PrimitiveType: int [7143,7146]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "VariableDeclarationFragment [7147,7189]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "PrimitiveType: int [7325,7328]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "VariableDeclarationFragment [7329,7378]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodInvocation [13226,13256]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Block [13258,13368]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [13374,13447]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "InfixExpression [16567,16698]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "InfixExpression [17182,17351]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "PrimitiveType: int [20873,20876]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "VariableDeclarationFragment [20877,20896]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SimpleType [20904,20913]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "VariableDeclarationFragment [20914,20937]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: refCount [7147,7155]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: firstRefAfterInit [7329,7346]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "ConditionalExpression [7349,7378]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [7625,7662]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [7671,7705]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [8207,8660]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "PrefixExpression [16029,16067]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [16567,16628]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "INFIX_EXPRESSION_OPERATOR: || [16639,16641]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "INFIX_EXPRESSION_OPERATOR: \u0026\u0026 [17284,17286]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "InfixExpression [17287,17351]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: startingReadRef [20877,20892]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: refDecl [20914,20921]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ParenthesizedExpression [7349,7370]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "NumberLiteral: 3 [7377,7378]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: refCount [7391,7399]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: refCount [7820,7828]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: firstRefAfterInit [7832,7849]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "MethodInvocation [11186,11210]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "MethodInvocation [17287,17324]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "INFIX_EXPRESSION_OPERATOR: \u003d\u003d [17325,17327]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "MethodInvocation [17328,17351]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: startingReadRef [21299,21314]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: value [11137,11142]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "METHOD_INVOCATION_RECEIVER [11186,11191]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: detachFromParent [11192,11208]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "METHOD_INVOCATION_RECEIVER [17287,17308]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "METHOD_INVOCATION_RECEIVER [17328,17337]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: refDecl [20969,20976]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: refInit [21550,21557]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [6554,6624]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [6635,6672]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: value [7743,7748]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [5377,5435]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: referenceInfo [6526,6539]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: init [8085,8089]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: value [17182,17187]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "InfixExpression [8026,8047]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: value [11795,11800]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: value [6709,6714]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: firstRefAfterInit [8026,8043]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "INFIX_EXPRESSION_OPERATOR: - [8044,8045]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: init [8138,8142]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [9390,9410]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [9425,9482]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [9497,9539]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [9554,9588]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: value [12241,12246]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: init [5461,5465]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: value [9664,9669]"
        },
        {
          "type": "delete-tree",
          "from": "FieldDeclaration [2405,2466]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "SimpleName: identifyConstants [3066,3083]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "METHOD_INVOCATION_RECEIVER [3198,3208]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "SimpleName: or [3214,3216]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "METHOD_INVOCATION_ARGUMENTS [3234,3281]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "MethodInvocation [3198,3282]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [3780,3847]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "PREFIX_EXPRESSION_OPERATOR: ! [3859,3860]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "PrefixExpression [3859,3873]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "Block [3875,3906]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "IfStatement [3855,3906]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [3914,4210]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [4262,4348]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [4356,4383]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ReturnStatement [4390,4402]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [6438,6494]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodInvocation [6520,6545]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "InfixExpression [6579,6625]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "INFIX_EXPRESSION_OPERATOR: \u0026\u0026 [6626,6628]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "InfixExpression [6579,6658]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "QualifiedName: referenceInfo.references [7669,7693]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodInvocation [8022,8034]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SingleVariableDeclaration [8116,8127]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [9227,9321]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [11547,11585]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodInvocation [11617,11637]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodInvocation [12078,12112]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodInvocation [12533,12552]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [13645,14095]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "METHOD_INVOCATION_RECEIVER [15974,15985]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "MethodInvocation [15974,15999]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "METHOD_INVOCATION_RECEIVER [15974,15999]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "MethodInvocation [15974,16015]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SingleVariableDeclaration [16378,16399]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [16512,16567]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [17100,17266]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "Javadoc [17489,17630]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ReturnStatement [17701,17799]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodInvocation [18704,18731]",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/NodeIterators.java",
        "src/com/google/javascript/jscomp/NodeIterators.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.NodeIterators\\$LocalVarMotion:LocalVarMotion:[Node... ancestors]:null"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.NodeIterators\\$LocalVarMotion:forAssign:[Node name, Node assign, Node expr, Node block]:LocalVarMotion",
            "com.google.javascript.jscomp.NodeIterators\\$LocalVarMotion:forVar:[Node name, Node var, Node block]:LocalVarMotion",
            "com.google.javascript.jscomp.NodeIterators\\$LocalVarMotion:LocalVarMotion:[Node nameNode, FunctionlessLocalScope iterator]:null"
          ],
          "num": 3
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "160",
            "161",
            "162",
            "164",
            "165",
            "166",
            "167",
            "169",
            "171",
            "172",
            "176"
          ],
          "num": 11
        },
        {
          "qualified_names": [
            "160",
            "161",
            "163",
            "164",
            "165",
            "166",
            "167",
            "168",
            "169",
            "170",
            "171",
            "172",
            "173",
            "175",
            "176",
            "177",
            "178",
            "179",
            "180",
            "181",
            "182",
            "183",
            "184",
            "185",
            "186",
            "187",
            "189",
            "190",
            "191",
            "192",
            "193",
            "194",
            "195",
            "199"
          ],
          "num": 34
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/NodeIterators.java b/src/com/google/javascript/jscomp/NodeIterators.java\nindex b0593d1..787eeb7 100644\n--- a/src/com/google/javascript/jscomp/NodeIterators.java\n+++ b/src/com/google/javascript/jscomp/NodeIterators.java\n@@ -157,23 +157,46 @@\n     private Node lookAhead;\n \n     /**\n-     * @param ancestors The ancestors of the point where iteration will start,\n-     *     beginning with the deepest ancestor. The start node will not be\n-     *     exposed in the iteration.\n+     * @return Create a LocalVarMotion for use with moving a value assigned\n+     * at a variable declaration.\n      */\n-    LocalVarMotion(Node ... ancestors) {\n-      Preconditions.checkArgument(ancestors.length \u003e\u003d 2);\n-      Preconditions.checkArgument(ancestors[0].getType() \u003d\u003d Token.NAME);\n-      Preconditions.checkArgument(ancestors[1].getType() \u003d\u003d Token.VAR);\n+    static LocalVarMotion forVar(\n+        Node name, Node var, Node block) {\n+      Preconditions.checkArgument(var.getType() \u003d\u003d Token.VAR);\n+      Preconditions.checkArgument(NodeUtil.isStatement(var));\n+      // The FunctionlessLocalScope must start at \"name\" as this may be used\n+      // before the Normalize pass, and thus the VAR node may define multiple\n+      // names and the \"name\" node may have siblings.  The actual assigned\n+      // value is skipped as it is a child of name.\n+      return new LocalVarMotion(\n+          name, new FunctionlessLocalScope(name, var, block));\n+    }\n \n-      this.iterator \u003d new FunctionlessLocalScope(ancestors);\n+    /**\n+     * @return Create a LocalVarMotion for use with moving a value assigned\n+     * as part of a simple assignment expression (\"a \u003d b;\").\n+     */\n+    static LocalVarMotion forAssign(\n+        Node name, Node assign, Node expr, Node block) {\n+      Preconditions.checkArgument(assign.getType() \u003d\u003d Token.ASSIGN);\n+      Preconditions.checkArgument(expr.getType() \u003d\u003d Token.EXPR_RESULT);\n+      // The FunctionlessLocalScope must start at \"assign\", to skip the value\n+      // assigned to \"name\" (which would be its sibling).\n+      return new LocalVarMotion(\n+          name, new FunctionlessLocalScope(assign, expr, block));\n+    }\n \n-      Node nameNode \u003d ancestors[0];\n-      Node valueNode \u003d nameNode.getFirstChild();\n+    /**\n+     * @param iterator The to use while inspecting the node\n+     *     beginning with the deepest ancestor.\n+     */\n+    private LocalVarMotion(Node nameNode, FunctionlessLocalScope iterator) {\n+      Preconditions.checkArgument(nameNode.getType() \u003d\u003d Token.NAME);\n+      Node valueNode \u003d NodeUtil.getAssignedValue(nameNode);\n       this.varName \u003d nameNode.getString();\n       this.valueHasSideEffects \u003d valueNode !\u003d null \u0026\u0026\n           NodeUtil.mayHaveSideEffects(valueNode);\n-\n+      this.iterator \u003d iterator;\n       advanceLookAhead(true);\n     }\n \n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [4339,5046]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [5052,5676]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Javadoc [5682,5801]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Modifier: private [5806,5813]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SingleVariableDeclaration [5829,5842]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SingleVariableDeclaration [5844,5875]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [6161,6186]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "METHOD_INVOCATION_ARGUMENTS [5997,6005]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: NodeUtil [5971,5979]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: nameNode [5913,5921]"
        },
        {
          "type": "delete-tree",
          "from": "Javadoc [4339,4541]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SingleVariableDeclaration [4561,4579]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [4589,4640]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ArrayAccess [4675,4687]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [4720,4785]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [4793,4847]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [4855,4884]",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/NodeUtil.java",
        "src/com/google/javascript/jscomp/NodeUtil.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.NodeUtil:removeChild:[Node parent, Node node]:void",
            "com.google.javascript.jscomp.NodeUtil:isString:[Node n]:boolean"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.NodeUtil:canBeSideEffected:[Node n, Set\u003cString\u003e knownConstants]:boolean",
            "com.google.javascript.jscomp.NodeUtil:isString:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:canBeSideEffected:[Node n]:boolean",
            "com.google.javascript.jscomp.NodeUtil:getAssignedValue:[Node n]:Node",
            "com.google.javascript.jscomp.NodeUtil:removeChild:[Node parent, Node node]:void"
          ],
          "num": 5
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "30",
            "543",
            "742",
            "955",
            "964"
          ],
          "num": 5
        },
        {
          "qualified_names": [
            "31",
            "545",
            "546",
            "547",
            "548",
            "549",
            "550",
            "551",
            "552",
            "553",
            "554",
            "555",
            "556",
            "557",
            "558",
            "559",
            "560",
            "561",
            "562",
            "563",
            "564",
            "565",
            "566",
            "567",
            "568",
            "569",
            "570",
            "571",
            "572",
            "573",
            "574",
            "575",
            "576",
            "577",
            "578",
            "579",
            "580",
            "581",
            "582",
            "583",
            "584",
            "585",
            "586",
            "587",
            "787",
            "788",
            "789",
            "790",
            "791",
            "792",
            "793",
            "794",
            "795",
            "796",
            "797",
            "798",
            "799",
            "800",
            "801",
            "802",
            "1016",
            "1017",
            "1027",
            "1028"
          ],
          "num": 64
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 4e8e256..0ec71df 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -28,6 +28,7 @@\n \n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n@@ -541,6 +542,49 @@\n     }\n   }\n \n+  /**\n+   * @return Whether the tree can be affected by side-effects or\n+   * has side-effects.\n+   */\n+  static boolean canBeSideEffected(Node n) {\n+    Set\u003cString\u003e emptySet \u003d Collections.emptySet();\n+    return canBeSideEffected(n, emptySet);\n+  }\n+\n+  /**\n+   * @param knownConstants A set of names known to be constant value at\n+   * node \u0027n\u0027 (such as locals that are last written before n can execute).\n+   * @return Whether the tree can be affected by side-effects or\n+   * has side-effects.\n+   */\n+  static boolean canBeSideEffected(Node n, Set\u003cString\u003e knownConstants) {\n+    switch (n.getType()) {\n+      case Token.CALL:\n+      case Token.NEW:\n+        // Function calls or constructor can reference changed values.\n+        // TODO(johnlenz): Add some mechanism for determining that functions\n+        // are unaffected by side effects.\n+        return true;\n+      case Token.NAME:\n+        // Non-constant names values may have been changed.\n+        return !NodeUtil.isConstantName(n)\n+            \u0026\u0026 !knownConstants.contains(n.getString());\n+\n+      // Properties on constant NAMEs can still be side-effected.\n+      case Token.GETPROP:\n+      case Token.GETELEM:\n+        return true;\n+    }\n+\n+    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n+      if (canBeSideEffected(c, knownConstants)) {\n+        return true;\n+      }\n+    }\n+\n+    return false;    \n+  }\n+\n   /*\n    *  0 comma ,\n    *  1 assignment \u003d +\u003d -\u003d *\u003d /\u003d %\u003d \u003c\u003c\u003d \u003e\u003e\u003d \u003e\u003e\u003e\u003d \u0026\u003d ^\u003d |\u003d\n@@ -740,6 +784,22 @@\n   }\n \n   /**\n+   * For an assignment or variable declaration get the assigned value.\n+   * @return The value node representing the new value.\n+   */\n+  static Node getAssignedValue(Node n) {\n+    Preconditions.checkState(isName(n));\n+    Node parent \u003d n.getParent();\n+    if (isVar(parent)) {\n+      return n.getFirstChild();\n+    } else if (isAssign(parent) \u0026\u0026 parent.getFirstChild() \u003d\u003d n) {\n+      return n.getNext();\n+    } else {\n+      return null;\n+    }\n+  }\n+  \n+  /**\n    * Is this a STRING node?\n    */\n   static boolean isString(Node n) {\n@@ -953,6 +1013,8 @@\n       if (parent.hasMoreThanOneChild()) {\n         parent.removeChild(node);\n       } else {\n+        // Remove the node from the parent, so it can be reused.\n+        parent.removeChild(node);\n         // This would leave an empty VAR, remove the VAR itself.\n         removeChild(parent.getParent(), parent);\n       }\n@@ -962,6 +1024,8 @@\n       node.detachChildren();\n     } else if (parent.getType() \u003d\u003d Token.LABEL\n         \u0026\u0026 node \u003d\u003d parent.getLastChild()) {\n+      // Remove the node from the parent, so it can be reused.\n+      parent.removeChild(node);\n       // A LABEL without children can not be referred to, remove it.\n       removeChild(parent.getParent(), parent);\n     } else if (parent.getType() \u003d\u003d Token.FOR\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [1083,1112]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [15307,15547]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [21593,22035]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Javadoc [15551,15795]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SingleVariableDeclaration [15839,15865]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ReturnStatement [16244,16334]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SwitchCase [16408,16427]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SwitchCase [16434,16453]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodInvocation [16559,16595]"
        },
        {
          "type": "M",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [28015,28040]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [28496,28521]"
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/Normalize.java",
        "src/com/google/javascript/jscomp/Normalize.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.Normalize:doStatementNormalizations:[NodeTraversal t, Node n, Node parent]:void",
            "com.google.javascript.jscomp.Normalize:splitAssignments:[Node n]:void",
            "com.google.javascript.jscomp.Normalize:isCompoundAssignment:[Node n]:boolean"
          ],
          "num": 3
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.Normalize:removeDuplicateDeclarations:[Node root]:void"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "71",
            "72",
            "261",
            "262",
            "263",
            "341",
            "342",
            "343",
            "344",
            "345",
            "346",
            "347",
            "348",
            "349",
            "350",
            "351",
            "352",
            "353",
            "354",
            "355",
            "356",
            "357",
            "358",
            "359",
            "360",
            "361",
            "362",
            "363",
            "364",
            "365",
            "366",
            "367",
            "368",
            "369",
            "370",
            "371",
            "372",
            "373",
            "374",
            "375",
            "376",
            "377",
            "378",
            "379",
            "380",
            "381",
            "382",
            "383",
            "384",
            "385",
            "386",
            "387"
          ],
          "num": 52
        },
        {
          "qualified_names": [
            "70",
            "262",
            "345"
          ],
          "num": 3
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/Normalize.java b/src/com/google/javascript/jscomp/Normalize.java\nindex d903f35..cadcadc 100644\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n@@ -68,8 +68,6 @@\n   private final AbstractCompiler compiler;\n   private final boolean assertOnChange;\n   private static final boolean CONVERT_WHILE_TO_FOR \u003d true;\n-  // TODO(johnlenz): Remove assignment splitting support.\n-  private static final boolean ALLOW_ASSIGNMENT_SPLITTING \u003d false;\n   static final boolean MAKE_LOCAL_NAMES_UNIQUE \u003d true;\n \n   Normalize(AbstractCompiler compiler, boolean assertOnChange) {\n@@ -258,9 +256,6 @@\n     if (NodeUtil.isStatementBlock(n) || n.getType() \u003d\u003d Token.LABEL) {\n       extractForInitializer(n, null, null);\n       splitVarDeclarations(n);\n-      if (ALLOW_ASSIGNMENT_SPLITTING) {\n-        splitAssignments(n);\n-      }\n     }\n   }\n \n@@ -338,53 +333,6 @@\n     }\n   }\n \n-\n-  /**\n-   * Split a compound assignment into individual statements.  This does not\n-   * split assignments within conditions, such as \"while(a \u003d b \u003d foo()){ blah }\"\n-   * which would require moving the code into the code while block.\n-   *\n-   * @param n The assignment node to break down.\n-   */\n-  private void splitAssignments(Node n) {\n-    for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n-      next \u003d c.getNext();\n-      if (NodeUtil.isExpressionNode(c)) {\n-        Node expression \u003d c;\n-        while (isCompoundAssignment(expression.getFirstChild())) {\n-          Node assign \u003d expression.getFirstChild();\n-          Node rhs \u003d assign.getLastChild();\n-          Node nameNode \u003d rhs.getFirstChild();\n-\n-          // Verify this is something safe to split.\n-          if (NodeUtil.mayEffectMutableState(nameNode)) {\n-            break;\n-          }\n-\n-          // Split it. For example change \"a \u003d b \u003d c \u003d foo();\"\n-          // into \"b \u003d c \u003d foo(); a \u003d b;\"\n-          assign.removeChild(rhs);\n-          assign.addChildToBack(nameNode.cloneTree());\n-\n-          Node newChild \u003d NodeUtil.newExpr(rhs);\n-          n.addChildBefore(newChild, expression);\n-          expression \u003d newChild;  // next iteration.\n-          compiler.reportCodeChange();\n-        }\n-      }\n-    }\n-  }\n-\n-  /**\n-   * @param n The node to check.\n-   * @return Whether n is an assignment and the RHS is also an\n-   *     assignment.\n-   */\n-  private static boolean isCompoundAssignment(Node n) {\n-    return (NodeUtil.isAssignmentOp(n)\n-        \u0026\u0026 NodeUtil.isAssignmentOp(n.getLastChild()));\n-  }\n-\n   /**\n    * Remove duplicate VAR declarations.\n    */\n",
      "operations": [
        {
          "type": "delete-tree",
          "from": "FieldDeclaration [2684,2748]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "IfStatement [8769,8839]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [11275,12537]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [12541,12821]",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:isWellDefined:[]:boolean",
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:isNeverReassigned:[]:boolean",
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$Reference:isLhsOfForInExpression:[Node n]:boolean",
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$Reference:isLvalue:[]:boolean"
          ],
          "num": 4
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:isAssignedOnce:[]:boolean",
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:isWellDefined:[]:boolean",
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$Reference:isVarDeclaration:[]:boolean",
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$Reference:getAssignedValue:[]:Node",
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:firstReferenceIsAssigningDeclaration:[]:boolean",
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$Reference:isSimpleAssignmentToName:[]:boolean",
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$Reference:isHoistedFunction:[]:boolean",
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:isInitializingDeclarationAt:[int index]:boolean",
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:isInitializingAssignmentAt:[int index]:boolean",
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:getInitializingReferenceForConstants:[]:Reference",
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:getInitializingReference:[]:Reference",
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$Reference:isLhsOfForInExpression:[Node n]:boolean",
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$Reference:isLvalue:[]:boolean"
          ],
          "num": 13
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "18",
            "250",
            "251",
            "255",
            "257",
            "266",
            "267",
            "268",
            "269",
            "270",
            "274",
            "322",
            "332",
            "352",
            "357",
            "360",
            "363"
          ],
          "num": 17
        },
        {
          "qualified_names": [
            "19",
            "251",
            "252",
            "256",
            "257",
            "259",
            "268",
            "269",
            "270",
            "271",
            "272",
            "273",
            "274",
            "275",
            "276",
            "277",
            "278",
            "279",
            "280",
            "281",
            "282",
            "283",
            "284",
            "285",
            "286",
            "287",
            "288",
            "289",
            "290",
            "291",
            "292",
            "293",
            "294",
            "295",
            "296",
            "297",
            "298",
            "299",
            "300",
            "303",
            "304",
            "306",
            "307",
            "308",
            "309",
            "310",
            "311",
            "312",
            "313",
            "314",
            "315",
            "316",
            "317",
            "318",
            "319",
            "320",
            "321",
            "322",
            "323",
            "324",
            "325",
            "326",
            "327",
            "328",
            "329",
            "330",
            "331",
            "332",
            "333",
            "334",
            "335",
            "336",
            "337",
            "338",
            "339",
            "340",
            "341",
            "342",
            "343",
            "344",
            "345",
            "346",
            "347",
            "348",
            "349",
            "350",
            "351",
            "352",
            "353",
            "354",
            "355",
            "356",
            "357",
            "358",
            "359",
            "408",
            "409",
            "410",
            "411",
            "412",
            "413",
            "414",
            "415",
            "416",
            "417",
            "428",
            "429",
            "430",
            "431",
            "432",
            "433",
            "434",
            "435",
            "455",
            "460",
            "463",
            "464",
            "465",
            "466",
            "467",
            "468",
            "471"
          ],
          "num": 122
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex 8eccd0f..28d6763 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -16,6 +16,7 @@\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n import com.google.common.base.Predicates;\n import com.google.common.collect.ImmutableSet;\n@@ -247,14 +248,15 @@\n \n       // If this is a declaration that does not instantiate the variable,\n       // it\u0027s not well-defined.\n-      Reference decl \u003d references.get(0);\n-      if (!decl.isInitializingDeclaration()) {\n+      Reference init \u003d getInitializingReference();\n+      if (init \u003d\u003d null) {\n         return false;\n       }\n \n-      BasicBlock declBlock \u003d decl.getBasicBlock();\n+      Preconditions.checkState(references.get(0).isDeclaration());\n+      BasicBlock initBlock \u003d init.getBasicBlock();\n       for (int i \u003d 1; i \u003c size; i++) {\n-        if (!declBlock.provablyExecutesBefore(\n+        if (!initBlock.provablyExecutesBefore(\n                 references.get(i).getBasicBlock())) {\n           return false;\n         }\n@@ -263,15 +265,98 @@\n       return true;\n     }\n \n-    boolean isNeverReassigned() {\n-      int size \u003d references.size();\n-      for (int i \u003d 1; i \u003c size; i++) {\n-        if (references.get(i).isLvalue()) {\n-          return false;\n+    /**\n+     * @param index The index into the references array to look for an \n+     * assigning declaration.\n+     *\n+     * This is either the declaration if a value is assigned (such as\n+     * \"var a \u003d 2\", \"function a()...\", \"... catch (a)...\").\n+     */\n+    private boolean isInitializingDeclarationAt(int index) {\n+      Reference maybeInit \u003d references.get(index);\n+      if (maybeInit.isInitializingDeclaration()) {\n+        // This is a declaration that represents the initial value. \n+        // Specifically, var declarations without assignments such as \"var a;\"\n+        // are not.\n+        return true;\n+      }\n+      return false;\n+    }\n+    \n+    /**\n+     * @param index The index into the references array to look for an \n+     * initialized assignment reference. That is, an assignment immediately\n+     * follow a variable declaration that itself does not initialize the\n+     * variable.\n+     */\n+    private boolean isInitializingAssignmentAt(int index) {\n+      if (index \u003c references.size() \u0026\u0026 index \u003e 0) {\n+        Reference maybeDecl \u003d references.get(index-1);\n+        if (maybeDecl.isVarDeclaration()) {\n+          Preconditions.checkState(!maybeDecl.isInitializingDeclaration());\n+          Reference maybeInit \u003d references.get(index);\n+          if (maybeInit.isSimpleAssignmentToName()) {\n+            return true;\n+          }\n         }\n       }\n+      return false;\n+    }    \n \n-      return true;\n+    /**\n+     * @return The reference that provides the value for the variable at the\n+     * time of the first read, if known, otherwise null.\n+     *\n+     * This is either the variable declaration (\"var a \u003d ...\") or first\n+     * reference following the declaration if it is an assignment.\n+     */\n+    Reference getInitializingReference() {\n+      if (isInitializingDeclarationAt(0)) {\n+        return references.get(0);\n+      } else if (isInitializingAssignmentAt(1)) {\n+        return references.get(1);\n+      }\n+      return null;\n+    }\n+\n+    /**\n+     * Constants are allowed to be defined after their first use.\n+     */\n+    Reference getInitializingReferenceForConstants() {\n+      int size \u003d references.size();\n+      for (int i \u003d 0; i \u003c size; i++) {\n+        if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) {\n+          return references.get(i);\n+        }\n+      }\n+      return null;\n+    }\n+\n+    /**\n+     * @return Whether the variable is only assigned a value once.\n+     */\n+    boolean isAssignedOnce() {\n+      boolean assigned \u003d false;\n+      int size \u003d references.size();\n+      for (int i \u003d 0; i \u003c size; i++) {\n+        Reference ref \u003d references.get(i);\n+        if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n+          if (!assigned) {\n+            assigned \u003d true;\n+          } else {\n+            return false;\n+          }\n+        }\n+      }\n+      return assigned;\n+    }\n+\n+    boolean firstReferenceIsAssigningDeclaration() {\n+      int size \u003d references.size();\n+      if (size \u003e 0 \u0026\u0026 references.get(0).isInitializingDeclaration()) {\n+        return true;\n+      }\n+      return false;\n     }\n   }\n \n@@ -320,6 +405,16 @@\n           grandparent.getType() \u003d\u003d Token.FUNCTION;\n     }\n \n+    boolean isVarDeclaration() {\n+      return parent.getType() \u003d\u003d Token.VAR;\n+    }\n+\n+    boolean isHoistedFunction() {\n+      return NodeUtil.isFunctionDeclaration(parent) \u0026\u0026\n+          (grandparent.getType() \u003d\u003d Token.SCRIPT ||\n+           grandparent.getParent().getType() \u003d\u003d Token.FUNCTION);\n+    }\n+\n     /**\n      * Determines whether the variable is initialized at the declaration.\n      */\n@@ -330,6 +425,14 @@\n           (parent.getType() !\u003d Token.VAR || nameNode.getFirstChild() !\u003d null);\n     }\n \n+   /**\n+    * @return For an assignment or variable declaration return the assigned\n+    * value, otherwise null.\n+    */\n+    Node getAssignedValue() {\n+      return NodeUtil.getAssignedValue(getNameNode());\n+    }\n+\n     BasicBlock getBasicBlock() {\n       return basicBlock;\n     }\n@@ -349,18 +452,23 @@\n     private static boolean isForIn(Node n) {\n       return n.getType() \u003d\u003d Token.FOR \u0026\u0026 n.getChildCount() \u003d\u003d 3;\n     }\n-    \n+\n     private static boolean isLhsOfForInExpression(Node n) {\n       Node parent \u003d n.getParent();\n       if (parent.getType() \u003d\u003d Token.VAR) {\n         return isLhsOfForInExpression(parent);\n-      } \n+      }\n       return isForIn(parent) \u0026\u0026 parent.getFirstChild() \u003d\u003d n;\n     }\n-    \n+\n+    boolean isSimpleAssignmentToName() {\n+      return parent.getType() \u003d\u003d Token.ASSIGN\n+          \u0026\u0026 parent.getFirstChild() \u003d\u003d nameNode;\n+    }\n+\n     boolean isLvalue() {\n       int parentType \u003d parent.getType();\n-      return parentType \u003d\u003d Token.VAR \n+      return (parentType \u003d\u003d Token.VAR \u0026\u0026 nameNode.getFirstChild() !\u003d null)\n           || parentType \u003d\u003d Token.INC\n           || parentType \u003d\u003d Token.DEC\n           || (NodeUtil.isAssignmentOp(parent)\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "ImportDeclaration [635,679]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [7947,8583]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [8593,9319]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [9329,9858]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [9864,10229]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [10725,10935]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [12504,12582]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [12588,12795]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [13205,13411]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [14027,14164]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Javadoc [10235,10313]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [7514,7558]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "ExpressionStatement [7622,7682]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [10351,10376]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [7569,7581]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "MethodInvocation [7622,7681]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: assigned [10704,10712]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "METHOD_INVOCATION_RECEIVER [7622,7635]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: checkState [7636,7646]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "METHOD_INVOCATION_ARGUMENTS [7647,7680]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "VariableDeclarationStatement [10460,10494]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "MethodInvocation [7647,7680]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SimpleType [10460,10469]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "VariableDeclarationFragment [10470,10493]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "InfixExpression [10507,10556]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "METHOD_INVOCATION_RECEIVER [7647,7664]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: isDeclaration [7665,7678]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: ref [10470,10473]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "MethodInvocation [10507,10521]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "INFIX_EXPRESSION_OPERATOR: || [10522,10524]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodInvocation [10525,10556]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [10570,10672]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "METHOD_INVOCATION_RECEIVER [10507,10510]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "PrefixExpression [10574,10583]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [10585,10627]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [10633,10672]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "ParenthesizedExpression [14245,14306]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "ExpressionStatement [10599,10615]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "InfixExpression [14246,14305]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Assignment [10599,10614]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "INFIX_EXPRESSION_OPERATOR: \u0026\u0026 [14270,14272]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [14273,14305]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: assigned [10599,10607]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "ASSIGNMENT_OPERATOR: \u003d [10608,10609]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SimpleType [7469,7478]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "SimpleName: decl [7479,7483]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "VariableDeclarationFragment [7479,7503]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "VariableDeclarationStatement [7469,7504]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "PrefixExpression [7515,7548]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "METHOD_INVOCATION_RECEIVER [7964,7981]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "MethodInvocation [7964,7992]",
          "to": ""
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/Scope.java",
        "src/com/google/javascript/jscomp/Scope.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [],
          "num": 0
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.Scope:getGlobalScope:[]:Scope"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "324"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "325",
            "326",
            "327",
            "328",
            "329",
            "330",
            "331",
            "332"
          ],
          "num": 8
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/Scope.java b/src/com/google/javascript/jscomp/Scope.java\nindex c8e57ab..c9f6719 100644\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n@@ -322,6 +322,14 @@\n     return parent;\n   }\n \n+  Scope getGlobalScope() {\n+    Scope result \u003d this;\n+    while (result.getParent() !\u003d null) {\n+      result \u003d result.getParent();\n+    }\n+    return result;\n+  }\n+\n   @Override\n   public StaticScope\u003cJSType\u003e getParentScope() {\n     return parent;\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [8439,8593]"
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/VarCheck.java",
        "src/com/google/javascript/jscomp/VarCheck.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.VarCheck:visit:[NodeTraversal t, Node n, Node parent]:void"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.VarCheck:visit:[NodeTraversal t, Node n, Node parent]:void"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "130"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "130"
          ],
          "num": 1
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/VarCheck.java b/src/com/google/javascript/jscomp/VarCheck.java\nindex 55c0a4a..9630502 100644\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n@@ -127,7 +127,7 @@\n           Node nameNode \u003d Node.newString(Token.NAME, varName);\n           getSynthesizedExternsRoot().addChildToBack(\n               new Node(Token.VAR, nameNode));\n-          scope.declare(varName, nameNode,\n+          scope.getGlobalScope().declare(varName, nameNode,\n               null, getSynthesizedExternsInput());\n         }\n       }\n",
      "operations": [
        {
          "type": "insert-node",
          "from": "",
          "to": "METHOD_INVOCATION_RECEIVER [4461,4483]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "MethodInvocation [4461,4483]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: getGlobalScope [4467,4481]"
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/VariableReferenceCheck.java",
        "src/com/google/javascript/jscomp/VariableReferenceCheck.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.VariableReferenceCheck\\$ReferenceCheckingBehavior:checkVar:[NodeTraversal t, Var v, List\u003cReference\u003e references]:void"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.VariableReferenceCheck\\$ReferenceCheckingBehavior:checkVar:[NodeTraversal t, Var v, List\u003cReference\u003e references]:void"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "97"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "98",
            "99",
            "100",
            "101",
            "102",
            "103",
            "104",
            "105",
            "106",
            "107",
            "108",
            "111",
            "112",
            "113",
            "114"
          ],
          "num": 15
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/VariableReferenceCheck.java b/src/com/google/javascript/jscomp/VariableReferenceCheck.java\nindex 32dbd4e..68c9c62 100644\n--- a/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n+++ b/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n@@ -95,8 +95,23 @@\n     private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n       blocksWithDeclarations.clear();\n       boolean isDeclaredInScope \u003d false;\n+      Reference hoistedFn \u003d null;\n+\n+      // Look for hoisted functions.\n+      for (Reference reference : references) {\n+        if (reference.isHoistedFunction()) {\n+          blocksWithDeclarations.add(reference.getBasicBlock());\n+          isDeclaredInScope \u003d true;\n+          hoistedFn \u003d reference;\n+          break;\n+        }\n+      }\n \n       for (Reference reference : references) {\n+        if (reference \u003d\u003d hoistedFn) {\n+          continue;\n+        }\n+\n         BasicBlock basicBlock \u003d reference.getBasicBlock();\n         boolean isDeclaration \u003d reference.isDeclaration();\n \n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationStatement [3564,3591]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "EnhancedForStatement [3636,3890]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "IfStatement [3947,4006]"
        }
      ]
    }
  ],
  "inducing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [],
      "num": 0
    },
    "add_functions": {
      "qualified_names": [
        "com.google.javascript.jscomp.ReferenceCollectingCallback\\$Reference:isSimpleAssignmentToName:[]:boolean",
        "com.google.javascript.jscomp.ExpressionDecomposer:isSubexpressionMovable:[Node expressionRoot, Node subExpression]:DecompositionType",
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineDeclaredConstant:[Var v, Node value, List\u003cReference\u003e refSet]:void",
        "com.google.javascript.jscomp.NodeIterators\\$LocalVarMotion:LocalVarMotion:[Node nameNode, FunctionlessLocalScope iterator]:null",
        "com.google.javascript.jscomp.NodeUtil:canBeSideEffected:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeIterators\\$LocalVarMotion:forAssign:[Node name, Node assign, Node expr, Node block]:LocalVarMotion",
        "com.google.javascript.jscomp.NodeUtil:canBeSideEffected:[Node n, Set\u003cString\u003e knownConstants]:boolean",
        "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:isAssignedOnce:[]:boolean",
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineWellDefinedVariable:[Var v, Node value, List\u003cReference\u003e refSet]:void",
        "com.google.javascript.jscomp.ReferenceCollectingCallback\\$Reference:isHoistedFunction:[]:boolean",
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:canInline:[Reference declaration, Reference initialization, Reference reference]:boolean",
        "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:firstReferenceIsAssigningDeclaration:[]:boolean",
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineNonConstants:[Var v, ReferenceCollection referenceInfo]:void",
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:canMoveModerately:[Reference initialization, Reference reference]:boolean",
        "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:isInitializingDeclarationAt:[int index]:boolean",
        "com.google.javascript.jscomp.ReferenceCollectingCallback\\$Reference:getAssignedValue:[]:Node",
        "com.google.javascript.jscomp.Normalize:removeDuplicateDeclarations:[Node root]:void",
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:isInlineableDeclaredConstant:[Var var, ReferenceCollection refInfo]:boolean",
        "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:isInitializingAssignmentAt:[int index]:boolean",
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:canMoveAggressively:[Node value]:boolean",
        "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:getInitializingReference:[]:Reference",
        "com.google.javascript.jscomp.ExpressionDecomposer:isSafeAssign:[Node n, boolean seenSideEffects]:boolean",
        "com.google.javascript.jscomp.ExpressionDecomposer:maybeExternMethod:[Node node]:boolean",
        "com.google.javascript.jscomp.NodeIterators\\$LocalVarMotion:forVar:[Node name, Node var, Node block]:LocalVarMotion",
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:isValidInitialization:[Reference initialization]:boolean",
        "com.google.javascript.jscomp.NodeUtil:getAssignedValue:[Node n]:Node",
        "com.google.javascript.jscomp.ReferenceCollectingCallback\\$Reference:isVarDeclaration:[]:boolean",
        "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:getInitializingReferenceForConstants:[]:Reference",
        "com.google.javascript.jscomp.Scope:getGlobalScope:[]:Scope",
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inline:[Var v, Reference declaration, Reference init, Reference reference]:void"
      ],
      "num": 30
    },
    "delete_functions": {
      "qualified_names": [
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineWellDefinedVariable:[Var v, List\u003cReference\u003e refSet]:void",
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:isInlineableDeclaredConstant:[Var var, List\u003cReference\u003e refs]:boolean",
        "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:isNeverReassigned:[]:boolean",
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inline:[Var v, Reference declaration, Reference reference]:void",
        "com.google.javascript.jscomp.Normalize:doStatementNormalizations:[NodeTraversal t, Node n, Node parent]:void",
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineDeclaredConstant:[Var v, List\u003cReference\u003e refSet]:void",
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:canMoveAggressively:[Reference declaration]:boolean",
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:canInline:[Reference declaration, Reference reference]:boolean",
        "com.google.javascript.jscomp.Normalize:splitAssignments:[Node n]:void",
        "com.google.javascript.jscomp.ExpressionDecomposer:canBeSideEffected:[Node n]:boolean",
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineNonConstants:[Scope scope, Var v, ReferenceCollection referenceInfo]:void",
        "com.google.javascript.jscomp.ExpressionDecomposer\\$SideEffected:apply:[Node n]:boolean",
        "com.google.javascript.jscomp.ExpressionDecomposer:isSubexpressionMovable:[Node expressionRoot, Node subExpression]:boolean",
        "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:canMoveModerately:[Reference declaration, Reference reference]:boolean",
        "com.google.javascript.jscomp.ExpressionDecomposer\\$SideEffected:SideEffected:[Set\u003cString\u003e additionalConsts]:null",
        "com.google.javascript.jscomp.FunctionArgumentInjector:canBeSideEffected:[Node n]:boolean",
        "com.google.javascript.jscomp.NodeIterators\\$LocalVarMotion:LocalVarMotion:[Node... ancestors]:null",
        "com.google.javascript.jscomp.Normalize:isCompoundAssignment:[Node n]:boolean"
      ],
      "num": 18
    }
  },
  "trigger_tests": [
    {
      "test_class": "com.google.javascript.jscomp.InlineVariablesTest",
      "test_function": "testExternalIssue1053",
      "assertion_line": "1069",
      "exception": "junit.framework.AssertionFailedError",
      "message": "Expected: var u;function f(){u\u003dRandom();var x\u003du;f();alert(x\u003d\u003d\u003du)}\nResult: var u;function f(){u\u003dRandom();f();alert(u\u003d\u003d\u003du)}"
    }
  ],
  "fixing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/InlineVariables.java",
        "src/com/google/javascript/jscomp/InlineVariables.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineNonConstants:[Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments]:void"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineNonConstants:[Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments]:void"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "302",
            "303"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "302",
            "303",
            "304",
            "305",
            "306",
            "307",
            "308",
            "309"
          ],
          "num": 8
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex b150053..5c9df61 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -299,8 +299,14 @@\n       // reference data is out of sync. We\u0027re better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments \u0026\u0026\n-          !staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+          !staleVars.contains(v) \u0026\u0026\n+          referenceInfo.isWellDefined() \u0026\u0026\n+          referenceInfo.isAssignedOnceInLifetime() \u0026\u0026\n+          // Inlining the variable based solely on well-defined and assigned\n+          // once is *NOT* correct. We relax the correctness requirement if\n+          // the variable is declared constant.\n+          (isInlineableDeclaredConstant(v, referenceInfo) ||\n+           referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {\n         List\u003cReference\u003e refs \u003d referenceInfo.references;\n         for (int i \u003d 1 /* start from a read */; i \u003c refs.size(); i++) {\n           Node nameNode \u003d refs.get(i).getNode();\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "ParenthesizedExpression [11422,11539]"
        }
      ]
    },
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:isAssignedOnceInLifetime:[]:boolean"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:isAssignedOnceInLifetime:[]:boolean",
            "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:isOnlyAssignmentSameScopeAsDeclaration:[]:boolean"
          ],
          "num": 2
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "426",
            "438"
          ],
          "num": 2
        },
        {
          "qualified_names": [
            "426",
            "439",
            "440",
            "441",
            "442",
            "443",
            "444",
            "445",
            "446",
            "447",
            "448",
            "449",
            "450",
            "451",
            "452",
            "453",
            "454",
            "455",
            "456",
            "457",
            "458",
            "459",
            "460",
            "461"
          ],
          "num": 24
        }
      ],
      "diff": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex cdacc5f..f89f10c 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -423,7 +423,7 @@\n       if (ref \u003d\u003d null) {\n         return false;\n       }\n-\n+      \n       // Make sure this assignment is not in a loop.\n       for (BasicBlock block \u003d ref.getBasicBlock();\n            block !\u003d null; block \u003d block.getParent()) {\n@@ -436,6 +436,29 @@\n \n       return true;\n     }\n+    \n+    /**\n+     * @return Whether the variable is only assigned a value once for its\n+     *     lifetime.\n+     */\n+    boolean isOnlyAssignmentSameScopeAsDeclaration() {\n+      Reference ref \u003d getOneAndOnlyAssignment();\n+      Preconditions.checkNotNull(ref);\n+      \n+      // Make sure the declaration is the same scope as the assignment.\n+      // Otherwise, the variable can be assigned multiple times and possibly\n+      // with a different variable.\n+      for (BasicBlock block \u003d ref.getBasicBlock();\n+           block !\u003d null; block \u003d block.getParent()) {\n+        if (block.isFunction) {\n+          if (ref.getSymbol().getScope() !\u003d ref.scope) {\n+            return false;\n+          }\n+        }\n+      }\n+\n+      return true;\n+    }\n \n     /**\n      * @return The one and only assignment. Returns if there are 0 or 2+\n",
      "operations": [
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [13071,13789]"
        }
      ]
    }
  ],
  "fixing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [],
      "num": 0
    },
    "add_functions": {
      "qualified_names": [
        "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:isOnlyAssignmentSameScopeAsDeclaration:[]:boolean"
      ],
      "num": 1
    },
    "delete_functions": {
      "qualified_names": [],
      "num": 0
    }
  },
  "patch_changed_mths": {
    "qualified_names": [
      "com.google.javascript.jscomp.InlineVariables\\$InliningBehavior:inlineNonConstants(Lcom/google/javascript/jscomp/Scope$Var;Lcom/google/javascript/jscomp/ReferenceCollectingCallback$ReferenceCollection;Z)V:regression",
      "com.google.javascript.jscomp.ReferenceCollectingCallback\\$ReferenceCollection:isAssignedOnceInLifetime()Z:regression"
    ],
    "num": 2
  }
}