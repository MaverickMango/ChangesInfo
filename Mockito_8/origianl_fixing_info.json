{
  "logger": {
    "currentLogLevel": 20,
    "name": "root.bean.benchmarks.Defects4JBug"
  },
  "d4jCmd": "/home/liumengjiao/Desktop/defects4j/framework/bin/defects4j",
  "dataDir": "/home/liumengjiao/Desktop/CI/Benchmark/data/changesInfo/",
  "properties": {
    "trigger.tests": "org.mockito.internal.util.reflection.GenericMetadataSupportTest::typeVariable_of_self_type",
    "test.dir": "test",
    "clz.modified": "org.mockito.internal.util.reflection.GenericMetadataSupport",
    "src.dir": "src"
  },
  "timeoutSecond": 100,
  "proj": "Mockito",
  "id": "8",
  "workingDir": "../bugs/Mockito_8_buggy",
  "buggyCommit": "9fb7d8b62814f959ceca6096d785b96c11bdfd0a",
  "inducingCommit": "ab9e9f347705bf9f4ebace4b07b085088275a256",
  "originalCommit": "6e97858d79d08b455cb3690b811120965ee1975a",
  "bug_name": "Mockito_8",
  "derive": "defects4j",
  "original_fixing_commit": "5a03bf5d0c9aedac9cfbf074833167c1eca6439f",
  "buildFiles_changed": false,
  "regression": false,
  "inducing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [],
          "num": 0
        },
        {
          "qualified_names": [
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$BoundedType:interfaceBounds:[]:Type[]",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$WildCardBoundedType:interfaceBounds:[]:Type[]",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$ParameterizedReturnType:rawType:[]:Class\u003c?\u003e",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVariableReturnType:extraInterfaces:[]:List\u003cType\u003e",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$NotGenericReturnTypeSupport:rawType:[]:Class\u003c?\u003e",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$ParameterizedReturnType:readTypeParameters:[]:void",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVariableReturnType:readTypeVariables:[]:void",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$FromParameterizedTypeGenericMetadataSupport:rawType:[]:Class\u003c?\u003e",
            "org.mockito.internal.util.reflection.GenericMetadataSupport:rawType:[]:Class\u003c?\u003e",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$FromParameterizedTypeGenericMetadataSupport:FromParameterizedTypeGenericMetadataSupport:[ParameterizedType parameterizedType]:null",
            "org.mockito.internal.util.reflection.GenericMetadataSupport:extraInterfaces:[]:List\u003cType\u003e",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$WildCardBoundedType:toString:[]:String",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$WildCardBoundedType:wildCard:[]:WildcardType",
            "org.mockito.internal.util.reflection.GenericMetadataSupport:hasRawExtraInterfaces:[]:boolean",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$FromClassGenericMetadataSupport:superClassOf:[Class currentExploredClass]:Class",
            "org.mockito.internal.util.reflection.GenericMetadataSupport:registerTypeVariableIfNotPresent:[TypeVariable typeVariable]:void",
            "org.mockito.internal.util.reflection.GenericMetadataSupport:boundsOf:[WildcardType wildCard]:BoundedType",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVariableReturnType:extractActualBoundedTypeOf:[Type type]:Type",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVariableReturnType:rawExtraInterfaces:[]:Class\u003c?\u003e[]",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$ParameterizedReturnType:ParameterizedReturnType:[GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType]:null",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVariableReturnType:TypeVariableReturnType:[GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable]:null",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVarBoundedType:hashCode:[]:int",
            "org.mockito.internal.util.reflection.GenericMetadataSupport:registerTypeParametersOn:[TypeVariable[] typeParameters]:void",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$FromClassGenericMetadataSupport:rawType:[]:Class\u003c?\u003e",
            "org.mockito.internal.util.reflection.GenericMetadataSupport:actualTypeArguments:[]:Map\u003cTypeVariable,Type\u003e",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVarBoundedType:TypeVarBoundedType:[TypeVariable typeVariable]:null",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVarBoundedType:toString:[]:String",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$WildCardBoundedType:hashCode:[]:int",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$FromClassGenericMetadataSupport:readActualTypeParametersOnDeclaringClass:[Class\u003c?\u003e clazz]:void",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$ParameterizedReturnType:readTypeVariables:[]:void",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVariableReturnType:extractRawTypeOf:[Type type]:Class\u003c?\u003e",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVarBoundedType:interfaceBounds:[]:Type[]",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$BoundedType:firstBound:[]:Type",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$FromClassGenericMetadataSupport:FromClassGenericMetadataSupport:[Class\u003c?\u003e clazz]:null",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$WildCardBoundedType:firstBound:[]:Type",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$NotGenericReturnTypeSupport:NotGenericReturnTypeSupport:[Type genericReturnType]:null",
            "org.mockito.internal.util.reflection.GenericMetadataSupport:getActualTypeArgumentFor:[TypeVariable typeParameter]:Type",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVariableReturnType:readTypeParameters:[]:void",
            "org.mockito.internal.util.reflection.GenericMetadataSupport:inferFrom:[Type type]:GenericMetadataSupport",
            "org.mockito.internal.util.reflection.GenericMetadataSupport:boundsOf:[TypeVariable typeParameter]:BoundedType",
            "org.mockito.internal.util.reflection.GenericMetadataSupport:rawExtraInterfaces:[]:Class\u003c?\u003e[]",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$FromParameterizedTypeGenericMetadataSupport:readActualTypeParameters:[]:void",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVarBoundedType:firstBound:[]:Type",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$WildCardBoundedType:WildCardBoundedType:[WildcardType wildcard]:null",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$WildCardBoundedType:equals:[Object o]:boolean",
            "org.mockito.internal.util.reflection.GenericMetadataSupport:resolveGenericReturnType:[Method method]:GenericMetadataSupport",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVariableReturnType:rawType:[]:Class\u003c?\u003e",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVarBoundedType:typeVariable:[]:TypeVariable",
            "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVarBoundedType:equals:[Object o]:boolean",
            "org.mockito.internal.util.reflection.GenericMetadataSupport:registerTypeVariablesOn:[Type classType]:void"
          ],
          "num": 50
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "-1"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10",
            "11",
            "12",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "27",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "37",
            "38",
            "39",
            "40",
            "41",
            "42",
            "43",
            "44",
            "45",
            "46",
            "47",
            "48",
            "49",
            "50",
            "51",
            "52",
            "53",
            "54",
            "55",
            "56",
            "57",
            "58",
            "59",
            "60",
            "61",
            "62",
            "63",
            "64",
            "65",
            "66",
            "67",
            "68",
            "69",
            "70",
            "71",
            "72",
            "73",
            "74",
            "75",
            "76",
            "77",
            "78",
            "79",
            "80",
            "81",
            "82",
            "83",
            "84",
            "85",
            "86",
            "87",
            "88",
            "89",
            "90",
            "91",
            "92",
            "93",
            "94",
            "95",
            "96",
            "97",
            "98",
            "99",
            "100",
            "101",
            "102",
            "103",
            "104",
            "105",
            "106",
            "107",
            "108",
            "109",
            "110",
            "111",
            "112",
            "113",
            "114",
            "115",
            "116",
            "117",
            "118",
            "119",
            "120",
            "121",
            "122",
            "123",
            "124",
            "125",
            "126",
            "127",
            "128",
            "129",
            "130",
            "131",
            "132",
            "133",
            "134",
            "135",
            "136",
            "137",
            "138",
            "139",
            "140",
            "141",
            "142",
            "143",
            "144",
            "145",
            "146",
            "147",
            "148",
            "149",
            "150",
            "151",
            "152",
            "153",
            "154",
            "155",
            "156",
            "157",
            "158",
            "159",
            "160",
            "161",
            "162",
            "163",
            "164",
            "165",
            "166",
            "167",
            "168",
            "169",
            "170",
            "171",
            "172",
            "173",
            "174",
            "175",
            "176",
            "177",
            "178",
            "179",
            "180",
            "181",
            "182",
            "183",
            "184",
            "185",
            "186",
            "187",
            "188",
            "189",
            "190",
            "191",
            "192",
            "193",
            "194",
            "195",
            "196",
            "197",
            "198",
            "199",
            "200",
            "201",
            "202",
            "203",
            "204",
            "205",
            "206",
            "207",
            "208",
            "209",
            "210",
            "211",
            "212",
            "213",
            "214",
            "215",
            "216",
            "217",
            "218",
            "219",
            "220",
            "221",
            "222",
            "223",
            "224",
            "225",
            "226",
            "227",
            "228",
            "229",
            "230",
            "231",
            "232",
            "233",
            "234",
            "235",
            "236",
            "237",
            "238",
            "239",
            "240",
            "241",
            "242",
            "243",
            "244",
            "245",
            "246",
            "247",
            "248",
            "249",
            "250",
            "251",
            "252",
            "253",
            "254",
            "255",
            "256",
            "257",
            "258",
            "259",
            "260",
            "261",
            "262",
            "263",
            "264",
            "265",
            "266",
            "267",
            "268",
            "269",
            "270",
            "271",
            "272",
            "273",
            "274",
            "275",
            "276",
            "277",
            "278",
            "279",
            "280",
            "281",
            "282",
            "283",
            "284",
            "285",
            "286",
            "287",
            "288",
            "289",
            "290",
            "291",
            "292",
            "293",
            "294",
            "295",
            "296",
            "297",
            "298",
            "299",
            "300",
            "301",
            "302",
            "303",
            "304",
            "305",
            "306",
            "307",
            "308",
            "309",
            "310",
            "311",
            "312",
            "313",
            "314",
            "315",
            "316",
            "317",
            "318",
            "319",
            "320",
            "321",
            "322",
            "323",
            "324",
            "325",
            "326",
            "327",
            "328",
            "329",
            "330",
            "331",
            "332",
            "333",
            "334",
            "335",
            "336",
            "337",
            "338",
            "339",
            "340",
            "341",
            "342",
            "343",
            "344",
            "345",
            "346",
            "347",
            "348",
            "349",
            "350",
            "351",
            "352",
            "353",
            "354",
            "355",
            "356",
            "357",
            "358",
            "359",
            "360",
            "361",
            "362",
            "363",
            "364",
            "365",
            "366",
            "367",
            "368",
            "369",
            "370",
            "371",
            "372",
            "373",
            "374",
            "375",
            "376",
            "377",
            "378",
            "379",
            "380",
            "381",
            "382",
            "383",
            "384",
            "385",
            "386",
            "387",
            "388",
            "389",
            "390",
            "391",
            "392",
            "393",
            "394",
            "395",
            "396",
            "397",
            "398",
            "399",
            "400",
            "401",
            "402",
            "403",
            "404",
            "405",
            "406",
            "407",
            "408",
            "409",
            "410",
            "411",
            "412",
            "413",
            "414",
            "415",
            "416",
            "417",
            "418",
            "419",
            "420",
            "421",
            "422",
            "423",
            "424",
            "425",
            "426",
            "427",
            "428",
            "429",
            "430",
            "431",
            "432",
            "433",
            "434",
            "435",
            "436",
            "437",
            "438",
            "439",
            "440",
            "441",
            "442",
            "443",
            "444",
            "445",
            "446",
            "447",
            "448",
            "449",
            "450",
            "451",
            "452",
            "453",
            "454",
            "455",
            "456",
            "457",
            "458",
            "459",
            "460",
            "461",
            "462",
            "463",
            "464",
            "465",
            "466",
            "467",
            "468",
            "469",
            "470",
            "471",
            "472",
            "473",
            "474",
            "475",
            "476",
            "477",
            "478",
            "479",
            "480",
            "481",
            "482",
            "483",
            "484",
            "485",
            "486",
            "487",
            "488",
            "489",
            "490",
            "491",
            "492",
            "493",
            "494",
            "495",
            "496",
            "497",
            "498",
            "499",
            "500",
            "501",
            "502",
            "503",
            "504",
            "505",
            "506",
            "507",
            "508",
            "509",
            "510",
            "511",
            "512",
            "513",
            "514",
            "515",
            "516",
            "517",
            "518",
            "519",
            "520",
            "521",
            "522",
            "523",
            "524",
            "525",
            "526",
            "527",
            "528",
            "529",
            "530",
            "531",
            "532",
            "533",
            "534",
            "535",
            "536",
            "537",
            "538",
            "539",
            "540",
            "541",
            "542",
            "543",
            "544",
            "545",
            "546",
            "547",
            "548",
            "549",
            "550",
            "551",
            "552",
            "553",
            "554",
            "555",
            "556",
            "557",
            "558",
            "559",
            "560",
            "561",
            "562",
            "563",
            "564",
            "565",
            "566",
            "567",
            "568",
            "569",
            "570",
            "571",
            "572",
            "573",
            "574",
            "575",
            "576",
            "577",
            "578",
            "579",
            "580",
            "581",
            "582",
            "583",
            "584",
            "585",
            "586",
            "587",
            "588",
            "589",
            "590",
            "591",
            "592",
            "593",
            "594",
            "595",
            "596",
            "597",
            "598",
            "599",
            "600",
            "601",
            "602",
            "603",
            "604",
            "605",
            "606",
            "607",
            "608",
            "609",
            "610",
            "611",
            "612",
            "613",
            "614",
            "615",
            "616",
            "617",
            "618",
            "619",
            "620",
            "621",
            "622",
            "623",
            "624",
            "625",
            "626",
            "627",
            "628",
            "629",
            "630",
            "631",
            "632",
            "633",
            "634",
            "635",
            "636",
            "637"
          ],
          "num": 637
        }
      ],
      "diff": "diff --git a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\nnew file mode 100644\nindex 0000000..26493ea\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n@@ -0,0 +1,637 @@\n+/*\r\n+ * Copyright (c) 2007 Mockito contributors\r\n+ * This program is made available under the terms of the MIT License.\r\n+ */\r\n+package org.mockito.internal.util.reflection;\r\n+\r\n+\r\n+import java.lang.reflect.Method;\r\n+import java.lang.reflect.ParameterizedType;\r\n+import java.lang.reflect.Type;\r\n+import java.lang.reflect.TypeVariable;\r\n+import java.lang.reflect.WildcardType;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.Collections;\r\n+import java.util.HashMap;\r\n+import java.util.LinkedHashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import org.mockito.Incubating;\r\n+import org.mockito.exceptions.base.MockitoException;\r\n+import org.mockito.internal.util.Checks;\r\n+\r\n+\r\n+/**\r\n+ * This class can retrieve generic meta-data that the compiler stores on classes\r\n+ * and accessible members.\r\n+ *\r\n+ * \u003cp\u003e\r\n+ *     The main idea of this code is to create a Map that will help to resolve return types.\r\n+ *     In order to actually work with nested generics, this map will have to be passed along new instances\r\n+ *     as a type context.\r\n+ * \u003c/p\u003e\r\n+ *\r\n+ * \u003cp\u003e\r\n+ *     Hence :\r\n+ *     \u003cul\u003e\r\n+ *         \u003cli\u003eA new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real\r\n+ *         \u003ccode\u003eClass\u003c/code\u003e or from a \u003ccode\u003eParameterizedType\u003c/code\u003e, other types are not yet supported.\u003c/li\u003e\r\n+ *\r\n+ *         \u003cli\u003eThen from this metadata, we can extract meta-data for a generic return type of a method, using\r\n+ *         {@link #resolveGenericReturnType(Method)}.\u003c/li\u003e\r\n+ *     \u003c/ul\u003e\r\n+ * \u003c/p\u003e\r\n+ *\r\n+ * \u003cp\u003e\r\n+ * For now this code support the following kind of generic declarations :\r\n+ * \u003cpre class\u003d\"code\"\u003e\u003ccode class\u003d\"java\"\u003e\r\n+ * interface GenericsNest\u0026lt;K extends Comparable\u0026lt;K\u0026gt; \u0026 Cloneable\u0026gt; extends Map\u0026lt;K, Set\u0026lt;Number\u0026gt;\u0026gt; {\r\n+ *     Set\u0026lt;Number\u0026gt; remove(Object key); // override with fixed ParameterizedType\r\n+ *     List\u0026lt;? super Integer\u0026gt; returning_wildcard_with_class_lower_bound();\r\n+ *     List\u0026lt;? super K\u0026gt; returning_wildcard_with_typeVar_lower_bound();\r\n+ *     List\u0026lt;? extends K\u0026gt; returning_wildcard_with_typeVar_upper_bound();\r\n+ *     K returningK();\r\n+ *     \u0026lt;O extends K\u0026gt; List\u0026lt;O\u0026gt; paramType_with_type_params();\r\n+ *     \u0026lt;S, T extends S\u0026gt; T two_type_params();\r\n+ *     \u0026lt;O extends K\u0026gt; O typeVar_with_type_params();\r\n+ *     Number returningNonGeneric();\r\n+ * }\r\n+ * \u003c/code\u003e\u003c/pre\u003e\r\n+ *\r\n+ * @see #inferFrom(Type)\r\n+ * @see #resolveGenericReturnType(Method)\r\n+ * @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs\r\n+ */\r\n+@Incubating\r\n+public abstract class GenericMetadataSupport {\r\n+\r\n+    // public static MockitoLogger logger \u003d new ConsoleMockitoLogger();\r\n+\r\n+    /**\r\n+     * Represents actual type variables resolved for current class.\r\n+     */\r\n+    protected Map\u003cTypeVariable, Type\u003e contextualActualTypeParameters \u003d new HashMap\u003cTypeVariable, Type\u003e();\r\n+\r\n+\r\n+    protected void registerTypeVariablesOn(Type classType) {\r\n+        if (!(classType instanceof ParameterizedType)) {\r\n+            return;\r\n+        }\r\n+        ParameterizedType parameterizedType \u003d (ParameterizedType) classType;\r\n+        TypeVariable[] typeParameters \u003d ((Class\u003c?\u003e) parameterizedType.getRawType()).getTypeParameters();\r\n+        Type[] actualTypeArguments \u003d parameterizedType.getActualTypeArguments();\r\n+        for (int i \u003d 0; i \u003c actualTypeArguments.length; i++) {\r\n+            TypeVariable typeParameter \u003d typeParameters[i];\r\n+            Type actualTypeArgument \u003d actualTypeArguments[i];\r\n+\r\n+            if (actualTypeArgument instanceof WildcardType) {\r\n+                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\r\n+            } else {\r\n+                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\r\n+            }\r\n+            // logger.log(\"For \u0027\" + parameterizedType + \"\u0027 found type variable : { \u0027\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"\u0027 : \u0027\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"\u0027 }\");\r\n+        }\r\n+    }\r\n+\r\n+    protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\r\n+        for (TypeVariable typeVariable : typeParameters) {\r\n+            registerTypeVariableIfNotPresent(typeVariable);\r\n+        }\r\n+    }\r\n+\r\n+    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\r\n+        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\r\n+            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\r\n+            // logger.log(\"For \u0027\" + typeVariable.getGenericDeclaration() + \"\u0027 found type variable : { \u0027\" + typeVariable + \"(\" + System.identityHashCode(typeVariable) + \")\" + \"\u0027 : \u0027\" + boundsOf(typeVariable) + \"\u0027 }\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * @param typeParameter The TypeVariable parameter\r\n+     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\r\n+     *         then retrieve BoundedType of this TypeVariable\r\n+     */\r\n+    private BoundedType boundsOf(TypeVariable typeParameter) {\r\n+        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\r\n+            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\r\n+        }\r\n+        return new TypeVarBoundedType(typeParameter);\r\n+    }\r\n+\r\n+    /**\r\n+     * @param wildCard The WildCard type\r\n+     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\r\n+     *         then retrieve BoundedType of this TypeVariable\r\n+     */\r\n+    private BoundedType boundsOf(WildcardType wildCard) {\r\n+        /*\r\n+         *  According to JLS(http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1):\r\n+         *  - Lower and upper can\u0027t coexist: (for instance, this is not allowed: \u003c? extends List\u003cString\u003e \u0026 super MyInterface\u003e)\r\n+         *  - Multiple bounds are not supported (for instance, this is not allowed: \u003c? extends List\u003cString\u003e \u0026 MyInterface\u003e)\r\n+         */\r\n+\r\n+        WildCardBoundedType wildCardBoundedType \u003d new WildCardBoundedType(wildCard);\r\n+        if (wildCardBoundedType.firstBound() instanceof TypeVariable) {\r\n+            return boundsOf((TypeVariable) wildCardBoundedType.firstBound());\r\n+        }\r\n+\r\n+        return wildCardBoundedType;\r\n+    }\r\n+\r\n+\r\n+\r\n+    /**\r\n+     * @return Raw type of the current instance.\r\n+     */\r\n+    public abstract Class\u003c?\u003e rawType();\r\n+\r\n+\r\n+\r\n+    /**\r\n+     * @return Returns extra interfaces \u003cstrong\u003eif relevant\u003c/strong\u003e, otherwise empty List.\r\n+     */\r\n+    public List\u003cType\u003e extraInterfaces() {\r\n+        return Collections.emptyList();\r\n+    }\r\n+\r\n+    /**\r\n+     * @return Returns an array with the raw types of {@link #extraInterfaces()} \u003cstrong\u003eif relevant\u003c/strong\u003e.\r\n+     */\r\n+    public Class\u003c?\u003e[] rawExtraInterfaces() {\r\n+        return new Class[0];\r\n+    }\r\n+\r\n+    /**\r\n+     * @return Returns true if metadata knows about extra-interfaces {@link #extraInterfaces()} \u003cstrong\u003eif relevant\u003c/strong\u003e.\r\n+     */\r\n+    public boolean hasRawExtraInterfaces() {\r\n+        return rawExtraInterfaces().length \u003e 0;\r\n+    }\r\n+\r\n+\r\n+\r\n+    /**\r\n+     * @return Actual type arguments matching the type variables of the raw type represented by this {@link GenericMetadataSupport} instance.\r\n+     */\r\n+    public Map\u003cTypeVariable, Type\u003e actualTypeArguments() {\r\n+        TypeVariable[] typeParameters \u003d rawType().getTypeParameters();\r\n+        LinkedHashMap\u003cTypeVariable, Type\u003e actualTypeArguments \u003d new LinkedHashMap\u003cTypeVariable, Type\u003e();\r\n+\r\n+        for (TypeVariable typeParameter : typeParameters) {\r\n+\r\n+            Type actualType \u003d getActualTypeArgumentFor(typeParameter);\r\n+\r\n+            actualTypeArguments.put(typeParameter, actualType);\r\n+            // logger.log(\"For \u0027\" + rawType().getCanonicalName() + \"\u0027 returning explicit TypeVariable : { \u0027\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"\u0027 : \u0027\" + actualType +\"\u0027 }\");\r\n+        }\r\n+\r\n+        return actualTypeArguments;\r\n+    }\r\n+\r\n+    protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {\r\n+        Type type \u003d this.contextualActualTypeParameters.get(typeParameter);\r\n+        if (type instanceof TypeVariable) {\r\n+            TypeVariable typeVariable \u003d (TypeVariable) type;\r\n+            return getActualTypeArgumentFor(typeVariable);\r\n+        }\r\n+\r\n+        return type;\r\n+    }\r\n+\r\n+\r\n+\r\n+    /**\r\n+     * Resolve current method generic return type to a {@link GenericMetadataSupport}.\r\n+     *\r\n+     * @param method Method to resolve the return type.\r\n+     * @return {@link GenericMetadataSupport} representing this generic return type.\r\n+     */\r\n+    public GenericMetadataSupport resolveGenericReturnType(Method method) {\r\n+        Type genericReturnType \u003d method.getGenericReturnType();\r\n+        // logger.log(\"Method \u0027\" + method.toGenericString() + \"\u0027 has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\r\n+\r\n+        if (genericReturnType instanceof Class) {\r\n+            return new NotGenericReturnTypeSupport(genericReturnType);\r\n+        }\r\n+        if (genericReturnType instanceof ParameterizedType) {\r\n+            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\r\n+        }\r\n+        if (genericReturnType instanceof TypeVariable) {\r\n+            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\r\n+        }\r\n+\r\n+        throw new MockitoException(\"Ouch, it shouldn\u0027t happen, type \u0027\" + genericReturnType.getClass().getCanonicalName() + \"\u0027 on method : \u0027\" + method.toGenericString() + \"\u0027 is not supported : \" + genericReturnType);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an new instance of {@link GenericMetadataSupport} inferred from a {@link Type}.\r\n+     *\r\n+     * \u003cp\u003e\r\n+     *     At the moment \u003ccode\u003etype\u003c/code\u003e can only be a {@link Class} or a {@link ParameterizedType}, otherwise\r\n+     *     it\u0027ll throw a {@link MockitoException}.\r\n+     * \u003c/p\u003e\r\n+     *\r\n+     * @param type The class from which the {@link GenericMetadataSupport} should be built.\r\n+     * @return The new {@link GenericMetadataSupport}.\r\n+     * @throws MockitoException Raised if type is not a {@link Class} or a {@link ParameterizedType}.\r\n+     */\r\n+    public static GenericMetadataSupport inferFrom(Type type) {\r\n+        Checks.checkNotNull(type, \"type\");\r\n+        if (type instanceof Class) {\r\n+            return new FromClassGenericMetadataSupport((Class\u003c?\u003e) type);\r\n+        }\r\n+        if (type instanceof ParameterizedType) {\r\n+            return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);\r\n+        }\r\n+\r\n+        throw new MockitoException(\"Type meta-data for this Type (\" + type.getClass().getCanonicalName() + \") is not supported : \" + type);\r\n+    }\r\n+\r\n+\r\n+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n+    //// Below are specializations of GenericMetadataSupport that could handle retrieval of possible Types\r\n+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n+\r\n+    /**\r\n+     * Generic metadata implementation for {@link Class}.\r\n+     *\r\n+     * Offer support to retrieve generic metadata on a {@link Class} by reading type parameters and type variables on\r\n+     * the class and its ancestors and interfaces.\r\n+     */\r\n+    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {\r\n+        private final Class\u003c?\u003e clazz;\r\n+\r\n+        public FromClassGenericMetadataSupport(Class\u003c?\u003e clazz) {\r\n+            this.clazz \u003d clazz;\r\n+\r\n+            for (Class currentExploredClass \u003d clazz;\r\n+                 currentExploredClass !\u003d null \u0026\u0026 currentExploredClass !\u003d Object.class;\r\n+                 currentExploredClass \u003d superClassOf(currentExploredClass)\r\n+                ) {\r\n+                readActualTypeParametersOnDeclaringClass(currentExploredClass);\r\n+            }\r\n+        }\r\n+\r\n+        private Class superClassOf(Class currentExploredClass) {\r\n+            Type genericSuperclass \u003d currentExploredClass.getGenericSuperclass();\r\n+            if (genericSuperclass instanceof ParameterizedType) {\r\n+                Type rawType \u003d ((ParameterizedType) genericSuperclass).getRawType();\r\n+                return (Class) rawType;\r\n+            }\r\n+            return (Class) genericSuperclass;\r\n+        }\r\n+\r\n+        private void readActualTypeParametersOnDeclaringClass(Class\u003c?\u003e clazz) {\r\n+            registerTypeParametersOn(clazz.getTypeParameters());\r\n+            registerTypeVariablesOn(clazz.getGenericSuperclass());\r\n+            for (Type genericInterface : clazz.getGenericInterfaces()) {\r\n+                registerTypeVariablesOn(genericInterface);\r\n+            }\r\n+        }\r\n+\r\n+        @Override\r\n+        public Class\u003c?\u003e rawType() {\r\n+            return clazz;\r\n+        }\r\n+    }\r\n+\r\n+\r\n+    /**\r\n+     * Generic metadata implementation for \"standalone\" {@link ParameterizedType}.\r\n+     *\r\n+     * Offer support to retrieve generic metadata on a {@link ParameterizedType} by reading type variables of\r\n+     * the related raw type and declared type variable of this parameterized type.\r\n+     *\r\n+     * This class is not designed to work on ParameterizedType returned by {@link Method#getGenericReturnType()}, as\r\n+     * the ParameterizedType instance return in these cases could have Type Variables that refer to type declaration(s).\r\n+     * That\u0027s what meant the \"standalone\" word at the beginning of the Javadoc.\r\n+     * Instead use {@link ParameterizedReturnType}.\r\n+     */\r\n+    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {\r\n+        private final ParameterizedType parameterizedType;\r\n+\r\n+        public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\r\n+            this.parameterizedType \u003d parameterizedType;\r\n+            readActualTypeParameters();\r\n+        }\r\n+\r\n+        private void readActualTypeParameters() {\r\n+            registerTypeVariablesOn(parameterizedType.getRawType());\r\n+            registerTypeVariablesOn(parameterizedType);\r\n+        }\r\n+\r\n+        @Override\r\n+        public Class\u003c?\u003e rawType() {\r\n+            return (Class\u003c?\u003e) parameterizedType.getRawType();\r\n+        }\r\n+    }\r\n+\r\n+\r\n+    /**\r\n+     * Generic metadata specific to {@link ParameterizedType} returned via {@link Method#getGenericReturnType()}.\r\n+     */\r\n+    private static class ParameterizedReturnType extends GenericMetadataSupport {\r\n+        private final ParameterizedType parameterizedType;\r\n+        private final TypeVariable[] typeParameters;\r\n+\r\n+        public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {\r\n+            this.parameterizedType \u003d parameterizedType;\r\n+            this.typeParameters \u003d typeParameters;\r\n+            this.contextualActualTypeParameters \u003d source.contextualActualTypeParameters;\r\n+\r\n+            readTypeParameters();\r\n+            readTypeVariables();\r\n+        }\r\n+\r\n+        private void readTypeParameters() {\r\n+            registerTypeParametersOn(typeParameters);\r\n+        }\r\n+\r\n+        private void readTypeVariables() {\r\n+            registerTypeVariablesOn(parameterizedType);\r\n+        }\r\n+\r\n+        @Override\r\n+        public Class\u003c?\u003e rawType() {\r\n+            return (Class\u003c?\u003e) parameterizedType.getRawType();\r\n+        }\r\n+\r\n+    }\r\n+\r\n+\r\n+    /**\r\n+     * Generic metadata for {@link TypeVariable} returned via {@link Method#getGenericReturnType()}.\r\n+     */\r\n+    private static class TypeVariableReturnType extends GenericMetadataSupport {\r\n+        private final TypeVariable typeVariable;\r\n+        private final TypeVariable[] typeParameters;\r\n+        private Class\u003c?\u003e rawType;\r\n+\r\n+\r\n+\r\n+        public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable) {\r\n+            this.typeParameters \u003d typeParameters;\r\n+            this.typeVariable \u003d typeVariable;\r\n+            this.contextualActualTypeParameters \u003d source.contextualActualTypeParameters;\r\n+\r\n+            readTypeParameters();\r\n+            readTypeVariables();\r\n+        }\r\n+\r\n+        private void readTypeParameters() {\r\n+            registerTypeParametersOn(typeParameters);\r\n+        }\r\n+\r\n+        private void readTypeVariables() {\r\n+            for (Type type : typeVariable.getBounds()) {\r\n+                registerTypeVariablesOn(type);\r\n+            }\r\n+            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\r\n+        }\r\n+\r\n+        @Override\r\n+        public Class\u003c?\u003e rawType() {\r\n+            if (rawType \u003d\u003d null) {\r\n+                rawType \u003d extractRawTypeOf(typeVariable);\r\n+            }\r\n+            return rawType;\r\n+        }\r\n+\r\n+        private Class\u003c?\u003e extractRawTypeOf(Type type) {\r\n+            if (type instanceof Class) {\r\n+                return (Class\u003c?\u003e) type;\r\n+            }\r\n+            if (type instanceof ParameterizedType) {\r\n+                return (Class\u003c?\u003e) ((ParameterizedType) type).getRawType();\r\n+            }\r\n+            if (type instanceof BoundedType) {\r\n+                return extractRawTypeOf(((BoundedType) type).firstBound());\r\n+            }\r\n+            if (type instanceof TypeVariable) {\r\n+                /*\r\n+                 * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\r\n+                 * on the class definition, such as such as List\u003cE\u003e.\r\n+                 */\r\n+                return extractRawTypeOf(contextualActualTypeParameters.get(type));\r\n+            }\r\n+            throw new MockitoException(\"Raw extraction not supported for : \u0027\" + type + \"\u0027\");\r\n+        }\r\n+\r\n+        @Override\r\n+        public List\u003cType\u003e extraInterfaces() {\r\n+            Type type \u003d extractActualBoundedTypeOf(typeVariable);\r\n+            if (type instanceof BoundedType) {\r\n+                return Arrays.asList(((BoundedType) type).interfaceBounds());\r\n+            }\r\n+            if (type instanceof ParameterizedType) {\r\n+                return Collections.singletonList(type);\r\n+            }\r\n+            if (type instanceof Class) {\r\n+                return Collections.emptyList();\r\n+            }\r\n+            throw new MockitoException(\"Cannot extract extra-interfaces from \u0027\" + typeVariable + \"\u0027 : \u0027\" + type + \"\u0027\");\r\n+        }\r\n+\r\n+        /**\r\n+         * @return Returns an array with the extracted raw types of {@link #extraInterfaces()}.\r\n+         * @see #extractRawTypeOf(java.lang.reflect.Type)\r\n+         */\r\n+        public Class\u003c?\u003e[] rawExtraInterfaces() {\r\n+            List\u003cType\u003e extraInterfaces \u003d extraInterfaces();\r\n+            List\u003cClass\u003c?\u003e\u003e rawExtraInterfaces \u003d new ArrayList\u003cClass\u003c?\u003e\u003e();\r\n+            for (Type extraInterface : extraInterfaces) {\r\n+                Class\u003c?\u003e rawInterface \u003d extractRawTypeOf(extraInterface);\r\n+                // avoid interface collision with actual raw type (with typevariables, resolution ca be quite aggressive)\r\n+                if(!rawType().equals(rawInterface)) {\r\n+                    rawExtraInterfaces.add(rawInterface);\r\n+                }\r\n+            }\r\n+            return rawExtraInterfaces.toArray(new Class[rawExtraInterfaces.size()]);\r\n+        }\r\n+\r\n+        private Type extractActualBoundedTypeOf(Type type) {\r\n+            if (type instanceof TypeVariable) {\r\n+                /*\r\n+                If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\r\n+                on the class definition, such as such as List\u003cE\u003e.\r\n+                */\r\n+                return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));\r\n+            }\r\n+            if (type instanceof BoundedType) {\r\n+                Type actualFirstBound \u003d extractActualBoundedTypeOf(((BoundedType) type).firstBound());\r\n+                if (!(actualFirstBound instanceof BoundedType)) {\r\n+                    return type; // avoid going one step further, ie avoid : O(TypeVar) -\u003e K(TypeVar) -\u003e Some ParamType\r\n+                }\r\n+                return actualFirstBound;\r\n+            }\r\n+            return type; // irrelevant, we don\u0027t manage other types as they are not bounded.\r\n+        }\r\n+    }\r\n+\r\n+\r\n+\r\n+    /**\r\n+     * Non-Generic metadata for {@link Class} returned via {@link Method#getGenericReturnType()}.\r\n+     */\r\n+    private static class NotGenericReturnTypeSupport extends GenericMetadataSupport {\r\n+        private final Class\u003c?\u003e returnType;\r\n+\r\n+        public NotGenericReturnTypeSupport(Type genericReturnType) {\r\n+            returnType \u003d (Class\u003c?\u003e) genericReturnType;\r\n+        }\r\n+\r\n+        @Override\r\n+        public Class\u003c?\u003e rawType() {\r\n+            return returnType;\r\n+        }\r\n+    }\r\n+\r\n+\r\n+\r\n+    /**\r\n+     * Type representing bounds of a type\r\n+     *\r\n+     * @see TypeVarBoundedType\r\n+     * @see \u003ca href\u003d\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\"\u003ehttp://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\u003c/a\u003e\r\n+     * @see WildCardBoundedType\r\n+     * @see \u003ca href\u003d\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1\"\u003ehttp://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1\u003c/a\u003e\r\n+     */\r\n+    public static interface BoundedType extends Type {\r\n+        Type firstBound();\r\n+\r\n+        Type[] interfaceBounds();\r\n+    }\r\n+\r\n+    /**\r\n+     * Type representing bounds of a type variable, allows to keep all bounds information.\r\n+     *\r\n+     * \u003cp\u003eIt uses the first bound in the array, as this array is never null and always contains at least\r\n+     * one element (Object is always here if no bounds are declared).\u003c/p\u003e\r\n+     *\r\n+     * \u003cp\u003eIf upper bounds are declared with SomeClass and additional interfaces, then firstBound will be SomeClass and\r\n+     * interfacesBound will be an array of the additional interfaces.\r\n+     *\r\n+     * i.e. \u003ccode\u003eSomeClass\u003c/code\u003e.\r\n+     * \u003cpre class\u003d\"code\"\u003e\u003ccode class\u003d\"java\"\u003e\r\n+     *     interface UpperBoundedTypeWithClass\u003cE extends Comparable\u003cE\u003e \u0026 Cloneable\u003e {\r\n+     *         E get();\r\n+     *     }\r\n+     *     // will return Comparable type\r\n+     * \u003c/code\u003e\u003c/pre\u003e\r\n+     * \u003c/p\u003e\r\n+     *\r\n+     * @see \u003ca href\u003d\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\"\u003ehttp://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\u003c/a\u003e\r\n+     */\r\n+    public static class TypeVarBoundedType implements BoundedType {\r\n+        private final TypeVariable typeVariable;\r\n+\r\n+\r\n+        public TypeVarBoundedType(TypeVariable typeVariable) {\r\n+            this.typeVariable \u003d typeVariable;\r\n+        }\r\n+\r\n+        /**\r\n+         * @return either a class or an interface (parameterized or not), if no bounds declared Object is returned.\r\n+         */\r\n+        public Type firstBound() {\r\n+            return typeVariable.getBounds()[0]; //\r\n+        }\r\n+\r\n+        /**\r\n+         * On a Type Variable (typeVar extends C_0 \u0026 I_1 \u0026 I_2 \u0026 etc), will return an array\r\n+         * containing I_1 and I_2.\r\n+         *\r\n+         * @return other bounds for this type, these bounds can only be only interfaces as the JLS says,\r\n+         * empty array if no other bound declared.\r\n+         */\r\n+        public Type[] interfaceBounds() {\r\n+            Type[] interfaceBounds \u003d new Type[typeVariable.getBounds().length - 1];\r\n+            System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);\r\n+            return interfaceBounds;\r\n+        }\r\n+\r\n+        @Override\r\n+        public boolean equals(Object o) {\r\n+            if (this \u003d\u003d o) return true;\r\n+            if (o \u003d\u003d null || getClass() !\u003d o.getClass()) return false;\r\n+\r\n+            return typeVariable.equals(((TypeVarBoundedType) o).typeVariable);\r\n+\r\n+        }\r\n+\r\n+        @Override\r\n+        public int hashCode() {\r\n+            return typeVariable.hashCode();\r\n+        }\r\n+\r\n+        @Override\r\n+        public String toString() {\r\n+            return \"{firstBound\u003d\" + firstBound() + \", interfaceBounds\u003d\" + Arrays.deepToString(interfaceBounds()) + \u0027}\u0027;\r\n+        }\r\n+\r\n+        public TypeVariable typeVariable() {\r\n+            return typeVariable;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Type representing bounds of a wildcard, allows to keep all bounds information.\r\n+     *\r\n+     * \u003cp\u003eThe JLS says that lower bound and upper bound are mutually exclusive, and that multiple bounds\r\n+     * are not allowed.\r\n+     *\r\n+     * @see \u003ca href\u003d\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\"\u003ehttp://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\u003c/a\u003e\r\n+     */\r\n+    public static class WildCardBoundedType implements BoundedType {\r\n+        private final WildcardType wildcard;\r\n+\r\n+\r\n+        public WildCardBoundedType(WildcardType wildcard) {\r\n+            this.wildcard \u003d wildcard;\r\n+        }\r\n+\r\n+        /**\r\n+         * @return The first bound, either a type or a reference to a TypeVariable\r\n+         */\r\n+        public Type firstBound() {\r\n+            Type[] lowerBounds \u003d wildcard.getLowerBounds();\r\n+            Type[] upperBounds \u003d wildcard.getUpperBounds();\r\n+\r\n+            return lowerBounds.length !\u003d 0 ? lowerBounds[0] : upperBounds[0];\r\n+        }\r\n+\r\n+        /**\r\n+         * @return An empty array as, wildcard don\u0027t support multiple bounds.\r\n+         */\r\n+        public Type[] interfaceBounds() {\r\n+            return new Type[0];\r\n+        }\r\n+\r\n+        @Override\r\n+        public boolean equals(Object o) {\r\n+            if (this \u003d\u003d o) return true;\r\n+            if (o \u003d\u003d null || getClass() !\u003d o.getClass()) return false;\r\n+\r\n+            return wildcard.equals(((TypeVarBoundedType) o).typeVariable);\r\n+\r\n+        }\r\n+\r\n+        @Override\r\n+        public int hashCode() {\r\n+            return wildcard.hashCode();\r\n+        }\r\n+\r\n+        @Override\r\n+        public String toString() {\r\n+            return \"{firstBound\u003d\" + firstBound() + \", interfaceBounds\u003d[]}\";\r\n+        }\r\n+\r\n+        public WildcardType wildCard() {\r\n+            return wildcard;\r\n+        }\r\n+    }\r\n+\r\n+}\r\n+\r\n+\r\n",
      "operations": [
        {
          "type": "insert-node",
          "from": "",
          "to": "MethodDeclaration [4256,4727]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [6756,6997]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Modifier: private [4256,4263]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "PrimitiveType: void [4264,4268]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: registerTypeVariableIfNotPresent [4269,4301]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SingleVariableDeclaration [4302,4327]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [4329,4727]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "MethodDeclaration [11896,12302]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [4340,4720]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Modifier: final [11414,11419]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "SingleVariableDeclaration [12368,12382]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Modifier: final [13594,13599]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Modifier: final [22230,22235]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Modifier: final [24436,24441]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "PrefixExpression [4344,4401]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [4403,4720]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "ForStatement [11552,11873]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [14667,14710]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [22344,22377]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ReturnStatement [23705,23812]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ReturnStatement [25580,25643]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "ExpressionStatement [4183,4230]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "VariableDeclarationExpression [11557,11591]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [11611,11679]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "Assignment [11699,11756]"
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "Block [11776,11873]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-node",
          "from": "",
          "to": "SimpleName: typeVariable [4453,4465]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "METHOD_INVOCATION_ARGUMENTS [11836,11856]"
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "update-node",
          "from": "",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ImportDeclaration [305,333]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SimpleType [2285,2297]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [3196,3292]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "InstanceofExpression [3506,3553]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "Block [3555,3725]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "IfStatement [3502,3846]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ClassInstanceCreation [4304,4347]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SimpleType [5092,5115]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "ClassInstanceCreation [5088,5154]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SimpleType [6103,6126]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "ClassInstanceCreation [6099,6147]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SimpleType [7279,7303]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "ClassInstanceCreation [7275,7318]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [13667,13745]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "SimpleName: fromArray [13781,13790]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "METHOD_INVOCATION_ARGUMENTS [13791,13805]",
          "to": ""
        },
        {
          "type": "delete-node",
          "from": "MethodInvocation [13781,13806]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SimpleType [21258,21270]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [21398,21461]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [22789,22834]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [22848,22895]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [22909,22988]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [23002,23017]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ReturnStatement [23031,23052]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "SimpleType [23658,23670]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "VariableDeclarationStatement [24828,24873]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [24887,24934]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ExpressionStatement [24948,24983]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "ReturnStatement [24997,25018]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TypeDeclaration [25129,25653]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TypeDeclaration [25663,26485]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [26493,26866]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [26872,27258]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [27266,27532]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "MethodDeclaration [27540,27949]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TypeDeclaration [27957,28847]",
          "to": ""
        },
        {
          "type": "delete-tree",
          "from": "TypeDeclaration [28855,29512]",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        },
        {
          "type": "multi-move-tree",
          "from": "",
          "to": ""
        }
      ]
    }
  ],
  "inducing_type": {
    "add_classes": {
      "qualified_names": [
        "src/org/mockito/exceptions/base/MockitoSerializationIssue.java",
        "src/org/mockito/exceptions/misusing/CannotVerifyStubOnlyMock.java",
        "src/org/mockito/exceptions/stacktrace/StackTraceCleaner.java",
        "src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java",
        "src/org/mockito/internal/exceptions/stacktrace/ConditionalStackTraceFilter.java",
        "src/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleaner.java",
        "src/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleanerProvider.java",
        "src/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java",
        "src/org/mockito/internal/matchers/VarargCapturingMatcher.java",
        "src/org/mockito/internal/util/reflection/Constructors.java",
        "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "src/org/mockito/internal/verification/DefaultRegisteredInvocations.java",
        "src/org/mockito/internal/verification/SingleRegisteredInvocation.java",
        "src/org/mockito/internal/verification/VerificationOverTimeImpl.java",
        "src/org/mockito/mock/SerializableMode.java",
        "src/org/mockito/plugins/StackTraceCleanerProvider.java",
        "src/org/mockito/verification/After.java",
        "src/org/mockito/verification/VerificationAfterDelay.java",
        "src/org/mockito/verification/VerificationWrapper.java"
      ],
      "num": 19
    },
    "delete_classes": {
      "qualified_names": [
        "src/org/mockito/internal/creation/ClassNameFinder.java",
        "src/org/mockito/internal/exceptions/base/ConditionalStackTraceFilter.java",
        "src/org/mockito/internal/exceptions/base/StackTraceFilter.java",
        "src/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubs.java",
        "src/org/mockito/internal/util/MockitoSpy.java",
        "src/org/mockito/internal/util/reflection/MockitoGenericMetadata.java",
        "src/org/mockito/internal/verification/VerificationWithTimeoutImpl.java"
      ],
      "num": 7
    },
    "add_functions": {
      "qualified_names": [
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$FromParameterizedTypeGenericMetadataSupport:rawType:[]:Class\u003c?\u003e",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$WildCardBoundedType:firstBound:[]:Type",
        "org.mockito.internal.util.reflection.GenericMetadataSupport:inferFrom:[Type type]:GenericMetadataSupport",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVariableReturnType:extraInterfaces:[]:List\u003cType\u003e",
        "org.mockito.internal.util.reflection.GenericMetadataSupport:extraInterfaces:[]:List\u003cType\u003e",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVariableReturnType:rawExtraInterfaces:[]:Class\u003c?\u003e[]",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVariableReturnType:readTypeVariables:[]:void",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$WildCardBoundedType:toString:[]:String",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$BoundedType:interfaceBounds:[]:Type[]",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$ParameterizedReturnType:readTypeVariables:[]:void",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVariableReturnType:extractRawTypeOf:[Type type]:Class\u003c?\u003e",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$FromParameterizedTypeGenericMetadataSupport:FromParameterizedTypeGenericMetadataSupport:[ParameterizedType parameterizedType]:null",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$ParameterizedReturnType:readTypeParameters:[]:void",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVarBoundedType:typeVariable:[]:TypeVariable",
        "org.mockito.internal.util.reflection.GenericMetadataSupport:actualTypeArguments:[]:Map\u003cTypeVariable,Type\u003e",
        "org.mockito.internal.util.reflection.GenericMetadataSupport:boundsOf:[TypeVariable typeParameter]:BoundedType",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$FromParameterizedTypeGenericMetadataSupport:readActualTypeParameters:[]:void",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVariableReturnType:extractActualBoundedTypeOf:[Type type]:Type",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$WildCardBoundedType:hashCode:[]:int",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$ParameterizedReturnType:ParameterizedReturnType:[GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType]:null",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVariableReturnType:rawType:[]:Class\u003c?\u003e",
        "org.mockito.internal.util.reflection.GenericMetadataSupport:registerTypeVariablesOn:[Type classType]:void",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$WildCardBoundedType:WildCardBoundedType:[WildcardType wildcard]:null",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVarBoundedType:hashCode:[]:int",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$FromClassGenericMetadataSupport:readActualTypeParametersOnDeclaringClass:[Class\u003c?\u003e clazz]:void",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVarBoundedType:TypeVarBoundedType:[TypeVariable typeVariable]:null",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$BoundedType:firstBound:[]:Type",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVarBoundedType:toString:[]:String",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVariableReturnType:readTypeParameters:[]:void",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVarBoundedType:firstBound:[]:Type",
        "org.mockito.internal.util.reflection.GenericMetadataSupport:registerTypeVariableIfNotPresent:[TypeVariable typeVariable]:void",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$FromClassGenericMetadataSupport:superClassOf:[Class currentExploredClass]:Class",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVarBoundedType:equals:[Object o]:boolean",
        "org.mockito.internal.util.reflection.GenericMetadataSupport:getActualTypeArgumentFor:[TypeVariable typeParameter]:Type",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$ParameterizedReturnType:rawType:[]:Class\u003c?\u003e",
        "org.mockito.internal.util.reflection.GenericMetadataSupport:resolveGenericReturnType:[Method method]:GenericMetadataSupport",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$FromClassGenericMetadataSupport:rawType:[]:Class\u003c?\u003e",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$NotGenericReturnTypeSupport:rawType:[]:Class\u003c?\u003e",
        "org.mockito.internal.util.reflection.GenericMetadataSupport:registerTypeParametersOn:[TypeVariable[] typeParameters]:void",
        "org.mockito.internal.util.reflection.GenericMetadataSupport:rawType:[]:Class\u003c?\u003e",
        "org.mockito.internal.util.reflection.GenericMetadataSupport:hasRawExtraInterfaces:[]:boolean",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVarBoundedType:interfaceBounds:[]:Type[]",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$WildCardBoundedType:wildCard:[]:WildcardType",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$TypeVariableReturnType:TypeVariableReturnType:[GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable]:null",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$NotGenericReturnTypeSupport:NotGenericReturnTypeSupport:[Type genericReturnType]:null",
        "org.mockito.internal.util.reflection.GenericMetadataSupport:rawExtraInterfaces:[]:Class\u003c?\u003e[]",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$WildCardBoundedType:interfaceBounds:[]:Type[]",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$FromClassGenericMetadataSupport:FromClassGenericMetadataSupport:[Class\u003c?\u003e clazz]:null",
        "org.mockito.internal.util.reflection.GenericMetadataSupport:boundsOf:[WildcardType wildCard]:BoundedType",
        "org.mockito.internal.util.reflection.GenericMetadataSupport\\$WildCardBoundedType:equals:[Object o]:boolean"
      ],
      "num": 50
    },
    "delete_functions": {
      "qualified_names": [],
      "num": 0
    }
  },
  "trigger_tests": [
    {
      "test_class": "org.mockito.internal.util.reflection.GenericMetadataSupportTest",
      "test_function": "typeVariable_of_self_type",
      "exception": "java.lang.StackOverflowError",
      "message": ""
    }
  ],
  "fixing_changes": [
    {
      "changed_type": "UPDATE",
      "changed_class": [
        "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java"
      ],
      "changed_functions": [
        {
          "qualified_names": [
            "org.mockito.internal.util.reflection.GenericMetadataSupport:registerTypeVariablesOn:[Type classType]:void"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "org.mockito.internal.util.reflection.GenericMetadataSupport:registerTypeVariablesOn:[Type classType]:void"
          ],
          "num": 1
        }
      ],
      "changed_lines": [
        {
          "qualified_names": [
            "79"
          ],
          "num": 1
        },
        {
          "qualified_names": [
            "79"
          ],
          "num": 1
        }
      ],
      "diff": "diff --git a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\nindex 152e942..8046052 100644\n--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n@@ -76,7 +76,7 @@\n \r\n             if (actualTypeArgument instanceof WildcardType) {\r\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\r\n-            } else {\r\n+            } else if (typeParameter !\u003d actualTypeArgument) {\r\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\r\n             }\r\n             // logger.log(\"For \u0027\" + parameterizedType + \"\u0027 found type variable : { \u0027\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"\u0027 : \u0027\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"\u0027 }\");\r\n",
      "operations": [
        {
          "type": "insert-node",
          "from": "",
          "to": "IfStatement [3280,3425]"
        },
        {
          "type": "insert-tree",
          "from": "",
          "to": "InfixExpression [3284,3319]"
        },
        {
          "type": "move-tree",
          "from": "",
          "to": ""
        }
      ]
    }
  ],
  "fixing_type": {
    "add_classes": {
      "qualified_names": [],
      "num": 0
    },
    "delete_classes": {
      "qualified_names": [],
      "num": 0
    },
    "add_functions": {
      "qualified_names": [],
      "num": 0
    },
    "delete_functions": {
      "qualified_names": [],
      "num": 0
    }
  },
  "patch_changed_mths": {
    "qualified_names": [],
    "num": 0
  }
}